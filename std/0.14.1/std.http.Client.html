<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">http</a></li><li><a href="std.http.Client.html" class="active">Client</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.http.Client" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.http.Client</span><a href="#src.zig-std.http.Client">[src]</a></h1><div class="tldDocs"><p>HTTP(S) Client implementation.</p>
<p>Connections are opened in a thread-safe manner, but individual Requests are not.</p>
<p>TLS support may be disabled via <code>std.options.http_disable_tls</code>.</p>
</div><div class="sectNamespaces"><h2 class="sectionHeader">Namespaces</h2><ul class="listNamespaces columns"><li><a href="std.http.Client.basic_authorization.html">std.http.Client.basic_authorization</a></li></ul></div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.http.Client.ConnectionPool.html">std.http.Client.ConnectionPool</a></li><li><a href="std.http.Client.Connection.html">std.http.Client.Connection</a></li><li><a href="std.http.Client.RequestTransfer.html">std.http.Client.RequestTransfer</a></li><li><a href="std.http.Client.Compression.html">std.http.Client.Compression</a></li><li><a href="std.http.Client.Response.html">std.http.Client.Response</a></li><li><a href="std.http.Client.Request.html">std.http.Client.Request</a></li><li><a href="std.http.Client.Proxy.html">std.http.Client.Proxy</a></li><li><a href="std.http.Client.RequestOptions.html">std.http.Client.RequestOptions</a></li><li><a href="std.http.Client.FetchOptions.html">std.http.Client.FetchOptions</a></li><li><a href="std.http.Client.FetchResult.html">std.http.Client.FetchResult</a></li></ul></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre><div class="fieldDocs"><p>Used for all client allocations. Must be thread-safe.</p>
</div></div><div><pre><code>ca_bundle: <span class="tok-kw">if</span> (<a href="std.http.Client.html#std.http.Client.disable_tls">disable_tls</a>) <span class="tok-type">void</span> <span class="tok-kw">else</span> <a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>.<a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.Bundle.html">Bundle</a> = <span class="tok-kw">if</span> (<a href="std.http.Client.html#std.http.Client.disable_tls">disable_tls</a>) {} <span class="tok-kw">else</span> .{}</code></pre></div><div><pre><code>ca_bundle_mutex: <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.Mutex.html">Mutex</a> = .{}</code></pre></div><div><pre><code>next_https_rescan_certs: <span class="tok-type">bool</span> = <span class="tok-null">true</span></code></pre><div class="fieldDocs"><p>When this is <code>true</code>, the next time this client performs an HTTPS request,
it will first rescan the system for root certificates.</p>
</div></div><div><pre><code>connection_pool: <a href="std.http.Client.ConnectionPool.html">ConnectionPool</a> = .{}</code></pre><div class="fieldDocs"><p>The pool of connections that can be reused (and currently in use).</p>
</div></div><div><pre><code>http_proxy: ?*<a href="std.http.Client.Proxy.html">Proxy</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>If populated, all http traffic travels through this third party.
This field cannot be modified while the client has active connections.
Pointer to externally-owned memory.</p>
</div></div><div><pre><code>https_proxy: ?*<a href="std.http.Client.Proxy.html">Proxy</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>If populated, all https traffic travels through this third party.
This field cannot be modified while the client has active connections.
Pointer to externally-owned memory.</p>
</div></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.http.Client.disable_tls" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">disable_tls</span><a href="#src.zig-std.http.Client.disable_tls">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.disable_tls">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> disable_tls = <a href="std.html">std</a>.<a href="std.html#std.options">options</a>.<a href="#">http_disable_tls</a></code></pre></details></div></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.http.Client.ConnectTcpError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ConnectTcpError</span><a href="#src.zig-std.http.Client.ConnectTcpError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>ConnectionRefused</dt></div><div><dt>ConnectionResetByPeer</dt></div><div><dt>ConnectionTimedOut</dt></div><div><dt>HostLacksNetworkAddresses</dt></div><div><dt>NameServerFailure</dt></div><div><dt>NetworkUnreachable</dt></div><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>TemporaryNameServerFailure</dt></div><div><dt>TlsInitializationFailed</dt></div><div><dt>UnexpectedConnectFailure</dt></div><div><dt>UnknownHostName</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.ConnectTcpError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ConnectTcpError = <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || <span class="tok-kw">error</span>{ ConnectionRefused, NetworkUnreachable, ConnectionTimedOut, ConnectionResetByPeer, TemporaryNameServerFailure, NameServerFailure, UnknownHostName, HostLacksNetworkAddresses, UnexpectedConnectFailure, TlsInitializationFailed }</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.ConnectUnixError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ConnectUnixError</span><a href="#src.zig-std.http.Client.ConnectUnixError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AddressFamilyNotSupported <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The implementation does not support the specified address family.</p>
</dd></div><div><dt>AddressInUse <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>Local address is already in use.</p>
</dd></div><div><dt>AddressNotAvailable <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>(Internet  domain  sockets)  The  socket  referred  to  by sockfd had not previously been bound to an
address and, upon attempting to bind it to an ephemeral port, it was determined that all port numbers
in    the    ephemeral    port    range    are   currently   in   use.    See   the   discussion   of
/proc/sys/net/ipv4/ip_local_port_range in ip(7).</p>
</dd></div><div><dt>ConnectionPending <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>Socket is non-blocking and already has a pending connection in progress.</p>
</dd></div><div><dt>ConnectionRefused <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>A connect() on a stream socket found no one listening on the remote address.</p>
</dd></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>Connection was reset by peer before connect could complete.</p>
</dd></div><div><dt>ConnectionTimedOut <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>Timeout  while  attempting  connection.   The server may be too busy to accept new connections.  Note
that for IP sockets the timeout may be very long when syncookies are enabled on the server.</p>
</dd></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>The given path for the unix socket does not exist.</p>
</dd></div><div><dt>NameTooLong</dt></div><div><dt>NetworkUnreachable <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>Network is unreachable.</p>
</dd></div><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>PermissionDenied <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>Permission to create a socket of the specified type and/or
pro‐tocol is denied.</p>
</dd></div><div><dt>ProcessFdQuotaExceeded <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The per-process limit on the number of open file descriptors has been reached.</p>
</dd></div><div><dt>ProtocolFamilyNotAvailable <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>Unknown protocol, or protocol family not available.</p>
</dd></div><div><dt>ProtocolNotSupported <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The protocol type or the specified protocol is not supported within this domain.</p>
</dd></div><div><dt>SocketTypeNotSupported <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The socket type is not supported by the protocol.</p>
</dd></div><div><dt>SystemFdQuotaExceeded <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The system-wide limit on the total number of open files has been reached.</p>
</dd></div><div><dt>SystemResources <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>Insufficient memory is available. The socket cannot be created until sufficient
resources are freed.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>This error occurs when no global event loop is configured,
and connecting to the socket would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.ConnectUnixError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ConnectUnixError = <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SocketError">SocketError</a> || <span class="tok-kw">error</span>{NameTooLong} || <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ConnectError">ConnectError</a></code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.ConnectError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ConnectError</span><a href="#src.zig-std.http.Client.ConnectError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>CertificateBundleLoadFailure <a href="std.http.Client.html#std.http.Client.RequestError">RequestError</a></dt></div><div><dt>ConnectionRefused <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>ConnectionResetByPeer <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>ConnectionTimedOut <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>HostLacksNetworkAddresses <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>InvalidCharacter <a href="std.fmt.html#std.fmt.ParseIntError">ParseIntError</a></dt><dd><p>The input was empty or contained an invalid character</p>
</dd></div><div><dt>InvalidContentLength <a href="std.http.Client.Request.html#std.http.Client.Request.SendError">SendError</a></dt></div><div><dt>NameServerFailure <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>NetworkUnreachable <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>Overflow <a href="std.fmt.html#std.fmt.ParseIntError">ParseIntError</a></dt><dd><p>The result cannot fit in the type specified</p>
</dd></div><div><dt>TemporaryNameServerFailure <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>TlsInitializationFailed <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>UnexpectedConnectFailure <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>UnexpectedWriteFailure <a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a></dt></div><div><dt>UnknownHostName <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>UnsupportedTransferEncoding <a href="std.http.Client.Request.html#std.http.Client.Request.SendError">SendError</a></dt></div><div><dt>UnsupportedUriScheme <a href="std.http.Client.html#std.http.Client.ConnectErrorPartial">ConnectErrorPartial</a></dt></div><div><dt>UriMissingHost <a href="std.http.Client.html#std.http.Client.RequestError">RequestError</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.ConnectError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ConnectError = <a href="std.http.Client.html#std.http.Client.ConnectErrorPartial">ConnectErrorPartial</a> || <a href="std.http.Client.html#std.http.Client.RequestError">RequestError</a></code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.RequestError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">RequestError</span><a href="#src.zig-std.http.Client.RequestError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>CertificateBundleLoadFailure</dt></div><div><dt>ConnectionRefused <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>ConnectionResetByPeer <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>ConnectionTimedOut <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>HostLacksNetworkAddresses <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>InvalidCharacter <a href="std.fmt.html#std.fmt.ParseIntError">ParseIntError</a></dt><dd><p>The input was empty or contained an invalid character</p>
</dd></div><div><dt>InvalidContentLength <a href="std.http.Client.Request.html#std.http.Client.Request.SendError">SendError</a></dt></div><div><dt>NameServerFailure <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>NetworkUnreachable <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>Overflow <a href="std.fmt.html#std.fmt.ParseIntError">ParseIntError</a></dt><dd><p>The result cannot fit in the type specified</p>
</dd></div><div><dt>TemporaryNameServerFailure <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>TlsInitializationFailed <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>UnexpectedConnectFailure <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>UnexpectedWriteFailure <a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a></dt></div><div><dt>UnknownHostName <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>UnsupportedTransferEncoding <a href="std.http.Client.Request.html#std.http.Client.Request.SendError">SendError</a></dt></div><div><dt>UnsupportedUriScheme <a href="std.http.Client.html#std.http.Client.ConnectErrorPartial">ConnectErrorPartial</a></dt></div><div><dt>UriMissingHost</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.RequestError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RequestError = <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a> || <a href="std.http.Client.html#std.http.Client.ConnectErrorPartial">ConnectErrorPartial</a> || <a href="std.http.Client.Request.html">Request</a>.<a href="std.http.Client.Request.html#std.http.Client.Request.SendError">SendError</a> ||
    <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.ParseIntError">ParseIntError</a> || <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a> ||
    <span class="tok-kw">error</span>{
        UnsupportedUriScheme,
        UriMissingHost,

        CertificateBundleLoadFailure,
        UnsupportedTransferEncoding,
    }</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.http.Client.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.http.Client.deinit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(client: *<a href="std.http.Client.html">Client</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Release all associated resources with the client.</p>
<p>All pending requests must be de-initialized and all active connections released
before calling this function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>client: *<a href="std.http.Client.html">Client</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.deinit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(client: *<a href="std.http.Client.html">Client</a>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(client.connection_pool.used.first == <span class="tok-null">null</span>);<span class="tok-comment"> // There are still active requests.

    </span>client.connection_pool.deinit(client.allocator);

    <span class="tok-kw">if</span> (!<a href="std.http.Client.html#std.http.Client.disable_tls">disable_tls</a>)
        client.ca_bundle.deinit(client.allocator);

    client.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.initDefaultProxies" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initDefaultProxies</span><a href="#src.zig-std.http.Client.initDefaultProxies">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initDefaultProxies</span>(client: *<a href="std.http.Client.html">Client</a>, arena: <a href="std.mem.Allocator.html">Allocator</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Populates <code>http_proxy</code> and <code>https_proxy</code> via standard proxy environment variables.
Asserts the client has no active connections.
Uses <code>arena</code> for a few small allocations that must outlive the client, or
at least until those fields are set to different values.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>client: *<a href="std.http.Client.html">Client</a></code></pre></div><div><pre><code>arena: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.initDefaultProxies">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initDefaultProxies</span>(client: *<a href="std.http.Client.html">Client</a>, arena: <a href="std.mem.Allocator.html">Allocator</a>) !<span class="tok-type">void</span> {<span class="tok-comment">
    // Prevent any new connections from being created.
    </span>client.connection_pool.mutex.lock();
    <span class="tok-kw">defer</span> client.connection_pool.mutex.unlock();

    <a href="std.debug.html#std.debug.assert">assert</a>(client.connection_pool.used.first == <span class="tok-null">null</span>);<span class="tok-comment"> // There are active requests.

    </span><span class="tok-kw">if</span> (client.http_proxy == <span class="tok-null">null</span>) {
        client.http_proxy = <span class="tok-kw">try</span> <a href="std.http.Client.html#std.http.Client.createProxyFromEnvVar">createProxyFromEnvVar</a>(arena, &amp;.{
            <span class="tok-str">&quot;http_proxy&quot;</span>, <span class="tok-str">&quot;HTTP_PROXY&quot;</span>, <span class="tok-str">&quot;all_proxy&quot;</span>, <span class="tok-str">&quot;ALL_PROXY&quot;</span>,
        });
    }

    <span class="tok-kw">if</span> (client.https_proxy == <span class="tok-null">null</span>) {
        client.https_proxy = <span class="tok-kw">try</span> <a href="std.http.Client.html#std.http.Client.createProxyFromEnvVar">createProxyFromEnvVar</a>(arena, &amp;.{
            <span class="tok-str">&quot;https_proxy&quot;</span>, <span class="tok-str">&quot;HTTPS_PROXY&quot;</span>, <span class="tok-str">&quot;all_proxy&quot;</span>, <span class="tok-str">&quot;ALL_PROXY&quot;</span>,
        });
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.connectTcp" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">connectTcp</span><a href="#src.zig-std.http.Client.connectTcp">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connectTcp</span>(client: *<a href="std.http.Client.html">Client</a>, host: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>, protocol: <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.Protocol.html">Protocol</a>) <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a>!*<a href="std.http.Client.Connection.html">Connection</a></code></pre></div><div class="tldDocs"><p>Connect to <code>host:port</code> using the specified protocol. This will reuse a connection if one is already open.</p>
<p>This function is threadsafe.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>client: *<a href="std.http.Client.html">Client</a></code></pre></div><div><pre><code>host: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>port: <span class="tok-type">u16</span></code></pre></div><div><pre><code>protocol: <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.Protocol.html">Protocol</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.connectTcp">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connectTcp</span>(client: *<a href="std.http.Client.html">Client</a>, host: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>, protocol: <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.Protocol.html">Protocol</a>) <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a>!*<a href="std.http.Client.Connection.html">Connection</a> {
    <span class="tok-kw">if</span> (client.connection_pool.findConnection(.{
        .host = host,
        .port = port,
        .protocol = protocol,
    })) |node| <span class="tok-kw">return</span> node;

    <span class="tok-kw">if</span> (<a href="std.http.Client.html#std.http.Client.disable_tls">disable_tls</a> <span class="tok-kw">and</span> protocol == .tls)
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsInitializationFailed;

    <span class="tok-kw">const</span> conn = <span class="tok-kw">try</span> client.allocator.create(<a href="std.http.Client.ConnectionPool.html">ConnectionPool</a>.<a href="std.http.Client.ConnectionPool.html#std.http.Client.ConnectionPool.Node">Node</a>);
    <span class="tok-kw">errdefer</span> client.allocator.destroy(conn);
    conn.* = .{ .data = <span class="tok-null">undefined</span> };

    <span class="tok-kw">const</span> stream = <a href="std.net.html">net</a>.<a href="std.net.html#std.net.tcpConnectToHost">tcpConnectToHost</a>(client.allocator, host, port) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.ConnectionRefused =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionRefused,
        <span class="tok-kw">error</span>.NetworkUnreachable =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
        <span class="tok-kw">error</span>.ConnectionTimedOut =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
        <span class="tok-kw">error</span>.ConnectionResetByPeer =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
        <span class="tok-kw">error</span>.TemporaryNameServerFailure =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TemporaryNameServerFailure,
        <span class="tok-kw">error</span>.NameServerFailure =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameServerFailure,
        <span class="tok-kw">error</span>.UnknownHostName =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownHostName,
        <span class="tok-kw">error</span>.HostLacksNetworkAddresses =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HostLacksNetworkAddresses,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedConnectFailure,
    };
    <span class="tok-kw">errdefer</span> stream.close();

    conn.data = .{
        .stream = stream,
        .tls_client = <span class="tok-null">undefined</span>,

        .protocol = protocol,
        .host = <span class="tok-kw">try</span> client.allocator.dupe(<span class="tok-type">u8</span>, host),
        .port = port,
    };
    <span class="tok-kw">errdefer</span> client.allocator.free(conn.data.host);

    <span class="tok-kw">if</span> (protocol == .tls) {
        <span class="tok-kw">if</span> (<a href="std.http.Client.html#std.http.Client.disable_tls">disable_tls</a>) <span class="tok-kw">unreachable</span>;

        conn.data.tls_client = <span class="tok-kw">try</span> client.allocator.create(<a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>.<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.Client.html">Client</a>);
        <span class="tok-kw">errdefer</span> client.allocator.destroy(conn.data.tls_client);

        <span class="tok-kw">const</span> ssl_key_log_file: ?<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a> = <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.html#std.options">options</a>.<a href="#">http_enable_ssl_key_log_file</a>) ssl_key_log_file: {
            <span class="tok-kw">const</span> ssl_key_log_path = <a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.html#std.process.getEnvVarOwned">getEnvVarOwned</a>(client.allocator, <span class="tok-str">&quot;SSLKEYLOGFILE&quot;</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.EnvironmentVariableNotFound, <span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">break</span> :ssl_key_log_file <span class="tok-null">null</span>,
                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
            };
            <span class="tok-kw">defer</span> client.allocator.free(ssl_key_log_path);
            <span class="tok-kw">break</span> :ssl_key_log_file <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().createFile(ssl_key_log_path, .{
                .truncate = <span class="tok-null">false</span>,
                .mode = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
                    .windows, .wasi =&gt; <span class="tok-number">0</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-number">0o600</span>,
                },
            }) <span class="tok-kw">catch</span> <span class="tok-null">null</span>;
        } <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        <span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (ssl_key_log_file) |key_log_file| key_log_file.close();

        conn.data.tls_client.* = <a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>.<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.Client.html">Client</a>.<a href="std.crypto.tls.Client.html#std.crypto.tls.Client.init">init</a>(stream, .{
            .host = .{ .explicit = host },
            .ca = .{ .bundle = client.ca_bundle },
            .ssl_key_log_file = ssl_key_log_file,
        }) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsInitializationFailed;<span class="tok-comment">
        // This is appropriate for HTTPS because the HTTP headers contain
        // the content length which is used to detect truncation attacks.
        </span>conn.data.tls_client.allow_truncation_attacks = <span class="tok-null">true</span>;
    }

    client.connection_pool.addUsed(conn);

    <span class="tok-kw">return</span> &amp;conn.data;
}</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.connectUnix" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">connectUnix</span><a href="#src.zig-std.http.Client.connectUnix">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connectUnix</span>(client: *<a href="std.http.Client.html">Client</a>, path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.http.Client.html#std.http.Client.ConnectUnixError">ConnectUnixError</a>!*<a href="std.http.Client.Connection.html">Connection</a></code></pre></div><div class="tldDocs"><p>Connect to <code>path</code> as a unix domain socket. This will reuse a connection if one is already open.</p>
<p>This function is threadsafe.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>client: *<a href="std.http.Client.html">Client</a></code></pre></div><div><pre><code>path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.connectUnix">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connectUnix</span>(client: *<a href="std.http.Client.html">Client</a>, path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.http.Client.html#std.http.Client.ConnectUnixError">ConnectUnixError</a>!*<a href="std.http.Client.Connection.html">Connection</a> {
    <span class="tok-kw">if</span> (client.connection_pool.findConnection(.{
        .host = path,
        .port = <span class="tok-number">0</span>,
        .protocol = .plain,
    })) |node|
        <span class="tok-kw">return</span> node;

    <span class="tok-kw">const</span> conn = <span class="tok-kw">try</span> client.allocator.create(<a href="std.http.Client.ConnectionPool.html">ConnectionPool</a>.<a href="std.http.Client.ConnectionPool.html#std.http.Client.ConnectionPool.Node">Node</a>);
    <span class="tok-kw">errdefer</span> client.allocator.destroy(conn);
    conn.* = .{ .data = <span class="tok-null">undefined</span> };

    <span class="tok-kw">const</span> stream = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.net.html">net</a>.<a href="std.net.html#std.net.connectUnixSocket">connectUnixSocket</a>(path);
    <span class="tok-kw">errdefer</span> stream.close();

    conn.data = .{
        .stream = stream,
        .tls_client = <span class="tok-null">undefined</span>,
        .protocol = .plain,

        .host = <span class="tok-kw">try</span> client.allocator.dupe(<span class="tok-type">u8</span>, path),
        .port = <span class="tok-number">0</span>,
    };
    <span class="tok-kw">errdefer</span> client.allocator.free(conn.data.host);

    client.connection_pool.addUsed(conn);

    <span class="tok-kw">return</span> &amp;conn.data;
}</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.connectTunnel" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">connectTunnel</span><a href="#src.zig-std.http.Client.connectTunnel">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connectTunnel</span>( client: *<a href="std.http.Client.html">Client</a>, proxy: *<a href="std.http.Client.Proxy.html">Proxy</a>, tunnel_host: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, tunnel_port: <span class="tok-type">u16</span>, ) !*<a href="std.http.Client.Connection.html">Connection</a></code></pre></div><div class="tldDocs"><p>Connect to <code>tunnel_host:tunnel_port</code> using the specified proxy with HTTP
CONNECT. This will reuse a connection if one is already open.</p>
<p>This function is threadsafe.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>client: *<a href="std.http.Client.html">Client</a></code></pre></div><div><pre><code>proxy: *<a href="std.http.Client.Proxy.html">Proxy</a></code></pre></div><div><pre><code>tunnel_host: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>tunnel_port: <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.connectTunnel">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connectTunnel</span>(
    client: *<a href="std.http.Client.html">Client</a>,
    proxy: *<a href="std.http.Client.Proxy.html">Proxy</a>,
    tunnel_host: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    tunnel_port: <span class="tok-type">u16</span>,
) !*<a href="std.http.Client.Connection.html">Connection</a> {
    <span class="tok-kw">if</span> (!proxy.supports_connect) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TunnelNotSupported;

    <span class="tok-kw">if</span> (client.connection_pool.findConnection(.{
        .host = tunnel_host,
        .port = tunnel_port,
        .protocol = proxy.protocol,
    })) |node|
        <span class="tok-kw">return</span> node;

    <span class="tok-kw">var</span> maybe_valid = <span class="tok-null">false</span>;
    (tunnel: {
        <span class="tok-kw">const</span> conn = <span class="tok-kw">try</span> client.connectTcp(proxy.host, proxy.port, proxy.protocol);
        <span class="tok-kw">errdefer</span> {
            conn.closing = <span class="tok-null">true</span>;
            client.connection_pool.release(client.allocator, conn);
        }

        <span class="tok-kw">var</span> buffer: [<span class="tok-number">8096</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> req = client.open(.CONNECT, .{
            .scheme = <span class="tok-str">&quot;http&quot;</span>,
            .host = .{ .raw = tunnel_host },
            .port = tunnel_port,
        }, .{
            .redirect_behavior = .unhandled,
            .connection = conn,
            .server_header_buffer = &amp;buffer,
        }) <span class="tok-kw">catch</span> |err| {
            <a href="std.html">std</a>.<a href="std.log.html">log</a>.<a href="std.log.html#std.log.debug">debug</a>(<span class="tok-str">&quot;err {}&quot;</span>, .{err});
            <span class="tok-kw">break</span> :tunnel err;
        };
        <span class="tok-kw">defer</span> req.deinit();

        req.send() <span class="tok-kw">catch</span> |err| <span class="tok-kw">break</span> :tunnel err;
        req.wait() <span class="tok-kw">catch</span> |err| <span class="tok-kw">break</span> :tunnel err;

        <span class="tok-kw">if</span> (req.response.status.class() == .server_error) {
            maybe_valid = <span class="tok-null">true</span>;
            <span class="tok-kw">break</span> :tunnel <span class="tok-kw">error</span>.ServerError;
        }

        <span class="tok-kw">if</span> (req.response.status != .ok) <span class="tok-kw">break</span> :tunnel <span class="tok-kw">error</span>.ConnectionRefused;<span class="tok-comment">

        // this connection is now a tunnel, so we can't use it for anything else, it will only be released when the client is de-initialized.
        </span>req.connection = <span class="tok-null">null</span>;

        client.allocator.free(conn.host);
        conn.host = <span class="tok-kw">try</span> client.allocator.dupe(<span class="tok-type">u8</span>, tunnel_host);
        <span class="tok-kw">errdefer</span> client.allocator.free(conn.host);

        conn.port = tunnel_port;
        conn.closing = <span class="tok-null">false</span>;

        <span class="tok-kw">return</span> conn;
    }) <span class="tok-kw">catch</span> {<span class="tok-comment">
        // something went wrong with the tunnel
        </span>proxy.supports_connect = maybe_valid;
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TunnelNotSupported;
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.connect" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">connect</span><a href="#src.zig-std.http.Client.connect">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connect</span>( client: *<a href="std.http.Client.html">Client</a>, host: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>, protocol: <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.Protocol.html">Protocol</a>, ) <a href="std.http.Client.html#std.http.Client.ConnectError">ConnectError</a>!*<a href="std.http.Client.Connection.html">Connection</a></code></pre></div><div class="tldDocs"><p>Connect to <code>host:port</code> using the specified protocol. This will reuse a
connection if one is already open.
If a proxy is configured for the client, then the proxy will be used to
connect to the host.</p>
<p>This function is threadsafe.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>client: *<a href="std.http.Client.html">Client</a></code></pre></div><div><pre><code>host: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>port: <span class="tok-type">u16</span></code></pre></div><div><pre><code>protocol: <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.Protocol.html">Protocol</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.connect">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connect</span>(
    client: *<a href="std.http.Client.html">Client</a>,
    host: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    port: <span class="tok-type">u16</span>,
    protocol: <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.Protocol.html">Protocol</a>,
) <a href="std.http.Client.html#std.http.Client.ConnectError">ConnectError</a>!*<a href="std.http.Client.Connection.html">Connection</a> {
    <span class="tok-kw">const</span> proxy = <span class="tok-kw">switch</span> (protocol) {
        .plain =&gt; client.http_proxy,
        .tls =&gt; client.https_proxy,
    } <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> client.connectTcp(host, port, protocol);<span class="tok-comment">

    // Prevent proxying through itself.
    </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(proxy.host, host) <span class="tok-kw">and</span>
        proxy.port == port <span class="tok-kw">and</span> proxy.protocol == protocol)
    {
        <span class="tok-kw">return</span> client.connectTcp(host, port, protocol);
    }

    <span class="tok-kw">if</span> (proxy.supports_connect) tunnel: {
        <span class="tok-kw">return</span> <a href="std.http.Client.html#std.http.Client.connectTunnel">connectTunnel</a>(client, proxy, host, port) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.TunnelNotSupported =&gt; <span class="tok-kw">break</span> :tunnel,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    }<span class="tok-comment">

    // fall back to using the proxy as a normal http proxy
    </span><span class="tok-kw">const</span> conn = <span class="tok-kw">try</span> client.connectTcp(proxy.host, proxy.port, proxy.protocol);
    <span class="tok-kw">errdefer</span> {
        conn.closing = <span class="tok-null">true</span>;
        client.connection_pool.release(conn);
    }

    conn.proxied = <span class="tok-null">true</span>;
    <span class="tok-kw">return</span> conn;
}</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.open" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">open</span><a href="#src.zig-std.http.Client.open">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">open</span>( client: *<a href="std.http.Client.html">Client</a>, method: <a href="std.http.html">http</a>.<a href="std.http.Method.html">Method</a>, uri: <a href="std.Uri.html">Uri</a>, options: <a href="std.http.Client.RequestOptions.html">RequestOptions</a>, ) <a href="std.http.Client.html#std.http.Client.RequestError">RequestError</a>!<a href="std.http.Client.Request.html">Request</a></code></pre></div><div class="tldDocs"><p>Open a connection to the host specified by <code>uri</code> and prepare to send a HTTP request.</p>
<p><code>uri</code> must remain alive during the entire request.</p>
<p>The caller is responsible for calling <code>deinit()</code> on the <code><a href="std.http.Client.Request.html">Request</a></code>.
This function is threadsafe.</p>
<p>Asserts that &quot;\r\n&quot; does not occur in any header name or value.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>client: *<a href="std.http.Client.html">Client</a></code></pre></div><div><pre><code>method: <a href="std.http.html">http</a>.<a href="std.http.Method.html">Method</a></code></pre></div><div><pre><code>uri: <a href="std.Uri.html">Uri</a></code></pre></div><div><pre><code>options: <a href="std.http.Client.RequestOptions.html">RequestOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.open">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">open</span>(
    client: *<a href="std.http.Client.html">Client</a>,
    method: <a href="std.http.html">http</a>.<a href="std.http.Method.html">Method</a>,
    uri: <a href="std.Uri.html">Uri</a>,
    options: <a href="std.http.Client.RequestOptions.html">RequestOptions</a>,
) <a href="std.http.Client.html#std.http.Client.RequestError">RequestError</a>!<a href="std.http.Client.Request.html">Request</a> {
    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.runtime_safety">runtime_safety</a>) {
        <span class="tok-kw">for</span> (options.extra_headers) |header| {
            <a href="std.debug.html#std.debug.assert">assert</a>(header.name.len != <span class="tok-number">0</span>);
            <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, header.name, <span class="tok-str">':'</span>) == <span class="tok-null">null</span>);
            <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, header.name, <span class="tok-number">0</span>, <span class="tok-str">&quot;\r\n&quot;</span>) == <span class="tok-null">null</span>);
            <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, header.value, <span class="tok-number">0</span>, <span class="tok-str">&quot;\r\n&quot;</span>) == <span class="tok-null">null</span>);
        }
        <span class="tok-kw">for</span> (options.privileged_headers) |header| {
            <a href="std.debug.html#std.debug.assert">assert</a>(header.name.len != <span class="tok-number">0</span>);
            <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, header.name, <span class="tok-number">0</span>, <span class="tok-str">&quot;\r\n&quot;</span>) == <span class="tok-null">null</span>);
            <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, header.value, <span class="tok-number">0</span>, <span class="tok-str">&quot;\r\n&quot;</span>) == <span class="tok-null">null</span>);
        }
    }

    <span class="tok-kw">var</span> server_header: <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.FixedBufferAllocator.html">FixedBufferAllocator</a> = .init(options.server_header_buffer);
    <span class="tok-kw">const</span> protocol, <span class="tok-kw">const</span> valid_uri = <span class="tok-kw">try</span> validateUri(uri, server_header.allocator());

    <span class="tok-kw">if</span> (protocol == .tls <span class="tok-kw">and</span> <span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">bool</span>, &amp;client.next_https_rescan_certs, .acquire)) {
        <span class="tok-kw">if</span> (<a href="std.http.Client.html#std.http.Client.disable_tls">disable_tls</a>) <span class="tok-kw">unreachable</span>;

        client.ca_bundle_mutex.lock();
        <span class="tok-kw">defer</span> client.ca_bundle_mutex.unlock();

        <span class="tok-kw">if</span> (client.next_https_rescan_certs) {
            client.ca_bundle.rescan(client.allocator) <span class="tok-kw">catch</span>
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateBundleLoadFailure;
            <span class="tok-builtin">@atomicStore</span>(<span class="tok-type">bool</span>, &amp;client.next_https_rescan_certs, <span class="tok-null">false</span>, .release);
        }
    }

    <span class="tok-kw">const</span> conn = options.connection <span class="tok-kw">orelse</span>
        <span class="tok-kw">try</span> client.connect(valid_uri.host.?.raw, <a href="std.http.Client.html#std.http.Client.uriPort">uriPort</a>(valid_uri, protocol), protocol);

    <span class="tok-kw">var</span> req: <a href="std.http.Client.Request.html">Request</a> = .{
        .uri = valid_uri,
        .client = client,
        .connection = conn,
        .keep_alive = options.keep_alive,
        .method = method,
        .version = options.version,
        .transfer_encoding = .none,
        .redirect_behavior = options.redirect_behavior,
        .handle_continue = options.handle_continue,
        .response = .{
            .version = <span class="tok-null">undefined</span>,
            .status = <span class="tok-null">undefined</span>,
            .reason = <span class="tok-null">undefined</span>,
            .keep_alive = <span class="tok-null">undefined</span>,
            .parser = .init(server_header.buffer[server_header.end_index..]),
        },
        .headers = options.headers,
        .extra_headers = options.extra_headers,
        .privileged_headers = options.privileged_headers,
    };
    <span class="tok-kw">errdefer</span> req.deinit();

    <span class="tok-kw">return</span> req;
}</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.fetch" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetch</span><a href="#src.zig-std.http.Client.fetch">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetch</span>(client: *<a href="std.http.Client.html">Client</a>, options: <a href="std.http.Client.FetchOptions.html">FetchOptions</a>) !<a href="std.http.Client.FetchResult.html">FetchResult</a></code></pre></div><div class="tldDocs"><p>Perform a one-shot HTTP request with the provided options.</p>
<p>This function is threadsafe.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>client: *<a href="std.http.Client.html">Client</a></code></pre></div><div><pre><code>options: <a href="std.http.Client.FetchOptions.html">FetchOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.fetch">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetch</span>(client: *<a href="std.http.Client.html">Client</a>, options: <a href="std.http.Client.FetchOptions.html">FetchOptions</a>) !<a href="std.http.Client.FetchResult.html">FetchResult</a> {
    <span class="tok-kw">const</span> uri = <span class="tok-kw">switch</span> (options.location) {
        .url =&gt; |u| <span class="tok-kw">try</span> <a href="std.Uri.html">Uri</a>.<a href="std.Uri.html#std.Uri.parse">parse</a>(u),
        .uri =&gt; |u| u,
    };
    <span class="tok-kw">var</span> server_header_buffer: [<span class="tok-number">16</span> * <span class="tok-number">1024</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">const</span> method: <a href="std.http.html">http</a>.<a href="std.http.Method.html">Method</a> = options.method <span class="tok-kw">orelse</span>
        <span class="tok-kw">if</span> (options.payload != <span class="tok-null">null</span>) .POST <span class="tok-kw">else</span> .GET;

    <span class="tok-kw">var</span> req = <span class="tok-kw">try</span> <a href="std.http.Client.html#std.http.Client.open">open</a>(client, method, uri, .{
        .server_header_buffer = options.server_header_buffer <span class="tok-kw">orelse</span> &amp;server_header_buffer,
        .redirect_behavior = options.redirect_behavior <span class="tok-kw">orelse</span>
            <span class="tok-kw">if</span> (options.payload == <span class="tok-null">null</span>) <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">3</span>) <span class="tok-kw">else</span> .unhandled,
        .headers = options.headers,
        .extra_headers = options.extra_headers,
        .privileged_headers = options.privileged_headers,
        .keep_alive = options.keep_alive,
    });
    <span class="tok-kw">defer</span> req.deinit();

    <span class="tok-kw">if</span> (options.payload) |payload| req.transfer_encoding = .{ .content_length = payload.len };

    <span class="tok-kw">try</span> req.send();

    <span class="tok-kw">if</span> (options.payload) |payload| <span class="tok-kw">try</span> req.writeAll(payload);

    <span class="tok-kw">try</span> req.finish();
    <span class="tok-kw">try</span> req.wait();

    <span class="tok-kw">switch</span> (options.response_storage) {
        .ignore =&gt; {<span class="tok-comment">
            // Take advantage of request internals to discard the response body
            // and make the connection available for another request.
            </span>req.response.skip = <span class="tok-null">true</span>;
            <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> req.transferRead(&amp;.{}) == <span class="tok-number">0</span>);<span class="tok-comment"> // No buffer is necessary when skipping.
        </span>},
        .dynamic =&gt; |list| {
            <span class="tok-kw">const</span> max_append_size = options.max_append_size <span class="tok-kw">orelse</span> <span class="tok-number">2</span> * <span class="tok-number">1024</span> * <span class="tok-number">1024</span>;
            <span class="tok-kw">try</span> req.reader().readAllArrayList(list, max_append_size);
        },
        .static =&gt; |list| {
            <span class="tok-kw">const</span> buf = b: {
                <span class="tok-kw">const</span> buf = list.unusedCapacitySlice();
                <span class="tok-kw">if</span> (options.max_append_size) |len| {
                    <span class="tok-kw">if</span> (len &lt; buf.len) <span class="tok-kw">break</span> :b buf[<span class="tok-number">0</span>..len];
                }
                <span class="tok-kw">break</span> :b buf;
            };
            list.items.len += <span class="tok-kw">try</span> req.reader().readAll(buf);
        },
    }

    <span class="tok-kw">return</span> .{
        .status = req.response.status,
    };
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.http.Client">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! HTTP(S) Client implementation.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! Connections are opened in a thread-safe manner, but individual Requests are not.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! TLS support may be disabled via `std.options.http_disable_tls`.</span>

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../std.zig&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;
<span class="tok-kw">const</span> http = <a href="std.html">std</a>.<a href="std.http.html">http</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> net = <a href="std.html">std</a>.<a href="std.net.html">net</a>;
<span class="tok-kw">const</span> Uri = <a href="std.html">std</a>.<a href="std.Uri.html">Uri</a>;
<span class="tok-kw">const</span> Allocator = <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> use_vectors = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> != .stage2_x86_64;

<span class="tok-kw">const</span> Client = <span class="tok-builtin">@This</span>();
<span class="tok-kw">const</span> proto = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;protocol.zig&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> disable_tls = <a href="std.html">std</a>.<a href="std.html#std.options">options</a>.<a href="#">http_disable_tls</a>;

<span class="tok-comment">/// Used for all client allocations. Must be thread-safe.</span>
allocator: <a href="std.mem.Allocator.html">Allocator</a>,

ca_bundle: <span class="tok-kw">if</span> (<a href="std.http.Client.html#std.http.Client.disable_tls">disable_tls</a>) <span class="tok-type">void</span> <span class="tok-kw">else</span> <a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>.<a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.Bundle.html">Bundle</a> = <span class="tok-kw">if</span> (<a href="std.http.Client.html#std.http.Client.disable_tls">disable_tls</a>) {} <span class="tok-kw">else</span> .{},
ca_bundle_mutex: <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.Mutex.html">Mutex</a> = .{},

<span class="tok-comment">/// When this is `true`, the next time this client performs an HTTPS request,</span>
<span class="tok-comment">/// it will first rescan the system for root certificates.</span>
next_https_rescan_certs: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,

<span class="tok-comment">/// The pool of connections that can be reused (and currently in use).</span>
connection_pool: <a href="std.http.Client.ConnectionPool.html">ConnectionPool</a> = .{},

<span class="tok-comment">/// If populated, all http traffic travels through this third party.</span>
<span class="tok-comment">/// This field cannot be modified while the client has active connections.</span>
<span class="tok-comment">/// Pointer to externally-owned memory.</span>
http_proxy: ?*<a href="std.http.Client.Proxy.html">Proxy</a> = <span class="tok-null">null</span>,
<span class="tok-comment">/// If populated, all https traffic travels through this third party.</span>
<span class="tok-comment">/// This field cannot be modified while the client has active connections.</span>
<span class="tok-comment">/// Pointer to externally-owned memory.</span>
https_proxy: ?*<a href="std.http.Client.Proxy.html">Proxy</a> = <span class="tok-null">null</span>,

<span class="tok-comment">/// A set of linked lists of connections that can be reused.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ConnectionPool = <span class="tok-kw">struct</span> {
    mutex: <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.Mutex.html">Mutex</a> = .{},
    <span class="tok-comment">/// Open connections that are currently in use.</span>
    used: <a href="std.http.Client.ConnectionPool.html#std.http.Client.ConnectionPool.Queue">Queue</a> = .{},
    <span class="tok-comment">/// Open connections that are not currently in use.</span>
    free: <a href="std.http.Client.ConnectionPool.html#std.http.Client.ConnectionPool.Queue">Queue</a> = .{},
    free_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
    free_size: <span class="tok-type">usize</span> = <span class="tok-number">32</span>,

    <span class="tok-comment">/// The criteria for a connection to be considered a match.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Criteria = <span class="tok-kw">struct</span> {
        host: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        port: <span class="tok-type">u16</span>,
        protocol: <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.Protocol.html">Protocol</a>,
    };

    <span class="tok-kw">const</span> Queue = <a href="std.html">std</a>.<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">DoublyLinkedList</a>(<a href="std.http.Client.Connection.html">Connection</a>);
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Node = <a href="std.http.Client.ConnectionPool.html#std.http.Client.ConnectionPool.Queue">Queue</a>.<a href="#">Node</a>;

    <span class="tok-comment">/// Finds and acquires a connection from the connection pool matching the criteria. This function is threadsafe.</span>
    <span class="tok-comment">/// If no connection is found, null is returned.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findConnection</span>(pool: *<a href="std.http.Client.ConnectionPool.html">ConnectionPool</a>, criteria: <a href="std.http.Client.ConnectionPool.Criteria.html">Criteria</a>) ?*<a href="std.http.Client.Connection.html">Connection</a> {
        pool.mutex.lock();
        <span class="tok-kw">defer</span> pool.mutex.unlock();

        <span class="tok-kw">var</span> next = pool.free.last;
        <span class="tok-kw">while</span> (next) |node| : (next = node.prev) {
            <span class="tok-kw">if</span> (node.data.protocol != criteria.protocol) <span class="tok-kw">continue</span>;
            <span class="tok-kw">if</span> (node.data.port != criteria.port) <span class="tok-kw">continue</span>;<span class="tok-comment">

            // Domain names are case-insensitive (RFC 5890, Section 2.3.2.4)
            </span><span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(node.data.host, criteria.host)) <span class="tok-kw">continue</span>;

            pool.acquireUnsafe(node);
            <span class="tok-kw">return</span> &amp;node.data;
        }

        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }

    <span class="tok-comment">/// Acquires an existing connection from the connection pool. This function is not threadsafe.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">acquireUnsafe</span>(pool: *<a href="std.http.Client.ConnectionPool.html">ConnectionPool</a>, node: *<a href="std.http.Client.ConnectionPool.html#std.http.Client.ConnectionPool.Node">Node</a>) <span class="tok-type">void</span> {
        pool.free.remove(node);
        pool.free_len -= <span class="tok-number">1</span>;

        pool.used.append(node);
    }

    <span class="tok-comment">/// Acquires an existing connection from the connection pool. This function is threadsafe.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">acquire</span>(pool: *<a href="std.http.Client.ConnectionPool.html">ConnectionPool</a>, node: *<a href="std.http.Client.ConnectionPool.html#std.http.Client.ConnectionPool.Node">Node</a>) <span class="tok-type">void</span> {
        pool.mutex.lock();
        <span class="tok-kw">defer</span> pool.mutex.unlock();

        <span class="tok-kw">return</span> pool.acquireUnsafe(node);
    }

    <span class="tok-comment">/// Tries to release a connection back to the connection pool. This function is threadsafe.</span>
    <span class="tok-comment">/// If the connection is marked as closing, it will be closed instead.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The allocator must be the owner of all nodes in this pool.</span>
    <span class="tok-comment">/// The allocator must be the owner of all resources associated with the connection.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">release</span>(pool: *<a href="std.http.Client.ConnectionPool.html">ConnectionPool</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, connection: *<a href="std.http.Client.Connection.html">Connection</a>) <span class="tok-type">void</span> {
        pool.mutex.lock();
        <span class="tok-kw">defer</span> pool.mutex.unlock();

        <span class="tok-kw">const</span> node: *<a href="std.http.Client.ConnectionPool.html#std.http.Client.ConnectionPool.Node">Node</a> = <span class="tok-builtin">@fieldParentPtr</span>(<span class="tok-str">&quot;data&quot;</span>, connection);

        pool.used.remove(node);

        <span class="tok-kw">if</span> (node.data.closing <span class="tok-kw">or</span> pool.free_size == <span class="tok-number">0</span>) {
            node.data.close(allocator);
            <span class="tok-kw">return</span> allocator.destroy(node);
        }

        <span class="tok-kw">if</span> (pool.free_len &gt;= pool.free_size) {
            <span class="tok-kw">const</span> popped = pool.free.popFirst() <span class="tok-kw">orelse</span> <span class="tok-kw">unreachable</span>;
            pool.free_len -= <span class="tok-number">1</span>;

            popped.data.close(allocator);
            allocator.destroy(popped);
        }

        <span class="tok-kw">if</span> (node.data.proxied) {
            pool.free.prepend(node);<span class="tok-comment"> // proxied connections go to the end of the queue, always try direct connections first
        </span>} <span class="tok-kw">else</span> {
            pool.free.append(node);
        }

        pool.free_len += <span class="tok-number">1</span>;
    }

    <span class="tok-comment">/// Adds a newly created node to the pool of used connections. This function is threadsafe.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addUsed</span>(pool: *<a href="std.http.Client.ConnectionPool.html">ConnectionPool</a>, node: *<a href="std.http.Client.ConnectionPool.html#std.http.Client.ConnectionPool.Node">Node</a>) <span class="tok-type">void</span> {
        pool.mutex.lock();
        <span class="tok-kw">defer</span> pool.mutex.unlock();

        pool.used.append(node);
    }

    <span class="tok-comment">/// Resizes the connection pool. This function is threadsafe.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If the new size is smaller than the current size, then idle connections will be closed until the pool is the new size.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(pool: *<a href="std.http.Client.ConnectionPool.html">ConnectionPool</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        pool.mutex.lock();
        <span class="tok-kw">defer</span> pool.mutex.unlock();

        <span class="tok-kw">const</span> next = pool.free.first;
        _ = next;
        <span class="tok-kw">while</span> (pool.free_len &gt; new_size) {
            <span class="tok-kw">const</span> popped = pool.free.popFirst() <span class="tok-kw">orelse</span> <span class="tok-kw">unreachable</span>;
            pool.free_len -= <span class="tok-number">1</span>;

            popped.data.close(allocator);
            allocator.destroy(popped);
        }

        pool.free_size = new_size;
    }

    <span class="tok-comment">/// Frees the connection pool and closes all connections within. This function is threadsafe.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// All future operations on the connection pool will deadlock.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(pool: *<a href="std.http.Client.ConnectionPool.html">ConnectionPool</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
        pool.mutex.lock();

        <span class="tok-kw">var</span> next = pool.free.first;
        <span class="tok-kw">while</span> (next) |node| {
            <span class="tok-kw">defer</span> allocator.destroy(node);
            next = node.next;

            node.data.close(allocator);
        }

        next = pool.used.first;
        <span class="tok-kw">while</span> (next) |node| {
            <span class="tok-kw">defer</span> allocator.destroy(node);
            next = node.next;

            node.data.close(allocator);
        }

        pool.* = <span class="tok-null">undefined</span>;
    }
};

<span class="tok-comment">/// An interface to either a plain or TLS connection.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Connection = <span class="tok-kw">struct</span> {
    stream: <a href="std.net.html">net</a>.<a href="std.net.Stream.html">Stream</a>,
    <span class="tok-comment">/// undefined unless protocol is tls.</span>
    tls_client: <span class="tok-kw">if</span> (!<a href="std.http.Client.html#std.http.Client.disable_tls">disable_tls</a>) *<a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>.<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.Client.html">Client</a> <span class="tok-kw">else</span> <span class="tok-type">void</span>,

    <span class="tok-comment">/// The protocol that this connection is using.</span>
    protocol: <a href="std.http.Client.Connection.Protocol.html">Protocol</a>,

    <span class="tok-comment">/// The host that this connection is connected to.</span>
    host: []<span class="tok-type">u8</span>,

    <span class="tok-comment">/// The port that this connection is connected to.</span>
    port: <span class="tok-type">u16</span>,

    <span class="tok-comment">/// Whether this connection is proxied and is not directly connected.</span>
    proxied: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

    <span class="tok-comment">/// Whether this connection is closing when we're done with it.</span>
    closing: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

    read_start: <a href="std.http.Client.Connection.html#std.http.Client.Connection.BufferSize">BufferSize</a> = <span class="tok-number">0</span>,
    read_end: <a href="std.http.Client.Connection.html#std.http.Client.Connection.BufferSize">BufferSize</a> = <span class="tok-number">0</span>,
    write_end: <a href="std.http.Client.Connection.html#std.http.Client.Connection.BufferSize">BufferSize</a> = <span class="tok-number">0</span>,
    read_buf: [<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_record_len">buffer_size</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,
    write_buf: [<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_record_len">buffer_size</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> buffer_size = <a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>.<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_record_len">max_ciphertext_record_len</a>;
    <span class="tok-kw">const</span> BufferSize = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.IntFittingRange">IntFittingRange</a>(<span class="tok-number">0</span>, <a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_record_len">buffer_size</a>);

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Protocol = <span class="tok-kw">enum</span> { plain, tls };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readvDirectTls</span>(conn: *<a href="std.http.Client.Connection.html">Connection</a>, buffers: []<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>) <a href="std.http.Client.Connection.html#std.http.Client.Connection.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> conn.tls_client.readv(conn.stream, buffers) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
            // https://github.com/ziglang/zig/issues/2473
            </span><span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u8</span>, <span class="tok-builtin">@errorName</span>(err), <span class="tok-str">&quot;TlsAlert&quot;</span>)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsAlert;

            <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.TlsConnectionTruncated, <span class="tok-kw">error</span>.TlsRecordOverflow, <span class="tok-kw">error</span>.TlsDecodeError, <span class="tok-kw">error</span>.TlsBadRecordMac, <span class="tok-kw">error</span>.TlsBadLength, <span class="tok-kw">error</span>.TlsIllegalParameter, <span class="tok-kw">error</span>.TlsUnexpectedMessage =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsFailure,
                <span class="tok-kw">error</span>.ConnectionTimedOut =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
                <span class="tok-kw">error</span>.ConnectionResetByPeer, <span class="tok-kw">error</span>.BrokenPipe =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedReadFailure,
            }
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readvDirect</span>(conn: *<a href="std.http.Client.Connection.html">Connection</a>, buffers: []<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>) <a href="std.http.Client.Connection.html#std.http.Client.Connection.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
        <span class="tok-kw">if</span> (conn.protocol == .tls) {
            <span class="tok-kw">if</span> (<a href="std.http.Client.html#std.http.Client.disable_tls">disable_tls</a>) <span class="tok-kw">unreachable</span>;

            <span class="tok-kw">return</span> conn.readvDirectTls(buffers);
        }

        <span class="tok-kw">return</span> conn.stream.readv(buffers) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.ConnectionTimedOut =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            <span class="tok-kw">error</span>.ConnectionResetByPeer, <span class="tok-kw">error</span>.BrokenPipe =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedReadFailure,
        };
    }

    <span class="tok-comment">/// Refills the read buffer with data from the connection.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fill</span>(conn: *<a href="std.http.Client.Connection.html">Connection</a>) <a href="std.http.Client.Connection.html#std.http.Client.Connection.ReadError">ReadError</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (conn.read_end != conn.read_start) <span class="tok-kw">return</span>;

        <span class="tok-kw">var</span> iovecs = [<span class="tok-number">1</span>]<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>{
            .{ .base = &amp;conn.read_buf, .len = conn.read_buf.len },
        };
        <span class="tok-kw">const</span> nread = <span class="tok-kw">try</span> conn.readvDirect(&amp;iovecs);
        <span class="tok-kw">if</span> (nread == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfStream;
        conn.read_start = <span class="tok-number">0</span>;
        conn.read_end = <span class="tok-builtin">@intCast</span>(nread);
    }

    <span class="tok-comment">/// Returns the current slice of buffered data.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peek</span>(conn: *<a href="std.http.Client.Connection.html">Connection</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">return</span> conn.read_buf[conn.read_start..conn.read_end];
    }

    <span class="tok-comment">/// Discards the given number of bytes from the read buffer.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">drop</span>(conn: *<a href="std.http.Client.Connection.html">Connection</a>, num: <a href="std.http.Client.Connection.html#std.http.Client.Connection.BufferSize">BufferSize</a>) <span class="tok-type">void</span> {
        conn.read_start += num;
    }

    <span class="tok-comment">/// Reads data from the connection into the given buffer.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(conn: *<a href="std.http.Client.Connection.html">Connection</a>, buffer: []<span class="tok-type">u8</span>) <a href="std.http.Client.Connection.html#std.http.Client.Connection.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
        <span class="tok-kw">const</span> available_read = conn.read_end - conn.read_start;
        <span class="tok-kw">const</span> available_buffer = buffer.len;

        <span class="tok-kw">if</span> (available_read &gt; available_buffer) {<span class="tok-comment"> // partially read buffered data
            </span><span class="tok-builtin">@memcpy</span>(buffer[<span class="tok-number">0</span>..available_buffer], conn.read_buf[conn.read_start..conn.read_end][<span class="tok-number">0</span>..available_buffer]);
            conn.read_start += <span class="tok-builtin">@intCast</span>(available_buffer);

            <span class="tok-kw">return</span> available_buffer;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (available_read &gt; <span class="tok-number">0</span>) {<span class="tok-comment"> // fully read buffered data
            </span><span class="tok-builtin">@memcpy</span>(buffer[<span class="tok-number">0</span>..available_read], conn.read_buf[conn.read_start..conn.read_end]);
            conn.read_start += available_read;

            <span class="tok-kw">return</span> available_read;
        }

        <span class="tok-kw">var</span> iovecs = [<span class="tok-number">2</span>]<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>{
            .{ .base = buffer.ptr, .len = buffer.len },
            .{ .base = &amp;conn.read_buf, .len = conn.read_buf.len },
        };
        <span class="tok-kw">const</span> nread = <span class="tok-kw">try</span> conn.readvDirect(&amp;iovecs);

        <span class="tok-kw">if</span> (nread &gt; buffer.len) {
            conn.read_start = <span class="tok-number">0</span>;
            conn.read_end = <span class="tok-builtin">@intCast</span>(nread - buffer.len);
            <span class="tok-kw">return</span> buffer.len;
        }

        <span class="tok-kw">return</span> nread;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadError = <span class="tok-kw">error</span>{
        TlsFailure,
        TlsAlert,
        ConnectionTimedOut,
        ConnectionResetByPeer,
        UnexpectedReadFailure,
        EndOfStream,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Reader = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericReader">Reader</a>(*<a href="std.http.Client.Connection.html">Connection</a>, <a href="std.http.Client.Connection.html#std.http.Client.Connection.ReadError">ReadError</a>, <a href="std.http.Client.Connection.html#std.http.Client.Connection.read">read</a>);

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reader</span>(conn: *<a href="std.http.Client.Connection.html">Connection</a>) <a href="std.http.Client.Connection.html#std.http.Client.Connection.Reader">Reader</a> {
        <span class="tok-kw">return</span> <a href="std.http.Client.Connection.html#std.http.Client.Connection.Reader">Reader</a>{ .context = conn };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAllDirectTls</span>(conn: *<a href="std.http.Client.Connection.html">Connection</a>, buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">return</span> conn.tls_client.writeAll(conn.stream, buffer) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.BrokenPipe, <span class="tok-kw">error</span>.ConnectionResetByPeer =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedWriteFailure,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAllDirect</span>(conn: *<a href="std.http.Client.Connection.html">Connection</a>, buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (conn.protocol == .tls) {
            <span class="tok-kw">if</span> (<a href="std.http.Client.html#std.http.Client.disable_tls">disable_tls</a>) <span class="tok-kw">unreachable</span>;

            <span class="tok-kw">return</span> conn.writeAllDirectTls(buffer);
        }

        <span class="tok-kw">return</span> conn.stream.writeAll(buffer) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.BrokenPipe, <span class="tok-kw">error</span>.ConnectionResetByPeer =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedWriteFailure,
        };
    }

    <span class="tok-comment">/// Writes the given buffer to the connection.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(conn: *<a href="std.http.Client.Connection.html">Connection</a>, buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a>!<span class="tok-type">usize</span> {
        <span class="tok-kw">if</span> (conn.write_buf.len - conn.write_end &lt; buffer.len) {
            <span class="tok-kw">try</span> conn.flush();

            <span class="tok-kw">if</span> (buffer.len &gt; conn.write_buf.len) {
                <span class="tok-kw">try</span> conn.writeAllDirect(buffer);
                <span class="tok-kw">return</span> buffer.len;
            }
        }

        <span class="tok-builtin">@memcpy</span>(conn.write_buf[conn.write_end..][<span class="tok-number">0</span>..buffer.len], buffer);
        conn.write_end += <span class="tok-builtin">@intCast</span>(buffer.len);

        <span class="tok-kw">return</span> buffer.len;
    }

    <span class="tok-comment">/// Returns a buffer to be filled with exactly len bytes to write to the connection.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocWriteBuffer</span>(conn: *<a href="std.http.Client.Connection.html">Connection</a>, len: <a href="std.http.Client.Connection.html#std.http.Client.Connection.BufferSize">BufferSize</a>) <a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a>![]<span class="tok-type">u8</span> {
        <span class="tok-kw">if</span> (conn.write_buf.len - conn.write_end &lt; len) <span class="tok-kw">try</span> conn.flush();
        <span class="tok-kw">defer</span> conn.write_end += len;
        <span class="tok-kw">return</span> conn.write_buf[conn.write_end..][<span class="tok-number">0</span>..len];
    }

    <span class="tok-comment">/// Flushes the write buffer to the connection.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">flush</span>(conn: *<a href="std.http.Client.Connection.html">Connection</a>) <a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (conn.write_end == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;

        <span class="tok-kw">try</span> conn.writeAllDirect(conn.write_buf[<span class="tok-number">0</span>..conn.write_end]);
        conn.write_end = <span class="tok-number">0</span>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteError = <span class="tok-kw">error</span>{
        ConnectionResetByPeer,
        UnexpectedWriteFailure,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.http.Client.Connection.html">Connection</a>, <a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a>, <a href="std.http.Client.Connection.html#std.http.Client.Connection.write">write</a>);

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(conn: *<a href="std.http.Client.Connection.html">Connection</a>) <a href="std.http.Client.Connection.html#std.http.Client.Connection.Writer">Writer</a> {
        <span class="tok-kw">return</span> <a href="std.http.Client.Connection.html#std.http.Client.Connection.Writer">Writer</a>{ .context = conn };
    }

    <span class="tok-comment">/// Closes the connection.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close</span>(conn: *<a href="std.http.Client.Connection.html">Connection</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (conn.protocol == .tls) {
            <span class="tok-kw">if</span> (<a href="std.http.Client.html#std.http.Client.disable_tls">disable_tls</a>) <span class="tok-kw">unreachable</span>;<span class="tok-comment">

            // try to cleanly close the TLS connection, for any server that cares.
            </span>_ = conn.tls_client.writeEnd(conn.stream, <span class="tok-str">&quot;&quot;</span>, <span class="tok-null">true</span>) <span class="tok-kw">catch</span> {};
            <span class="tok-kw">if</span> (conn.tls_client.ssl_key_log) |key_log| key_log.file.close();
            allocator.destroy(conn.tls_client);
        }

        conn.stream.close();
        allocator.free(conn.host);
    }
};

<span class="tok-comment">/// The mode of transport for requests.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RequestTransfer = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    content_length: <span class="tok-type">u64</span>,
    chunked: <span class="tok-type">void</span>,
    none: <span class="tok-type">void</span>,
};

<span class="tok-comment">/// The decompressor for response messages.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Compression = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeflateDecompressor = <a href="std.html">std</a>.<a href="std.compress.html">compress</a>.<a href="std.compress.zlib.html">zlib</a>.<a href="std.compress.zlib.html#std.compress.zlib.Decompressor">Decompressor</a>(<a href="std.http.Client.Request.html">Request</a>.<a href="std.http.Client.Request.html#std.http.Client.Request.TransferReader">TransferReader</a>);
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GzipDecompressor = <a href="std.html">std</a>.<a href="std.compress.html">compress</a>.<a href="std.compress.gzip.html">gzip</a>.<a href="std.compress.gzip.html#std.compress.gzip.Decompressor">Decompressor</a>(<a href="std.http.Client.Request.html">Request</a>.<a href="std.http.Client.Request.html#std.http.Client.Request.TransferReader">TransferReader</a>);<span class="tok-comment">
    // https://github.com/ziglang/zig/issues/18937
    //pub const ZstdDecompressor = std.compress.zstd.DecompressStream(Request.TransferReader, .{});

    </span>deflate: <a href="std.http.Client.Compression.html#std.http.Client.Compression.DeflateDecompressor">DeflateDecompressor</a>,
    gzip: <a href="std.http.Client.Compression.html#std.http.Client.Compression.GzipDecompressor">GzipDecompressor</a>,<span class="tok-comment">
    // https://github.com/ziglang/zig/issues/18937
    //zstd: ZstdDecompressor,
    </span>none: <span class="tok-type">void</span>,
};

<span class="tok-comment">/// A HTTP response originating from a server.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Response = <span class="tok-kw">struct</span> {
    version: <a href="std.http.html">http</a>.<a href="std.http.Version.html">Version</a>,
    status: <a href="std.http.html">http</a>.<a href="std.http.Status.html">Status</a>,
    reason: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,

    <span class="tok-comment">/// Points into the user-provided `server_header_buffer`.</span>
    location: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Points into the user-provided `server_header_buffer`.</span>
    content_type: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Points into the user-provided `server_header_buffer`.</span>
    content_disposition: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,

    keep_alive: <span class="tok-type">bool</span>,

    <span class="tok-comment">/// If present, the number of bytes in the response body.</span>
    content_length: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>,

    <span class="tok-comment">/// If present, the transfer encoding of the response body, otherwise none.</span>
    transfer_encoding: <a href="std.http.html">http</a>.<a href="std.http.TransferEncoding.html">TransferEncoding</a> = .none,

    <span class="tok-comment">/// If present, the compression of the response body, otherwise identity (no compression).</span>
    transfer_compression: <a href="std.http.html">http</a>.<a href="std.http.ContentEncoding.html">ContentEncoding</a> = .identity,

    parser: <a href="std.http.protocol.html">proto</a>.<a href="std.http.protocol.HeadersParser.html">HeadersParser</a>,
    compression: <a href="std.http.Client.Compression.html">Compression</a> = .none,

    <span class="tok-comment">/// Whether the response body should be skipped. Any data read from the</span>
    <span class="tok-comment">/// response body will be discarded.</span>
    skip: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ParseError = <span class="tok-kw">error</span>{
        HttpHeadersInvalid,
        HttpHeaderContinuationsUnsupported,
        HttpTransferEncodingUnsupported,
        HttpConnectionHeaderUnsupported,
        InvalidContentLength,
        CompressionUnsupported,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parse</span>(res: *<a href="std.http.Client.Response.html">Response</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.http.Client.Response.html#std.http.Client.Response.ParseError">ParseError</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">var</span> it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.splitSequence">splitSequence</a>(<span class="tok-type">u8</span>, bytes, <span class="tok-str">&quot;\r\n&quot;</span>);

        <span class="tok-kw">const</span> first_line = it.next().?;
        <span class="tok-kw">if</span> (first_line.len &lt; <span class="tok-number">12</span>) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid;
        }

        <span class="tok-kw">const</span> version: <a href="std.http.html">http</a>.<a href="std.http.Version.html">Version</a> = <span class="tok-kw">switch</span> (<a href="std.http.Client.Response.html#std.http.Client.Response.int64">int64</a>(first_line[<span class="tok-number">0</span>..<span class="tok-number">8</span>])) {
            <a href="std.http.Client.Response.html#std.http.Client.Response.int64">int64</a>(<span class="tok-str">&quot;HTTP/1.0&quot;</span>) =&gt; .@&quot;HTTP/1.0&quot;,
            <a href="std.http.Client.Response.html#std.http.Client.Response.int64">int64</a>(<span class="tok-str">&quot;HTTP/1.1&quot;</span>) =&gt; .@&quot;HTTP/1.1&quot;,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid,
        };
        <span class="tok-kw">if</span> (first_line[<span class="tok-number">8</span>] != <span class="tok-str">' '</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid;
        <span class="tok-kw">const</span> status: <a href="std.http.html">http</a>.<a href="std.http.Status.html">Status</a> = <span class="tok-builtin">@enumFromInt</span>(<a href="std.http.Client.Response.html#std.http.Client.Response.parseInt3">parseInt3</a>(first_line[<span class="tok-number">9</span>..<span class="tok-number">12</span>]));
        <span class="tok-kw">const</span> reason = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trimLeft">trimLeft</a>(<span class="tok-type">u8</span>, first_line[<span class="tok-number">12</span>..], <span class="tok-str">&quot; &quot;</span>);

        res.version = version;
        res.status = status;
        res.reason = reason;
        res.keep_alive = <span class="tok-kw">switch</span> (version) {
            .@&quot;HTTP/1.0&quot; =&gt; <span class="tok-null">false</span>,
            .@&quot;HTTP/1.1&quot; =&gt; <span class="tok-null">true</span>,
        };

        <span class="tok-kw">while</span> (it.next()) |line| {
            <span class="tok-kw">if</span> (line.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;
            <span class="tok-kw">switch</span> (line[<span class="tok-number">0</span>]) {
                <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeaderContinuationsUnsupported,
                <span class="tok-kw">else</span> =&gt; {},
            }

            <span class="tok-kw">var</span> line_it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(<span class="tok-type">u8</span>, line, <span class="tok-str">':'</span>);
            <span class="tok-kw">const</span> header_name = line_it.next().?;
            <span class="tok-kw">const</span> header_value = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, line_it.rest(), <span class="tok-str">&quot; \t&quot;</span>);
            <span class="tok-kw">if</span> (header_name.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid;

            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(header_name, <span class="tok-str">&quot;connection&quot;</span>)) {
                res.keep_alive = !<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(header_value, <span class="tok-str">&quot;close&quot;</span>);
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(header_name, <span class="tok-str">&quot;content-type&quot;</span>)) {
                res.content_type = header_value;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(header_name, <span class="tok-str">&quot;location&quot;</span>)) {
                res.location = header_value;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(header_name, <span class="tok-str">&quot;content-disposition&quot;</span>)) {
                res.content_disposition = header_value;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(header_name, <span class="tok-str">&quot;transfer-encoding&quot;</span>)) {<span class="tok-comment">
                // Transfer-Encoding: second, first
                // Transfer-Encoding: deflate, chunked
                </span><span class="tok-kw">var</span> iter = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a>(<span class="tok-type">u8</span>, header_value, <span class="tok-str">','</span>);

                <span class="tok-kw">const</span> first = iter.first();
                <span class="tok-kw">const</span> trimmed_first = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, first, <span class="tok-str">&quot; &quot;</span>);

                <span class="tok-kw">var</span> next: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = first;
                <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.stringToEnum">stringToEnum</a>(<a href="std.http.html">http</a>.<a href="std.http.TransferEncoding.html">TransferEncoding</a>, trimmed_first)) |transfer| {
                    <span class="tok-kw">if</span> (res.transfer_encoding != .none) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid;<span class="tok-comment"> // we already have a transfer encoding
                    </span>res.transfer_encoding = transfer;

                    next = iter.next();
                }

                <span class="tok-kw">if</span> (next) |second| {
                    <span class="tok-kw">const</span> trimmed_second = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, second, <span class="tok-str">&quot; &quot;</span>);

                    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.stringToEnum">stringToEnum</a>(<a href="std.http.html">http</a>.<a href="std.http.ContentEncoding.html">ContentEncoding</a>, trimmed_second)) |transfer| {
                        <span class="tok-kw">if</span> (res.transfer_compression != .identity) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid;<span class="tok-comment"> // double compression is not supported
                        </span>res.transfer_compression = transfer;
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpTransferEncodingUnsupported;
                    }
                }

                <span class="tok-kw">if</span> (iter.next()) |_| <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpTransferEncodingUnsupported;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(header_name, <span class="tok-str">&quot;content-length&quot;</span>)) {
                <span class="tok-kw">const</span> content_length = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">u64</span>, header_value, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidContentLength;

                <span class="tok-kw">if</span> (res.content_length != <span class="tok-null">null</span> <span class="tok-kw">and</span> res.content_length != content_length) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid;

                res.content_length = content_length;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(header_name, <span class="tok-str">&quot;content-encoding&quot;</span>)) {
                <span class="tok-kw">if</span> (res.transfer_compression != .identity) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid;

                <span class="tok-kw">const</span> trimmed = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, header_value, <span class="tok-str">&quot; &quot;</span>);

                <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.stringToEnum">stringToEnum</a>(<a href="std.http.html">http</a>.<a href="std.http.ContentEncoding.html">ContentEncoding</a>, trimmed)) |ce| {
                    res.transfer_compression = ce;
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpTransferEncodingUnsupported;
                }
            }
        }
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid;<span class="tok-comment"> // missing empty line
    </span>}

    <span class="tok-kw">test</span> parse {
        <span class="tok-kw">const</span> response_bytes = <span class="tok-str">&quot;HTTP/1.1 200 OK\r\n&quot;</span> ++
            <span class="tok-str">&quot;LOcation:url\r\n&quot;</span> ++
            <span class="tok-str">&quot;content-tYpe: text/plain\r\n&quot;</span> ++
            <span class="tok-str">&quot;content-disposition:attachment; filename=example.txt \r\n&quot;</span> ++
            <span class="tok-str">&quot;content-Length:10\r\n&quot;</span> ++
            <span class="tok-str">&quot;TRansfer-encoding:\tdeflate, chunked \r\n&quot;</span> ++
            <span class="tok-str">&quot;connectioN:\t keep-alive \r\n\r\n&quot;</span>;

        <span class="tok-kw">var</span> header_buffer: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> res = <a href="std.http.Client.Response.html">Response</a>{
            .status = <span class="tok-null">undefined</span>,
            .reason = <span class="tok-null">undefined</span>,
            .version = <span class="tok-null">undefined</span>,
            .keep_alive = <span class="tok-null">false</span>,
            .parser = .init(&amp;header_buffer),
        };

        <span class="tok-builtin">@memcpy</span>(header_buffer[<span class="tok-number">0</span>..response_bytes.len], response_bytes);
        res.parser.header_bytes_len = response_bytes.len;

        <span class="tok-kw">try</span> res.parse(response_bytes);

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.@&quot;HTTP/1.1&quot;, res.version);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;OK&quot;</span>, res.reason);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.ok, res.status);

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;url&quot;</span>, res.location.?);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;text/plain&quot;</span>, res.content_type.?);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;attachment; filename=example.txt&quot;</span>, res.content_disposition.?);

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">true</span>, res.keep_alive);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">10</span>, res.content_length.?);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.chunked, res.transfer_encoding);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.deflate, res.transfer_compression);
    }

    <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">int64</span>(array: *<span class="tok-kw">const</span> [<span class="tok-number">8</span>]<span class="tok-type">u8</span>) <span class="tok-type">u64</span> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(array.*);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseInt3</span>(text: *<span class="tok-kw">const</span> [<span class="tok-number">3</span>]<span class="tok-type">u8</span>) <span class="tok-type">u10</span> {
        <span class="tok-kw">if</span> (<a href="std.http.Client.html#std.http.Client.use_vectors">use_vectors</a>) {
            <span class="tok-kw">const</span> nnn: <span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">u8</span>) = text.*;
            <span class="tok-kw">const</span> zero: <span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">u8</span>) = .{ <span class="tok-str">'0'</span>, <span class="tok-str">'0'</span>, <span class="tok-str">'0'</span> };
            <span class="tok-kw">const</span> mmm: <span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">u10</span>) = .{ <span class="tok-number">100</span>, <span class="tok-number">10</span>, <span class="tok-number">1</span> };
            <span class="tok-kw">return</span> <span class="tok-builtin">@reduce</span>(.Add, <span class="tok-builtin">@as</span>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">u10</span>), nnn -% zero) *% mmm);
        }
        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">u10</span>, text, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">test</span> parseInt3 {
        <span class="tok-kw">const</span> expectEqual = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>;
        <span class="tok-kw">try</span> expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">u10</span>, <span class="tok-number">0</span>), <a href="std.http.Client.Response.html#std.http.Client.Response.parseInt3">parseInt3</a>(<span class="tok-str">&quot;000&quot;</span>));
        <span class="tok-kw">try</span> expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">u10</span>, <span class="tok-number">418</span>), <a href="std.http.Client.Response.html#std.http.Client.Response.parseInt3">parseInt3</a>(<span class="tok-str">&quot;418&quot;</span>));
        <span class="tok-kw">try</span> expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">u10</span>, <span class="tok-number">999</span>), <a href="std.http.Client.Response.html#std.http.Client.Response.parseInt3">parseInt3</a>(<span class="tok-str">&quot;999&quot;</span>));
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterateHeaders</span>(r: <a href="std.http.Client.Response.html">Response</a>) <a href="std.http.html">http</a>.<a href="std.http.HeaderIterator.html">HeaderIterator</a> {
        <span class="tok-kw">return</span> .init(r.parser.get());
    }

    <span class="tok-kw">test</span> iterateHeaders {
        <span class="tok-kw">const</span> response_bytes = <span class="tok-str">&quot;HTTP/1.1 200 OK\r\n&quot;</span> ++
            <span class="tok-str">&quot;LOcation:url\r\n&quot;</span> ++
            <span class="tok-str">&quot;content-tYpe: text/plain\r\n&quot;</span> ++
            <span class="tok-str">&quot;content-disposition:attachment; filename=example.txt \r\n&quot;</span> ++
            <span class="tok-str">&quot;content-Length:10\r\n&quot;</span> ++
            <span class="tok-str">&quot;TRansfer-encoding:\tdeflate, chunked \r\n&quot;</span> ++
            <span class="tok-str">&quot;connectioN:\t keep-alive \r\n\r\n&quot;</span>;

        <span class="tok-kw">var</span> header_buffer: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> res = <a href="std.http.Client.Response.html">Response</a>{
            .status = <span class="tok-null">undefined</span>,
            .reason = <span class="tok-null">undefined</span>,
            .version = <span class="tok-null">undefined</span>,
            .keep_alive = <span class="tok-null">false</span>,
            .parser = .init(&amp;header_buffer),
        };

        <span class="tok-builtin">@memcpy</span>(header_buffer[<span class="tok-number">0</span>..response_bytes.len], response_bytes);
        res.parser.header_bytes_len = response_bytes.len;

        <span class="tok-kw">var</span> it = res.iterateHeaders();
        {
            <span class="tok-kw">const</span> header = it.next().?;
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;LOcation&quot;</span>, header.name);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;url&quot;</span>, header.value);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!it.is_trailer);
        }
        {
            <span class="tok-kw">const</span> header = it.next().?;
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;content-tYpe&quot;</span>, header.name);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;text/plain&quot;</span>, header.value);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!it.is_trailer);
        }
        {
            <span class="tok-kw">const</span> header = it.next().?;
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;content-disposition&quot;</span>, header.name);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;attachment; filename=example.txt&quot;</span>, header.value);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!it.is_trailer);
        }
        {
            <span class="tok-kw">const</span> header = it.next().?;
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;content-Length&quot;</span>, header.name);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;10&quot;</span>, header.value);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!it.is_trailer);
        }
        {
            <span class="tok-kw">const</span> header = it.next().?;
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;TRansfer-encoding&quot;</span>, header.name);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;deflate, chunked&quot;</span>, header.value);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!it.is_trailer);
        }
        {
            <span class="tok-kw">const</span> header = it.next().?;
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;connectioN&quot;</span>, header.name);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;keep-alive&quot;</span>, header.value);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!it.is_trailer);
        }
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, it.next());
    }
};

<span class="tok-comment">/// A HTTP request that has been sent.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Order of operations: open -&gt; send[ -&gt; write -&gt; finish] -&gt; wait -&gt; read</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Request = <span class="tok-kw">struct</span> {
    uri: <a href="std.Uri.html">Uri</a>,
    client: *<a href="std.http.Client.html">Client</a>,
    <span class="tok-comment">/// This is null when the connection is released.</span>
    connection: ?*<a href="std.http.Client.Connection.html">Connection</a>,
    keep_alive: <span class="tok-type">bool</span>,

    method: <a href="std.http.html">http</a>.<a href="std.http.Method.html">Method</a>,
    version: <a href="std.http.html">http</a>.<a href="std.http.Version.html">Version</a> = .@&quot;HTTP/1.1&quot;,
    transfer_encoding: <a href="std.http.Client.RequestTransfer.html">RequestTransfer</a>,
    redirect_behavior: <a href="std.http.Client.Request.RedirectBehavior.html">RedirectBehavior</a>,

    <span class="tok-comment">/// Whether the request should handle a 100-continue response before sending the request body.</span>
    handle_continue: <span class="tok-type">bool</span>,

    <span class="tok-comment">/// The response associated with this request.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// This field is undefined until `wait` is called.</span>
    response: <a href="std.http.Client.Response.html">Response</a>,

    <span class="tok-comment">/// Standard headers that have default, but overridable, behavior.</span>
    headers: <a href="std.http.Client.Request.Headers.html">Headers</a>,

    <span class="tok-comment">/// These headers are kept including when following a redirect to a</span>
    <span class="tok-comment">/// different domain.</span>
    <span class="tok-comment">/// Externally-owned; must outlive the Request.</span>
    extra_headers: []<span class="tok-kw">const</span> <a href="std.http.html">http</a>.<a href="std.http.Header.html">Header</a>,

    <span class="tok-comment">/// These headers are stripped when following a redirect to a different</span>
    <span class="tok-comment">/// domain.</span>
    <span class="tok-comment">/// Externally-owned; must outlive the Request.</span>
    privileged_headers: []<span class="tok-kw">const</span> <a href="std.http.html">http</a>.<a href="std.http.Header.html">Header</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Headers = <span class="tok-kw">struct</span> {
        host: <a href="std.http.Client.Request.Headers.Value.html">Value</a> = .default,
        authorization: <a href="std.http.Client.Request.Headers.Value.html">Value</a> = .default,
        user_agent: <a href="std.http.Client.Request.Headers.Value.html">Value</a> = .default,
        connection: <a href="std.http.Client.Request.Headers.Value.html">Value</a> = .default,
        accept_encoding: <a href="std.http.Client.Request.Headers.Value.html">Value</a> = .default,
        content_type: <a href="std.http.Client.Request.Headers.Value.html">Value</a> = .default,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Value = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
            default,
            omit,
            override: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        };
    };

    <span class="tok-comment">/// Any value other than `not_allowed` or `unhandled` means that integer represents</span>
    <span class="tok-comment">/// how many remaining redirects are allowed.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> RedirectBehavior = <span class="tok-kw">enum</span>(<span class="tok-type">u16</span>) {
        <span class="tok-comment">/// The next redirect will cause an error.</span>
        not_allowed = <span class="tok-number">0</span>,
        <span class="tok-comment">/// Redirects are passed to the client to analyze the redirect response</span>
        <span class="tok-comment">/// directly.</span>
        unhandled = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u16</span>),
        _,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subtractOne</span>(rb: *<a href="std.http.Client.Request.RedirectBehavior.html">RedirectBehavior</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">switch</span> (rb.*) {
                .not_allowed =&gt; <span class="tok-kw">unreachable</span>,
                .unhandled =&gt; <span class="tok-kw">unreachable</span>,
                _ =&gt; rb.* = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(rb.*) - <span class="tok-number">1</span>),
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remaining</span>(rb: <a href="std.http.Client.Request.RedirectBehavior.html">RedirectBehavior</a>) <span class="tok-type">u16</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(rb != .unhandled);
            <span class="tok-kw">return</span> <span class="tok-builtin">@intFromEnum</span>(rb);
        }
    };

    <span class="tok-comment">/// Frees all resources associated with the request.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (req.connection) |connection| {
            <span class="tok-kw">if</span> (!req.response.parser.done) {<span class="tok-comment">
                // If the response wasn't fully read, then we need to close the connection.
                </span>connection.closing = <span class="tok-null">true</span>;
            }
            req.client.connection_pool.release(req.client.allocator, connection);
        }
        req.* = <span class="tok-null">undefined</span>;
    }<span class="tok-comment">

    // This function must deallocate all resources associated with the request,
    // or keep those which will be used.
    // This needs to be kept in sync with deinit and request.
    </span><span class="tok-kw">fn</span> <span class="tok-fn">redirect</span>(req: *<a href="std.http.Client.Request.html">Request</a>, uri: <a href="std.Uri.html">Uri</a>) !<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(req.response.parser.done);

        req.client.connection_pool.release(req.client.allocator, req.connection.?);
        req.connection = <span class="tok-null">null</span>;

        <span class="tok-kw">var</span> server_header: <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.FixedBufferAllocator.html">FixedBufferAllocator</a> = .init(req.response.parser.header_bytes_buffer);
        <span class="tok-kw">defer</span> req.response.parser.header_bytes_buffer = server_header.buffer[server_header.end_index..];
        <span class="tok-kw">const</span> protocol, <span class="tok-kw">const</span> valid_uri = <span class="tok-kw">try</span> validateUri(uri, server_header.allocator());

        <span class="tok-kw">const</span> new_host = valid_uri.host.?.raw;
        <span class="tok-kw">const</span> prev_host = req.uri.host.?.raw;
        <span class="tok-kw">const</span> keep_privileged_headers =
            <a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(valid_uri.scheme, req.uri.scheme) <span class="tok-kw">and</span>
            <a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.endsWithIgnoreCase">endsWithIgnoreCase</a>(new_host, prev_host) <span class="tok-kw">and</span>
            (new_host.len == prev_host.len <span class="tok-kw">or</span> new_host[new_host.len - prev_host.len - <span class="tok-number">1</span>] == <span class="tok-str">'.'</span>);
        <span class="tok-kw">if</span> (!keep_privileged_headers) {<span class="tok-comment">
            // When redirecting to a different domain, strip privileged headers.
            </span>req.privileged_headers = &amp;.{};
        }

        <span class="tok-kw">if</span> (<span class="tok-kw">switch</span> (req.response.status) {
            .see_other =&gt; <span class="tok-null">true</span>,
            .moved_permanently, .found =&gt; req.method == .POST,
            <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
        }) {<span class="tok-comment">
            // A redirect to a GET must change the method and remove the body.
            </span>req.method = .GET;
            req.transfer_encoding = .none;
            req.headers.content_type = .omit;
        }

        <span class="tok-kw">if</span> (req.transfer_encoding != .none) {<span class="tok-comment">
            // The request body has already been sent. The request is
            // still in a valid state, but the redirect must be handled
            // manually.
            </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.RedirectRequiresResend;
        }

        req.uri = valid_uri;
        req.connection = <span class="tok-kw">try</span> req.client.connect(new_host, <a href="std.http.Client.html#std.http.Client.uriPort">uriPort</a>(valid_uri, protocol), protocol);
        req.redirect_behavior.subtractOne();
        req.response.parser.reset();

        req.response = .{
            .version = <span class="tok-null">undefined</span>,
            .status = <span class="tok-null">undefined</span>,
            .reason = <span class="tok-null">undefined</span>,
            .keep_alive = <span class="tok-null">undefined</span>,
            .parser = req.response.parser,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SendError = <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a> || <span class="tok-kw">error</span>{ InvalidContentLength, UnsupportedTransferEncoding };

    <span class="tok-comment">/// Send the HTTP request headers to the server.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">send</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.SendError">SendError</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (!req.method.requestHasBody() <span class="tok-kw">and</span> req.transfer_encoding != .none)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedTransferEncoding;

        <span class="tok-kw">const</span> connection = req.connection.?;
        <span class="tok-kw">const</span> w = connection.writer();

        <span class="tok-kw">try</span> req.method.write(w);
        <span class="tok-kw">try</span> w.writeByte(<span class="tok-str">' '</span>);

        <span class="tok-kw">if</span> (req.method == .CONNECT) {
            <span class="tok-kw">try</span> req.uri.writeToStream(.{ .authority = <span class="tok-null">true</span> }, w);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> req.uri.writeToStream(.{
                .scheme = connection.proxied,
                .authentication = connection.proxied,
                .authority = connection.proxied,
                .path = <span class="tok-null">true</span>,
                .query = <span class="tok-null">true</span>,
            }, w);
        }
        <span class="tok-kw">try</span> w.writeByte(<span class="tok-str">' '</span>);
        <span class="tok-kw">try</span> w.writeAll(<span class="tok-builtin">@tagName</span>(req.version));
        <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);

        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.emitOverridableHeader">emitOverridableHeader</a>(<span class="tok-str">&quot;host: &quot;</span>, req.headers.host, w)) {
            <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;host: &quot;</span>);
            <span class="tok-kw">try</span> req.uri.writeToStream(.{ .authority = <span class="tok-null">true</span> }, w);
            <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);
        }

        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.emitOverridableHeader">emitOverridableHeader</a>(<span class="tok-str">&quot;authorization: &quot;</span>, req.headers.authorization, w)) {
            <span class="tok-kw">if</span> (req.uri.user != <span class="tok-null">null</span> <span class="tok-kw">or</span> req.uri.password != <span class="tok-null">null</span>) {
                <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;authorization: &quot;</span>);
                <span class="tok-kw">const</span> authorization = <span class="tok-kw">try</span> connection.allocWriteBuffer(
                    <span class="tok-builtin">@intCast</span>(<a href="std.http.Client.basic_authorization.html">basic_authorization</a>.<a href="std.http.Client.basic_authorization.html#std.http.Client.basic_authorization.valueLengthFromUri">valueLengthFromUri</a>(req.uri)),
                );
                <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.http.Client.basic_authorization.html">basic_authorization</a>.<a href="std.http.Client.basic_authorization.html#std.http.Client.basic_authorization.value">value</a>(req.uri, authorization).len == authorization.len);
                <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);
            }
        }

        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.emitOverridableHeader">emitOverridableHeader</a>(<span class="tok-str">&quot;user-agent: &quot;</span>, req.headers.user_agent, w)) {
            <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;user-agent: zig/&quot;</span>);
            <span class="tok-kw">try</span> w.writeAll(<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_version_string">zig_version_string</a>);
            <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot; (std.http)\r\n&quot;</span>);
        }

        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.emitOverridableHeader">emitOverridableHeader</a>(<span class="tok-str">&quot;connection: &quot;</span>, req.headers.connection, w)) {
            <span class="tok-kw">if</span> (req.keep_alive) {
                <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;connection: keep-alive\r\n&quot;</span>);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;connection: close\r\n&quot;</span>);
            }
        }

        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.emitOverridableHeader">emitOverridableHeader</a>(<span class="tok-str">&quot;accept-encoding: &quot;</span>, req.headers.accept_encoding, w)) {<span class="tok-comment">
            // https://github.com/ziglang/zig/issues/18937
            //try w.writeAll(&quot;accept-encoding: gzip, deflate, zstd\r\n&quot;);
            </span><span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;accept-encoding: gzip, deflate\r\n&quot;</span>);
        }

        <span class="tok-kw">switch</span> (req.transfer_encoding) {
            .chunked =&gt; <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;transfer-encoding: chunked\r\n&quot;</span>),
            .content_length =&gt; |len| <span class="tok-kw">try</span> w.print(<span class="tok-str">&quot;content-length: {d}\r\n&quot;</span>, .{len}),
            .none =&gt; {},
        }

        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.emitOverridableHeader">emitOverridableHeader</a>(<span class="tok-str">&quot;content-type: &quot;</span>, req.headers.content_type, w)) {<span class="tok-comment">
            // The default is to omit content-type if not provided because
            // &quot;application/octet-stream&quot; is redundant.
        </span>}

        <span class="tok-kw">for</span> (req.extra_headers) |header| {
            <a href="std.debug.html#std.debug.assert">assert</a>(header.name.len != <span class="tok-number">0</span>);

            <span class="tok-kw">try</span> w.writeAll(header.name);
            <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;: &quot;</span>);
            <span class="tok-kw">try</span> w.writeAll(header.value);
            <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);
        }

        <span class="tok-kw">if</span> (connection.proxied) proxy: {
            <span class="tok-kw">const</span> proxy = <span class="tok-kw">switch</span> (connection.protocol) {
                .plain =&gt; req.client.http_proxy,
                .tls =&gt; req.client.https_proxy,
            } <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :proxy;

            <span class="tok-kw">const</span> authorization = proxy.authorization <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :proxy;
            <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;proxy-authorization: &quot;</span>);
            <span class="tok-kw">try</span> w.writeAll(authorization);
            <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);
        }

        <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);

        <span class="tok-kw">try</span> connection.flush();
    }

    <span class="tok-comment">/// Returns true if the default behavior is required, otherwise handles</span>
    <span class="tok-comment">/// writing (or not writing) the header.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">emitOverridableHeader</span>(prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, v: <a href="std.http.Client.Request.Headers.html">Headers</a>.<a href="std.http.Client.Request.Headers.Value.html">Value</a>, w: <span class="tok-kw">anytype</span>) !<span class="tok-type">bool</span> {
        <span class="tok-kw">switch</span> (v) {
            .default =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,
            .omit =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
            .override =&gt; |x| {
                <span class="tok-kw">try</span> w.writeAll(prefix);
                <span class="tok-kw">try</span> w.writeAll(x);
                <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);
                <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            },
        }
    }

    <span class="tok-kw">const</span> TransferReadError = <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.html#std.http.Client.Connection.ReadError">ReadError</a> || <a href="std.http.protocol.html">proto</a>.<a href="std.http.protocol.HeadersParser.html">HeadersParser</a>.<a href="std.http.protocol.HeadersParser.html#std.http.protocol.HeadersParser.ReadError">ReadError</a>;

    <span class="tok-kw">const</span> TransferReader = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericReader">Reader</a>(*<a href="std.http.Client.Request.html">Request</a>, <a href="std.http.Client.Request.html#std.http.Client.Request.TransferReadError">TransferReadError</a>, <a href="std.http.Client.Request.html#std.http.Client.Request.transferRead">transferRead</a>);

    <span class="tok-kw">fn</span> <span class="tok-fn">transferReader</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.TransferReader">TransferReader</a> {
        <span class="tok-kw">return</span> .{ .context = req };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">transferRead</span>(req: *<a href="std.http.Client.Request.html">Request</a>, buf: []<span class="tok-type">u8</span>) <a href="std.http.Client.Request.html#std.http.Client.Request.TransferReadError">TransferReadError</a>!<span class="tok-type">usize</span> {
        <span class="tok-kw">if</span> (req.response.parser.done) <span class="tok-kw">return</span> <span class="tok-number">0</span>;

        <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (index == <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> req.response.parser.read(req.connection.?, buf[index..], req.response.skip);
            <span class="tok-kw">if</span> (amt == <span class="tok-number">0</span> <span class="tok-kw">and</span> req.response.parser.done) <span class="tok-kw">break</span>;
            index += amt;
        }

        <span class="tok-kw">return</span> index;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> WaitError = <a href="std.http.Client.html#std.http.Client.RequestError">RequestError</a> || <a href="std.http.Client.Request.html#std.http.Client.Request.SendError">SendError</a> || <a href="std.http.Client.Request.html#std.http.Client.Request.TransferReadError">TransferReadError</a> ||
        <a href="std.http.protocol.html">proto</a>.<a href="std.http.protocol.HeadersParser.html">HeadersParser</a>.<a href="std.http.protocol.HeadersParser.html#std.http.protocol.HeadersParser.CheckCompleteHeadError">CheckCompleteHeadError</a> || <a href="std.http.Client.Response.html">Response</a>.<a href="std.http.Client.Response.html#std.http.Client.Response.ParseError">ParseError</a> ||
        <span class="tok-kw">error</span>{
            TooManyHttpRedirects,
            RedirectRequiresResend,
            HttpRedirectLocationMissing,
            HttpRedirectLocationInvalid,
            CompressionInitializationFailed,
            CompressionUnsupported,
        };

    <span class="tok-comment">/// Waits for a response from the server and parses any headers that are sent.</span>
    <span class="tok-comment">/// This function will block until the final response is received.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If handling redirects and the request has no payload, then this</span>
    <span class="tok-comment">/// function will automatically follow redirects. If a request payload is</span>
    <span class="tok-comment">/// present, then this function will error with</span>
    <span class="tok-comment">/// error.RedirectRequiresResend.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Must be called after `send` and, if any data was written to the request</span>
    <span class="tok-comment">/// body, then also after `finish`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">wait</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.WaitError">WaitError</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment">
            // This while loop is for handling redirects, which means the request's
            // connection may be different than the previous iteration. However, it
            // is still guaranteed to be non-null with each iteration of this loop.
            </span><span class="tok-kw">const</span> connection = req.connection.?;

            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment"> // read headers
                </span><span class="tok-kw">try</span> connection.fill();

                <span class="tok-kw">const</span> nchecked = <span class="tok-kw">try</span> req.response.parser.checkCompleteHead(connection.peek());
                connection.drop(<span class="tok-builtin">@intCast</span>(nchecked));

                <span class="tok-kw">if</span> (req.response.parser.state.isContent()) <span class="tok-kw">break</span>;
            }

            <span class="tok-kw">try</span> req.response.parse(req.response.parser.get());

            <span class="tok-kw">if</span> (req.response.status == .@&quot;continue&quot;) {<span class="tok-comment">
                // We're done parsing the continue response; reset to prepare
                // for the real response.
                </span>req.response.parser.done = <span class="tok-null">true</span>;
                req.response.parser.reset();

                <span class="tok-kw">if</span> (req.handle_continue)
                    <span class="tok-kw">continue</span>;

                <span class="tok-kw">return</span>;<span class="tok-comment"> // we're not handling the 100-continue
            </span>}<span class="tok-comment">

            // we're switching protocols, so this connection is no longer doing http
            </span><span class="tok-kw">if</span> (req.method == .CONNECT <span class="tok-kw">and</span> req.response.status.class() == .success) {
                connection.closing = <span class="tok-null">false</span>;
                req.response.parser.done = <span class="tok-null">true</span>;
                <span class="tok-kw">return</span>;<span class="tok-comment"> // the connection is not HTTP past this point
            </span>}

            connection.closing = !req.response.keep_alive <span class="tok-kw">or</span> !req.keep_alive;<span class="tok-comment">

            // Any response to a HEAD request and any response with a 1xx
            // (Informational), 204 (No Content), or 304 (Not Modified) status
            // code is always terminated by the first empty line after the
            // header fields, regardless of the header fields present in the
            // message.
            </span><span class="tok-kw">if</span> (req.method == .HEAD <span class="tok-kw">or</span> req.response.status.class() == .informational <span class="tok-kw">or</span>
                req.response.status == .no_content <span class="tok-kw">or</span> req.response.status == .not_modified)
            {
                req.response.parser.done = <span class="tok-null">true</span>;
                <span class="tok-kw">return</span>;<span class="tok-comment"> // The response is empty; no further setup or redirection is necessary.
            </span>}

            <span class="tok-kw">switch</span> (req.response.transfer_encoding) {
                .none =&gt; {
                    <span class="tok-kw">if</span> (req.response.content_length) |cl| {
                        req.response.parser.next_chunk_length = cl;

                        <span class="tok-kw">if</span> (cl == <span class="tok-number">0</span>) req.response.parser.done = <span class="tok-null">true</span>;
                    } <span class="tok-kw">else</span> {<span class="tok-comment">
                        // read until the connection is closed
                        </span>req.response.parser.next_chunk_length = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u64</span>);
                    }
                },
                .chunked =&gt; {
                    req.response.parser.next_chunk_length = <span class="tok-number">0</span>;
                    req.response.parser.state = .chunk_head_size;
                },
            }

            <span class="tok-kw">if</span> (req.response.status.class() == .redirect <span class="tok-kw">and</span> req.redirect_behavior != .unhandled) {<span class="tok-comment">
                // skip the body of the redirect response, this will at least
                // leave the connection in a known good state.
                </span>req.response.skip = <span class="tok-null">true</span>;
                <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> req.transferRead(&amp;.{}) == <span class="tok-number">0</span>);<span class="tok-comment"> // we're skipping, no buffer is necessary

                </span><span class="tok-kw">if</span> (req.redirect_behavior == .not_allowed) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TooManyHttpRedirects;

                <span class="tok-kw">const</span> location = req.response.location <span class="tok-kw">orelse</span>
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpRedirectLocationMissing;<span class="tok-comment">

                // This mutates the beginning of header_bytes_buffer and uses that
                // for the backing memory of the returned Uri.
                </span><span class="tok-kw">try</span> req.redirect(req.uri.resolve_inplace(
                    location,
                    &amp;req.response.parser.header_bytes_buffer,
                ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.UnexpectedCharacter,
                    <span class="tok-kw">error</span>.InvalidFormat,
                    <span class="tok-kw">error</span>.InvalidPort,
                    =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpRedirectLocationInvalid,
                    <span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersOversize,
                });
                <span class="tok-kw">try</span> req.send();
            } <span class="tok-kw">else</span> {
                req.response.skip = <span class="tok-null">false</span>;
                <span class="tok-kw">if</span> (!req.response.parser.done) {
                    <span class="tok-kw">switch</span> (req.response.transfer_compression) {
                        .identity =&gt; req.response.compression = .none,
                        .compress, .@&quot;x-compress&quot; =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CompressionUnsupported,
                        .deflate =&gt; req.response.compression = .{
                            .deflate = <a href="std.html">std</a>.<a href="std.compress.html">compress</a>.<a href="std.compress.zlib.html">zlib</a>.<a href="std.compress.zlib.html#std.compress.zlib.decompressor">decompressor</a>(req.transferReader()),
                        },
                        .gzip, .@&quot;x-gzip&quot; =&gt; req.response.compression = .{
                            .gzip = <a href="std.html">std</a>.<a href="std.compress.html">compress</a>.<a href="std.compress.gzip.html">gzip</a>.<a href="std.compress.gzip.html#std.compress.gzip.decompressor">decompressor</a>(req.transferReader()),
                        },<span class="tok-comment">
                        // https://github.com/ziglang/zig/issues/18937
                        //.zstd =&gt; req.response.compression = .{
                        //    .zstd = std.compress.zstd.decompressStream(req.client.allocator, req.transferReader()),
                        //},
                        </span>.zstd =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CompressionUnsupported,
                    }
                }

                <span class="tok-kw">break</span>;
            }
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadError = <a href="std.http.Client.Request.html#std.http.Client.Request.TransferReadError">TransferReadError</a> || <a href="std.http.protocol.html">proto</a>.<a href="std.http.protocol.HeadersParser.html">HeadersParser</a>.<a href="std.http.protocol.HeadersParser.html#std.http.protocol.HeadersParser.CheckCompleteHeadError">CheckCompleteHeadError</a> ||
        <span class="tok-kw">error</span>{ DecompressionFailure, InvalidTrailers };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Reader = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericReader">Reader</a>(*<a href="std.http.Client.Request.html">Request</a>, <a href="std.http.Client.Request.html#std.http.Client.Request.ReadError">ReadError</a>, <a href="std.http.Client.Request.html#std.http.Client.Request.read">read</a>);

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reader</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.Reader">Reader</a> {
        <span class="tok-kw">return</span> .{ .context = req };
    }

    <span class="tok-comment">/// Reads data from the response body. Must be called after `wait`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(req: *<a href="std.http.Client.Request.html">Request</a>, buffer: []<span class="tok-type">u8</span>) <a href="std.http.Client.Request.html#std.http.Client.Request.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
        <span class="tok-kw">const</span> out_index = <span class="tok-kw">switch</span> (req.response.compression) {
            .deflate =&gt; |*deflate| deflate.read(buffer) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DecompressionFailure,
            .gzip =&gt; |*gzip| gzip.read(buffer) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DecompressionFailure,<span class="tok-comment">
            // https://github.com/ziglang/zig/issues/18937
            //.zstd =&gt; |*zstd| zstd.read(buffer) catch return error.DecompressionFailure,
            </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> req.transferRead(buffer),
        };
        <span class="tok-kw">if</span> (out_index &gt; <span class="tok-number">0</span>) <span class="tok-kw">return</span> out_index;

        <span class="tok-kw">while</span> (!req.response.parser.state.isContent()) {<span class="tok-comment"> // read trailing headers
            </span><span class="tok-kw">try</span> req.connection.?.fill();

            <span class="tok-kw">const</span> nchecked = <span class="tok-kw">try</span> req.response.parser.checkCompleteHead(req.connection.?.peek());
            req.connection.?.drop(<span class="tok-builtin">@intCast</span>(nchecked));
        }

        <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    }

    <span class="tok-comment">/// Reads data from the response body. Must be called after `wait`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readAll</span>(req: *<a href="std.http.Client.Request.html">Request</a>, buffer: []<span class="tok-type">u8</span>) !<span class="tok-type">usize</span> {
        <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (index &lt; buffer.len) {
            <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.read">read</a>(req, buffer[index..]);
            <span class="tok-kw">if</span> (amt == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            index += amt;
        }
        <span class="tok-kw">return</span> index;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteError = <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a> || <span class="tok-kw">error</span>{ NotWriteable, MessageTooLong };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.http.Client.Request.html">Request</a>, <a href="std.http.Client.Request.html#std.http.Client.Request.WriteError">WriteError</a>, <a href="std.http.Client.Request.html#std.http.Client.Request.write">write</a>);

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.Writer">Writer</a> {
        <span class="tok-kw">return</span> .{ .context = req };
    }

    <span class="tok-comment">/// Write `bytes` to the server. The `transfer_encoding` field determines how data will be sent.</span>
    <span class="tok-comment">/// Must be called after `send` and before `finish`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(req: *<a href="std.http.Client.Request.html">Request</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.http.Client.Request.html#std.http.Client.Request.WriteError">WriteError</a>!<span class="tok-type">usize</span> {
        <span class="tok-kw">switch</span> (req.transfer_encoding) {
            .chunked =&gt; {
                <span class="tok-kw">if</span> (bytes.len &gt; <span class="tok-number">0</span>) {
                    <span class="tok-kw">try</span> req.connection.?.writer().print(<span class="tok-str">&quot;{x}\r\n&quot;</span>, .{bytes.len});
                    <span class="tok-kw">try</span> req.connection.?.writer().writeAll(bytes);
                    <span class="tok-kw">try</span> req.connection.?.writer().writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);
                }

                <span class="tok-kw">return</span> bytes.len;
            },
            .content_length =&gt; |*len| {
                <span class="tok-kw">if</span> (len.* &lt; bytes.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MessageTooLong;

                <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> req.connection.?.write(bytes);
                len.* -= amt;
                <span class="tok-kw">return</span> amt;
            },
            .none =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotWriteable,
        }
    }

    <span class="tok-comment">/// Write `bytes` to the server. The `transfer_encoding` field determines how data will be sent.</span>
    <span class="tok-comment">/// Must be called after `send` and before `finish`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAll</span>(req: *<a href="std.http.Client.Request.html">Request</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.http.Client.Request.html#std.http.Client.Request.WriteError">WriteError</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (index &lt; bytes.len) {
            index += <span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.write">write</a>(req, bytes[index..]);
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FinishError = <a href="std.http.Client.Request.html#std.http.Client.Request.WriteError">WriteError</a> || <span class="tok-kw">error</span>{MessageNotCompleted};

    <span class="tok-comment">/// Finish the body of a request. This notifies the server that you have no more data to send.</span>
    <span class="tok-comment">/// Must be called after `send`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finish</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.FinishError">FinishError</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">switch</span> (req.transfer_encoding) {
            .chunked =&gt; <span class="tok-kw">try</span> req.connection.?.writer().writeAll(<span class="tok-str">&quot;0\r\n\r\n&quot;</span>),
            .content_length =&gt; |len| <span class="tok-kw">if</span> (len != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MessageNotCompleted,
            .none =&gt; {},
        }

        <span class="tok-kw">try</span> req.connection.?.flush();
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Proxy = <span class="tok-kw">struct</span> {
    protocol: <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.Protocol.html">Protocol</a>,
    host: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    authorization: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    port: <span class="tok-type">u16</span>,
    supports_connect: <span class="tok-type">bool</span>,
};

<span class="tok-comment">/// Release all associated resources with the client.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// All pending requests must be de-initialized and all active connections released</span>
<span class="tok-comment">/// before calling this function.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(client: *<a href="std.http.Client.html">Client</a>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(client.connection_pool.used.first == <span class="tok-null">null</span>);<span class="tok-comment"> // There are still active requests.

    </span>client.connection_pool.deinit(client.allocator);

    <span class="tok-kw">if</span> (!<a href="std.http.Client.html#std.http.Client.disable_tls">disable_tls</a>)
        client.ca_bundle.deinit(client.allocator);

    client.* = <span class="tok-null">undefined</span>;
}

<span class="tok-comment">/// Populates `http_proxy` and `https_proxy` via standard proxy environment variables.</span>
<span class="tok-comment">/// Asserts the client has no active connections.</span>
<span class="tok-comment">/// Uses `arena` for a few small allocations that must outlive the client, or</span>
<span class="tok-comment">/// at least until those fields are set to different values.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initDefaultProxies</span>(client: *<a href="std.http.Client.html">Client</a>, arena: <a href="std.mem.Allocator.html">Allocator</a>) !<span class="tok-type">void</span> {<span class="tok-comment">
    // Prevent any new connections from being created.
    </span>client.connection_pool.mutex.lock();
    <span class="tok-kw">defer</span> client.connection_pool.mutex.unlock();

    <a href="std.debug.html#std.debug.assert">assert</a>(client.connection_pool.used.first == <span class="tok-null">null</span>);<span class="tok-comment"> // There are active requests.

    </span><span class="tok-kw">if</span> (client.http_proxy == <span class="tok-null">null</span>) {
        client.http_proxy = <span class="tok-kw">try</span> <a href="std.http.Client.html#std.http.Client.createProxyFromEnvVar">createProxyFromEnvVar</a>(arena, &amp;.{
            <span class="tok-str">&quot;http_proxy&quot;</span>, <span class="tok-str">&quot;HTTP_PROXY&quot;</span>, <span class="tok-str">&quot;all_proxy&quot;</span>, <span class="tok-str">&quot;ALL_PROXY&quot;</span>,
        });
    }

    <span class="tok-kw">if</span> (client.https_proxy == <span class="tok-null">null</span>) {
        client.https_proxy = <span class="tok-kw">try</span> <a href="std.http.Client.html#std.http.Client.createProxyFromEnvVar">createProxyFromEnvVar</a>(arena, &amp;.{
            <span class="tok-str">&quot;https_proxy&quot;</span>, <span class="tok-str">&quot;HTTPS_PROXY&quot;</span>, <span class="tok-str">&quot;all_proxy&quot;</span>, <span class="tok-str">&quot;ALL_PROXY&quot;</span>,
        });
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">createProxyFromEnvVar</span>(arena: <a href="std.mem.Allocator.html">Allocator</a>, env_var_names: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !?*<a href="std.http.Client.Proxy.html">Proxy</a> {
    <span class="tok-kw">const</span> content = <span class="tok-kw">for</span> (env_var_names) |name| {
        <span class="tok-kw">const</span> content = <a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.html#std.process.getEnvVarOwned">getEnvVarOwned</a>(arena, name) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.EnvironmentVariableNotFound =&gt; <span class="tok-kw">continue</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };

        <span class="tok-kw">if</span> (content.len == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;

        <span class="tok-kw">break</span> content;
    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;

    <span class="tok-kw">const</span> uri = <a href="std.Uri.html">Uri</a>.<a href="std.Uri.html#std.Uri.parse">parse</a>(content) <span class="tok-kw">catch</span> <span class="tok-kw">try</span> <a href="std.Uri.html">Uri</a>.<a href="std.Uri.html#std.Uri.parseAfterScheme">parseAfterScheme</a>(<span class="tok-str">&quot;http&quot;</span>, content);
    <span class="tok-kw">const</span> protocol, <span class="tok-kw">const</span> valid_uri = validateUri(uri, arena) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.UnsupportedUriScheme =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
        <span class="tok-kw">error</span>.UriMissingHost =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpProxyMissingHost,
        <span class="tok-kw">error</span>.OutOfMemory =&gt; |e| <span class="tok-kw">return</span> e,
    };

    <span class="tok-kw">const</span> authorization: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-kw">if</span> (valid_uri.user != <span class="tok-null">null</span> <span class="tok-kw">or</span> valid_uri.password != <span class="tok-null">null</span>) a: {
        <span class="tok-kw">const</span> authorization = <span class="tok-kw">try</span> arena.alloc(<span class="tok-type">u8</span>, <a href="std.http.Client.basic_authorization.html">basic_authorization</a>.<a href="std.http.Client.basic_authorization.html#std.http.Client.basic_authorization.valueLengthFromUri">valueLengthFromUri</a>(valid_uri));
        <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.http.Client.basic_authorization.html">basic_authorization</a>.<a href="std.http.Client.basic_authorization.html#std.http.Client.basic_authorization.value">value</a>(valid_uri, authorization).len == authorization.len);
        <span class="tok-kw">break</span> :a authorization;
    } <span class="tok-kw">else</span> <span class="tok-null">null</span>;

    <span class="tok-kw">const</span> proxy = <span class="tok-kw">try</span> arena.create(<a href="std.http.Client.Proxy.html">Proxy</a>);
    proxy.* = .{
        .protocol = protocol,
        .host = valid_uri.host.?.raw,
        .authorization = authorization,
        .port = <a href="std.http.Client.html#std.http.Client.uriPort">uriPort</a>(valid_uri, protocol),
        .supports_connect = <span class="tok-null">true</span>,
    };
    <span class="tok-kw">return</span> proxy;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> basic_authorization = <span class="tok-kw">struct</span> {
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> max_user_len = <span class="tok-number">255</span>;
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> max_password_len = <span class="tok-number">255</span>;
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> max_value_len = <a href="std.http.Client.basic_authorization.html#std.http.Client.basic_authorization.valueLength">valueLength</a>(<a href="std.http.Client.basic_authorization.html#std.http.Client.basic_authorization.max_user_len">max_user_len</a>, <a href="std.http.Client.basic_authorization.html#std.http.Client.basic_authorization.max_password_len">max_password_len</a>);

    <span class="tok-kw">const</span> prefix = <span class="tok-str">&quot;Basic &quot;</span>;

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueLength</span>(user_len: <span class="tok-type">usize</span>, password_len: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> <a href="std.http.Client.basic_authorization.html#std.http.Client.basic_authorization.prefix">prefix</a>.<a href="#">len</a> + <a href="std.html">std</a>.<a href="std.base64.html">base64</a>.<a href="std.base64.html#std.base64.standard">standard</a>.<a href="#">Encoder</a>.<a href="#">calcSize</a>(user_len + <span class="tok-number">1</span> + password_len);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueLengthFromUri</span>(uri: <a href="std.Uri.html">Uri</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">var</span> stream = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.counting_writer.html#std.io.counting_writer.countingWriter">countingWriter</a>(<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.null_writer">null_writer</a>);
        <span class="tok-kw">try</span> stream.writer().print(<span class="tok-str">&quot;{user}&quot;</span>, .{uri.user <span class="tok-kw">orelse</span> <a href="std.Uri.html">Uri</a>.<a href="std.Uri.Component.html">Component</a>.<a href="std.Uri.Component.html#std.Uri.Component.empty">empty</a>});
        <span class="tok-kw">const</span> user_len = stream.bytes_written;
        stream.bytes_written = <span class="tok-number">0</span>;
        <span class="tok-kw">try</span> stream.writer().print(<span class="tok-str">&quot;{password}&quot;</span>, .{uri.password <span class="tok-kw">orelse</span> <a href="std.Uri.html">Uri</a>.<a href="std.Uri.Component.html">Component</a>.<a href="std.Uri.Component.html#std.Uri.Component.empty">empty</a>});
        <span class="tok-kw">const</span> password_len = stream.bytes_written;
        <span class="tok-kw">return</span> <a href="std.http.Client.basic_authorization.html#std.http.Client.basic_authorization.valueLength">valueLength</a>(<span class="tok-builtin">@intCast</span>(user_len), <span class="tok-builtin">@intCast</span>(password_len));
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">value</span>(uri: <a href="std.Uri.html">Uri</a>, out: []<span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {
        <span class="tok-kw">var</span> buf: [<a href="std.http.Client.basic_authorization.html#std.http.Client.basic_authorization.max_user_len">max_user_len</a> + <span class="tok-str">&quot;:&quot;</span>.len + <a href="std.http.Client.basic_authorization.html#std.http.Client.basic_authorization.max_password_len">max_password_len</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> stream = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(&amp;buf);
        stream.writer().print(<span class="tok-str">&quot;{user}&quot;</span>, .{uri.user <span class="tok-kw">orelse</span> <a href="std.Uri.html">Uri</a>.<a href="std.Uri.Component.html">Component</a>.<a href="std.Uri.Component.html#std.Uri.Component.empty">empty</a>}) <span class="tok-kw">catch</span>
            <span class="tok-kw">unreachable</span>;
        <a href="std.debug.html#std.debug.assert">assert</a>(stream.pos &lt;= <a href="std.http.Client.basic_authorization.html#std.http.Client.basic_authorization.max_user_len">max_user_len</a>);
        stream.writer().print(<span class="tok-str">&quot;:{password}&quot;</span>, .{uri.password <span class="tok-kw">orelse</span> <a href="std.Uri.html">Uri</a>.<a href="std.Uri.Component.html">Component</a>.<a href="std.Uri.Component.html#std.Uri.Component.empty">empty</a>}) <span class="tok-kw">catch</span>
            <span class="tok-kw">unreachable</span>;

        <span class="tok-builtin">@memcpy</span>(out[<span class="tok-number">0</span>..<a href="std.http.Client.basic_authorization.html#std.http.Client.basic_authorization.prefix">prefix</a>.<a href="#">len</a>], <a href="std.http.Client.basic_authorization.html#std.http.Client.basic_authorization.prefix">prefix</a>);
        <span class="tok-kw">const</span> base64 = <a href="std.html">std</a>.<a href="std.base64.html">base64</a>.<a href="std.base64.html#std.base64.standard">standard</a>.<a href="#">Encoder</a>.<a href="#">encode</a>(out[<a href="std.http.Client.basic_authorization.html#std.http.Client.basic_authorization.prefix">prefix</a>.<a href="#">len</a>..], stream.getWritten());
        <span class="tok-kw">return</span> out[<span class="tok-number">0</span> .. <a href="std.http.Client.basic_authorization.html#std.http.Client.basic_authorization.prefix">prefix</a>.<a href="#">len</a> + base64.len];
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ConnectTcpError = <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || <span class="tok-kw">error</span>{ ConnectionRefused, NetworkUnreachable, ConnectionTimedOut, ConnectionResetByPeer, TemporaryNameServerFailure, NameServerFailure, UnknownHostName, HostLacksNetworkAddresses, UnexpectedConnectFailure, TlsInitializationFailed };

<span class="tok-comment">/// Connect to `host:port` using the specified protocol. This will reuse a connection if one is already open.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This function is threadsafe.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connectTcp</span>(client: *<a href="std.http.Client.html">Client</a>, host: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>, protocol: <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.Protocol.html">Protocol</a>) <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a>!*<a href="std.http.Client.Connection.html">Connection</a> {
    <span class="tok-kw">if</span> (client.connection_pool.findConnection(.{
        .host = host,
        .port = port,
        .protocol = protocol,
    })) |node| <span class="tok-kw">return</span> node;

    <span class="tok-kw">if</span> (<a href="std.http.Client.html#std.http.Client.disable_tls">disable_tls</a> <span class="tok-kw">and</span> protocol == .tls)
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsInitializationFailed;

    <span class="tok-kw">const</span> conn = <span class="tok-kw">try</span> client.allocator.create(<a href="std.http.Client.ConnectionPool.html">ConnectionPool</a>.<a href="std.http.Client.ConnectionPool.html#std.http.Client.ConnectionPool.Node">Node</a>);
    <span class="tok-kw">errdefer</span> client.allocator.destroy(conn);
    conn.* = .{ .data = <span class="tok-null">undefined</span> };

    <span class="tok-kw">const</span> stream = <a href="std.net.html">net</a>.<a href="std.net.html#std.net.tcpConnectToHost">tcpConnectToHost</a>(client.allocator, host, port) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.ConnectionRefused =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionRefused,
        <span class="tok-kw">error</span>.NetworkUnreachable =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
        <span class="tok-kw">error</span>.ConnectionTimedOut =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
        <span class="tok-kw">error</span>.ConnectionResetByPeer =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
        <span class="tok-kw">error</span>.TemporaryNameServerFailure =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TemporaryNameServerFailure,
        <span class="tok-kw">error</span>.NameServerFailure =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameServerFailure,
        <span class="tok-kw">error</span>.UnknownHostName =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownHostName,
        <span class="tok-kw">error</span>.HostLacksNetworkAddresses =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HostLacksNetworkAddresses,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedConnectFailure,
    };
    <span class="tok-kw">errdefer</span> stream.close();

    conn.data = .{
        .stream = stream,
        .tls_client = <span class="tok-null">undefined</span>,

        .protocol = protocol,
        .host = <span class="tok-kw">try</span> client.allocator.dupe(<span class="tok-type">u8</span>, host),
        .port = port,
    };
    <span class="tok-kw">errdefer</span> client.allocator.free(conn.data.host);

    <span class="tok-kw">if</span> (protocol == .tls) {
        <span class="tok-kw">if</span> (<a href="std.http.Client.html#std.http.Client.disable_tls">disable_tls</a>) <span class="tok-kw">unreachable</span>;

        conn.data.tls_client = <span class="tok-kw">try</span> client.allocator.create(<a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>.<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.Client.html">Client</a>);
        <span class="tok-kw">errdefer</span> client.allocator.destroy(conn.data.tls_client);

        <span class="tok-kw">const</span> ssl_key_log_file: ?<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a> = <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.html#std.options">options</a>.<a href="#">http_enable_ssl_key_log_file</a>) ssl_key_log_file: {
            <span class="tok-kw">const</span> ssl_key_log_path = <a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.html#std.process.getEnvVarOwned">getEnvVarOwned</a>(client.allocator, <span class="tok-str">&quot;SSLKEYLOGFILE&quot;</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.EnvironmentVariableNotFound, <span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">break</span> :ssl_key_log_file <span class="tok-null">null</span>,
                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
            };
            <span class="tok-kw">defer</span> client.allocator.free(ssl_key_log_path);
            <span class="tok-kw">break</span> :ssl_key_log_file <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().createFile(ssl_key_log_path, .{
                .truncate = <span class="tok-null">false</span>,
                .mode = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
                    .windows, .wasi =&gt; <span class="tok-number">0</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-number">0o600</span>,
                },
            }) <span class="tok-kw">catch</span> <span class="tok-null">null</span>;
        } <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        <span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (ssl_key_log_file) |key_log_file| key_log_file.close();

        conn.data.tls_client.* = <a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>.<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.Client.html">Client</a>.<a href="std.crypto.tls.Client.html#std.crypto.tls.Client.init">init</a>(stream, .{
            .host = .{ .explicit = host },
            .ca = .{ .bundle = client.ca_bundle },
            .ssl_key_log_file = ssl_key_log_file,
        }) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsInitializationFailed;<span class="tok-comment">
        // This is appropriate for HTTPS because the HTTP headers contain
        // the content length which is used to detect truncation attacks.
        </span>conn.data.tls_client.allow_truncation_attacks = <span class="tok-null">true</span>;
    }

    client.connection_pool.addUsed(conn);

    <span class="tok-kw">return</span> &amp;conn.data;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ConnectUnixError = <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SocketError">SocketError</a> || <span class="tok-kw">error</span>{NameTooLong} || <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ConnectError">ConnectError</a>;

<span class="tok-comment">/// Connect to `path` as a unix domain socket. This will reuse a connection if one is already open.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This function is threadsafe.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connectUnix</span>(client: *<a href="std.http.Client.html">Client</a>, path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.http.Client.html#std.http.Client.ConnectUnixError">ConnectUnixError</a>!*<a href="std.http.Client.Connection.html">Connection</a> {
    <span class="tok-kw">if</span> (client.connection_pool.findConnection(.{
        .host = path,
        .port = <span class="tok-number">0</span>,
        .protocol = .plain,
    })) |node|
        <span class="tok-kw">return</span> node;

    <span class="tok-kw">const</span> conn = <span class="tok-kw">try</span> client.allocator.create(<a href="std.http.Client.ConnectionPool.html">ConnectionPool</a>.<a href="std.http.Client.ConnectionPool.html#std.http.Client.ConnectionPool.Node">Node</a>);
    <span class="tok-kw">errdefer</span> client.allocator.destroy(conn);
    conn.* = .{ .data = <span class="tok-null">undefined</span> };

    <span class="tok-kw">const</span> stream = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.net.html">net</a>.<a href="std.net.html#std.net.connectUnixSocket">connectUnixSocket</a>(path);
    <span class="tok-kw">errdefer</span> stream.close();

    conn.data = .{
        .stream = stream,
        .tls_client = <span class="tok-null">undefined</span>,
        .protocol = .plain,

        .host = <span class="tok-kw">try</span> client.allocator.dupe(<span class="tok-type">u8</span>, path),
        .port = <span class="tok-number">0</span>,
    };
    <span class="tok-kw">errdefer</span> client.allocator.free(conn.data.host);

    client.connection_pool.addUsed(conn);

    <span class="tok-kw">return</span> &amp;conn.data;
}

<span class="tok-comment">/// Connect to `tunnel_host:tunnel_port` using the specified proxy with HTTP</span>
<span class="tok-comment">/// CONNECT. This will reuse a connection if one is already open.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This function is threadsafe.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connectTunnel</span>(
    client: *<a href="std.http.Client.html">Client</a>,
    proxy: *<a href="std.http.Client.Proxy.html">Proxy</a>,
    tunnel_host: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    tunnel_port: <span class="tok-type">u16</span>,
) !*<a href="std.http.Client.Connection.html">Connection</a> {
    <span class="tok-kw">if</span> (!proxy.supports_connect) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TunnelNotSupported;

    <span class="tok-kw">if</span> (client.connection_pool.findConnection(.{
        .host = tunnel_host,
        .port = tunnel_port,
        .protocol = proxy.protocol,
    })) |node|
        <span class="tok-kw">return</span> node;

    <span class="tok-kw">var</span> maybe_valid = <span class="tok-null">false</span>;
    (tunnel: {
        <span class="tok-kw">const</span> conn = <span class="tok-kw">try</span> client.connectTcp(proxy.host, proxy.port, proxy.protocol);
        <span class="tok-kw">errdefer</span> {
            conn.closing = <span class="tok-null">true</span>;
            client.connection_pool.release(client.allocator, conn);
        }

        <span class="tok-kw">var</span> buffer: [<span class="tok-number">8096</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> req = client.open(.CONNECT, .{
            .scheme = <span class="tok-str">&quot;http&quot;</span>,
            .host = .{ .raw = tunnel_host },
            .port = tunnel_port,
        }, .{
            .redirect_behavior = .unhandled,
            .connection = conn,
            .server_header_buffer = &amp;buffer,
        }) <span class="tok-kw">catch</span> |err| {
            <a href="std.html">std</a>.<a href="std.log.html">log</a>.<a href="std.log.html#std.log.debug">debug</a>(<span class="tok-str">&quot;err {}&quot;</span>, .{err});
            <span class="tok-kw">break</span> :tunnel err;
        };
        <span class="tok-kw">defer</span> req.deinit();

        req.send() <span class="tok-kw">catch</span> |err| <span class="tok-kw">break</span> :tunnel err;
        req.wait() <span class="tok-kw">catch</span> |err| <span class="tok-kw">break</span> :tunnel err;

        <span class="tok-kw">if</span> (req.response.status.class() == .server_error) {
            maybe_valid = <span class="tok-null">true</span>;
            <span class="tok-kw">break</span> :tunnel <span class="tok-kw">error</span>.ServerError;
        }

        <span class="tok-kw">if</span> (req.response.status != .ok) <span class="tok-kw">break</span> :tunnel <span class="tok-kw">error</span>.ConnectionRefused;<span class="tok-comment">

        // this connection is now a tunnel, so we can't use it for anything else, it will only be released when the client is de-initialized.
        </span>req.connection = <span class="tok-null">null</span>;

        client.allocator.free(conn.host);
        conn.host = <span class="tok-kw">try</span> client.allocator.dupe(<span class="tok-type">u8</span>, tunnel_host);
        <span class="tok-kw">errdefer</span> client.allocator.free(conn.host);

        conn.port = tunnel_port;
        conn.closing = <span class="tok-null">false</span>;

        <span class="tok-kw">return</span> conn;
    }) <span class="tok-kw">catch</span> {<span class="tok-comment">
        // something went wrong with the tunnel
        </span>proxy.supports_connect = maybe_valid;
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TunnelNotSupported;
    };
}<span class="tok-comment">

// Prevents a dependency loop in open()
</span><span class="tok-kw">const</span> ConnectErrorPartial = <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a> || <span class="tok-kw">error</span>{ UnsupportedUriScheme, ConnectionRefused };
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ConnectError = <a href="std.http.Client.html#std.http.Client.ConnectErrorPartial">ConnectErrorPartial</a> || <a href="std.http.Client.html#std.http.Client.RequestError">RequestError</a>;

<span class="tok-comment">/// Connect to `host:port` using the specified protocol. This will reuse a</span>
<span class="tok-comment">/// connection if one is already open.</span>
<span class="tok-comment">/// If a proxy is configured for the client, then the proxy will be used to</span>
<span class="tok-comment">/// connect to the host.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This function is threadsafe.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connect</span>(
    client: *<a href="std.http.Client.html">Client</a>,
    host: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    port: <span class="tok-type">u16</span>,
    protocol: <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.Protocol.html">Protocol</a>,
) <a href="std.http.Client.html#std.http.Client.ConnectError">ConnectError</a>!*<a href="std.http.Client.Connection.html">Connection</a> {
    <span class="tok-kw">const</span> proxy = <span class="tok-kw">switch</span> (protocol) {
        .plain =&gt; client.http_proxy,
        .tls =&gt; client.https_proxy,
    } <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> client.connectTcp(host, port, protocol);<span class="tok-comment">

    // Prevent proxying through itself.
    </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(proxy.host, host) <span class="tok-kw">and</span>
        proxy.port == port <span class="tok-kw">and</span> proxy.protocol == protocol)
    {
        <span class="tok-kw">return</span> client.connectTcp(host, port, protocol);
    }

    <span class="tok-kw">if</span> (proxy.supports_connect) tunnel: {
        <span class="tok-kw">return</span> <a href="std.http.Client.html#std.http.Client.connectTunnel">connectTunnel</a>(client, proxy, host, port) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.TunnelNotSupported =&gt; <span class="tok-kw">break</span> :tunnel,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    }<span class="tok-comment">

    // fall back to using the proxy as a normal http proxy
    </span><span class="tok-kw">const</span> conn = <span class="tok-kw">try</span> client.connectTcp(proxy.host, proxy.port, proxy.protocol);
    <span class="tok-kw">errdefer</span> {
        conn.closing = <span class="tok-null">true</span>;
        client.connection_pool.release(conn);
    }

    conn.proxied = <span class="tok-null">true</span>;
    <span class="tok-kw">return</span> conn;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RequestError = <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a> || <a href="std.http.Client.html#std.http.Client.ConnectErrorPartial">ConnectErrorPartial</a> || <a href="std.http.Client.Request.html">Request</a>.<a href="std.http.Client.Request.html#std.http.Client.Request.SendError">SendError</a> ||
    <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.ParseIntError">ParseIntError</a> || <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a> ||
    <span class="tok-kw">error</span>{
        UnsupportedUriScheme,
        UriMissingHost,

        CertificateBundleLoadFailure,
        UnsupportedTransferEncoding,
    };

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RequestOptions = <span class="tok-kw">struct</span> {
    version: <a href="std.http.html">http</a>.<a href="std.http.Version.html">Version</a> = .@&quot;HTTP/1.1&quot;,

    <span class="tok-comment">/// Automatically ignore 100 Continue responses. This assumes you don't</span>
    <span class="tok-comment">/// care, and will have sent the body before you wait for the response.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If this is not the case AND you know the server will send a 100</span>
    <span class="tok-comment">/// Continue, set this to false and wait for a response before sending the</span>
    <span class="tok-comment">/// body. If you wait AND the server does not send a 100 Continue before</span>
    <span class="tok-comment">/// you finish the request, then the request *will* deadlock.</span>
    handle_continue: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,

    <span class="tok-comment">/// If false, close the connection after the one request. If true,</span>
    <span class="tok-comment">/// participate in the client connection pool.</span>
    keep_alive: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,

    <span class="tok-comment">/// This field specifies whether to automatically follow redirects, and if</span>
    <span class="tok-comment">/// so, how many redirects to follow before returning an error.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// This will only follow redirects for repeatable requests (ie. with no</span>
    <span class="tok-comment">/// payload or the server has acknowledged the payload).</span>
    redirect_behavior: <a href="std.http.Client.Request.html">Request</a>.<a href="std.http.Client.Request.RedirectBehavior.html">RedirectBehavior</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">3</span>),

    <span class="tok-comment">/// Externally-owned memory used to store the server's entire HTTP header.</span>
    <span class="tok-comment">/// `error.HttpHeadersOversize` is returned from read() when a</span>
    <span class="tok-comment">/// client sends too many bytes of HTTP headers.</span>
    server_header_buffer: []<span class="tok-type">u8</span>,

    <span class="tok-comment">/// Must be an already acquired connection.</span>
    connection: ?*<a href="std.http.Client.Connection.html">Connection</a> = <span class="tok-null">null</span>,

    <span class="tok-comment">/// Standard headers that have default, but overridable, behavior.</span>
    headers: <a href="std.http.Client.Request.html">Request</a>.<a href="std.http.Client.Request.Headers.html">Headers</a> = .{},
    <span class="tok-comment">/// These headers are kept including when following a redirect to a</span>
    <span class="tok-comment">/// different domain.</span>
    <span class="tok-comment">/// Externally-owned; must outlive the Request.</span>
    extra_headers: []<span class="tok-kw">const</span> <a href="std.http.html">http</a>.<a href="std.http.Header.html">Header</a> = &amp;.{},
    <span class="tok-comment">/// These headers are stripped when following a redirect to a different</span>
    <span class="tok-comment">/// domain.</span>
    <span class="tok-comment">/// Externally-owned; must outlive the Request.</span>
    privileged_headers: []<span class="tok-kw">const</span> <a href="std.http.html">http</a>.<a href="std.http.Header.html">Header</a> = &amp;.{},
};

<span class="tok-kw">fn</span> <span class="tok-fn">validateUri</span>(uri: <a href="std.Uri.html">Uri</a>, arena: <a href="std.mem.Allocator.html">Allocator</a>) !<span class="tok-kw">struct</span> { <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.Protocol.html">Protocol</a>, <a href="std.Uri.html">Uri</a> } {
    <span class="tok-kw">const</span> protocol_map = <a href="std.html">std</a>.<a href="std.static_string_map.html#std.static_string_map.StaticStringMap">StaticStringMap</a>(<a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.Protocol.html">Protocol</a>).initComptime(.{
        .{ <span class="tok-str">&quot;http&quot;</span>, .plain },
        .{ <span class="tok-str">&quot;ws&quot;</span>, .plain },
        .{ <span class="tok-str">&quot;https&quot;</span>, .tls },
        .{ <span class="tok-str">&quot;wss&quot;</span>, .tls },
    });
    <span class="tok-kw">const</span> protocol = protocol_map.get(uri.scheme) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedUriScheme;
    <span class="tok-kw">var</span> valid_uri = uri;<span class="tok-comment">
    // The host is always going to be needed as a raw string for hostname resolution anyway.
    </span>valid_uri.host = .{
        .raw = <span class="tok-kw">try</span> (uri.host <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UriMissingHost).toRawMaybeAlloc(arena),
    };
    <span class="tok-kw">return</span> .{ protocol, valid_uri };
}

<span class="tok-kw">fn</span> <span class="tok-fn">uriPort</span>(uri: <a href="std.Uri.html">Uri</a>, protocol: <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.Protocol.html">Protocol</a>) <span class="tok-type">u16</span> {
    <span class="tok-kw">return</span> uri.port <span class="tok-kw">orelse</span> <span class="tok-kw">switch</span> (protocol) {
        .plain =&gt; <span class="tok-number">80</span>,
        .tls =&gt; <span class="tok-number">443</span>,
    };
}

<span class="tok-comment">/// Open a connection to the host specified by `uri` and prepare to send a HTTP request.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `uri` must remain alive during the entire request.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The caller is responsible for calling `deinit()` on the `Request`.</span>
<span class="tok-comment">/// This function is threadsafe.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Asserts that &quot;\r\n&quot; does not occur in any header name or value.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">open</span>(
    client: *<a href="std.http.Client.html">Client</a>,
    method: <a href="std.http.html">http</a>.<a href="std.http.Method.html">Method</a>,
    uri: <a href="std.Uri.html">Uri</a>,
    options: <a href="std.http.Client.RequestOptions.html">RequestOptions</a>,
) <a href="std.http.Client.html#std.http.Client.RequestError">RequestError</a>!<a href="std.http.Client.Request.html">Request</a> {
    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.runtime_safety">runtime_safety</a>) {
        <span class="tok-kw">for</span> (options.extra_headers) |header| {
            <a href="std.debug.html#std.debug.assert">assert</a>(header.name.len != <span class="tok-number">0</span>);
            <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, header.name, <span class="tok-str">':'</span>) == <span class="tok-null">null</span>);
            <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, header.name, <span class="tok-number">0</span>, <span class="tok-str">&quot;\r\n&quot;</span>) == <span class="tok-null">null</span>);
            <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, header.value, <span class="tok-number">0</span>, <span class="tok-str">&quot;\r\n&quot;</span>) == <span class="tok-null">null</span>);
        }
        <span class="tok-kw">for</span> (options.privileged_headers) |header| {
            <a href="std.debug.html#std.debug.assert">assert</a>(header.name.len != <span class="tok-number">0</span>);
            <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, header.name, <span class="tok-number">0</span>, <span class="tok-str">&quot;\r\n&quot;</span>) == <span class="tok-null">null</span>);
            <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, header.value, <span class="tok-number">0</span>, <span class="tok-str">&quot;\r\n&quot;</span>) == <span class="tok-null">null</span>);
        }
    }

    <span class="tok-kw">var</span> server_header: <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.FixedBufferAllocator.html">FixedBufferAllocator</a> = .init(options.server_header_buffer);
    <span class="tok-kw">const</span> protocol, <span class="tok-kw">const</span> valid_uri = <span class="tok-kw">try</span> validateUri(uri, server_header.allocator());

    <span class="tok-kw">if</span> (protocol == .tls <span class="tok-kw">and</span> <span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">bool</span>, &amp;client.next_https_rescan_certs, .acquire)) {
        <span class="tok-kw">if</span> (<a href="std.http.Client.html#std.http.Client.disable_tls">disable_tls</a>) <span class="tok-kw">unreachable</span>;

        client.ca_bundle_mutex.lock();
        <span class="tok-kw">defer</span> client.ca_bundle_mutex.unlock();

        <span class="tok-kw">if</span> (client.next_https_rescan_certs) {
            client.ca_bundle.rescan(client.allocator) <span class="tok-kw">catch</span>
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateBundleLoadFailure;
            <span class="tok-builtin">@atomicStore</span>(<span class="tok-type">bool</span>, &amp;client.next_https_rescan_certs, <span class="tok-null">false</span>, .release);
        }
    }

    <span class="tok-kw">const</span> conn = options.connection <span class="tok-kw">orelse</span>
        <span class="tok-kw">try</span> client.connect(valid_uri.host.?.raw, <a href="std.http.Client.html#std.http.Client.uriPort">uriPort</a>(valid_uri, protocol), protocol);

    <span class="tok-kw">var</span> req: <a href="std.http.Client.Request.html">Request</a> = .{
        .uri = valid_uri,
        .client = client,
        .connection = conn,
        .keep_alive = options.keep_alive,
        .method = method,
        .version = options.version,
        .transfer_encoding = .none,
        .redirect_behavior = options.redirect_behavior,
        .handle_continue = options.handle_continue,
        .response = .{
            .version = <span class="tok-null">undefined</span>,
            .status = <span class="tok-null">undefined</span>,
            .reason = <span class="tok-null">undefined</span>,
            .keep_alive = <span class="tok-null">undefined</span>,
            .parser = .init(server_header.buffer[server_header.end_index..]),
        },
        .headers = options.headers,
        .extra_headers = options.extra_headers,
        .privileged_headers = options.privileged_headers,
    };
    <span class="tok-kw">errdefer</span> req.deinit();

    <span class="tok-kw">return</span> req;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FetchOptions = <span class="tok-kw">struct</span> {
    server_header_buffer: ?[]<span class="tok-type">u8</span> = <span class="tok-null">null</span>,
    redirect_behavior: ?<a href="std.http.Client.Request.html">Request</a>.<a href="std.http.Client.Request.RedirectBehavior.html">RedirectBehavior</a> = <span class="tok-null">null</span>,

    <span class="tok-comment">/// If the server sends a body, it will be appended to this ArrayList.</span>
    <span class="tok-comment">/// `max_append_size` provides an upper limit for how much they can grow.</span>
    response_storage: <a href="std.http.Client.FetchOptions.ResponseStorage.html">ResponseStorage</a> = .ignore,
    max_append_size: ?<span class="tok-type">usize</span> = <span class="tok-null">null</span>,

    location: <a href="std.http.Client.FetchOptions.Location.html">Location</a>,
    method: ?<a href="std.http.html">http</a>.<a href="std.http.Method.html">Method</a> = <span class="tok-null">null</span>,
    payload: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
    raw_uri: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    keep_alive: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,

    <span class="tok-comment">/// Standard headers that have default, but overridable, behavior.</span>
    headers: <a href="std.http.Client.Request.html">Request</a>.<a href="std.http.Client.Request.Headers.html">Headers</a> = .{},
    <span class="tok-comment">/// These headers are kept including when following a redirect to a</span>
    <span class="tok-comment">/// different domain.</span>
    <span class="tok-comment">/// Externally-owned; must outlive the Request.</span>
    extra_headers: []<span class="tok-kw">const</span> <a href="std.http.html">http</a>.<a href="std.http.Header.html">Header</a> = &amp;.{},
    <span class="tok-comment">/// These headers are stripped when following a redirect to a different</span>
    <span class="tok-comment">/// domain.</span>
    <span class="tok-comment">/// Externally-owned; must outlive the Request.</span>
    privileged_headers: []<span class="tok-kw">const</span> <a href="std.http.html">http</a>.<a href="std.http.Header.html">Header</a> = &amp;.{},

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Location = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        url: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        uri: <a href="std.Uri.html">Uri</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ResponseStorage = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        ignore,
        <span class="tok-comment">/// Only the existing capacity will be used.</span>
        static: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>),
        dynamic: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>),
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FetchResult = <span class="tok-kw">struct</span> {
    status: <a href="std.http.html">http</a>.<a href="std.http.Status.html">Status</a>,
};

<span class="tok-comment">/// Perform a one-shot HTTP request with the provided options.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This function is threadsafe.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetch</span>(client: *<a href="std.http.Client.html">Client</a>, options: <a href="std.http.Client.FetchOptions.html">FetchOptions</a>) !<a href="std.http.Client.FetchResult.html">FetchResult</a> {
    <span class="tok-kw">const</span> uri = <span class="tok-kw">switch</span> (options.location) {
        .url =&gt; |u| <span class="tok-kw">try</span> <a href="std.Uri.html">Uri</a>.<a href="std.Uri.html#std.Uri.parse">parse</a>(u),
        .uri =&gt; |u| u,
    };
    <span class="tok-kw">var</span> server_header_buffer: [<span class="tok-number">16</span> * <span class="tok-number">1024</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">const</span> method: <a href="std.http.html">http</a>.<a href="std.http.Method.html">Method</a> = options.method <span class="tok-kw">orelse</span>
        <span class="tok-kw">if</span> (options.payload != <span class="tok-null">null</span>) .POST <span class="tok-kw">else</span> .GET;

    <span class="tok-kw">var</span> req = <span class="tok-kw">try</span> <a href="std.http.Client.html#std.http.Client.open">open</a>(client, method, uri, .{
        .server_header_buffer = options.server_header_buffer <span class="tok-kw">orelse</span> &amp;server_header_buffer,
        .redirect_behavior = options.redirect_behavior <span class="tok-kw">orelse</span>
            <span class="tok-kw">if</span> (options.payload == <span class="tok-null">null</span>) <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">3</span>) <span class="tok-kw">else</span> .unhandled,
        .headers = options.headers,
        .extra_headers = options.extra_headers,
        .privileged_headers = options.privileged_headers,
        .keep_alive = options.keep_alive,
    });
    <span class="tok-kw">defer</span> req.deinit();

    <span class="tok-kw">if</span> (options.payload) |payload| req.transfer_encoding = .{ .content_length = payload.len };

    <span class="tok-kw">try</span> req.send();

    <span class="tok-kw">if</span> (options.payload) |payload| <span class="tok-kw">try</span> req.writeAll(payload);

    <span class="tok-kw">try</span> req.finish();
    <span class="tok-kw">try</span> req.wait();

    <span class="tok-kw">switch</span> (options.response_storage) {
        .ignore =&gt; {<span class="tok-comment">
            // Take advantage of request internals to discard the response body
            // and make the connection available for another request.
            </span>req.response.skip = <span class="tok-null">true</span>;
            <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> req.transferRead(&amp;.{}) == <span class="tok-number">0</span>);<span class="tok-comment"> // No buffer is necessary when skipping.
        </span>},
        .dynamic =&gt; |list| {
            <span class="tok-kw">const</span> max_append_size = options.max_append_size <span class="tok-kw">orelse</span> <span class="tok-number">2</span> * <span class="tok-number">1024</span> * <span class="tok-number">1024</span>;
            <span class="tok-kw">try</span> req.reader().readAllArrayList(list, max_append_size);
        },
        .static =&gt; |list| {
            <span class="tok-kw">const</span> buf = b: {
                <span class="tok-kw">const</span> buf = list.unusedCapacitySlice();
                <span class="tok-kw">if</span> (options.max_append_size) |len| {
                    <span class="tok-kw">if</span> (len &lt; buf.len) <span class="tok-kw">break</span> :b buf[<span class="tok-number">0</span>..len];
                }
                <span class="tok-kw">break</span> :b buf;
            };
            list.items.len += <span class="tok-kw">try</span> req.reader().readAll(buf);
        },
    }

    <span class="tok-kw">return</span> .{
        .status = req.response.status,
    };
}

<span class="tok-kw">test</span> {
    _ = &amp;<a href="std.http.Client.html#std.http.Client.initDefaultProxies">initDefaultProxies</a>;
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
