<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.meta.html" class="active">meta</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.meta" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.meta</span><a href="#src.zig-std.meta">[src]</a></h1><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.meta.trailer_flags.TrailerFlags" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">TrailerFlags</span><a href="#src.zig-std.meta.trailer_flags.TrailerFlags">[src]</a></h2><div class="tldDocs"><p>This is useful for saving memory when allocating an object that has many
optional components. The optional objects are allocated sequentially in
memory, and a single integer is used to represent each optional object
and whether it is present based on each corresponding bit.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>Fields: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.meta.trailer_flags.TrailerFlags.Int" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Int</span><a href="#src.zig-std.meta.trailer_flags.TrailerFlags.Int">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.meta.trailer_flags.TrailerFlags.Int">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Int = <a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.bit_count">bit_count</a>)</code></pre></details></div></div><div class="decl"><h3 id="std.meta.trailer_flags.TrailerFlags.FieldEnum" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">FieldEnum</span><a href="#src.zig-std.meta.trailer_flags.TrailerFlags.FieldEnum">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.meta.trailer_flags.TrailerFlags.FieldEnum">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FieldEnum = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(Fields)</code></pre></details></div></div><div class="decl"><h3 id="std.meta.trailer_flags.TrailerFlags.ActiveFields" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">ActiveFields</span><a href="#src.zig-std.meta.trailer_flags.TrailerFlags.ActiveFields">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.meta.trailer_flags.TrailerFlags.ActiveFields">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ActiveFields = <a href="std.html">std</a>.<a href="std.enums.html">enums</a>.<a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(<a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>, <span class="tok-type">bool</span>, <span class="tok-null">false</span>)</code></pre></details></div></div><div class="decl"><h3 id="std.meta.trailer_flags.TrailerFlags" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">TrailerFlags</span><a href="#src.zig-std.meta.trailer_flags.TrailerFlags">[src]</a></h3></div><div class="decl"><h3 id="std.meta.trailer_flags.TrailerFlags.Field" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Field</span><a href="#src.zig-std.meta.trailer_flags.TrailerFlags.Field">[src]</a></h3><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.meta.trailer_flags.TrailerFlags.Field">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Field</span>(<span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@typeInfo</span>(Fields).@&quot;struct&quot;.fields[<span class="tok-builtin">@intFromEnum</span>(field)].<span class="tok-type">type</span>;
}</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>bits: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.Int">Int</a></code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.meta.trailer_flags.TrailerFlags.bit_count" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">bit_count</span><a href="#src.zig-std.meta.trailer_flags.TrailerFlags.bit_count">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.meta.trailer_flags.TrailerFlags.bit_count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> bit_count = <span class="tok-builtin">@typeInfo</span>(Fields).@&quot;struct&quot;.fields.len</code></pre></details></div></div><div class="decl"><h3 id="std.meta.trailer_flags.TrailerFlags.FieldValues" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">FieldValues</span><a href="#src.zig-std.meta.trailer_flags.TrailerFlags.FieldValues">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.meta.trailer_flags.TrailerFlags.FieldValues">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FieldValues = blk: {
    <span class="tok-kw">var</span> fields: [<a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.bit_count">bit_count</a>]<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.StructField.html">StructField</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(Fields).@&quot;struct&quot;.fields, <span class="tok-number">0</span>..) |struct_field, i| {
        fields[i] = <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.StructField.html">StructField</a>{
            .name = struct_field.name,
            .<span class="tok-type">type</span> = ?struct_field.<span class="tok-type">type</span>,
            .default_value_ptr = &amp;<span class="tok-builtin">@as</span>(?struct_field.<span class="tok-type">type</span>, <span class="tok-null">null</span>),
            .is_comptime = <span class="tok-null">false</span>,
            .alignment = <span class="tok-builtin">@alignOf</span>(?struct_field.<span class="tok-type">type</span>),
        };
    }
    <span class="tok-kw">break</span> :blk <span class="tok-builtin">@Type</span>(.{
        .@&quot;struct&quot; = .{
            .layout = .auto,
            .fields = &amp;fields,
            .decls = &amp;.{},
            .is_tuple = <span class="tok-null">false</span>,
        },
    });
}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.meta.trailer_flags.TrailerFlags.has" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">has</span><a href="#src.zig-std.meta.trailer_flags.TrailerFlags.has">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">has</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a></code></pre></div><div><pre><code>field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.meta.trailer_flags.TrailerFlags.has">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">has</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> field_index = <span class="tok-builtin">@intFromEnum</span>(field);
    <span class="tok-kw">return</span> (self.bits &amp; (<span class="tok-number">1</span> &lt;&lt; field_index)) != <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.meta.trailer_flags.TrailerFlags.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.meta.trailer_flags.TrailerFlags.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, p: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(Fields)) <span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>) ?<a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.Field">Field</a>(field)</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a></code></pre></div><div><pre><code>p: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(Fields)) <span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.meta.trailer_flags.TrailerFlags.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, p: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(Fields)) <span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>) ?<a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.Field">Field</a>(field) {
    <span class="tok-kw">if</span> (!self.has(field))
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> self.ptrConst(p, field).*;
}</code></pre></details></div></div><div class="decl"><h3 id="std.meta.trailer_flags.TrailerFlags.setFlag" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setFlag</span><a href="#src.zig-std.meta.trailer_flags.TrailerFlags.setFlag">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setFlag</span>(self: *<a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a></code></pre></div><div><pre><code>field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.meta.trailer_flags.TrailerFlags.setFlag">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setFlag</span>(self: *<a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> field_index = <span class="tok-builtin">@intFromEnum</span>(field);
    self.bits |= <span class="tok-number">1</span> &lt;&lt; field_index;
}</code></pre></details></div></div><div class="decl"><h3 id="std.meta.trailer_flags.TrailerFlags.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.meta.trailer_flags.TrailerFlags.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(fields: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.ActiveFields">ActiveFields</a>) <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a></code></pre></div><div class="tldDocs"><p><code>fields</code> is a boolean struct where each active field is set to <code>true</code></p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>fields: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.ActiveFields">ActiveFields</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.meta.trailer_flags.TrailerFlags.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(fields: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.ActiveFields">ActiveFields</a>) <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a> {
    <span class="tok-kw">var</span> self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a> = .{ .bits = <span class="tok-number">0</span> };
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(Fields).@&quot;struct&quot;.fields, <span class="tok-number">0</span>..) |field, i| {
        <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(fields, field.name))
            self.bits |= <span class="tok-number">1</span> &lt;&lt; i;
    }
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h3 id="std.meta.trailer_flags.TrailerFlags.setMany" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setMany</span><a href="#src.zig-std.meta.trailer_flags.TrailerFlags.setMany">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setMany</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, p: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(Fields)) <span class="tok-type">u8</span>, fields: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldValues">FieldValues</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p><code>fields</code> is a struct with each field set to an optional value</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a></code></pre></div><div><pre><code>p: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(Fields)) <span class="tok-type">u8</span></code></pre></div><div><pre><code>fields: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldValues">FieldValues</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.meta.trailer_flags.TrailerFlags.setMany">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setMany</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, p: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(Fields)) <span class="tok-type">u8</span>, fields: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldValues">FieldValues</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(Fields).@&quot;struct&quot;.fields, <span class="tok-number">0</span>..) |field, i| {
        <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(fields, field.name)) |value|
            self.set(p, <span class="tok-builtin">@as</span>(<a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>, <span class="tok-builtin">@enumFromInt</span>(i)), value);
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.meta.trailer_flags.TrailerFlags.set" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">set</span><a href="#src.zig-std.meta.trailer_flags.TrailerFlags.set">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>( self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, p: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(Fields)) <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>, value: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.Field">Field</a>(field), ) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a></code></pre></div><div><pre><code>p: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(Fields)) <span class="tok-type">u8</span></code></pre></div><div><pre><code>field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a></code></pre></div><div><pre><code>value: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.Field">Field</a>(field)</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.meta.trailer_flags.TrailerFlags.set">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(
    self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>,
    p: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(Fields)) <span class="tok-type">u8</span>,
    <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>,
    value: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.Field">Field</a>(field),
) <span class="tok-type">void</span> {
    self.ptr(p, field).* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.meta.trailer_flags.TrailerFlags.ptr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ptr</span><a href="#src.zig-std.meta.trailer_flags.TrailerFlags.ptr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptr</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, p: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(Fields)) <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>) *<a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.Field">Field</a>(field)</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a></code></pre></div><div><pre><code>p: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(Fields)) <span class="tok-type">u8</span></code></pre></div><div><pre><code>field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.meta.trailer_flags.TrailerFlags.ptr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptr</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, p: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(Fields)) <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>) *<a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.Field">Field</a>(field) {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.Field">Field</a>(field)) == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> off = self.offset(field);
    <span class="tok-kw">return</span> <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(p + off));
}</code></pre></details></div></div><div class="decl"><h3 id="std.meta.trailer_flags.TrailerFlags.ptrConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ptrConst</span><a href="#src.zig-std.meta.trailer_flags.TrailerFlags.ptrConst">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrConst</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, p: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(Fields)) <span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>) *<span class="tok-kw">const</span> <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.Field">Field</a>(field)</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a></code></pre></div><div><pre><code>p: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(Fields)) <span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.meta.trailer_flags.TrailerFlags.ptrConst">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrConst</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, p: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(Fields)) <span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>) *<span class="tok-kw">const</span> <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.Field">Field</a>(field) {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.Field">Field</a>(field)) == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> off = self.offset(field);
    <span class="tok-kw">return</span> <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(p + off));
}</code></pre></details></div></div><div class="decl"><h3 id="std.meta.trailer_flags.TrailerFlags.offset" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">offset</span><a href="#src.zig-std.meta.trailer_flags.TrailerFlags.offset">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">offset</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>) <span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a></code></pre></div><div><pre><code>field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.meta.trailer_flags.TrailerFlags.offset">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">offset</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> off: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(Fields).@&quot;struct&quot;.fields, <span class="tok-number">0</span>..) |field_info, i| {
        <span class="tok-kw">const</span> active = (self.bits &amp; (<span class="tok-number">1</span> &lt;&lt; i)) != <span class="tok-number">0</span>;
        <span class="tok-kw">if</span> (i == <span class="tok-builtin">@intFromEnum</span>(field)) {
            <a href="std.debug.html#std.debug.assert">assert</a>(active);
            <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, off, <span class="tok-builtin">@alignOf</span>(field_info.<span class="tok-type">type</span>));
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (active) {
            off = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, off, <span class="tok-builtin">@alignOf</span>(field_info.<span class="tok-type">type</span>));
            off += <span class="tok-builtin">@sizeOf</span>(field_info.<span class="tok-type">type</span>);
        }
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.meta.trailer_flags.TrailerFlags.sizeInBytes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sizeInBytes</span><a href="#src.zig-std.meta.trailer_flags.TrailerFlags.sizeInBytes">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sizeInBytes</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.meta.trailer_flags.TrailerFlags.sizeInBytes">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sizeInBytes</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> off: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(Fields).@&quot;struct&quot;.fields, <span class="tok-number">0</span>..) |field, i| {
        <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(field.<span class="tok-type">type</span>) == <span class="tok-number">0</span>)
            <span class="tok-kw">continue</span>;
        <span class="tok-kw">if</span> ((self.bits &amp; (<span class="tok-number">1</span> &lt;&lt; i)) != <span class="tok-number">0</span>) {
            off = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, off, <span class="tok-builtin">@alignOf</span>(field.<span class="tok-type">type</span>));
            off += <span class="tok-builtin">@sizeOf</span>(field.<span class="tok-type">type</span>);
        }
    }
    <span class="tok-kw">return</span> off;
}</code></pre></details></div></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> TrailerFlags {
    <span class="tok-kw">const</span> Flags = <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">TrailerFlags</a>(<span class="tok-kw">struct</span> {
        a: <span class="tok-type">i32</span>,
        b: <span class="tok-type">bool</span>,
        c: <span class="tok-type">u64</span>,
    });
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-type">u2</span>, <a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Tag">Tag</a>(Flags.FieldEnum));

    <span class="tok-kw">var</span> flags = Flags.init(.{
        .b = <span class="tok-null">true</span>,
        .c = <span class="tok-null">true</span>,
    });
    <span class="tok-kw">const</span> slice = <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">alignedAlloc</a>(<span class="tok-type">u8</span>, <span class="tok-number">8</span>, flags.sizeInBytes());
    <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(slice);

    flags.set(slice.ptr, .b, <span class="tok-null">false</span>);
    flags.set(slice.ptr, .c, <span class="tok-number">12345678</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(flags.get(slice.ptr, .a) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!flags.get(slice.ptr, .b).?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(flags.get(slice.ptr, .c).? == <span class="tok-number">12345678</span>);

    flags.setMany(slice.ptr, .{
        .b = <span class="tok-null">true</span>,
        .c = <span class="tok-number">5678</span>,
    });

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(flags.get(slice.ptr, .a) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(flags.get(slice.ptr, .b).?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(flags.get(slice.ptr, .c).? == <span class="tok-number">5678</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.trailer_flags.TrailerFlags">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">TrailerFlags</span>(<span class="tok-kw">comptime</span> Fields: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        bits: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.Int">Int</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Int = <a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.bit_count">bit_count</a>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> bit_count = <span class="tok-builtin">@typeInfo</span>(Fields).@&quot;struct&quot;.fields.len;

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FieldEnum = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(Fields);

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ActiveFields = <a href="std.html">std</a>.<a href="std.enums.html">enums</a>.<a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(<a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>, <span class="tok-type">bool</span>, <span class="tok-null">false</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FieldValues = blk: {
            <span class="tok-kw">var</span> fields: [<a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.bit_count">bit_count</a>]<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.StructField.html">StructField</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(Fields).@&quot;struct&quot;.fields, <span class="tok-number">0</span>..) |struct_field, i| {
                fields[i] = <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.StructField.html">StructField</a>{
                    .name = struct_field.name,
                    .<span class="tok-type">type</span> = ?struct_field.<span class="tok-type">type</span>,
                    .default_value_ptr = &amp;<span class="tok-builtin">@as</span>(?struct_field.<span class="tok-type">type</span>, <span class="tok-null">null</span>),
                    .is_comptime = <span class="tok-null">false</span>,
                    .alignment = <span class="tok-builtin">@alignOf</span>(?struct_field.<span class="tok-type">type</span>),
                };
            }
            <span class="tok-kw">break</span> :blk <span class="tok-builtin">@Type</span>(.{
                .@&quot;struct&quot; = .{
                    .layout = .auto,
                    .fields = &amp;fields,
                    .decls = &amp;.{},
                    .is_tuple = <span class="tok-null">false</span>,
                },
            });
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">has</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> field_index = <span class="tok-builtin">@intFromEnum</span>(field);
            <span class="tok-kw">return</span> (self.bits &amp; (<span class="tok-number">1</span> &lt;&lt; field_index)) != <span class="tok-number">0</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, p: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(Fields)) <span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>) ?<a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.Field">Field</a>(field) {
            <span class="tok-kw">if</span> (!self.has(field))
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> self.ptrConst(p, field).*;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setFlag</span>(self: *<a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> field_index = <span class="tok-builtin">@intFromEnum</span>(field);
            self.bits |= <span class="tok-number">1</span> &lt;&lt; field_index;
        }

        <span class="tok-comment">/// `fields` is a boolean struct where each active field is set to `true`</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(fields: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.ActiveFields">ActiveFields</a>) <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a> {
            <span class="tok-kw">var</span> self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a> = .{ .bits = <span class="tok-number">0</span> };
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(Fields).@&quot;struct&quot;.fields, <span class="tok-number">0</span>..) |field, i| {
                <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(fields, field.name))
                    self.bits |= <span class="tok-number">1</span> &lt;&lt; i;
            }
            <span class="tok-kw">return</span> self;
        }

        <span class="tok-comment">/// `fields` is a struct with each field set to an optional value</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setMany</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, p: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(Fields)) <span class="tok-type">u8</span>, fields: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldValues">FieldValues</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(Fields).@&quot;struct&quot;.fields, <span class="tok-number">0</span>..) |field, i| {
                <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(fields, field.name)) |value|
                    self.set(p, <span class="tok-builtin">@as</span>(<a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>, <span class="tok-builtin">@enumFromInt</span>(i)), value);
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(
            self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>,
            p: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(Fields)) <span class="tok-type">u8</span>,
            <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>,
            value: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.Field">Field</a>(field),
        ) <span class="tok-type">void</span> {
            self.ptr(p, field).* = value;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptr</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, p: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(Fields)) <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>) *<a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.Field">Field</a>(field) {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.Field">Field</a>(field)) == <span class="tok-number">0</span>)
                <span class="tok-kw">return</span> <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> off = self.offset(field);
            <span class="tok-kw">return</span> <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(p + off));
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrConst</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, p: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(Fields)) <span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>) *<span class="tok-kw">const</span> <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.Field">Field</a>(field) {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.Field">Field</a>(field)) == <span class="tok-number">0</span>)
                <span class="tok-kw">return</span> <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> off = self.offset(field);
            <span class="tok-kw">return</span> <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(p + off));
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">offset</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>, <span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">var</span> off: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(Fields).@&quot;struct&quot;.fields, <span class="tok-number">0</span>..) |field_info, i| {
                <span class="tok-kw">const</span> active = (self.bits &amp; (<span class="tok-number">1</span> &lt;&lt; i)) != <span class="tok-number">0</span>;
                <span class="tok-kw">if</span> (i == <span class="tok-builtin">@intFromEnum</span>(field)) {
                    <a href="std.debug.html#std.debug.assert">assert</a>(active);
                    <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, off, <span class="tok-builtin">@alignOf</span>(field_info.<span class="tok-type">type</span>));
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (active) {
                    off = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, off, <span class="tok-builtin">@alignOf</span>(field_info.<span class="tok-type">type</span>));
                    off += <span class="tok-builtin">@sizeOf</span>(field_info.<span class="tok-type">type</span>);
                }
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Field</span>(<span class="tok-kw">comptime</span> field: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags.FieldEnum">FieldEnum</a>) <span class="tok-type">type</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@typeInfo</span>(Fields).@&quot;struct&quot;.fields[<span class="tok-builtin">@intFromEnum</span>(field)].<span class="tok-type">type</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sizeInBytes</span>(self: <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">var</span> off: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(Fields).@&quot;struct&quot;.fields, <span class="tok-number">0</span>..) |field, i| {
                <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(field.<span class="tok-type">type</span>) == <span class="tok-number">0</span>)
                    <span class="tok-kw">continue</span>;
                <span class="tok-kw">if</span> ((self.bits &amp; (<span class="tok-number">1</span> &lt;&lt; i)) != <span class="tok-number">0</span>) {
                    off = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, off, <span class="tok-builtin">@alignOf</span>(field.<span class="tok-type">type</span>));
                    off += <span class="tok-builtin">@sizeOf</span>(field.<span class="tok-type">type</span>);
                }
            }
            <span class="tok-kw">return</span> off;
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.Child" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Child</span><a href="#src.zig-std.meta.Child">[src]</a></h2><div class="tldDocs"><p>Given a parameterized type (array, vector, pointer, optional), returns the &quot;child type&quot;.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> Child {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Child">Child</a>([<span class="tok-number">1</span>]<span class="tok-type">u8</span>) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Child">Child</a>(*<span class="tok-type">u8</span>) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Child">Child</a>([]<span class="tok-type">u8</span>) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Child">Child</a>(?<span class="tok-type">u8</span>) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">u8</span>)) == <span class="tok-type">u8</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.Child">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Child</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .array =&gt; |info| info.child,
        .vector =&gt; |info| info.child,
        .pointer =&gt; |info| info.child,
        .optional =&gt; |info| info.child,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Expected pointer, optional, array or vector type, found '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.Elem" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Elem</span><a href="#src.zig-std.meta.Elem">[src]</a></h2><div class="tldDocs"><p>Given a &quot;memory span&quot; type (array, slice, vector, or pointer to such), returns the &quot;element type&quot;.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> Elem {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Elem">Elem</a>([<span class="tok-number">1</span>]<span class="tok-type">u8</span>) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Elem">Elem</a>([*]<span class="tok-type">u8</span>) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Elem">Elem</a>([]<span class="tok-type">u8</span>) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Elem">Elem</a>(*[<span class="tok-number">10</span>]<span class="tok-type">u8</span>) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Elem">Elem</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">u8</span>)) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Elem">Elem</a>(*<span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">u8</span>)) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Elem">Elem</a>(?[*]<span class="tok-type">u8</span>) == <span class="tok-type">u8</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.Elem">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Elem</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .array =&gt; |info| <span class="tok-kw">return</span> info.child,
        .vector =&gt; |info| <span class="tok-kw">return</span> info.child,
        .pointer =&gt; |info| <span class="tok-kw">switch</span> (info.size) {
            .one =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(info.child)) {
                .array =&gt; |array_info| <span class="tok-kw">return</span> array_info.child,
                .vector =&gt; |vector_info| <span class="tok-kw">return</span> vector_info.child,
                <span class="tok-kw">else</span> =&gt; {},
            },
            .many, .c, .slice =&gt; <span class="tok-kw">return</span> info.child,
        },
        .optional =&gt; |info| <span class="tok-kw">return</span> <a href="std.meta.html#std.meta.Elem">Elem</a>(info.child),
        <span class="tok-kw">else</span> =&gt; {},
    }
    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Expected pointer, slice, array or vector type, found '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.Sentinel" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Sentinel</span><a href="#src.zig-std.meta.Sentinel">[src]</a></h2><div class="tldDocs"><p>Given a &quot;memory span&quot; type, returns the same type except with the given sentinel value.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>sentinel_val: <a href="std.meta.html#std.meta.Elem">Elem</a>(T)</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.Sentinel">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Sentinel</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> sentinel_val: <a href="std.meta.html#std.meta.Elem">Elem</a>(T)) <span class="tok-type">type</span> {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .pointer =&gt; |info| <span class="tok-kw">switch</span> (info.size) {
            .one =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(info.child)) {
                .array =&gt; |array_info| <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{
                    .pointer = .{
                        .size = info.size,
                        .is_const = info.is_const,
                        .is_volatile = info.is_volatile,
                        .alignment = info.alignment,
                        .address_space = info.address_space,
                        .child = <span class="tok-builtin">@Type</span>(.{
                            .array = .{
                                .len = array_info.len,
                                .child = array_info.child,
                                .sentinel_ptr = <span class="tok-builtin">@as</span>(?*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(&amp;sentinel_val)),
                            },
                        }),
                        .is_allowzero = info.is_allowzero,
                        .sentinel_ptr = info.sentinel_ptr,
                    },
                }),
                <span class="tok-kw">else</span> =&gt; {},
            },
            .many, .slice =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{
                .pointer = .{
                    .size = info.size,
                    .is_const = info.is_const,
                    .is_volatile = info.is_volatile,
                    .alignment = info.alignment,
                    .address_space = info.address_space,
                    .child = info.child,
                    .is_allowzero = info.is_allowzero,
                    .sentinel_ptr = <span class="tok-builtin">@as</span>(?*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(&amp;sentinel_val)),
                },
            }),
            <span class="tok-kw">else</span> =&gt; {},
        },
        .optional =&gt; |info| <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(info.child)) {
            .pointer =&gt; |ptr_info| <span class="tok-kw">switch</span> (ptr_info.size) {
                .many =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{
                    .optional = .{
                        .child = <span class="tok-builtin">@Type</span>(.{
                            .pointer = .{
                                .size = ptr_info.size,
                                .is_const = ptr_info.is_const,
                                .is_volatile = ptr_info.is_volatile,
                                .alignment = ptr_info.alignment,
                                .address_space = ptr_info.address_space,
                                .child = ptr_info.child,
                                .is_allowzero = ptr_info.is_allowzero,
                                .sentinel_ptr = <span class="tok-builtin">@as</span>(?*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(&amp;sentinel_val)),
                            },
                        }),
                    },
                }),
                <span class="tok-kw">else</span> =&gt; {},
            },
            <span class="tok-kw">else</span> =&gt; {},
        },
        <span class="tok-kw">else</span> =&gt; {},
    }
    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to derive a sentinel pointer type from &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T));
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.FieldType" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">FieldType</span><a href="#src.zig-std.meta.FieldType">[src]</a></h2><div class="tldDocs"><p>Deprecated: use @FieldType</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>field: <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(T)</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> FieldType {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u8</span>,
        b: <span class="tok-type">u16</span>,
    };

    <span class="tok-kw">const</span> U = <span class="tok-kw">union</span> {
        c: <span class="tok-type">u32</span>,
        d: *<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.FieldType">FieldType</a>(S, .a) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.FieldType">FieldType</a>(S, .b) == <span class="tok-type">u16</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.FieldType">FieldType</a>(U, .c) == <span class="tok-type">u32</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.FieldType">FieldType</a>(U, .d) == *<span class="tok-kw">const</span> <span class="tok-type">u8</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.FieldType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">FieldType</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> field: <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(T)) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@FieldType</span>(T, <span class="tok-builtin">@tagName</span>(field));
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.FieldEnum" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">FieldEnum</span><a href="#src.zig-std.meta.FieldEnum">[src]</a></h2><div class="tldDocs"><p>Returns an enum with a variant named after each field of <code>T</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> FieldEnum {
    <span class="tok-kw">try</span> <a href="std.meta.html#std.meta.expectEqualEnum">expectEqualEnum</a>(<span class="tok-kw">enum</span> {}, <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(<span class="tok-kw">struct</span> {}));
    <span class="tok-kw">try</span> <a href="std.meta.html#std.meta.expectEqualEnum">expectEqualEnum</a>(<span class="tok-kw">enum</span> { a }, <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(<span class="tok-kw">struct</span> { a: <span class="tok-type">u8</span> }));
    <span class="tok-kw">try</span> <a href="std.meta.html#std.meta.expectEqualEnum">expectEqualEnum</a>(<span class="tok-kw">enum</span> { a, b, c }, <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(<span class="tok-kw">struct</span> { a: <span class="tok-type">u8</span>, b: <span class="tok-type">void</span>, c: <span class="tok-type">f32</span> }));
    <span class="tok-kw">try</span> <a href="std.meta.html#std.meta.expectEqualEnum">expectEqualEnum</a>(<span class="tok-kw">enum</span> { a, b, c }, <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(<span class="tok-kw">union</span> { a: <span class="tok-type">u8</span>, b: <span class="tok-type">void</span>, c: <span class="tok-type">f32</span> }));

    <span class="tok-kw">const</span> Tagged = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) { a: <span class="tok-type">u8</span>, b: <span class="tok-type">void</span>, c: <span class="tok-type">f32</span> };
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.meta.html#std.meta.Tag">Tag</a>(Tagged), <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(Tagged));

    <span class="tok-kw">const</span> Tag2 = <span class="tok-kw">enum</span> { a, b, c };
    <span class="tok-kw">const</span> Tagged2 = <span class="tok-kw">union</span>(Tag2) { a: <span class="tok-type">u8</span>, b: <span class="tok-type">void</span>, c: <span class="tok-type">f32</span> };
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Tag">Tag</a>(Tagged2) == <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(Tagged2));

    <span class="tok-kw">const</span> Tag3 = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) { a, b, c = <span class="tok-number">7</span> };
    <span class="tok-kw">const</span> Tagged3 = <span class="tok-kw">union</span>(Tag3) { a: <span class="tok-type">u8</span>, b: <span class="tok-type">void</span>, c: <span class="tok-type">f32</span> };
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Tag">Tag</a>(Tagged3) != <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(Tagged3));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.FieldEnum">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">FieldEnum</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> field_infos = <a href="std.meta.html#std.meta.fields">fields</a>(T);

    <span class="tok-kw">if</span> (field_infos.len == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{
            .@&quot;enum&quot; = .{
                .tag_type = <span class="tok-type">u0</span>,
                .fields = &amp;.{},
                .decls = &amp;.{},
                .is_exhaustive = <span class="tok-null">true</span>,
            },
        });
    }

    <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(T) == .@&quot;union&quot;) {
        <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(T).@&quot;union&quot;.tag_type) |tag_type| {
            <span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.enums.html">enums</a>.<a href="std.enums.html#std.enums.values">values</a>(tag_type), <span class="tok-number">0</span>..) |v, i| {
                <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(v) != i) <span class="tok-kw">break</span>;<span class="tok-comment"> // enum values not consecutive
                </span><span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-builtin">@tagName</span>(v), field_infos[i].name)) <span class="tok-kw">break</span>;<span class="tok-comment"> // fields out of order
            </span>} <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> tag_type;
            }
        }
    }

    <span class="tok-kw">var</span> enumFields: [field_infos.len]<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.EnumField.html">EnumField</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> decls = [_]<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Declaration.html">Declaration</a>{};
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (field_infos, <span class="tok-number">0</span>..) |field, i| {
        enumFields[i] = .{
            .name = field.name ++ <span class="tok-str">&quot;&quot;</span>,
            .value = i,
        };
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{
        .@&quot;enum&quot; = .{
            .tag_type = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.IntFittingRange">IntFittingRange</a>(<span class="tok-number">0</span>, field_infos.len - <span class="tok-number">1</span>),
            .fields = &amp;enumFields,
            .decls = &amp;decls,
            .is_exhaustive = <span class="tok-null">true</span>,
        },
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.DeclEnum" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">DeclEnum</span><a href="#src.zig-std.meta.DeclEnum">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> DeclEnum {
    <span class="tok-kw">const</span> A = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> a: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;
    };
    <span class="tok-kw">const</span> B = <span class="tok-kw">union</span> {
        foo: <span class="tok-type">void</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> a: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> b: <span class="tok-type">void</span> = {};
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> c: <span class="tok-type">f32</span> = <span class="tok-number">0</span>;
    };
    <span class="tok-kw">const</span> C = <span class="tok-kw">enum</span> {
        bar,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> a: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> b: <span class="tok-type">void</span> = {};
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> c: <span class="tok-type">f32</span> = <span class="tok-number">0</span>;
    };
    <span class="tok-kw">const</span> D = <span class="tok-kw">struct</span> {};

    <span class="tok-kw">try</span> <a href="std.meta.html#std.meta.expectEqualEnum">expectEqualEnum</a>(<span class="tok-kw">enum</span> { a }, <a href="std.meta.html#std.meta.DeclEnum">DeclEnum</a>(A));
    <span class="tok-kw">try</span> <a href="std.meta.html#std.meta.expectEqualEnum">expectEqualEnum</a>(<span class="tok-kw">enum</span> { a, b, c }, <a href="std.meta.html#std.meta.DeclEnum">DeclEnum</a>(B));
    <span class="tok-kw">try</span> <a href="std.meta.html#std.meta.expectEqualEnum">expectEqualEnum</a>(<span class="tok-kw">enum</span> { a, b, c }, <a href="std.meta.html#std.meta.DeclEnum">DeclEnum</a>(C));
    <span class="tok-kw">try</span> <a href="std.meta.html#std.meta.expectEqualEnum">expectEqualEnum</a>(<span class="tok-kw">enum</span> {}, <a href="std.meta.html#std.meta.DeclEnum">DeclEnum</a>(D));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.DeclEnum">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">DeclEnum</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> fieldInfos = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.declarations">declarations</a>(T);
    <span class="tok-kw">var</span> enumDecls: [fieldInfos.len]<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.EnumField.html">EnumField</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> decls = [_]<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Declaration.html">Declaration</a>{};
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fieldInfos, <span class="tok-number">0</span>..) |field, i| {
        enumDecls[i] = .{ .name = field.name ++ <span class="tok-str">&quot;&quot;</span>, .value = i };
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{
        .@&quot;enum&quot; = .{
            .tag_type = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.IntFittingRange">IntFittingRange</a>(<span class="tok-number">0</span>, <span class="tok-kw">if</span> (fieldInfos.len == <span class="tok-number">0</span>) <span class="tok-number">0</span> <span class="tok-kw">else</span> fieldInfos.len - <span class="tok-number">1</span>),
            .fields = &amp;enumDecls,
            .decls = &amp;decls,
            .is_exhaustive = <span class="tok-null">true</span>,
        },
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.Tag" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Tag</span><a href="#src.zig-std.meta.Tag">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> Tag {
    <span class="tok-kw">const</span> E = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {
        C = <span class="tok-number">33</span>,
        D,
    };
    <span class="tok-kw">const</span> U = <span class="tok-kw">union</span>(E) {
        C: <span class="tok-type">u8</span>,
        D: <span class="tok-type">u16</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Tag">Tag</a>(E) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Tag">Tag</a>(U) == E);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.Tag">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Tag</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .@&quot;enum&quot; =&gt; |info| info.tag_type,
        .@&quot;union&quot; =&gt; |info| info.tag_type <span class="tok-kw">orelse</span> <span class="tok-builtin">@compileError</span>(<span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot; has no tag type&quot;</span>),
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected enum or union type, found '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.TagPayloadByName" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">TagPayloadByName</span><a href="#src.zig-std.meta.TagPayloadByName">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>U: <span class="tok-type">type</span></code></pre></div><div><pre><code>tag_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.TagPayloadByName">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">TagPayloadByName</span>(<span class="tok-kw">comptime</span> U: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> tag_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(U).@&quot;union&quot;;

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (info.fields) |field_info| {
        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, field_info.name, tag_name))
            <span class="tok-kw">return</span> field_info.<span class="tok-type">type</span>;
    }

    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;no field '&quot;</span> ++ tag_name ++ <span class="tok-str">&quot;' in union '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(U) ++ <span class="tok-str">&quot;'&quot;</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.TagPayload" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">TagPayload</span><a href="#src.zig-std.meta.TagPayload">[src]</a></h2><div class="tldDocs"><p>Given a tagged union type, and an enum, return the type of the union field
corresponding to the enum tag.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>U: <span class="tok-type">type</span></code></pre></div><div><pre><code>tag: <a href="std.meta.html#std.meta.Tag">Tag</a>(U)</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> TagPayload {
    <span class="tok-kw">const</span> Event = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        Moved: <span class="tok-kw">struct</span> {
            from: <span class="tok-type">i32</span>,
            to: <span class="tok-type">i32</span>,
        },
    };
    <span class="tok-kw">const</span> MovedEvent = <a href="std.meta.html#std.meta.TagPayload">TagPayload</a>(Event, Event.Moved);
    <span class="tok-kw">const</span> e: Event = .{ .Moved = <span class="tok-null">undefined</span> };
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(MovedEvent == <span class="tok-builtin">@TypeOf</span>(e.Moved));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.TagPayload">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">TagPayload</span>(<span class="tok-kw">comptime</span> U: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> tag: <a href="std.meta.html#std.meta.Tag">Tag</a>(U)) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.meta.html#std.meta.TagPayloadByName">TagPayloadByName</a>(U, <span class="tok-builtin">@tagName</span>(tag));
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.Int" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Int</span><a href="#src.zig-std.meta.Int">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>signedness: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.Int">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Int</span>(<span class="tok-kw">comptime</span> signedness: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Signedness.html">Signedness</a>, <span class="tok-kw">comptime</span> bit_count: <span class="tok-type">u16</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{
        .int = .{
            .signedness = signedness,
            .bits = bit_count,
        },
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.Float" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Float</span><a href="#src.zig-std.meta.Float">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>bit_count: <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> Float {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-type">f16</span>, <a href="std.meta.html#std.meta.Float">Float</a>(<span class="tok-number">16</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-type">f32</span>, <a href="std.meta.html#std.meta.Float">Float</a>(<span class="tok-number">32</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-type">f64</span>, <a href="std.meta.html#std.meta.Float">Float</a>(<span class="tok-number">64</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-type">f128</span>, <a href="std.meta.html#std.meta.Float">Float</a>(<span class="tok-number">128</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.Float">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Float</span>(<span class="tok-kw">comptime</span> bit_count: <span class="tok-type">u8</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{
        .float = .{ .bits = bit_count },
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.ArgsTuple" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">ArgsTuple</span><a href="#src.zig-std.meta.ArgsTuple">[src]</a></h2><div class="tldDocs"><p>For a given function type, returns a tuple type which fields will
correspond to the argument types.</p>
<p>Examples:</p>
<ul>
<li><code>ArgsTuple(fn () void)</code> ⇒ <code>tuple { }</code></li>
<li><code>ArgsTuple(fn (a: u32) u32)</code> ⇒ <code>tuple { u32 }</code></li>
<li><code>ArgsTuple(fn (a: u32, b: f16) noreturn)</code> ⇒ <code>tuple { u32, f16 }</code></li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>Function: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> ArgsTuple {
    <a href="std.meta.TupleTester.html">TupleTester</a>.<a href="std.meta.TupleTester.html#std.meta.TupleTester.assertTuple">assertTuple</a>(.{}, <a href="std.meta.html#std.meta.ArgsTuple">ArgsTuple</a>(<span class="tok-kw">fn</span> () <span class="tok-type">void</span>));
    <a href="std.meta.TupleTester.html">TupleTester</a>.<a href="std.meta.TupleTester.html#std.meta.TupleTester.assertTuple">assertTuple</a>(.{<span class="tok-type">u32</span>}, <a href="std.meta.html#std.meta.ArgsTuple">ArgsTuple</a>(<span class="tok-kw">fn</span> (a: <span class="tok-type">u32</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span>));
    <a href="std.meta.TupleTester.html">TupleTester</a>.<a href="std.meta.TupleTester.html#std.meta.TupleTester.assertTuple">assertTuple</a>(.{ <span class="tok-type">u32</span>, <span class="tok-type">f16</span> }, <a href="std.meta.html#std.meta.ArgsTuple">ArgsTuple</a>(<span class="tok-kw">fn</span> (a: <span class="tok-type">u32</span>, b: <span class="tok-type">f16</span>) <span class="tok-type">noreturn</span>));
    <a href="std.meta.TupleTester.html">TupleTester</a>.<a href="std.meta.TupleTester.html#std.meta.TupleTester.assertTuple">assertTuple</a>(.{ <span class="tok-type">u32</span>, <span class="tok-type">f16</span>, []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-type">void</span> }, <a href="std.meta.html#std.meta.ArgsTuple">ArgsTuple</a>(<span class="tok-kw">fn</span> (a: <span class="tok-type">u32</span>, b: <span class="tok-type">f16</span>, c: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-type">void</span>) <span class="tok-type">noreturn</span>));
    <a href="std.meta.TupleTester.html">TupleTester</a>.<a href="std.meta.TupleTester.html#std.meta.TupleTester.assertTuple">assertTuple</a>(.{<span class="tok-type">u32</span>}, <a href="std.meta.html#std.meta.ArgsTuple">ArgsTuple</a>(<span class="tok-kw">fn</span> (<span class="tok-kw">comptime</span> a: <span class="tok-type">u32</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.ArgsTuple">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ArgsTuple</span>(<span class="tok-kw">comptime</span> Function: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(Function);
    <span class="tok-kw">if</span> (info != .@&quot;fn&quot;)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;ArgsTuple expects a function type&quot;</span>);

    <span class="tok-kw">const</span> function_info = info.@&quot;fn&quot;;
    <span class="tok-kw">if</span> (function_info.is_var_args)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot create ArgsTuple for variadic function&quot;</span>);

    <span class="tok-kw">var</span> argument_field_list: [function_info.params.len]<span class="tok-type">type</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (function_info.params, <span class="tok-number">0</span>..) |arg, i| {
        <span class="tok-kw">const</span> T = arg.<span class="tok-type">type</span> <span class="tok-kw">orelse</span> <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;cannot create ArgsTuple for function with an 'anytype' parameter&quot;</span>);
        argument_field_list[i] = T;
    }

    <span class="tok-kw">return</span> <a href="std.meta.html#std.meta.CreateUniqueTuple">CreateUniqueTuple</a>(argument_field_list.len, argument_field_list);
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.Tuple" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Tuple</span><a href="#src.zig-std.meta.Tuple">[src]</a></h2><div class="tldDocs"><p>For a given anonymous list of types, returns a new tuple type
with those types as fields.</p>
<p>Examples:</p>
<ul>
<li><code>Tuple(&amp;[_]type {})</code> ⇒ <code>tuple { }</code></li>
<li><code>Tuple(&amp;[_]type {f32})</code> ⇒ <code>tuple { f32 }</code></li>
<li><code>Tuple(&amp;[_]type {f32,u32})</code> ⇒ <code>tuple { f32, u32 }</code></li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>types: []<span class="tok-kw">const</span> <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> Tuple {
    <a href="std.meta.TupleTester.html">TupleTester</a>.<a href="std.meta.TupleTester.html#std.meta.TupleTester.assertTuple">assertTuple</a>(.{}, <a href="std.meta.html#std.meta.Tuple">Tuple</a>(&amp;[_]<span class="tok-type">type</span>{}));
    <a href="std.meta.TupleTester.html">TupleTester</a>.<a href="std.meta.TupleTester.html#std.meta.TupleTester.assertTuple">assertTuple</a>(.{<span class="tok-type">u32</span>}, <a href="std.meta.html#std.meta.Tuple">Tuple</a>(&amp;[_]<span class="tok-type">type</span>{<span class="tok-type">u32</span>}));
    <a href="std.meta.TupleTester.html">TupleTester</a>.<a href="std.meta.TupleTester.html#std.meta.TupleTester.assertTuple">assertTuple</a>(.{ <span class="tok-type">u32</span>, <span class="tok-type">f16</span> }, <a href="std.meta.html#std.meta.Tuple">Tuple</a>(&amp;[_]<span class="tok-type">type</span>{ <span class="tok-type">u32</span>, <span class="tok-type">f16</span> }));
    <a href="std.meta.TupleTester.html">TupleTester</a>.<a href="std.meta.TupleTester.html#std.meta.TupleTester.assertTuple">assertTuple</a>(.{ <span class="tok-type">u32</span>, <span class="tok-type">f16</span>, []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-type">void</span> }, <a href="std.meta.html#std.meta.Tuple">Tuple</a>(&amp;[_]<span class="tok-type">type</span>{ <span class="tok-type">u32</span>, <span class="tok-type">f16</span>, []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-type">void</span> }));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.Tuple">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Tuple</span>(<span class="tok-kw">comptime</span> types: []<span class="tok-kw">const</span> <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.meta.html#std.meta.CreateUniqueTuple">CreateUniqueTuple</a>(types.len, types[<span class="tok-number">0</span>..types.len].*);
}</code></pre></details></div></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.meta.a" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">a</span><a href="#src.zig-std.meta.a">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.a">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> a: <span class="tok-type">u8</span> = <span class="tok-number">0</span></code></pre></details></div></div><div class="decl"><h2 id="std.meta.a" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">a</span><a href="#src.zig-std.meta.a">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.a">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> a: <span class="tok-type">u8</span> = <span class="tok-number">0</span></code></pre></details></div></div><div class="decl"><h2 id="std.meta.b" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">b</span><a href="#src.zig-std.meta.b">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.b">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> b: <span class="tok-type">void</span> = {}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.c" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">c</span><a href="#src.zig-std.meta.c">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.c">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> c: <span class="tok-type">f32</span> = <span class="tok-number">0</span></code></pre></details></div></div><div class="decl"><h2 id="std.meta.a" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">a</span><a href="#src.zig-std.meta.a">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.a">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> a: <span class="tok-type">u8</span> = <span class="tok-number">0</span></code></pre></details></div></div><div class="decl"><h2 id="std.meta.b" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">b</span><a href="#src.zig-std.meta.b">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.b">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> b: <span class="tok-type">void</span> = {}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.c" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">c</span><a href="#src.zig-std.meta.c">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.c">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> c: <span class="tok-type">f32</span> = <span class="tok-number">0</span></code></pre></details></div></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.meta.IntToEnumError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">IntToEnumError</span><a href="#src.zig-std.meta.IntToEnumError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>InvalidEnumTag</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.IntToEnumError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> IntToEnumError = <span class="tok-kw">error</span>{InvalidEnumTag}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.meta.stringToEnum" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">stringToEnum</span><a href="#src.zig-std.meta.stringToEnum">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringToEnum</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?T</code></pre></div><div class="tldDocs"><p>Returns the variant of an enum type, <code>T</code>, which is named <code>str</code>, or <code>null</code> if no such variant exists.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> stringToEnum {
    <span class="tok-kw">const</span> E1 = <span class="tok-kw">enum</span> {
        A,
        B,
    };
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(E1.A == <a href="std.meta.html#std.meta.stringToEnum">stringToEnum</a>(E1, <span class="tok-str">&quot;A&quot;</span>).?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(E1.B == <a href="std.meta.html#std.meta.stringToEnum">stringToEnum</a>(E1, <span class="tok-str">&quot;B&quot;</span>).?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-null">null</span> == <a href="std.meta.html#std.meta.stringToEnum">stringToEnum</a>(E1, <span class="tok-str">&quot;C&quot;</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.stringToEnum">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringToEnum</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?T {<span class="tok-comment">
    // Using StaticStringMap here is more performant, but it will start to take too
    // long to compile if the enum is large enough, due to the current limits of comptime
    // performance when doing things like constructing lookup maps at comptime.
    // TODO The '100' here is arbitrary and should be increased when possible:
    // - https://github.com/ziglang/zig/issues/4055
    // - https://github.com/ziglang/zig/issues/3863
    </span><span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(T).@&quot;enum&quot;.fields.len &lt;= <span class="tok-number">100</span>) {
        <span class="tok-kw">const</span> kvs = <span class="tok-kw">comptime</span> build_kvs: {
            <span class="tok-kw">const</span> EnumKV = <span class="tok-kw">struct</span> { []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, T };
            <span class="tok-kw">var</span> kvs_array: [<span class="tok-builtin">@typeInfo</span>(T).@&quot;enum&quot;.fields.len]EnumKV = <span class="tok-null">undefined</span>;
            <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(T).@&quot;enum&quot;.fields, <span class="tok-number">0</span>..) |enumField, i| {
                kvs_array[i] = .{ enumField.name, <span class="tok-builtin">@field</span>(T, enumField.name) };
            }
            <span class="tok-kw">break</span> :build_kvs kvs_array[<span class="tok-number">0</span>..];
        };
        <span class="tok-kw">const</span> map = <a href="std.html">std</a>.<a href="std.static_string_map.html#std.static_string_map.StaticStringMap">StaticStringMap</a>(T).initComptime(kvs);
        <span class="tok-kw">return</span> map.get(str);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(T).@&quot;enum&quot;.fields) |enumField| {
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, str, enumField.name)) {
                <span class="tok-kw">return</span> <span class="tok-builtin">@field</span>(T, enumField.name);
            }
        }
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.alignment" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">alignment</span><a href="#src.zig-std.meta.alignment">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignment</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span></code></pre></div><div class="tldDocs"><p>Returns the alignment of type T.
Note that if T is a pointer type the result is different than the one
returned by @alignOf(T).
If T is a pointer type the alignment of the type it points to is returned.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> alignment {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.alignment">alignment</a>(<span class="tok-type">u8</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.alignment">alignment</a>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-type">u8</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.alignment">alignment</a>(*<span class="tok-kw">align</span>(<span class="tok-number">2</span>) <span class="tok-type">u8</span>) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.alignment">alignment</a>([]<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-type">u8</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.alignment">alignment</a>([]<span class="tok-kw">align</span>(<span class="tok-number">2</span>) <span class="tok-type">u8</span>) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.alignment">alignment</a>(<span class="tok-kw">fn</span> () <span class="tok-type">void</span>) &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.alignment">alignment</a>(*<span class="tok-kw">const</span> <span class="tok-kw">fn</span> () <span class="tok-type">void</span>) &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.alignment">alignment</a>(*<span class="tok-kw">align</span>(<span class="tok-number">128</span>) <span class="tok-kw">const</span> <span class="tok-kw">fn</span> () <span class="tok-type">void</span>) == <span class="tok-number">128</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.alignment">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignment</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .optional =&gt; |info| <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(info.child)) {
            .pointer, .@&quot;fn&quot; =&gt; <a href="std.meta.html#std.meta.alignment">alignment</a>(info.child),
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@alignOf</span>(T),
        },
        .pointer =&gt; |info| info.alignment,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@alignOf</span>(T),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.sentinel" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sentinel</span><a href="#src.zig-std.meta.sentinel">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sentinel</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) ?<a href="std.meta.html#std.meta.Elem">Elem</a>(T)</code></pre></div><div class="tldDocs"><p>Given a type which can have a sentinel e.g. <code>[:0]u8</code>, returns the sentinel value,
or <code>null</code> if there is not one.
Types which cannot possibly have a sentinel will be a compile error.
Result is always comptime-known.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> sentinel {
    <span class="tok-kw">try</span> <a href="std.meta.html#std.meta.testSentinel">testSentinel</a>();
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> <a href="std.meta.html#std.meta.testSentinel">testSentinel</a>();
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.sentinel">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sentinel</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) ?<a href="std.meta.html#std.meta.Elem">Elem</a>(T) {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .array =&gt; |info| <span class="tok-kw">return</span> info.sentinel(),
        .pointer =&gt; |info| {
            <span class="tok-kw">switch</span> (info.size) {
                .many, .slice =&gt; <span class="tok-kw">return</span> info.sentinel(),
                .one =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(info.child)) {
                    .array =&gt; |array_info| <span class="tok-kw">return</span> array_info.sentinel(),
                    <span class="tok-kw">else</span> =&gt; {},
                },
                <span class="tok-kw">else</span> =&gt; {},
            }
        },
        <span class="tok-kw">else</span> =&gt; {},
    }
    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;' cannot possibly have a sentinel&quot;</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.containerLayout" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containerLayout</span><a href="#src.zig-std.meta.containerLayout">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerLayout</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.ContainerLayout.html">ContainerLayout</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> containerLayout {
    <span class="tok-kw">const</span> S1 = <span class="tok-kw">struct</span> {};
    <span class="tok-kw">const</span> S2 = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {};
    <span class="tok-kw">const</span> S3 = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {};
    <span class="tok-kw">const</span> U1 = <span class="tok-kw">union</span> {
        a: <span class="tok-type">u8</span>,
    };
    <span class="tok-kw">const</span> U2 = <span class="tok-kw">packed</span> <span class="tok-kw">union</span> {
        a: <span class="tok-type">u8</span>,
    };
    <span class="tok-kw">const</span> U3 = <span class="tok-kw">extern</span> <span class="tok-kw">union</span> {
        a: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.containerLayout">containerLayout</a>(S1) == .auto);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.containerLayout">containerLayout</a>(S2) == .@&quot;packed&quot;);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.containerLayout">containerLayout</a>(S3) == .@&quot;extern&quot;);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.containerLayout">containerLayout</a>(U1) == .auto);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.containerLayout">containerLayout</a>(U2) == .@&quot;packed&quot;);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.containerLayout">containerLayout</a>(U3) == .@&quot;extern&quot;);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.containerLayout">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerLayout</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.ContainerLayout.html">ContainerLayout</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .@&quot;struct&quot; =&gt; |info| info.layout,
        .@&quot;union&quot; =&gt; |info| info.layout,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected struct or union type, found '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.declarations" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">declarations</span><a href="#src.zig-std.meta.declarations">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">declarations</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) []<span class="tok-kw">const</span> <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Declaration.html">Declaration</a></code></pre></div><div class="tldDocs"><p>Instead of this function, prefer to use e.g. <code>@typeInfo(foo).@&quot;struct&quot;.decls</code>
directly when you know what kind of type it is.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> declarations {
    <span class="tok-kw">const</span> E1 = <span class="tok-kw">enum</span> {
        A,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}
    };
    <span class="tok-kw">const</span> S1 = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}
    };
    <span class="tok-kw">const</span> U1 = <span class="tok-kw">union</span> {
        b: <span class="tok-type">u8</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}
    };
    <span class="tok-kw">const</span> O1 = <span class="tok-kw">opaque</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}
    };

    <span class="tok-kw">const</span> decls = <span class="tok-kw">comptime</span> [_][]<span class="tok-kw">const</span> <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Declaration.html">Declaration</a>{
        <a href="std.meta.html#std.meta.declarations">declarations</a>(E1),
        <a href="std.meta.html#std.meta.declarations">declarations</a>(S1),
        <a href="std.meta.html#std.meta.declarations">declarations</a>(U1),
        <a href="std.meta.html#std.meta.declarations">declarations</a>(O1),
    };

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (decls) |decl| {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(decl.len == <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, decl[<span class="tok-number">0</span>].name, <span class="tok-str">&quot;a&quot;</span>));
    }
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.declarations">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">declarations</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) []<span class="tok-kw">const</span> <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Declaration.html">Declaration</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .@&quot;struct&quot; =&gt; |info| info.decls,
        .@&quot;enum&quot; =&gt; |info| info.decls,
        .@&quot;union&quot; =&gt; |info| info.decls,
        .@&quot;opaque&quot; =&gt; |info| info.decls,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Expected struct, enum, union, or opaque type, found '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.a" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">a</span><a href="#src.zig-std.meta.a">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span></code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.a">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.a" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">a</span><a href="#src.zig-std.meta.a">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span></code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.a">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.a" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">a</span><a href="#src.zig-std.meta.a">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span></code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.a">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.a" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">a</span><a href="#src.zig-std.meta.a">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span></code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.a">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.declarationInfo" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">declarationInfo</span><a href="#src.zig-std.meta.declarationInfo">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">declarationInfo</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> decl_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Declaration.html">Declaration</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>decl_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> declarationInfo {
    <span class="tok-kw">const</span> E1 = <span class="tok-kw">enum</span> {
        A,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}
    };
    <span class="tok-kw">const</span> S1 = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}
    };
    <span class="tok-kw">const</span> U1 = <span class="tok-kw">union</span> {
        b: <span class="tok-type">u8</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}
    };

    <span class="tok-kw">const</span> infos = <span class="tok-kw">comptime</span> [_]<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Declaration.html">Declaration</a>{
        <a href="std.meta.html#std.meta.declarationInfo">declarationInfo</a>(E1, <span class="tok-str">&quot;a&quot;</span>),
        <a href="std.meta.html#std.meta.declarationInfo">declarationInfo</a>(S1, <span class="tok-str">&quot;a&quot;</span>),
        <a href="std.meta.html#std.meta.declarationInfo">declarationInfo</a>(U1, <span class="tok-str">&quot;a&quot;</span>),
    };

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (infos) |info| {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, info.name, <span class="tok-str">&quot;a&quot;</span>));
    }
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.declarationInfo">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">declarationInfo</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> decl_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Declaration.html">Declaration</a> {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-kw">comptime</span> <a href="std.meta.html#std.meta.declarations">declarations</a>(T)) |decl| {
        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, decl.name, decl_name))
            <span class="tok-kw">return</span> decl;
    }

    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;'&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;' has no declaration '&quot;</span> ++ decl_name ++ <span class="tok-str">&quot;'&quot;</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.a" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">a</span><a href="#src.zig-std.meta.a">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span></code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.a">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.a" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">a</span><a href="#src.zig-std.meta.a">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span></code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.a">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.a" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">a</span><a href="#src.zig-std.meta.a">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span></code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.a">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.fields" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fields</span><a href="#src.zig-std.meta.fields">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fields</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) { .@&quot;struct&quot; =&gt; []<span class="tok-kw">const</span> <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.StructField.html">StructField</a>, .@&quot;union&quot; =&gt; []<span class="tok-kw">const</span> <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.UnionField.html">UnionField</a>, .@&quot;enum&quot; =&gt; []<span class="tok-kw">const</span> <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.EnumField.html">EnumField</a>, .error_set =&gt; []<span class="tok-kw">const</span> <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Error.html">Error</a>, <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Expected struct, union, error set or enum type, found '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>), }</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> fields {
    <span class="tok-kw">const</span> E1 = <span class="tok-kw">enum</span> {
        A,
    };
    <span class="tok-kw">const</span> E2 = <span class="tok-kw">error</span>{A};
    <span class="tok-kw">const</span> S1 = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u8</span>,
    };
    <span class="tok-kw">const</span> U1 = <span class="tok-kw">union</span> {
        a: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">const</span> e1f = <span class="tok-kw">comptime</span> <a href="std.meta.html#std.meta.fields">fields</a>(E1);
    <span class="tok-kw">const</span> e2f = <span class="tok-kw">comptime</span> <a href="std.meta.html#std.meta.fields">fields</a>(E2);
    <span class="tok-kw">const</span> sf = <span class="tok-kw">comptime</span> <a href="std.meta.html#std.meta.fields">fields</a>(S1);
    <span class="tok-kw">const</span> uf = <span class="tok-kw">comptime</span> <a href="std.meta.html#std.meta.fields">fields</a>(U1);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(e1f.len == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(e2f.len == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(sf.len == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(uf.len == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, e1f[<span class="tok-number">0</span>].name, <span class="tok-str">&quot;A&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, e2f[<span class="tok-number">0</span>].name, <span class="tok-str">&quot;A&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, sf[<span class="tok-number">0</span>].name, <span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, uf[<span class="tok-number">0</span>].name, <span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> sf[<span class="tok-number">0</span>].<span class="tok-type">type</span> == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> uf[<span class="tok-number">0</span>].<span class="tok-type">type</span> == <span class="tok-type">u8</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.fields">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fields</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
    .@&quot;struct&quot; =&gt; []<span class="tok-kw">const</span> <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.StructField.html">StructField</a>,
    .@&quot;union&quot; =&gt; []<span class="tok-kw">const</span> <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.UnionField.html">UnionField</a>,
    .@&quot;enum&quot; =&gt; []<span class="tok-kw">const</span> <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.EnumField.html">EnumField</a>,
    .error_set =&gt; []<span class="tok-kw">const</span> <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Error.html">Error</a>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Expected struct, union, error set or enum type, found '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
} {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .@&quot;struct&quot; =&gt; |info| info.fields,
        .@&quot;union&quot; =&gt; |info| info.fields,
        .@&quot;enum&quot; =&gt; |info| info.fields,
        .error_set =&gt; |errors| errors.?,<span class="tok-comment"> // must be non global error set
        </span><span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Expected struct, union, error set or enum type, found '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.fieldInfo" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fieldInfo</span><a href="#src.zig-std.meta.fieldInfo">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fieldInfo</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> field: <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(T)) <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) { .@&quot;struct&quot; =&gt; <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.StructField.html">StructField</a>, .@&quot;union&quot; =&gt; <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.UnionField.html">UnionField</a>, .@&quot;enum&quot; =&gt; <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.EnumField.html">EnumField</a>, .error_set =&gt; <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Error.html">Error</a>, <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Expected struct, union, error set or enum type, found '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>), }</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>field: <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(T)</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> fieldInfo {
    <span class="tok-kw">const</span> E1 = <span class="tok-kw">enum</span> {
        A,
    };
    <span class="tok-kw">const</span> E2 = <span class="tok-kw">error</span>{A};
    <span class="tok-kw">const</span> S1 = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u8</span>,
    };
    <span class="tok-kw">const</span> U1 = <span class="tok-kw">union</span> {
        a: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">const</span> e1f = <a href="std.meta.html#std.meta.fieldInfo">fieldInfo</a>(E1, .A);
    <span class="tok-kw">const</span> e2f = <a href="std.meta.html#std.meta.fieldInfo">fieldInfo</a>(E2, .A);
    <span class="tok-kw">const</span> sf = <a href="std.meta.html#std.meta.fieldInfo">fieldInfo</a>(S1, .a);
    <span class="tok-kw">const</span> uf = <a href="std.meta.html#std.meta.fieldInfo">fieldInfo</a>(U1, .a);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, e1f.name, <span class="tok-str">&quot;A&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, e2f.name, <span class="tok-str">&quot;A&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, sf.name, <span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, uf.name, <span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> sf.<span class="tok-type">type</span> == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> uf.<span class="tok-type">type</span> == <span class="tok-type">u8</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.fieldInfo">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fieldInfo</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> field: <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(T)) <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
    .@&quot;struct&quot; =&gt; <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.StructField.html">StructField</a>,
    .@&quot;union&quot; =&gt; <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.UnionField.html">UnionField</a>,
    .@&quot;enum&quot; =&gt; <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.EnumField.html">EnumField</a>,
    .error_set =&gt; <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Error.html">Error</a>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Expected struct, union, error set or enum type, found '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
} {
    <span class="tok-kw">return</span> <a href="std.meta.html#std.meta.fields">fields</a>(T)[<span class="tok-builtin">@intFromEnum</span>(field)];
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.fieldNames" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fieldNames</span><a href="#src.zig-std.meta.fieldNames">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fieldNames</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) *<span class="tok-kw">const</span> [<a href="std.meta.html#std.meta.fields">fields</a>(T).len][:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> fieldNames {
    <span class="tok-kw">const</span> E1 = <span class="tok-kw">enum</span> { A, B };
    <span class="tok-kw">const</span> E2 = <span class="tok-kw">error</span>{A};
    <span class="tok-kw">const</span> S1 = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u8</span>,
    };
    <span class="tok-kw">const</span> U1 = <span class="tok-kw">union</span> {
        a: <span class="tok-type">u8</span>,
        b: <span class="tok-type">void</span>,
    };

    <span class="tok-kw">const</span> e1names = <a href="std.meta.html#std.meta.fieldNames">fieldNames</a>(E1);
    <span class="tok-kw">const</span> e2names = <a href="std.meta.html#std.meta.fieldNames">fieldNames</a>(E2);
    <span class="tok-kw">const</span> s1names = <a href="std.meta.html#std.meta.fieldNames">fieldNames</a>(S1);
    <span class="tok-kw">const</span> u1names = <a href="std.meta.html#std.meta.fieldNames">fieldNames</a>(U1);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(e1names.len == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, e1names[<span class="tok-number">0</span>], <span class="tok-str">&quot;A&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, e1names[<span class="tok-number">1</span>], <span class="tok-str">&quot;B&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(e2names.len == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, e2names[<span class="tok-number">0</span>], <span class="tok-str">&quot;A&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(s1names.len == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, s1names[<span class="tok-number">0</span>], <span class="tok-str">&quot;a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(u1names.len == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, u1names[<span class="tok-number">0</span>], <span class="tok-str">&quot;a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, u1names[<span class="tok-number">1</span>], <span class="tok-str">&quot;b&quot;</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.fieldNames">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fieldNames</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) *<span class="tok-kw">const</span> [<a href="std.meta.html#std.meta.fields">fields</a>(T).len][:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">comptime</span> blk: {
        <span class="tok-kw">const</span> fieldInfos = <a href="std.meta.html#std.meta.fields">fields</a>(T);
        <span class="tok-kw">var</span> names: [fieldInfos.len][:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">for</span> (&amp;names, fieldInfos) |*name, field| name.* = field.name;
        <span class="tok-kw">const</span> final = names;
        <span class="tok-kw">break</span> :blk &amp;final;
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.tags" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">tags</span><a href="#src.zig-std.meta.tags">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tags</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) *<span class="tok-kw">const</span> [<a href="std.meta.html#std.meta.fields">fields</a>(T).len]T</code></pre></div><div class="tldDocs"><p>Given an enum or error set type, returns a pointer to an array containing all tags for that
enum or error set.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> tags {
    <span class="tok-kw">const</span> E1 = <span class="tok-kw">enum</span> { A, B };
    <span class="tok-kw">const</span> E2 = <span class="tok-kw">error</span>{A};

    <span class="tok-kw">const</span> e1_tags = <a href="std.meta.html#std.meta.tags">tags</a>(E1);
    <span class="tok-kw">const</span> e2_tags = <a href="std.meta.html#std.meta.tags">tags</a>(E2);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(e1_tags.len == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E1.A, e1_tags[<span class="tok-number">0</span>]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E1.B, e1_tags[<span class="tok-number">1</span>]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(e2_tags.len == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E2.A, e2_tags[<span class="tok-number">0</span>]);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.tags">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tags</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) *<span class="tok-kw">const</span> [<a href="std.meta.html#std.meta.fields">fields</a>(T).len]T {
    <span class="tok-kw">return</span> <span class="tok-kw">comptime</span> blk: {
        <span class="tok-kw">const</span> fieldInfos = <a href="std.meta.html#std.meta.fields">fields</a>(T);
        <span class="tok-kw">var</span> res: [fieldInfos.len]T = <span class="tok-null">undefined</span>;
        <span class="tok-kw">for</span> (fieldInfos, <span class="tok-number">0</span>..) |field, i| {
            res[i] = <span class="tok-builtin">@field</span>(T, field.name);
        }
        <span class="tok-kw">const</span> final = res;
        <span class="tok-kw">break</span> :blk &amp;final;
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.activeTag" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">activeTag</span><a href="#src.zig-std.meta.activeTag">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">activeTag</span>(u: <span class="tok-kw">anytype</span>) <a href="std.meta.html#std.meta.Tag">Tag</a>(<span class="tok-builtin">@TypeOf</span>(u))</code></pre></div><div class="tldDocs"><p>Returns the active tag of a tagged union</p>
</div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> activeTag {
    <span class="tok-kw">const</span> UE = <span class="tok-kw">enum</span> {
        <a href="std.meta.html#std.meta.Int">Int</a>,
        <a href="std.meta.html#std.meta.Float">Float</a>,
    };

    <span class="tok-kw">const</span> U = <span class="tok-kw">union</span>(UE) {
        Int: <span class="tok-type">u32</span>,
        Float: <span class="tok-type">f32</span>,
    };

    <span class="tok-kw">var</span> u = U{ .Int = <span class="tok-number">32</span> };
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.activeTag">activeTag</a>(u) == UE.Int);

    u = U{ .Float = <span class="tok-number">112.9876</span> };
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.activeTag">activeTag</a>(u) == UE.Float);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.activeTag">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">activeTag</span>(u: <span class="tok-kw">anytype</span>) <a href="std.meta.html#std.meta.Tag">Tag</a>(<span class="tok-builtin">@TypeOf</span>(u)) {
    <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(u);
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.meta.html#std.meta.Tag">Tag</a>(T), u);
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.eql" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">eql</span><a href="#src.zig-std.meta.eql">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(a: <span class="tok-kw">anytype</span>, b: <span class="tok-builtin">@TypeOf</span>(a)) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Compares two of any type for equality. Containers that do not support comparison
on their own are compared on a field-by-field basis. Pointers are not followed.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: <span class="tok-builtin">@TypeOf</span>(a)</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> eql {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u32</span>,
        b: <span class="tok-type">f64</span>,
        c: [<span class="tok-number">5</span>]<span class="tok-type">u8</span>,
    };

    <span class="tok-kw">const</span> U = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        s: S,
        f: ?<span class="tok-type">f32</span>,
    };

    <span class="tok-kw">const</span> s_1 = S{
        .a = <span class="tok-number">134</span>,
        .b = <span class="tok-number">123.3</span>,
        .c = <span class="tok-str">&quot;12345&quot;</span>.*,
    };

    <span class="tok-kw">var</span> s_3 = S{
        .a = <span class="tok-number">134</span>,
        .b = <span class="tok-number">123.3</span>,
        .c = <span class="tok-str">&quot;12345&quot;</span>.*,
    };

    <span class="tok-kw">const</span> u_1 = U{ .f = <span class="tok-number">24</span> };
    <span class="tok-kw">const</span> u_2 = U{ .s = s_1 };
    <span class="tok-kw">const</span> u_3 = U{ .f = <span class="tok-number">24</span> };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.eql">eql</a>(s_1, s_3));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.eql">eql</a>(&amp;s_1, &amp;s_1));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.eql">eql</a>(&amp;s_1, &amp;s_3));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.eql">eql</a>(u_1, u_3));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.eql">eql</a>(u_1, u_2));

    <span class="tok-kw">const</span> a1 = <span class="tok-str">&quot;abcdef&quot;</span>.*;
    <span class="tok-kw">const</span> a2 = <span class="tok-str">&quot;abcdef&quot;</span>.*;
    <span class="tok-kw">const</span> a3 = <span class="tok-str">&quot;ghijkl&quot;</span>.*;

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.eql">eql</a>(a1, a2));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.eql">eql</a>(a1, a3));

    <span class="tok-kw">const</span> EU = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">tst</span>(err: <span class="tok-type">bool</span>) !<span class="tok-type">u8</span> {
            <span class="tok-kw">if</span> (err) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Error;
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">5</span>);
        }
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.eql">eql</a>(EU.tst(<span class="tok-null">true</span>), EU.tst(<span class="tok-null">true</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.eql">eql</a>(EU.tst(<span class="tok-null">false</span>), EU.tst(<span class="tok-null">false</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.eql">eql</a>(EU.tst(<span class="tok-null">false</span>), EU.tst(<span class="tok-null">true</span>)));

    <span class="tok-kw">const</span> V = <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">u32</span>);
    <span class="tok-kw">const</span> v1: V = <span class="tok-builtin">@splat</span>(<span class="tok-number">1</span>);
    <span class="tok-kw">const</span> v2: V = <span class="tok-builtin">@splat</span>(<span class="tok-number">1</span>);
    <span class="tok-kw">const</span> v3: V = <span class="tok-builtin">@splat</span>(<span class="tok-number">2</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.eql">eql</a>(v1, v2));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.eql">eql</a>(v1, v3));

    <span class="tok-kw">const</span> CU = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        a: <span class="tok-type">void</span>,
        b: <span class="tok-type">void</span>,
        c: <span class="tok-type">comptime_int</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.eql">eql</a>(CU{ .a = {} }, .a));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.eql">eql</a>(CU{ .a = {} }, .b));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.eql">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(a: <span class="tok-kw">anytype</span>, b: <span class="tok-builtin">@TypeOf</span>(a)) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(a);

    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .@&quot;struct&quot; =&gt; |info| {
            <span class="tok-kw">if</span> (info.layout == .@&quot;packed&quot;) <span class="tok-kw">return</span> a == b;

            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (info.fields) |field_info| {
                <span class="tok-kw">if</span> (!<a href="std.meta.html#std.meta.eql">eql</a>(<span class="tok-builtin">@field</span>(a, field_info.name), <span class="tok-builtin">@field</span>(b, field_info.name))) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            }
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
        .error_union =&gt; {
            <span class="tok-kw">if</span> (a) |a_p| {
                <span class="tok-kw">if</span> (b) |b_p| <span class="tok-kw">return</span> <a href="std.meta.html#std.meta.eql">eql</a>(a_p, b_p) <span class="tok-kw">else</span> |_| <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            } <span class="tok-kw">else</span> |a_e| {
                <span class="tok-kw">if</span> (b) |_| <span class="tok-kw">return</span> <span class="tok-null">false</span> <span class="tok-kw">else</span> |b_e| <span class="tok-kw">return</span> a_e == b_e;
            }
        },
        .@&quot;union&quot; =&gt; |info| {
            <span class="tok-kw">if</span> (info.tag_type) |UnionTag| {
                <span class="tok-kw">const</span> tag_a: UnionTag = a;
                <span class="tok-kw">const</span> tag_b: UnionTag = b;
                <span class="tok-kw">if</span> (tag_a != tag_b) <span class="tok-kw">return</span> <span class="tok-null">false</span>;

                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (a) {
                    <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |val, tag| <span class="tok-kw">return</span> <a href="std.meta.html#std.meta.eql">eql</a>(val, <span class="tok-builtin">@field</span>(b, <span class="tok-builtin">@tagName</span>(tag))),
                };
            }

            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;cannot compare untagged union type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T));
        },
        .array =&gt; {
            <span class="tok-kw">if</span> (a.len != b.len) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">for</span> (a, <span class="tok-number">0</span>..) |e, i|
                <span class="tok-kw">if</span> (!<a href="std.meta.html#std.meta.eql">eql</a>(e, b[i])) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
        .vector =&gt; |info| {
            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (i &lt; info.len) : (i += <span class="tok-number">1</span>) {
                <span class="tok-kw">if</span> (!<a href="std.meta.html#std.meta.eql">eql</a>(a[i], b[i])) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            }
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
        .pointer =&gt; |info| {
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (info.size) {
                .one, .many, .c =&gt; a == b,
                .slice =&gt; a.ptr == b.ptr <span class="tok-kw">and</span> a.len == b.len,
            };
        },
        .optional =&gt; {
            <span class="tok-kw">if</span> (a == <span class="tok-null">null</span> <span class="tok-kw">and</span> b == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
            <span class="tok-kw">if</span> (a == <span class="tok-null">null</span> <span class="tok-kw">or</span> b == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">return</span> <a href="std.meta.html#std.meta.eql">eql</a>(a.?, b.?);
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> a == b,
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.intToEnum" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">intToEnum</span><a href="#src.zig-std.meta.intToEnum">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intToEnum</span>(<span class="tok-kw">comptime</span> EnumTag: <span class="tok-type">type</span>, tag_int: <span class="tok-kw">anytype</span>) <a href="std.meta.html#std.meta.IntToEnumError">IntToEnumError</a>!EnumTag</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>EnumTag: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> intToEnum {
    <span class="tok-kw">const</span> E1 = <span class="tok-kw">enum</span> {
        A,
    };
    <span class="tok-kw">const</span> E2 = <span class="tok-kw">enum</span> {
        A,
        B,
    };
    <span class="tok-kw">const</span> E3 = <span class="tok-kw">enum</span>(<span class="tok-type">i8</span>) { A, _ };

    <span class="tok-kw">var</span> zero: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> one: <span class="tok-type">u16</span> = <span class="tok-number">1</span>;
    _ = &amp;zero;
    _ = &amp;one;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(E1, zero) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span> == E1.A);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(E2, one) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span> == E2.B);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(E3, zero) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span> == E3.A);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(E3, <span class="tok-number">127</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span> == <span class="tok-builtin">@as</span>(E3, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">127</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(E3, -<span class="tok-number">128</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span> == <span class="tok-builtin">@as</span>(E3, <span class="tok-builtin">@enumFromInt</span>(-<span class="tok-number">128</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.InvalidEnumTag, <a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(E1, one));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.InvalidEnumTag, <a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(E3, <span class="tok-number">128</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.InvalidEnumTag, <a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(E3, -<span class="tok-number">129</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.intToEnum">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intToEnum</span>(<span class="tok-kw">comptime</span> EnumTag: <span class="tok-type">type</span>, tag_int: <span class="tok-kw">anytype</span>) <a href="std.meta.html#std.meta.IntToEnumError">IntToEnumError</a>!EnumTag {
    <span class="tok-kw">const</span> enum_info = <span class="tok-builtin">@typeInfo</span>(EnumTag).@&quot;enum&quot;;

    <span class="tok-kw">if</span> (!enum_info.is_exhaustive) {
        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(enum_info.tag_type, tag_int)) |tag| {
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(EnumTag, <span class="tok-builtin">@enumFromInt</span>(tag));
        }
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEnumTag;
    }<span class="tok-comment">

    // We don't directly iterate over the fields of EnumTag, as that
    // would require an inline loop. Instead, we create an array of
    // values that is comptime-know, but can be iterated at runtime
    // without requiring an inline loop. This generates better
    // machine code.
    </span><span class="tok-kw">const</span> values = <span class="tok-kw">comptime</span> blk: {
        <span class="tok-kw">var</span> result: [enum_info.fields.len]enum_info.tag_type = <span class="tok-null">undefined</span>;
        <span class="tok-kw">for</span> (&amp;result, enum_info.fields) |*dst, src| {
            dst.* = src.value;
        }
        <span class="tok-kw">break</span> :blk result;
    };
    <span class="tok-kw">for</span> (values) |v| {
        <span class="tok-kw">if</span> (v == tag_int) <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(tag_int);
    }
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEnumTag;
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.fieldIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fieldIndex</span><a href="#src.zig-std.meta.fieldIndex">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fieldIndex</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<span class="tok-type">comptime_int</span></code></pre></div><div class="tldDocs"><p>Given a type and a name, return the field index according to source order.
Returns <code>null</code> if the field is not found.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.fieldIndex">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fieldIndex</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<span class="tok-type">comptime_int</span> {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.meta.html#std.meta.fields">fields</a>(T), <span class="tok-number">0</span>..) |field, i| {
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, field.name, name))
            <span class="tok-kw">return</span> i;
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.declList" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">declList</span><a href="#src.zig-std.meta.declList">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">declList</span>(<span class="tok-kw">comptime</span> Namespace: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Decl: <span class="tok-type">type</span>) []<span class="tok-kw">const</span> *<span class="tok-kw">const</span> Decl</code></pre></div><div class="tldDocs"><p>Returns a slice of pointers to public declarations of a namespace.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>Namespace: <span class="tok-type">type</span></code></pre></div><div><pre><code>Decl: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.declList">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">declList</span>(<span class="tok-kw">comptime</span> Namespace: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Decl: <span class="tok-type">type</span>) []<span class="tok-kw">const</span> *<span class="tok-kw">const</span> Decl {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">declNameLessThan</span>(context: <span class="tok-type">void</span>, lhs: *<span class="tok-kw">const</span> Decl, rhs: *<span class="tok-kw">const</span> Decl) <span class="tok-type">bool</span> {
            _ = context;
            <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.lessThan">lessThan</a>(<span class="tok-type">u8</span>, lhs.name, rhs.name);
        }
    };
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">const</span> decls = <a href="std.meta.html#std.meta.declarations">declarations</a>(Namespace);
        <span class="tok-kw">var</span> array: [decls.len]*<span class="tok-kw">const</span> Decl = <span class="tok-null">undefined</span>;
        <span class="tok-kw">for</span> (decls, <span class="tok-number">0</span>..) |decl, i| {
            array[i] = &amp;<span class="tok-builtin">@field</span>(Namespace, decl.name);
        }
        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sort">sort</a>(*<span class="tok-kw">const</span> Decl, &amp;array, {}, S.declNameLessThan);
        <span class="tok-kw">return</span> &amp;array;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.isError" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isError</span><a href="#src.zig-std.meta.isError">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isError</span>(error_union: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns whether <code>error_union</code> contains an error.</p>
</div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> isError {
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.isError">isError</a>(<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divTrunc">divTrunc</a>(<span class="tok-type">u8</span>, <span class="tok-number">5</span>, <span class="tok-number">0</span>)));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.isError">isError</a>(<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divTrunc">divTrunc</a>(<span class="tok-type">u8</span>, <span class="tok-number">5</span>, <span class="tok-number">5</span>)));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.isError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isError</span>(error_union: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (error_union) |_| <span class="tok-null">false</span> <span class="tok-kw">else</span> |_| <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.hasFn" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">hasFn</span><a href="#src.zig-std.meta.hasFn">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasFn</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true if a type has a namespace and the namespace contains <code>name</code>;
<code>false</code> otherwise. Result is always comptime-known.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> hasFn {
    <span class="tok-kw">const</span> S1 = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> {}
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasFn">hasFn</a>(S1, <span class="tok-str">&quot;foo&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasFn">hasFn</a>(S1, <span class="tok-str">&quot;bar&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasFn">hasFn</a>(*S1, <span class="tok-str">&quot;foo&quot;</span>));

    <span class="tok-kw">const</span> S2 = <span class="tok-kw">struct</span> {
        foo: <span class="tok-kw">fn</span> () <span class="tok-type">void</span>,
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasFn">hasFn</a>(S2, <span class="tok-str">&quot;foo&quot;</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.hasFn">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasFn</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .@&quot;struct&quot;, .@&quot;union&quot;, .@&quot;enum&quot;, .@&quot;opaque&quot; =&gt; {},
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
    }
    <span class="tok-kw">if</span> (!<span class="tok-builtin">@hasDecl</span>(T, name))
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;

    <span class="tok-kw">return</span> <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(<span class="tok-builtin">@field</span>(T, name))) == .@&quot;fn&quot;;
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.foo" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">foo</span><a href="#src.zig-std.meta.foo">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span></code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.foo">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> {}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.hasMethod" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">hasMethod</span><a href="#src.zig-std.meta.hasMethod">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasMethod</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true if a type has a <code>name</code> method; <code>false</code> otherwise.
Result is always comptime-known.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> hasMethod {
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(<span class="tok-type">u32</span>, <span class="tok-str">&quot;foo&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>([]<span class="tok-type">u32</span>, <span class="tok-str">&quot;len&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(<span class="tok-kw">struct</span> { <span class="tok-type">u32</span>, <span class="tok-type">u64</span> }, <span class="tok-str">&quot;len&quot;</span>));

    <span class="tok-kw">const</span> S1 = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> {}
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(S1, <span class="tok-str">&quot;foo&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(*S1, <span class="tok-str">&quot;foo&quot;</span>));

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(S1, <span class="tok-str">&quot;bar&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(*[<span class="tok-number">1</span>]S1, <span class="tok-str">&quot;foo&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(*[<span class="tok-number">10</span>]S1, <span class="tok-str">&quot;foo&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>([]S1, <span class="tok-str">&quot;foo&quot;</span>));

    <span class="tok-kw">const</span> S2 = <span class="tok-kw">struct</span> {
        foo: <span class="tok-kw">fn</span> () <span class="tok-type">void</span>,
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(S2, <span class="tok-str">&quot;foo&quot;</span>));

    <span class="tok-kw">const</span> U = <span class="tok-kw">union</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> {}
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(U, <span class="tok-str">&quot;foo&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(*U, <span class="tok-str">&quot;foo&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(U, <span class="tok-str">&quot;bar&quot;</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.hasMethod">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasMethod</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .pointer =&gt; |P| <span class="tok-kw">switch</span> (P.size) {
            .one =&gt; <a href="std.meta.html#std.meta.hasFn">hasFn</a>(P.child, name),
            .many, .slice, .c =&gt; <span class="tok-null">false</span>,
        },
        <span class="tok-kw">else</span> =&gt; <a href="std.meta.html#std.meta.hasFn">hasFn</a>(T, name),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.foo" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">foo</span><a href="#src.zig-std.meta.foo">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span></code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.foo">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> {}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.foo" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">foo</span><a href="#src.zig-std.meta.foo">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span></code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.foo">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> {}</code></pre></details></div></div><div class="decl"><h2 id="std.meta.hasUniqueRepresentation" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">hasUniqueRepresentation</span><a href="#src.zig-std.meta.hasUniqueRepresentation">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasUniqueRepresentation</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>True if every value of the type <code>T</code> has a unique bit pattern representing it.
In other words, <code>T</code> has no unused bits and no padding.
Result is always comptime-known.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> hasUniqueRepresentation {
    <span class="tok-kw">const</span> TestStruct1 = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u32</span>,
        b: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(TestStruct1));

    <span class="tok-kw">const</span> TestStruct2 = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u32</span>,
        b: <span class="tok-type">u16</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(TestStruct2));

    <span class="tok-kw">const</span> TestStruct3 = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u32</span>,
        b: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(TestStruct3));

    <span class="tok-kw">const</span> TestStruct4 = <span class="tok-kw">struct</span> { a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(TestStruct4));

    <span class="tok-kw">const</span> TestStruct5 = <span class="tok-kw">struct</span> { a: TestStruct4 };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(TestStruct5));

    <span class="tok-kw">const</span> TestStruct6 = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u8</span>) {
        @&quot;0&quot;: <span class="tok-type">bool</span>,
        @&quot;1&quot;: <span class="tok-type">bool</span>,
        @&quot;2&quot;: <span class="tok-type">bool</span>,
        @&quot;3&quot;: <span class="tok-type">bool</span>,
        @&quot;4&quot;: <span class="tok-type">bool</span>,
        @&quot;5&quot;: <span class="tok-type">bool</span>,
        @&quot;6&quot;: <span class="tok-type">bool</span>,
        @&quot;7&quot;: <span class="tok-type">bool</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(TestStruct6));

    <span class="tok-kw">const</span> TestUnion1 = <span class="tok-kw">packed</span> <span class="tok-kw">union</span> {
        a: <span class="tok-type">u32</span>,
        b: <span class="tok-type">u16</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(TestUnion1));

    <span class="tok-kw">const</span> TestUnion2 = <span class="tok-kw">extern</span> <span class="tok-kw">union</span> {
        a: <span class="tok-type">u32</span>,
        b: <span class="tok-type">u16</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(TestUnion2));

    <span class="tok-kw">const</span> TestUnion3 = <span class="tok-kw">union</span> {
        a: <span class="tok-type">u32</span>,
        b: <span class="tok-type">u16</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(TestUnion3));

    <span class="tok-kw">const</span> TestUnion4 = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        a: <span class="tok-type">u32</span>,
        b: <span class="tok-type">u16</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(TestUnion4));

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> ([_]<span class="tok-type">type</span>{ <span class="tok-type">i0</span>, <span class="tok-type">u8</span>, <span class="tok-type">i16</span>, <span class="tok-type">u32</span>, <span class="tok-type">i64</span> }) |T| {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(T));
    }
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> ([_]<span class="tok-type">type</span>{ <span class="tok-type">i1</span>, <span class="tok-type">u9</span>, <span class="tok-type">i17</span>, <span class="tok-type">u33</span>, <span class="tok-type">i24</span> }) |T| {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(T));
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(*<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(*<span class="tok-kw">const</span> <span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(?*<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(?*<span class="tok-kw">const</span> <span class="tok-type">u8</span>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>([]<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(?[]<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(<span class="tok-builtin">@Vector</span>(<a href="std.html">std</a>.<a href="std.simd.html">simd</a>.<a href="std.simd.html#std.simd.suggestVectorLength">suggestVectorLength</a>(<span class="tok-type">u8</span>) <span class="tok-kw">orelse</span> <span class="tok-number">1</span>, <span class="tok-type">u8</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">u8</span>)) == <span class="tok-number">3</span> <span class="tok-kw">or</span> !<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">u8</span>)));

    <span class="tok-kw">const</span> StructWithComptimeFields = <span class="tok-kw">struct</span> {
        <span class="tok-kw">comptime</span> should_be_ignored: <span class="tok-type">u64</span> = <span class="tok-number">42</span>,
        <span class="tok-kw">comptime</span> should_also_be_ignored: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;hope you're having a good day :)&quot;</span>,
        field: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(StructWithComptimeFields));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.meta.hasUniqueRepresentation">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasUniqueRepresentation</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,<span class="tok-comment"> // TODO can we know if it's true for some of these types ?

        </span>.@&quot;anyframe&quot;,
        .@&quot;enum&quot;,
        .error_set,
        .@&quot;fn&quot;,
        =&gt; <span class="tok-null">true</span>,

        .<span class="tok-type">bool</span> =&gt; <span class="tok-null">false</span>,

        .int =&gt; |info| <span class="tok-builtin">@sizeOf</span>(T) * <span class="tok-number">8</span> == info.bits,

        .pointer =&gt; |info| info.size != .slice,

        .optional =&gt; |info| <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(info.child)) {
            .pointer =&gt; |ptr| !ptr.is_allowzero <span class="tok-kw">and</span> <span class="tok-kw">switch</span> (ptr.size) {
                .slice, .c =&gt; <span class="tok-null">false</span>,
                .one, .many =&gt; <span class="tok-null">true</span>,
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
        },

        .array =&gt; |info| <a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(info.child),

        .@&quot;struct&quot; =&gt; |info| {
            <span class="tok-kw">if</span> (info.layout == .@&quot;packed&quot;) <span class="tok-kw">return</span> <span class="tok-builtin">@sizeOf</span>(T) * <span class="tok-number">8</span> == <span class="tok-builtin">@bitSizeOf</span>(T);

            <span class="tok-kw">var</span> sum_size = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>);

            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (info.fields) |field| {
                <span class="tok-kw">if</span> (field.is_comptime) <span class="tok-kw">continue</span>;
                <span class="tok-kw">if</span> (!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(field.<span class="tok-type">type</span>)) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                sum_size += <span class="tok-builtin">@sizeOf</span>(field.<span class="tok-type">type</span>);
            }

            <span class="tok-kw">return</span> <span class="tok-builtin">@sizeOf</span>(T) == sum_size;
        },

        .vector =&gt; |info| <a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(info.child) <span class="tok-kw">and</span>
            <span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-builtin">@sizeOf</span>(info.child) * info.len,
    };
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.meta">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);
<span class="tok-kw">const</span> debug = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> math = <a href="std.html">std</a>.<a href="std.math.html">math</a>;
<span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;
<span class="tok-kw">const</span> root = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TrailerFlags = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;meta/trailer_flags.zig&quot;</span>).TrailerFlags;

<span class="tok-kw">const</span> Type = <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>;

<span class="tok-kw">test</span> {
    _ = <a href="std.meta.trailer_flags.html#std.meta.trailer_flags.TrailerFlags">TrailerFlags</a>;
}

<span class="tok-comment">/// Returns the variant of an enum type, `T`, which is named `str`, or `null` if no such variant exists.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringToEnum</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?T {<span class="tok-comment">
    // Using StaticStringMap here is more performant, but it will start to take too
    // long to compile if the enum is large enough, due to the current limits of comptime
    // performance when doing things like constructing lookup maps at comptime.
    // TODO The '100' here is arbitrary and should be increased when possible:
    // - https://github.com/ziglang/zig/issues/4055
    // - https://github.com/ziglang/zig/issues/3863
    </span><span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(T).@&quot;enum&quot;.fields.len &lt;= <span class="tok-number">100</span>) {
        <span class="tok-kw">const</span> kvs = <span class="tok-kw">comptime</span> build_kvs: {
            <span class="tok-kw">const</span> EnumKV = <span class="tok-kw">struct</span> { []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, T };
            <span class="tok-kw">var</span> kvs_array: [<span class="tok-builtin">@typeInfo</span>(T).@&quot;enum&quot;.fields.len]EnumKV = <span class="tok-null">undefined</span>;
            <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(T).@&quot;enum&quot;.fields, <span class="tok-number">0</span>..) |enumField, i| {
                kvs_array[i] = .{ enumField.name, <span class="tok-builtin">@field</span>(T, enumField.name) };
            }
            <span class="tok-kw">break</span> :build_kvs kvs_array[<span class="tok-number">0</span>..];
        };
        <span class="tok-kw">const</span> map = <a href="std.html">std</a>.<a href="std.static_string_map.html#std.static_string_map.StaticStringMap">StaticStringMap</a>(T).initComptime(kvs);
        <span class="tok-kw">return</span> map.get(str);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(T).@&quot;enum&quot;.fields) |enumField| {
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, str, enumField.name)) {
                <span class="tok-kw">return</span> <span class="tok-builtin">@field</span>(T, enumField.name);
            }
        }
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }
}

<span class="tok-kw">test</span> stringToEnum {
    <span class="tok-kw">const</span> E1 = <span class="tok-kw">enum</span> {
        A,
        B,
    };
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(E1.A == <a href="std.meta.html#std.meta.stringToEnum">stringToEnum</a>(E1, <span class="tok-str">&quot;A&quot;</span>).?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(E1.B == <a href="std.meta.html#std.meta.stringToEnum">stringToEnum</a>(E1, <span class="tok-str">&quot;B&quot;</span>).?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-null">null</span> == <a href="std.meta.html#std.meta.stringToEnum">stringToEnum</a>(E1, <span class="tok-str">&quot;C&quot;</span>));
}

<span class="tok-comment">/// Returns the alignment of type T.</span>
<span class="tok-comment">/// Note that if T is a pointer type the result is different than the one</span>
<span class="tok-comment">/// returned by @alignOf(T).</span>
<span class="tok-comment">/// If T is a pointer type the alignment of the type it points to is returned.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignment</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .optional =&gt; |info| <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(info.child)) {
            .pointer, .@&quot;fn&quot; =&gt; <a href="std.meta.html#std.meta.alignment">alignment</a>(info.child),
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@alignOf</span>(T),
        },
        .pointer =&gt; |info| info.alignment,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@alignOf</span>(T),
    };
}

<span class="tok-kw">test</span> alignment {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.alignment">alignment</a>(<span class="tok-type">u8</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.alignment">alignment</a>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-type">u8</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.alignment">alignment</a>(*<span class="tok-kw">align</span>(<span class="tok-number">2</span>) <span class="tok-type">u8</span>) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.alignment">alignment</a>([]<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-type">u8</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.alignment">alignment</a>([]<span class="tok-kw">align</span>(<span class="tok-number">2</span>) <span class="tok-type">u8</span>) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.alignment">alignment</a>(<span class="tok-kw">fn</span> () <span class="tok-type">void</span>) &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.alignment">alignment</a>(*<span class="tok-kw">const</span> <span class="tok-kw">fn</span> () <span class="tok-type">void</span>) &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.alignment">alignment</a>(*<span class="tok-kw">align</span>(<span class="tok-number">128</span>) <span class="tok-kw">const</span> <span class="tok-kw">fn</span> () <span class="tok-type">void</span>) == <span class="tok-number">128</span>);
}

<span class="tok-comment">/// Given a parameterized type (array, vector, pointer, optional), returns the &quot;child type&quot;.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Child</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .array =&gt; |info| info.child,
        .vector =&gt; |info| info.child,
        .pointer =&gt; |info| info.child,
        .optional =&gt; |info| info.child,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Expected pointer, optional, array or vector type, found '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
    };
}

<span class="tok-kw">test</span> Child {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Child">Child</a>([<span class="tok-number">1</span>]<span class="tok-type">u8</span>) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Child">Child</a>(*<span class="tok-type">u8</span>) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Child">Child</a>([]<span class="tok-type">u8</span>) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Child">Child</a>(?<span class="tok-type">u8</span>) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">u8</span>)) == <span class="tok-type">u8</span>);
}

<span class="tok-comment">/// Given a &quot;memory span&quot; type (array, slice, vector, or pointer to such), returns the &quot;element type&quot;.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Elem</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .array =&gt; |info| <span class="tok-kw">return</span> info.child,
        .vector =&gt; |info| <span class="tok-kw">return</span> info.child,
        .pointer =&gt; |info| <span class="tok-kw">switch</span> (info.size) {
            .one =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(info.child)) {
                .array =&gt; |array_info| <span class="tok-kw">return</span> array_info.child,
                .vector =&gt; |vector_info| <span class="tok-kw">return</span> vector_info.child,
                <span class="tok-kw">else</span> =&gt; {},
            },
            .many, .c, .slice =&gt; <span class="tok-kw">return</span> info.child,
        },
        .optional =&gt; |info| <span class="tok-kw">return</span> <a href="std.meta.html#std.meta.Elem">Elem</a>(info.child),
        <span class="tok-kw">else</span> =&gt; {},
    }
    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Expected pointer, slice, array or vector type, found '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>);
}

<span class="tok-kw">test</span> Elem {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Elem">Elem</a>([<span class="tok-number">1</span>]<span class="tok-type">u8</span>) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Elem">Elem</a>([*]<span class="tok-type">u8</span>) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Elem">Elem</a>([]<span class="tok-type">u8</span>) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Elem">Elem</a>(*[<span class="tok-number">10</span>]<span class="tok-type">u8</span>) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Elem">Elem</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">u8</span>)) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Elem">Elem</a>(*<span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">u8</span>)) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Elem">Elem</a>(?[*]<span class="tok-type">u8</span>) == <span class="tok-type">u8</span>);
}

<span class="tok-comment">/// Given a type which can have a sentinel e.g. `[:0]u8`, returns the sentinel value,</span>
<span class="tok-comment">/// or `null` if there is not one.</span>
<span class="tok-comment">/// Types which cannot possibly have a sentinel will be a compile error.</span>
<span class="tok-comment">/// Result is always comptime-known.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sentinel</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) ?<a href="std.meta.html#std.meta.Elem">Elem</a>(T) {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .array =&gt; |info| <span class="tok-kw">return</span> info.sentinel(),
        .pointer =&gt; |info| {
            <span class="tok-kw">switch</span> (info.size) {
                .many, .slice =&gt; <span class="tok-kw">return</span> info.sentinel(),
                .one =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(info.child)) {
                    .array =&gt; |array_info| <span class="tok-kw">return</span> array_info.sentinel(),
                    <span class="tok-kw">else</span> =&gt; {},
                },
                <span class="tok-kw">else</span> =&gt; {},
            }
        },
        <span class="tok-kw">else</span> =&gt; {},
    }
    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;' cannot possibly have a sentinel&quot;</span>);
}

<span class="tok-kw">test</span> sentinel {
    <span class="tok-kw">try</span> <a href="std.meta.html#std.meta.testSentinel">testSentinel</a>();
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> <a href="std.meta.html#std.meta.testSentinel">testSentinel</a>();
}

<span class="tok-kw">fn</span> <span class="tok-fn">testSentinel</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>), <a href="std.meta.html#std.meta.sentinel">sentinel</a>([:<span class="tok-number">0</span>]<span class="tok-type">u8</span>).?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>), <a href="std.meta.html#std.meta.sentinel">sentinel</a>([*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>).?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>), <a href="std.meta.html#std.meta.sentinel">sentinel</a>([<span class="tok-number">5</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span>).?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>), <a href="std.meta.html#std.meta.sentinel">sentinel</a>(*<span class="tok-kw">const</span> [<span class="tok-number">5</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span>).?);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.sentinel">sentinel</a>([]<span class="tok-type">u8</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.sentinel">sentinel</a>([*]<span class="tok-type">u8</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.sentinel">sentinel</a>([<span class="tok-number">5</span>]<span class="tok-type">u8</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.sentinel">sentinel</a>(*<span class="tok-kw">const</span> [<span class="tok-number">5</span>]<span class="tok-type">u8</span>) == <span class="tok-null">null</span>);
}

<span class="tok-comment">/// Given a &quot;memory span&quot; type, returns the same type except with the given sentinel value.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Sentinel</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> sentinel_val: <a href="std.meta.html#std.meta.Elem">Elem</a>(T)) <span class="tok-type">type</span> {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .pointer =&gt; |info| <span class="tok-kw">switch</span> (info.size) {
            .one =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(info.child)) {
                .array =&gt; |array_info| <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{
                    .pointer = .{
                        .size = info.size,
                        .is_const = info.is_const,
                        .is_volatile = info.is_volatile,
                        .alignment = info.alignment,
                        .address_space = info.address_space,
                        .child = <span class="tok-builtin">@Type</span>(.{
                            .array = .{
                                .len = array_info.len,
                                .child = array_info.child,
                                .sentinel_ptr = <span class="tok-builtin">@as</span>(?*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(&amp;sentinel_val)),
                            },
                        }),
                        .is_allowzero = info.is_allowzero,
                        .sentinel_ptr = info.sentinel_ptr,
                    },
                }),
                <span class="tok-kw">else</span> =&gt; {},
            },
            .many, .slice =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{
                .pointer = .{
                    .size = info.size,
                    .is_const = info.is_const,
                    .is_volatile = info.is_volatile,
                    .alignment = info.alignment,
                    .address_space = info.address_space,
                    .child = info.child,
                    .is_allowzero = info.is_allowzero,
                    .sentinel_ptr = <span class="tok-builtin">@as</span>(?*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(&amp;sentinel_val)),
                },
            }),
            <span class="tok-kw">else</span> =&gt; {},
        },
        .optional =&gt; |info| <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(info.child)) {
            .pointer =&gt; |ptr_info| <span class="tok-kw">switch</span> (ptr_info.size) {
                .many =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{
                    .optional = .{
                        .child = <span class="tok-builtin">@Type</span>(.{
                            .pointer = .{
                                .size = ptr_info.size,
                                .is_const = ptr_info.is_const,
                                .is_volatile = ptr_info.is_volatile,
                                .alignment = ptr_info.alignment,
                                .address_space = ptr_info.address_space,
                                .child = ptr_info.child,
                                .is_allowzero = ptr_info.is_allowzero,
                                .sentinel_ptr = <span class="tok-builtin">@as</span>(?*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(&amp;sentinel_val)),
                            },
                        }),
                    },
                }),
                <span class="tok-kw">else</span> =&gt; {},
            },
            <span class="tok-kw">else</span> =&gt; {},
        },
        <span class="tok-kw">else</span> =&gt; {},
    }
    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to derive a sentinel pointer type from &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerLayout</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.ContainerLayout.html">ContainerLayout</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .@&quot;struct&quot; =&gt; |info| info.layout,
        .@&quot;union&quot; =&gt; |info| info.layout,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected struct or union type, found '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
    };
}

<span class="tok-kw">test</span> containerLayout {
    <span class="tok-kw">const</span> S1 = <span class="tok-kw">struct</span> {};
    <span class="tok-kw">const</span> S2 = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {};
    <span class="tok-kw">const</span> S3 = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {};
    <span class="tok-kw">const</span> U1 = <span class="tok-kw">union</span> {
        a: <span class="tok-type">u8</span>,
    };
    <span class="tok-kw">const</span> U2 = <span class="tok-kw">packed</span> <span class="tok-kw">union</span> {
        a: <span class="tok-type">u8</span>,
    };
    <span class="tok-kw">const</span> U3 = <span class="tok-kw">extern</span> <span class="tok-kw">union</span> {
        a: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.containerLayout">containerLayout</a>(S1) == .auto);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.containerLayout">containerLayout</a>(S2) == .@&quot;packed&quot;);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.containerLayout">containerLayout</a>(S3) == .@&quot;extern&quot;);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.containerLayout">containerLayout</a>(U1) == .auto);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.containerLayout">containerLayout</a>(U2) == .@&quot;packed&quot;);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.containerLayout">containerLayout</a>(U3) == .@&quot;extern&quot;);
}

<span class="tok-comment">/// Instead of this function, prefer to use e.g. `@typeInfo(foo).@&quot;struct&quot;.decls`</span>
<span class="tok-comment">/// directly when you know what kind of type it is.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">declarations</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) []<span class="tok-kw">const</span> <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Declaration.html">Declaration</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .@&quot;struct&quot; =&gt; |info| info.decls,
        .@&quot;enum&quot; =&gt; |info| info.decls,
        .@&quot;union&quot; =&gt; |info| info.decls,
        .@&quot;opaque&quot; =&gt; |info| info.decls,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Expected struct, enum, union, or opaque type, found '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
    };
}

<span class="tok-kw">test</span> declarations {
    <span class="tok-kw">const</span> E1 = <span class="tok-kw">enum</span> {
        A,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}
    };
    <span class="tok-kw">const</span> S1 = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}
    };
    <span class="tok-kw">const</span> U1 = <span class="tok-kw">union</span> {
        b: <span class="tok-type">u8</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}
    };
    <span class="tok-kw">const</span> O1 = <span class="tok-kw">opaque</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}
    };

    <span class="tok-kw">const</span> decls = <span class="tok-kw">comptime</span> [_][]<span class="tok-kw">const</span> <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Declaration.html">Declaration</a>{
        <a href="std.meta.html#std.meta.declarations">declarations</a>(E1),
        <a href="std.meta.html#std.meta.declarations">declarations</a>(S1),
        <a href="std.meta.html#std.meta.declarations">declarations</a>(U1),
        <a href="std.meta.html#std.meta.declarations">declarations</a>(O1),
    };

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (decls) |decl| {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(decl.len == <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, decl[<span class="tok-number">0</span>].name, <span class="tok-str">&quot;a&quot;</span>));
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">declarationInfo</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> decl_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Declaration.html">Declaration</a> {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-kw">comptime</span> <a href="std.meta.html#std.meta.declarations">declarations</a>(T)) |decl| {
        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, decl.name, decl_name))
            <span class="tok-kw">return</span> decl;
    }

    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;'&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;' has no declaration '&quot;</span> ++ decl_name ++ <span class="tok-str">&quot;'&quot;</span>);
}

<span class="tok-kw">test</span> declarationInfo {
    <span class="tok-kw">const</span> E1 = <span class="tok-kw">enum</span> {
        A,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}
    };
    <span class="tok-kw">const</span> S1 = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}
    };
    <span class="tok-kw">const</span> U1 = <span class="tok-kw">union</span> {
        b: <span class="tok-type">u8</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">a</span>() <span class="tok-type">void</span> {}
    };

    <span class="tok-kw">const</span> infos = <span class="tok-kw">comptime</span> [_]<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Declaration.html">Declaration</a>{
        <a href="std.meta.html#std.meta.declarationInfo">declarationInfo</a>(E1, <span class="tok-str">&quot;a&quot;</span>),
        <a href="std.meta.html#std.meta.declarationInfo">declarationInfo</a>(S1, <span class="tok-str">&quot;a&quot;</span>),
        <a href="std.meta.html#std.meta.declarationInfo">declarationInfo</a>(U1, <span class="tok-str">&quot;a&quot;</span>),
    };

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (infos) |info| {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, info.name, <span class="tok-str">&quot;a&quot;</span>));
    }
}
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fields</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
    .@&quot;struct&quot; =&gt; []<span class="tok-kw">const</span> <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.StructField.html">StructField</a>,
    .@&quot;union&quot; =&gt; []<span class="tok-kw">const</span> <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.UnionField.html">UnionField</a>,
    .@&quot;enum&quot; =&gt; []<span class="tok-kw">const</span> <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.EnumField.html">EnumField</a>,
    .error_set =&gt; []<span class="tok-kw">const</span> <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Error.html">Error</a>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Expected struct, union, error set or enum type, found '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
} {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .@&quot;struct&quot; =&gt; |info| info.fields,
        .@&quot;union&quot; =&gt; |info| info.fields,
        .@&quot;enum&quot; =&gt; |info| info.fields,
        .error_set =&gt; |errors| errors.?,<span class="tok-comment"> // must be non global error set
        </span><span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Expected struct, union, error set or enum type, found '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
    };
}

<span class="tok-kw">test</span> fields {
    <span class="tok-kw">const</span> E1 = <span class="tok-kw">enum</span> {
        A,
    };
    <span class="tok-kw">const</span> E2 = <span class="tok-kw">error</span>{A};
    <span class="tok-kw">const</span> S1 = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u8</span>,
    };
    <span class="tok-kw">const</span> U1 = <span class="tok-kw">union</span> {
        a: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">const</span> e1f = <span class="tok-kw">comptime</span> <a href="std.meta.html#std.meta.fields">fields</a>(E1);
    <span class="tok-kw">const</span> e2f = <span class="tok-kw">comptime</span> <a href="std.meta.html#std.meta.fields">fields</a>(E2);
    <span class="tok-kw">const</span> sf = <span class="tok-kw">comptime</span> <a href="std.meta.html#std.meta.fields">fields</a>(S1);
    <span class="tok-kw">const</span> uf = <span class="tok-kw">comptime</span> <a href="std.meta.html#std.meta.fields">fields</a>(U1);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(e1f.len == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(e2f.len == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(sf.len == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(uf.len == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, e1f[<span class="tok-number">0</span>].name, <span class="tok-str">&quot;A&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, e2f[<span class="tok-number">0</span>].name, <span class="tok-str">&quot;A&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, sf[<span class="tok-number">0</span>].name, <span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, uf[<span class="tok-number">0</span>].name, <span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> sf[<span class="tok-number">0</span>].<span class="tok-type">type</span> == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> uf[<span class="tok-number">0</span>].<span class="tok-type">type</span> == <span class="tok-type">u8</span>);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fieldInfo</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> field: <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(T)) <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
    .@&quot;struct&quot; =&gt; <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.StructField.html">StructField</a>,
    .@&quot;union&quot; =&gt; <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.UnionField.html">UnionField</a>,
    .@&quot;enum&quot; =&gt; <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.EnumField.html">EnumField</a>,
    .error_set =&gt; <a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Error.html">Error</a>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Expected struct, union, error set or enum type, found '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
} {
    <span class="tok-kw">return</span> <a href="std.meta.html#std.meta.fields">fields</a>(T)[<span class="tok-builtin">@intFromEnum</span>(field)];
}

<span class="tok-kw">test</span> fieldInfo {
    <span class="tok-kw">const</span> E1 = <span class="tok-kw">enum</span> {
        A,
    };
    <span class="tok-kw">const</span> E2 = <span class="tok-kw">error</span>{A};
    <span class="tok-kw">const</span> S1 = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u8</span>,
    };
    <span class="tok-kw">const</span> U1 = <span class="tok-kw">union</span> {
        a: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">const</span> e1f = <a href="std.meta.html#std.meta.fieldInfo">fieldInfo</a>(E1, .A);
    <span class="tok-kw">const</span> e2f = <a href="std.meta.html#std.meta.fieldInfo">fieldInfo</a>(E2, .A);
    <span class="tok-kw">const</span> sf = <a href="std.meta.html#std.meta.fieldInfo">fieldInfo</a>(S1, .a);
    <span class="tok-kw">const</span> uf = <a href="std.meta.html#std.meta.fieldInfo">fieldInfo</a>(U1, .a);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, e1f.name, <span class="tok-str">&quot;A&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, e2f.name, <span class="tok-str">&quot;A&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, sf.name, <span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, uf.name, <span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> sf.<span class="tok-type">type</span> == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> uf.<span class="tok-type">type</span> == <span class="tok-type">u8</span>);
}

<span class="tok-comment">/// Deprecated: use @FieldType</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">FieldType</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> field: <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(T)) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@FieldType</span>(T, <span class="tok-builtin">@tagName</span>(field));
}

<span class="tok-kw">test</span> FieldType {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u8</span>,
        b: <span class="tok-type">u16</span>,
    };

    <span class="tok-kw">const</span> U = <span class="tok-kw">union</span> {
        c: <span class="tok-type">u32</span>,
        d: *<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.FieldType">FieldType</a>(S, .a) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.FieldType">FieldType</a>(S, .b) == <span class="tok-type">u16</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.FieldType">FieldType</a>(U, .c) == <span class="tok-type">u32</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.FieldType">FieldType</a>(U, .d) == *<span class="tok-kw">const</span> <span class="tok-type">u8</span>);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fieldNames</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) *<span class="tok-kw">const</span> [<a href="std.meta.html#std.meta.fields">fields</a>(T).len][:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">comptime</span> blk: {
        <span class="tok-kw">const</span> fieldInfos = <a href="std.meta.html#std.meta.fields">fields</a>(T);
        <span class="tok-kw">var</span> names: [fieldInfos.len][:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">for</span> (&amp;names, fieldInfos) |*name, field| name.* = field.name;
        <span class="tok-kw">const</span> final = names;
        <span class="tok-kw">break</span> :blk &amp;final;
    };
}

<span class="tok-kw">test</span> fieldNames {
    <span class="tok-kw">const</span> E1 = <span class="tok-kw">enum</span> { A, B };
    <span class="tok-kw">const</span> E2 = <span class="tok-kw">error</span>{A};
    <span class="tok-kw">const</span> S1 = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u8</span>,
    };
    <span class="tok-kw">const</span> U1 = <span class="tok-kw">union</span> {
        a: <span class="tok-type">u8</span>,
        b: <span class="tok-type">void</span>,
    };

    <span class="tok-kw">const</span> e1names = <a href="std.meta.html#std.meta.fieldNames">fieldNames</a>(E1);
    <span class="tok-kw">const</span> e2names = <a href="std.meta.html#std.meta.fieldNames">fieldNames</a>(E2);
    <span class="tok-kw">const</span> s1names = <a href="std.meta.html#std.meta.fieldNames">fieldNames</a>(S1);
    <span class="tok-kw">const</span> u1names = <a href="std.meta.html#std.meta.fieldNames">fieldNames</a>(U1);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(e1names.len == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, e1names[<span class="tok-number">0</span>], <span class="tok-str">&quot;A&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, e1names[<span class="tok-number">1</span>], <span class="tok-str">&quot;B&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(e2names.len == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, e2names[<span class="tok-number">0</span>], <span class="tok-str">&quot;A&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(s1names.len == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, s1names[<span class="tok-number">0</span>], <span class="tok-str">&quot;a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(u1names.len == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, u1names[<span class="tok-number">0</span>], <span class="tok-str">&quot;a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, u1names[<span class="tok-number">1</span>], <span class="tok-str">&quot;b&quot;</span>);
}

<span class="tok-comment">/// Given an enum or error set type, returns a pointer to an array containing all tags for that</span>
<span class="tok-comment">/// enum or error set.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tags</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) *<span class="tok-kw">const</span> [<a href="std.meta.html#std.meta.fields">fields</a>(T).len]T {
    <span class="tok-kw">return</span> <span class="tok-kw">comptime</span> blk: {
        <span class="tok-kw">const</span> fieldInfos = <a href="std.meta.html#std.meta.fields">fields</a>(T);
        <span class="tok-kw">var</span> res: [fieldInfos.len]T = <span class="tok-null">undefined</span>;
        <span class="tok-kw">for</span> (fieldInfos, <span class="tok-number">0</span>..) |field, i| {
            res[i] = <span class="tok-builtin">@field</span>(T, field.name);
        }
        <span class="tok-kw">const</span> final = res;
        <span class="tok-kw">break</span> :blk &amp;final;
    };
}

<span class="tok-kw">test</span> tags {
    <span class="tok-kw">const</span> E1 = <span class="tok-kw">enum</span> { A, B };
    <span class="tok-kw">const</span> E2 = <span class="tok-kw">error</span>{A};

    <span class="tok-kw">const</span> e1_tags = <a href="std.meta.html#std.meta.tags">tags</a>(E1);
    <span class="tok-kw">const</span> e2_tags = <a href="std.meta.html#std.meta.tags">tags</a>(E2);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(e1_tags.len == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E1.A, e1_tags[<span class="tok-number">0</span>]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E1.B, e1_tags[<span class="tok-number">1</span>]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(e2_tags.len == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E2.A, e2_tags[<span class="tok-number">0</span>]);
}

<span class="tok-comment">/// Returns an enum with a variant named after each field of `T`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">FieldEnum</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> field_infos = <a href="std.meta.html#std.meta.fields">fields</a>(T);

    <span class="tok-kw">if</span> (field_infos.len == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{
            .@&quot;enum&quot; = .{
                .tag_type = <span class="tok-type">u0</span>,
                .fields = &amp;.{},
                .decls = &amp;.{},
                .is_exhaustive = <span class="tok-null">true</span>,
            },
        });
    }

    <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(T) == .@&quot;union&quot;) {
        <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(T).@&quot;union&quot;.tag_type) |tag_type| {
            <span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.enums.html">enums</a>.<a href="std.enums.html#std.enums.values">values</a>(tag_type), <span class="tok-number">0</span>..) |v, i| {
                <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(v) != i) <span class="tok-kw">break</span>;<span class="tok-comment"> // enum values not consecutive
                </span><span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-builtin">@tagName</span>(v), field_infos[i].name)) <span class="tok-kw">break</span>;<span class="tok-comment"> // fields out of order
            </span>} <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> tag_type;
            }
        }
    }

    <span class="tok-kw">var</span> enumFields: [field_infos.len]<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.EnumField.html">EnumField</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> decls = [_]<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Declaration.html">Declaration</a>{};
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (field_infos, <span class="tok-number">0</span>..) |field, i| {
        enumFields[i] = .{
            .name = field.name ++ <span class="tok-str">&quot;&quot;</span>,
            .value = i,
        };
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{
        .@&quot;enum&quot; = .{
            .tag_type = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.IntFittingRange">IntFittingRange</a>(<span class="tok-number">0</span>, field_infos.len - <span class="tok-number">1</span>),
            .fields = &amp;enumFields,
            .decls = &amp;decls,
            .is_exhaustive = <span class="tok-null">true</span>,
        },
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">expectEqualEnum</span>(expected: <span class="tok-kw">anytype</span>, actual: <span class="tok-builtin">@TypeOf</span>(expected)) !<span class="tok-type">void</span> {<span class="tok-comment">
    // TODO: https://github.com/ziglang/zig/issues/7419
    // testing.expectEqual(@typeInfo(expected).@&quot;enum&quot;, @typeInfo(actual).@&quot;enum&quot;);
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@typeInfo</span>(expected).@&quot;enum&quot;.tag_type,
        <span class="tok-builtin">@typeInfo</span>(actual).@&quot;enum&quot;.tag_type,
    );<span class="tok-comment">
    // For comparing decls and fields, we cannot use the meta eql function here
    // because the language does not guarantee that the slice pointers for field names
    // and decl names will be the same.
    </span><span class="tok-kw">comptime</span> {
        <span class="tok-kw">const</span> expected_fields = <span class="tok-builtin">@typeInfo</span>(expected).@&quot;enum&quot;.fields;
        <span class="tok-kw">const</span> actual_fields = <span class="tok-builtin">@typeInfo</span>(actual).@&quot;enum&quot;.fields;
        <span class="tok-kw">if</span> (expected_fields.len != actual_fields.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FailedTest;
        <span class="tok-kw">for</span> (expected_fields, <span class="tok-number">0</span>..) |expected_field, i| {
            <span class="tok-kw">const</span> actual_field = actual_fields[i];
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(expected_field.value, actual_field.value);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(expected_field.name, actual_field.name);
        }
    }
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">const</span> expected_decls = <span class="tok-builtin">@typeInfo</span>(expected).@&quot;enum&quot;.decls;
        <span class="tok-kw">const</span> actual_decls = <span class="tok-builtin">@typeInfo</span>(actual).@&quot;enum&quot;.decls;
        <span class="tok-kw">if</span> (expected_decls.len != actual_decls.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FailedTest;
        <span class="tok-kw">for</span> (expected_decls, <span class="tok-number">0</span>..) |expected_decl, i| {
            <span class="tok-kw">const</span> actual_decl = actual_decls[i];
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(expected_decl.name, actual_decl.name);
        }
    }
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@typeInfo</span>(expected).@&quot;enum&quot;.is_exhaustive,
        <span class="tok-builtin">@typeInfo</span>(actual).@&quot;enum&quot;.is_exhaustive,
    );
}

<span class="tok-kw">test</span> FieldEnum {
    <span class="tok-kw">try</span> <a href="std.meta.html#std.meta.expectEqualEnum">expectEqualEnum</a>(<span class="tok-kw">enum</span> {}, <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(<span class="tok-kw">struct</span> {}));
    <span class="tok-kw">try</span> <a href="std.meta.html#std.meta.expectEqualEnum">expectEqualEnum</a>(<span class="tok-kw">enum</span> { a }, <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(<span class="tok-kw">struct</span> { a: <span class="tok-type">u8</span> }));
    <span class="tok-kw">try</span> <a href="std.meta.html#std.meta.expectEqualEnum">expectEqualEnum</a>(<span class="tok-kw">enum</span> { a, b, c }, <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(<span class="tok-kw">struct</span> { a: <span class="tok-type">u8</span>, b: <span class="tok-type">void</span>, c: <span class="tok-type">f32</span> }));
    <span class="tok-kw">try</span> <a href="std.meta.html#std.meta.expectEqualEnum">expectEqualEnum</a>(<span class="tok-kw">enum</span> { a, b, c }, <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(<span class="tok-kw">union</span> { a: <span class="tok-type">u8</span>, b: <span class="tok-type">void</span>, c: <span class="tok-type">f32</span> }));

    <span class="tok-kw">const</span> Tagged = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) { a: <span class="tok-type">u8</span>, b: <span class="tok-type">void</span>, c: <span class="tok-type">f32</span> };
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.meta.html#std.meta.Tag">Tag</a>(Tagged), <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(Tagged));

    <span class="tok-kw">const</span> Tag2 = <span class="tok-kw">enum</span> { a, b, c };
    <span class="tok-kw">const</span> Tagged2 = <span class="tok-kw">union</span>(Tag2) { a: <span class="tok-type">u8</span>, b: <span class="tok-type">void</span>, c: <span class="tok-type">f32</span> };
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Tag">Tag</a>(Tagged2) == <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(Tagged2));

    <span class="tok-kw">const</span> Tag3 = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) { a, b, c = <span class="tok-number">7</span> };
    <span class="tok-kw">const</span> Tagged3 = <span class="tok-kw">union</span>(Tag3) { a: <span class="tok-type">u8</span>, b: <span class="tok-type">void</span>, c: <span class="tok-type">f32</span> };
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Tag">Tag</a>(Tagged3) != <a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(Tagged3));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">DeclEnum</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> fieldInfos = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.declarations">declarations</a>(T);
    <span class="tok-kw">var</span> enumDecls: [fieldInfos.len]<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.EnumField.html">EnumField</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> decls = [_]<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Declaration.html">Declaration</a>{};
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fieldInfos, <span class="tok-number">0</span>..) |field, i| {
        enumDecls[i] = .{ .name = field.name ++ <span class="tok-str">&quot;&quot;</span>, .value = i };
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{
        .@&quot;enum&quot; = .{
            .tag_type = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.IntFittingRange">IntFittingRange</a>(<span class="tok-number">0</span>, <span class="tok-kw">if</span> (fieldInfos.len == <span class="tok-number">0</span>) <span class="tok-number">0</span> <span class="tok-kw">else</span> fieldInfos.len - <span class="tok-number">1</span>),
            .fields = &amp;enumDecls,
            .decls = &amp;decls,
            .is_exhaustive = <span class="tok-null">true</span>,
        },
    });
}

<span class="tok-kw">test</span> DeclEnum {
    <span class="tok-kw">const</span> A = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> a: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;
    };
    <span class="tok-kw">const</span> B = <span class="tok-kw">union</span> {
        foo: <span class="tok-type">void</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> a: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> b: <span class="tok-type">void</span> = {};
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> c: <span class="tok-type">f32</span> = <span class="tok-number">0</span>;
    };
    <span class="tok-kw">const</span> C = <span class="tok-kw">enum</span> {
        bar,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> a: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> b: <span class="tok-type">void</span> = {};
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> c: <span class="tok-type">f32</span> = <span class="tok-number">0</span>;
    };
    <span class="tok-kw">const</span> D = <span class="tok-kw">struct</span> {};

    <span class="tok-kw">try</span> <a href="std.meta.html#std.meta.expectEqualEnum">expectEqualEnum</a>(<span class="tok-kw">enum</span> { a }, <a href="std.meta.html#std.meta.DeclEnum">DeclEnum</a>(A));
    <span class="tok-kw">try</span> <a href="std.meta.html#std.meta.expectEqualEnum">expectEqualEnum</a>(<span class="tok-kw">enum</span> { a, b, c }, <a href="std.meta.html#std.meta.DeclEnum">DeclEnum</a>(B));
    <span class="tok-kw">try</span> <a href="std.meta.html#std.meta.expectEqualEnum">expectEqualEnum</a>(<span class="tok-kw">enum</span> { a, b, c }, <a href="std.meta.html#std.meta.DeclEnum">DeclEnum</a>(C));
    <span class="tok-kw">try</span> <a href="std.meta.html#std.meta.expectEqualEnum">expectEqualEnum</a>(<span class="tok-kw">enum</span> {}, <a href="std.meta.html#std.meta.DeclEnum">DeclEnum</a>(D));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Tag</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .@&quot;enum&quot; =&gt; |info| info.tag_type,
        .@&quot;union&quot; =&gt; |info| info.tag_type <span class="tok-kw">orelse</span> <span class="tok-builtin">@compileError</span>(<span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot; has no tag type&quot;</span>),
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected enum or union type, found '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
    };
}

<span class="tok-kw">test</span> Tag {
    <span class="tok-kw">const</span> E = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {
        C = <span class="tok-number">33</span>,
        D,
    };
    <span class="tok-kw">const</span> U = <span class="tok-kw">union</span>(E) {
        C: <span class="tok-type">u8</span>,
        D: <span class="tok-type">u16</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Tag">Tag</a>(E) == <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.Tag">Tag</a>(U) == E);
}

<span class="tok-comment">/// Returns the active tag of a tagged union</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">activeTag</span>(u: <span class="tok-kw">anytype</span>) <a href="std.meta.html#std.meta.Tag">Tag</a>(<span class="tok-builtin">@TypeOf</span>(u)) {
    <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(u);
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.meta.html#std.meta.Tag">Tag</a>(T), u);
}

<span class="tok-kw">test</span> activeTag {
    <span class="tok-kw">const</span> UE = <span class="tok-kw">enum</span> {
        <a href="std.meta.html#std.meta.Int">Int</a>,
        <a href="std.meta.html#std.meta.Float">Float</a>,
    };

    <span class="tok-kw">const</span> U = <span class="tok-kw">union</span>(UE) {
        Int: <span class="tok-type">u32</span>,
        Float: <span class="tok-type">f32</span>,
    };

    <span class="tok-kw">var</span> u = U{ .Int = <span class="tok-number">32</span> };
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.activeTag">activeTag</a>(u) == UE.Int);

    u = U{ .Float = <span class="tok-number">112.9876</span> };
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.activeTag">activeTag</a>(u) == UE.Float);
}

<span class="tok-kw">const</span> TagPayloadType = <a href="std.meta.html#std.meta.TagPayload">TagPayload</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">TagPayloadByName</span>(<span class="tok-kw">comptime</span> U: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> tag_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(U).@&quot;union&quot;;

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (info.fields) |field_info| {
        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, field_info.name, tag_name))
            <span class="tok-kw">return</span> field_info.<span class="tok-type">type</span>;
    }

    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;no field '&quot;</span> ++ tag_name ++ <span class="tok-str">&quot;' in union '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(U) ++ <span class="tok-str">&quot;'&quot;</span>);
}

<span class="tok-comment">/// Given a tagged union type, and an enum, return the type of the union field</span>
<span class="tok-comment">/// corresponding to the enum tag.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">TagPayload</span>(<span class="tok-kw">comptime</span> U: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> tag: <a href="std.meta.html#std.meta.Tag">Tag</a>(U)) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.meta.html#std.meta.TagPayloadByName">TagPayloadByName</a>(U, <span class="tok-builtin">@tagName</span>(tag));
}

<span class="tok-kw">test</span> TagPayload {
    <span class="tok-kw">const</span> Event = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        Moved: <span class="tok-kw">struct</span> {
            from: <span class="tok-type">i32</span>,
            to: <span class="tok-type">i32</span>,
        },
    };
    <span class="tok-kw">const</span> MovedEvent = <a href="std.meta.html#std.meta.TagPayload">TagPayload</a>(Event, Event.Moved);
    <span class="tok-kw">const</span> e: Event = .{ .Moved = <span class="tok-null">undefined</span> };
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(MovedEvent == <span class="tok-builtin">@TypeOf</span>(e.Moved));
}

<span class="tok-comment">/// Compares two of any type for equality. Containers that do not support comparison</span>
<span class="tok-comment">/// on their own are compared on a field-by-field basis. Pointers are not followed.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(a: <span class="tok-kw">anytype</span>, b: <span class="tok-builtin">@TypeOf</span>(a)) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(a);

    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .@&quot;struct&quot; =&gt; |info| {
            <span class="tok-kw">if</span> (info.layout == .@&quot;packed&quot;) <span class="tok-kw">return</span> a == b;

            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (info.fields) |field_info| {
                <span class="tok-kw">if</span> (!<a href="std.meta.html#std.meta.eql">eql</a>(<span class="tok-builtin">@field</span>(a, field_info.name), <span class="tok-builtin">@field</span>(b, field_info.name))) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            }
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
        .error_union =&gt; {
            <span class="tok-kw">if</span> (a) |a_p| {
                <span class="tok-kw">if</span> (b) |b_p| <span class="tok-kw">return</span> <a href="std.meta.html#std.meta.eql">eql</a>(a_p, b_p) <span class="tok-kw">else</span> |_| <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            } <span class="tok-kw">else</span> |a_e| {
                <span class="tok-kw">if</span> (b) |_| <span class="tok-kw">return</span> <span class="tok-null">false</span> <span class="tok-kw">else</span> |b_e| <span class="tok-kw">return</span> a_e == b_e;
            }
        },
        .@&quot;union&quot; =&gt; |info| {
            <span class="tok-kw">if</span> (info.tag_type) |UnionTag| {
                <span class="tok-kw">const</span> tag_a: UnionTag = a;
                <span class="tok-kw">const</span> tag_b: UnionTag = b;
                <span class="tok-kw">if</span> (tag_a != tag_b) <span class="tok-kw">return</span> <span class="tok-null">false</span>;

                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (a) {
                    <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |val, tag| <span class="tok-kw">return</span> <a href="std.meta.html#std.meta.eql">eql</a>(val, <span class="tok-builtin">@field</span>(b, <span class="tok-builtin">@tagName</span>(tag))),
                };
            }

            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;cannot compare untagged union type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T));
        },
        .array =&gt; {
            <span class="tok-kw">if</span> (a.len != b.len) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">for</span> (a, <span class="tok-number">0</span>..) |e, i|
                <span class="tok-kw">if</span> (!<a href="std.meta.html#std.meta.eql">eql</a>(e, b[i])) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
        .vector =&gt; |info| {
            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (i &lt; info.len) : (i += <span class="tok-number">1</span>) {
                <span class="tok-kw">if</span> (!<a href="std.meta.html#std.meta.eql">eql</a>(a[i], b[i])) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            }
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
        .pointer =&gt; |info| {
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (info.size) {
                .one, .many, .c =&gt; a == b,
                .slice =&gt; a.ptr == b.ptr <span class="tok-kw">and</span> a.len == b.len,
            };
        },
        .optional =&gt; {
            <span class="tok-kw">if</span> (a == <span class="tok-null">null</span> <span class="tok-kw">and</span> b == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
            <span class="tok-kw">if</span> (a == <span class="tok-null">null</span> <span class="tok-kw">or</span> b == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">return</span> <a href="std.meta.html#std.meta.eql">eql</a>(a.?, b.?);
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> a == b,
    }
}

<span class="tok-kw">test</span> eql {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u32</span>,
        b: <span class="tok-type">f64</span>,
        c: [<span class="tok-number">5</span>]<span class="tok-type">u8</span>,
    };

    <span class="tok-kw">const</span> U = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        s: S,
        f: ?<span class="tok-type">f32</span>,
    };

    <span class="tok-kw">const</span> s_1 = S{
        .a = <span class="tok-number">134</span>,
        .b = <span class="tok-number">123.3</span>,
        .c = <span class="tok-str">&quot;12345&quot;</span>.*,
    };

    <span class="tok-kw">var</span> s_3 = S{
        .a = <span class="tok-number">134</span>,
        .b = <span class="tok-number">123.3</span>,
        .c = <span class="tok-str">&quot;12345&quot;</span>.*,
    };

    <span class="tok-kw">const</span> u_1 = U{ .f = <span class="tok-number">24</span> };
    <span class="tok-kw">const</span> u_2 = U{ .s = s_1 };
    <span class="tok-kw">const</span> u_3 = U{ .f = <span class="tok-number">24</span> };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.eql">eql</a>(s_1, s_3));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.eql">eql</a>(&amp;s_1, &amp;s_1));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.eql">eql</a>(&amp;s_1, &amp;s_3));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.eql">eql</a>(u_1, u_3));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.eql">eql</a>(u_1, u_2));

    <span class="tok-kw">const</span> a1 = <span class="tok-str">&quot;abcdef&quot;</span>.*;
    <span class="tok-kw">const</span> a2 = <span class="tok-str">&quot;abcdef&quot;</span>.*;
    <span class="tok-kw">const</span> a3 = <span class="tok-str">&quot;ghijkl&quot;</span>.*;

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.eql">eql</a>(a1, a2));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.eql">eql</a>(a1, a3));

    <span class="tok-kw">const</span> EU = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">tst</span>(err: <span class="tok-type">bool</span>) !<span class="tok-type">u8</span> {
            <span class="tok-kw">if</span> (err) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Error;
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">5</span>);
        }
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.eql">eql</a>(EU.tst(<span class="tok-null">true</span>), EU.tst(<span class="tok-null">true</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.eql">eql</a>(EU.tst(<span class="tok-null">false</span>), EU.tst(<span class="tok-null">false</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.eql">eql</a>(EU.tst(<span class="tok-null">false</span>), EU.tst(<span class="tok-null">true</span>)));

    <span class="tok-kw">const</span> V = <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">u32</span>);
    <span class="tok-kw">const</span> v1: V = <span class="tok-builtin">@splat</span>(<span class="tok-number">1</span>);
    <span class="tok-kw">const</span> v2: V = <span class="tok-builtin">@splat</span>(<span class="tok-number">1</span>);
    <span class="tok-kw">const</span> v3: V = <span class="tok-builtin">@splat</span>(<span class="tok-number">2</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.eql">eql</a>(v1, v2));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.eql">eql</a>(v1, v3));

    <span class="tok-kw">const</span> CU = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        a: <span class="tok-type">void</span>,
        b: <span class="tok-type">void</span>,
        c: <span class="tok-type">comptime_int</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.eql">eql</a>(CU{ .a = {} }, .a));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.eql">eql</a>(CU{ .a = {} }, .b));
}

<span class="tok-kw">test</span> intToEnum {
    <span class="tok-kw">const</span> E1 = <span class="tok-kw">enum</span> {
        A,
    };
    <span class="tok-kw">const</span> E2 = <span class="tok-kw">enum</span> {
        A,
        B,
    };
    <span class="tok-kw">const</span> E3 = <span class="tok-kw">enum</span>(<span class="tok-type">i8</span>) { A, _ };

    <span class="tok-kw">var</span> zero: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> one: <span class="tok-type">u16</span> = <span class="tok-number">1</span>;
    _ = &amp;zero;
    _ = &amp;one;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(E1, zero) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span> == E1.A);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(E2, one) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span> == E2.B);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(E3, zero) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span> == E3.A);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(E3, <span class="tok-number">127</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span> == <span class="tok-builtin">@as</span>(E3, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">127</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(E3, -<span class="tok-number">128</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span> == <span class="tok-builtin">@as</span>(E3, <span class="tok-builtin">@enumFromInt</span>(-<span class="tok-number">128</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.InvalidEnumTag, <a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(E1, one));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.InvalidEnumTag, <a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(E3, <span class="tok-number">128</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.InvalidEnumTag, <a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(E3, -<span class="tok-number">129</span>));
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> IntToEnumError = <span class="tok-kw">error</span>{InvalidEnumTag};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intToEnum</span>(<span class="tok-kw">comptime</span> EnumTag: <span class="tok-type">type</span>, tag_int: <span class="tok-kw">anytype</span>) <a href="std.meta.html#std.meta.IntToEnumError">IntToEnumError</a>!EnumTag {
    <span class="tok-kw">const</span> enum_info = <span class="tok-builtin">@typeInfo</span>(EnumTag).@&quot;enum&quot;;

    <span class="tok-kw">if</span> (!enum_info.is_exhaustive) {
        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(enum_info.tag_type, tag_int)) |tag| {
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(EnumTag, <span class="tok-builtin">@enumFromInt</span>(tag));
        }
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEnumTag;
    }<span class="tok-comment">

    // We don't directly iterate over the fields of EnumTag, as that
    // would require an inline loop. Instead, we create an array of
    // values that is comptime-know, but can be iterated at runtime
    // without requiring an inline loop. This generates better
    // machine code.
    </span><span class="tok-kw">const</span> values = <span class="tok-kw">comptime</span> blk: {
        <span class="tok-kw">var</span> result: [enum_info.fields.len]enum_info.tag_type = <span class="tok-null">undefined</span>;
        <span class="tok-kw">for</span> (&amp;result, enum_info.fields) |*dst, src| {
            dst.* = src.value;
        }
        <span class="tok-kw">break</span> :blk result;
    };
    <span class="tok-kw">for</span> (values) |v| {
        <span class="tok-kw">if</span> (v == tag_int) <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(tag_int);
    }
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEnumTag;
}

<span class="tok-comment">/// Given a type and a name, return the field index according to source order.</span>
<span class="tok-comment">/// Returns `null` if the field is not found.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fieldIndex</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<span class="tok-type">comptime_int</span> {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.meta.html#std.meta.fields">fields</a>(T), <span class="tok-number">0</span>..) |field, i| {
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, field.name, name))
            <span class="tok-kw">return</span> i;
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-comment">/// Returns a slice of pointers to public declarations of a namespace.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">declList</span>(<span class="tok-kw">comptime</span> Namespace: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Decl: <span class="tok-type">type</span>) []<span class="tok-kw">const</span> *<span class="tok-kw">const</span> Decl {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">declNameLessThan</span>(context: <span class="tok-type">void</span>, lhs: *<span class="tok-kw">const</span> Decl, rhs: *<span class="tok-kw">const</span> Decl) <span class="tok-type">bool</span> {
            _ = context;
            <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.lessThan">lessThan</a>(<span class="tok-type">u8</span>, lhs.name, rhs.name);
        }
    };
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">const</span> decls = <a href="std.meta.html#std.meta.declarations">declarations</a>(Namespace);
        <span class="tok-kw">var</span> array: [decls.len]*<span class="tok-kw">const</span> Decl = <span class="tok-null">undefined</span>;
        <span class="tok-kw">for</span> (decls, <span class="tok-number">0</span>..) |decl, i| {
            array[i] = &amp;<span class="tok-builtin">@field</span>(Namespace, decl.name);
        }
        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sort">sort</a>(*<span class="tok-kw">const</span> Decl, &amp;array, {}, S.declNameLessThan);
        <span class="tok-kw">return</span> &amp;array;
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Int</span>(<span class="tok-kw">comptime</span> signedness: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Signedness.html">Signedness</a>, <span class="tok-kw">comptime</span> bit_count: <span class="tok-type">u16</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{
        .int = .{
            .signedness = signedness,
            .bits = bit_count,
        },
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Float</span>(<span class="tok-kw">comptime</span> bit_count: <span class="tok-type">u8</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{
        .float = .{ .bits = bit_count },
    });
}

<span class="tok-kw">test</span> Float {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-type">f16</span>, <a href="std.meta.html#std.meta.Float">Float</a>(<span class="tok-number">16</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-type">f32</span>, <a href="std.meta.html#std.meta.Float">Float</a>(<span class="tok-number">32</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-type">f64</span>, <a href="std.meta.html#std.meta.Float">Float</a>(<span class="tok-number">64</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-type">f128</span>, <a href="std.meta.html#std.meta.Float">Float</a>(<span class="tok-number">128</span>));
}

<span class="tok-comment">/// For a given function type, returns a tuple type which fields will</span>
<span class="tok-comment">/// correspond to the argument types.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Examples:</span>
<span class="tok-comment">/// - `ArgsTuple(fn () void)` ⇒ `tuple { }`</span>
<span class="tok-comment">/// - `ArgsTuple(fn (a: u32) u32)` ⇒ `tuple { u32 }`</span>
<span class="tok-comment">/// - `ArgsTuple(fn (a: u32, b: f16) noreturn)` ⇒ `tuple { u32, f16 }`</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ArgsTuple</span>(<span class="tok-kw">comptime</span> Function: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(Function);
    <span class="tok-kw">if</span> (info != .@&quot;fn&quot;)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;ArgsTuple expects a function type&quot;</span>);

    <span class="tok-kw">const</span> function_info = info.@&quot;fn&quot;;
    <span class="tok-kw">if</span> (function_info.is_var_args)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot create ArgsTuple for variadic function&quot;</span>);

    <span class="tok-kw">var</span> argument_field_list: [function_info.params.len]<span class="tok-type">type</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (function_info.params, <span class="tok-number">0</span>..) |arg, i| {
        <span class="tok-kw">const</span> T = arg.<span class="tok-type">type</span> <span class="tok-kw">orelse</span> <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;cannot create ArgsTuple for function with an 'anytype' parameter&quot;</span>);
        argument_field_list[i] = T;
    }

    <span class="tok-kw">return</span> <a href="std.meta.html#std.meta.CreateUniqueTuple">CreateUniqueTuple</a>(argument_field_list.len, argument_field_list);
}

<span class="tok-comment">/// For a given anonymous list of types, returns a new tuple type</span>
<span class="tok-comment">/// with those types as fields.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Examples:</span>
<span class="tok-comment">/// - `Tuple(&amp;[_]type {})` ⇒ `tuple { }`</span>
<span class="tok-comment">/// - `Tuple(&amp;[_]type {f32})` ⇒ `tuple { f32 }`</span>
<span class="tok-comment">/// - `Tuple(&amp;[_]type {f32,u32})` ⇒ `tuple { f32, u32 }`</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Tuple</span>(<span class="tok-kw">comptime</span> types: []<span class="tok-kw">const</span> <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.meta.html#std.meta.CreateUniqueTuple">CreateUniqueTuple</a>(types.len, types[<span class="tok-number">0</span>..types.len].*);
}

<span class="tok-kw">fn</span> <span class="tok-fn">CreateUniqueTuple</span>(<span class="tok-kw">comptime</span> N: <span class="tok-type">comptime_int</span>, <span class="tok-kw">comptime</span> types: [N]<span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">var</span> tuple_fields: [types.len]<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.StructField.html">StructField</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (types, <span class="tok-number">0</span>..) |T, i| {
        <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">10_000</span>);
        <span class="tok-kw">var</span> num_buf: [<span class="tok-number">128</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        tuple_fields[i] = .{
            .name = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.bufPrintZ">bufPrintZ</a>(&amp;num_buf, <span class="tok-str">&quot;{d}&quot;</span>, .{i}) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>,
            .<span class="tok-type">type</span> = T,
            .default_value_ptr = <span class="tok-null">null</span>,
            .is_comptime = <span class="tok-null">false</span>,
            .alignment = <span class="tok-number">0</span>,
        };
    }

    <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{
        .@&quot;struct&quot; = .{
            .is_tuple = <span class="tok-null">true</span>,
            .layout = .auto,
            .decls = &amp;.{},
            .fields = &amp;tuple_fields,
        },
    });
}

<span class="tok-kw">const</span> TupleTester = <span class="tok-kw">struct</span> {
    <span class="tok-kw">fn</span> <span class="tok-fn">assertTypeEqual</span>(<span class="tok-kw">comptime</span> Expected: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Actual: <span class="tok-type">type</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (Expected != Actual)
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Expected type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Expected) ++ <span class="tok-str">&quot;, but got type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Actual));
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">assertTuple</span>(<span class="tok-kw">comptime</span> expected: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> Actual: <span class="tok-type">type</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(Actual);
        <span class="tok-kw">if</span> (info != .@&quot;struct&quot;)
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Expected struct type&quot;</span>);
        <span class="tok-kw">if</span> (!info.@&quot;struct&quot;.is_tuple)
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Struct type must be a tuple type&quot;</span>);

        <span class="tok-kw">const</span> fields_list = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(Actual);
        <span class="tok-kw">if</span> (expected.len != fields_list.len)
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Argument count mismatch&quot;</span>);

        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields_list, <span class="tok-number">0</span>..) |fld, i| {
            <span class="tok-kw">if</span> (expected[i] != fld.<span class="tok-type">type</span>) {
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Field &quot;</span> ++ fld.name ++ <span class="tok-str">&quot; expected to be type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(expected[i]) ++ <span class="tok-str">&quot;, but was type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(fld.<span class="tok-type">type</span>));
            }
        }
    }
};

<span class="tok-kw">test</span> ArgsTuple {
    <a href="std.meta.TupleTester.html">TupleTester</a>.<a href="std.meta.TupleTester.html#std.meta.TupleTester.assertTuple">assertTuple</a>(.{}, <a href="std.meta.html#std.meta.ArgsTuple">ArgsTuple</a>(<span class="tok-kw">fn</span> () <span class="tok-type">void</span>));
    <a href="std.meta.TupleTester.html">TupleTester</a>.<a href="std.meta.TupleTester.html#std.meta.TupleTester.assertTuple">assertTuple</a>(.{<span class="tok-type">u32</span>}, <a href="std.meta.html#std.meta.ArgsTuple">ArgsTuple</a>(<span class="tok-kw">fn</span> (a: <span class="tok-type">u32</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span>));
    <a href="std.meta.TupleTester.html">TupleTester</a>.<a href="std.meta.TupleTester.html#std.meta.TupleTester.assertTuple">assertTuple</a>(.{ <span class="tok-type">u32</span>, <span class="tok-type">f16</span> }, <a href="std.meta.html#std.meta.ArgsTuple">ArgsTuple</a>(<span class="tok-kw">fn</span> (a: <span class="tok-type">u32</span>, b: <span class="tok-type">f16</span>) <span class="tok-type">noreturn</span>));
    <a href="std.meta.TupleTester.html">TupleTester</a>.<a href="std.meta.TupleTester.html#std.meta.TupleTester.assertTuple">assertTuple</a>(.{ <span class="tok-type">u32</span>, <span class="tok-type">f16</span>, []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-type">void</span> }, <a href="std.meta.html#std.meta.ArgsTuple">ArgsTuple</a>(<span class="tok-kw">fn</span> (a: <span class="tok-type">u32</span>, b: <span class="tok-type">f16</span>, c: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-type">void</span>) <span class="tok-type">noreturn</span>));
    <a href="std.meta.TupleTester.html">TupleTester</a>.<a href="std.meta.TupleTester.html#std.meta.TupleTester.assertTuple">assertTuple</a>(.{<span class="tok-type">u32</span>}, <a href="std.meta.html#std.meta.ArgsTuple">ArgsTuple</a>(<span class="tok-kw">fn</span> (<span class="tok-kw">comptime</span> a: <span class="tok-type">u32</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span>));
}

<span class="tok-kw">test</span> Tuple {
    <a href="std.meta.TupleTester.html">TupleTester</a>.<a href="std.meta.TupleTester.html#std.meta.TupleTester.assertTuple">assertTuple</a>(.{}, <a href="std.meta.html#std.meta.Tuple">Tuple</a>(&amp;[_]<span class="tok-type">type</span>{}));
    <a href="std.meta.TupleTester.html">TupleTester</a>.<a href="std.meta.TupleTester.html#std.meta.TupleTester.assertTuple">assertTuple</a>(.{<span class="tok-type">u32</span>}, <a href="std.meta.html#std.meta.Tuple">Tuple</a>(&amp;[_]<span class="tok-type">type</span>{<span class="tok-type">u32</span>}));
    <a href="std.meta.TupleTester.html">TupleTester</a>.<a href="std.meta.TupleTester.html#std.meta.TupleTester.assertTuple">assertTuple</a>(.{ <span class="tok-type">u32</span>, <span class="tok-type">f16</span> }, <a href="std.meta.html#std.meta.Tuple">Tuple</a>(&amp;[_]<span class="tok-type">type</span>{ <span class="tok-type">u32</span>, <span class="tok-type">f16</span> }));
    <a href="std.meta.TupleTester.html">TupleTester</a>.<a href="std.meta.TupleTester.html#std.meta.TupleTester.assertTuple">assertTuple</a>(.{ <span class="tok-type">u32</span>, <span class="tok-type">f16</span>, []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-type">void</span> }, <a href="std.meta.html#std.meta.Tuple">Tuple</a>(&amp;[_]<span class="tok-type">type</span>{ <span class="tok-type">u32</span>, <span class="tok-type">f16</span>, []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-type">void</span> }));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;Tuple deduplication&quot;</span> {
    <span class="tok-kw">const</span> T1 = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Tuple">Tuple</a>(&amp;.{ <span class="tok-type">u32</span>, <span class="tok-type">f32</span>, <span class="tok-type">i8</span> });
    <span class="tok-kw">const</span> T2 = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Tuple">Tuple</a>(&amp;.{ <span class="tok-type">u32</span>, <span class="tok-type">f32</span>, <span class="tok-type">i8</span> });
    <span class="tok-kw">const</span> T3 = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Tuple">Tuple</a>(&amp;.{ <span class="tok-type">u32</span>, <span class="tok-type">f32</span>, <span class="tok-type">i7</span> });

    <span class="tok-kw">if</span> (T1 != T2) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.meta.Tuple doesn't deduplicate tuple types.&quot;</span>);
    }
    <span class="tok-kw">if</span> (T1 == T3) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.meta.Tuple fails to generate different types.&quot;</span>);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;ArgsTuple forwarding&quot;</span> {
    <span class="tok-kw">const</span> T1 = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Tuple">Tuple</a>(&amp;.{ <span class="tok-type">u32</span>, <span class="tok-type">f32</span>, <span class="tok-type">i8</span> });
    <span class="tok-kw">const</span> T2 = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.ArgsTuple">ArgsTuple</a>(<span class="tok-kw">fn</span> (<span class="tok-type">u32</span>, <span class="tok-type">f32</span>, <span class="tok-type">i8</span>) <span class="tok-type">void</span>);
    <span class="tok-kw">const</span> T3 = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.ArgsTuple">ArgsTuple</a>(<span class="tok-kw">fn</span> (<span class="tok-type">u32</span>, <span class="tok-type">f32</span>, <span class="tok-type">i8</span>) <span class="tok-kw">callconv</span>(.c) <span class="tok-type">noreturn</span>);

    <span class="tok-kw">if</span> (T1 != T2) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.meta.ArgsTuple produces different types than std.meta.Tuple&quot;</span>);
    }
    <span class="tok-kw">if</span> (T1 != T3) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.meta.ArgsTuple produces different types for the same argument lists.&quot;</span>);
    }
}

<span class="tok-comment">/// Returns whether `error_union` contains an error.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isError</span>(error_union: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (error_union) |_| <span class="tok-null">false</span> <span class="tok-kw">else</span> |_| <span class="tok-null">true</span>;
}

<span class="tok-kw">test</span> isError {
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.isError">isError</a>(<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divTrunc">divTrunc</a>(<span class="tok-type">u8</span>, <span class="tok-number">5</span>, <span class="tok-number">0</span>)));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.isError">isError</a>(<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divTrunc">divTrunc</a>(<span class="tok-type">u8</span>, <span class="tok-number">5</span>, <span class="tok-number">5</span>)));
}

<span class="tok-comment">/// Returns true if a type has a namespace and the namespace contains `name`;</span>
<span class="tok-comment">/// `false` otherwise. Result is always comptime-known.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasFn</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .@&quot;struct&quot;, .@&quot;union&quot;, .@&quot;enum&quot;, .@&quot;opaque&quot; =&gt; {},
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
    }
    <span class="tok-kw">if</span> (!<span class="tok-builtin">@hasDecl</span>(T, name))
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;

    <span class="tok-kw">return</span> <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(<span class="tok-builtin">@field</span>(T, name))) == .@&quot;fn&quot;;
}

<span class="tok-kw">test</span> hasFn {
    <span class="tok-kw">const</span> S1 = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> {}
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasFn">hasFn</a>(S1, <span class="tok-str">&quot;foo&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasFn">hasFn</a>(S1, <span class="tok-str">&quot;bar&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasFn">hasFn</a>(*S1, <span class="tok-str">&quot;foo&quot;</span>));

    <span class="tok-kw">const</span> S2 = <span class="tok-kw">struct</span> {
        foo: <span class="tok-kw">fn</span> () <span class="tok-type">void</span>,
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasFn">hasFn</a>(S2, <span class="tok-str">&quot;foo&quot;</span>));
}

<span class="tok-comment">/// Returns true if a type has a `name` method; `false` otherwise.</span>
<span class="tok-comment">/// Result is always comptime-known.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasMethod</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .pointer =&gt; |P| <span class="tok-kw">switch</span> (P.size) {
            .one =&gt; <a href="std.meta.html#std.meta.hasFn">hasFn</a>(P.child, name),
            .many, .slice, .c =&gt; <span class="tok-null">false</span>,
        },
        <span class="tok-kw">else</span> =&gt; <a href="std.meta.html#std.meta.hasFn">hasFn</a>(T, name),
    };
}

<span class="tok-kw">test</span> hasMethod {
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(<span class="tok-type">u32</span>, <span class="tok-str">&quot;foo&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>([]<span class="tok-type">u32</span>, <span class="tok-str">&quot;len&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(<span class="tok-kw">struct</span> { <span class="tok-type">u32</span>, <span class="tok-type">u64</span> }, <span class="tok-str">&quot;len&quot;</span>));

    <span class="tok-kw">const</span> S1 = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> {}
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(S1, <span class="tok-str">&quot;foo&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(*S1, <span class="tok-str">&quot;foo&quot;</span>));

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(S1, <span class="tok-str">&quot;bar&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(*[<span class="tok-number">1</span>]S1, <span class="tok-str">&quot;foo&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(*[<span class="tok-number">10</span>]S1, <span class="tok-str">&quot;foo&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>([]S1, <span class="tok-str">&quot;foo&quot;</span>));

    <span class="tok-kw">const</span> S2 = <span class="tok-kw">struct</span> {
        foo: <span class="tok-kw">fn</span> () <span class="tok-type">void</span>,
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(S2, <span class="tok-str">&quot;foo&quot;</span>));

    <span class="tok-kw">const</span> U = <span class="tok-kw">union</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> {}
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(U, <span class="tok-str">&quot;foo&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(*U, <span class="tok-str">&quot;foo&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasMethod">hasMethod</a>(U, <span class="tok-str">&quot;bar&quot;</span>));
}

<span class="tok-comment">/// True if every value of the type `T` has a unique bit pattern representing it.</span>
<span class="tok-comment">/// In other words, `T` has no unused bits and no padding.</span>
<span class="tok-comment">/// Result is always comptime-known.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasUniqueRepresentation</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,<span class="tok-comment"> // TODO can we know if it's true for some of these types ?

        </span>.@&quot;anyframe&quot;,
        .@&quot;enum&quot;,
        .error_set,
        .@&quot;fn&quot;,
        =&gt; <span class="tok-null">true</span>,

        .<span class="tok-type">bool</span> =&gt; <span class="tok-null">false</span>,

        .int =&gt; |info| <span class="tok-builtin">@sizeOf</span>(T) * <span class="tok-number">8</span> == info.bits,

        .pointer =&gt; |info| info.size != .slice,

        .optional =&gt; |info| <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(info.child)) {
            .pointer =&gt; |ptr| !ptr.is_allowzero <span class="tok-kw">and</span> <span class="tok-kw">switch</span> (ptr.size) {
                .slice, .c =&gt; <span class="tok-null">false</span>,
                .one, .many =&gt; <span class="tok-null">true</span>,
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
        },

        .array =&gt; |info| <a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(info.child),

        .@&quot;struct&quot; =&gt; |info| {
            <span class="tok-kw">if</span> (info.layout == .@&quot;packed&quot;) <span class="tok-kw">return</span> <span class="tok-builtin">@sizeOf</span>(T) * <span class="tok-number">8</span> == <span class="tok-builtin">@bitSizeOf</span>(T);

            <span class="tok-kw">var</span> sum_size = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>);

            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (info.fields) |field| {
                <span class="tok-kw">if</span> (field.is_comptime) <span class="tok-kw">continue</span>;
                <span class="tok-kw">if</span> (!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(field.<span class="tok-type">type</span>)) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                sum_size += <span class="tok-builtin">@sizeOf</span>(field.<span class="tok-type">type</span>);
            }

            <span class="tok-kw">return</span> <span class="tok-builtin">@sizeOf</span>(T) == sum_size;
        },

        .vector =&gt; |info| <a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(info.child) <span class="tok-kw">and</span>
            <span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-builtin">@sizeOf</span>(info.child) * info.len,
    };
}

<span class="tok-kw">test</span> hasUniqueRepresentation {
    <span class="tok-kw">const</span> TestStruct1 = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u32</span>,
        b: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(TestStruct1));

    <span class="tok-kw">const</span> TestStruct2 = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u32</span>,
        b: <span class="tok-type">u16</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(TestStruct2));

    <span class="tok-kw">const</span> TestStruct3 = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u32</span>,
        b: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(TestStruct3));

    <span class="tok-kw">const</span> TestStruct4 = <span class="tok-kw">struct</span> { a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(TestStruct4));

    <span class="tok-kw">const</span> TestStruct5 = <span class="tok-kw">struct</span> { a: TestStruct4 };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(TestStruct5));

    <span class="tok-kw">const</span> TestStruct6 = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u8</span>) {
        @&quot;0&quot;: <span class="tok-type">bool</span>,
        @&quot;1&quot;: <span class="tok-type">bool</span>,
        @&quot;2&quot;: <span class="tok-type">bool</span>,
        @&quot;3&quot;: <span class="tok-type">bool</span>,
        @&quot;4&quot;: <span class="tok-type">bool</span>,
        @&quot;5&quot;: <span class="tok-type">bool</span>,
        @&quot;6&quot;: <span class="tok-type">bool</span>,
        @&quot;7&quot;: <span class="tok-type">bool</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(TestStruct6));

    <span class="tok-kw">const</span> TestUnion1 = <span class="tok-kw">packed</span> <span class="tok-kw">union</span> {
        a: <span class="tok-type">u32</span>,
        b: <span class="tok-type">u16</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(TestUnion1));

    <span class="tok-kw">const</span> TestUnion2 = <span class="tok-kw">extern</span> <span class="tok-kw">union</span> {
        a: <span class="tok-type">u32</span>,
        b: <span class="tok-type">u16</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(TestUnion2));

    <span class="tok-kw">const</span> TestUnion3 = <span class="tok-kw">union</span> {
        a: <span class="tok-type">u32</span>,
        b: <span class="tok-type">u16</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(TestUnion3));

    <span class="tok-kw">const</span> TestUnion4 = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        a: <span class="tok-type">u32</span>,
        b: <span class="tok-type">u16</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(TestUnion4));

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> ([_]<span class="tok-type">type</span>{ <span class="tok-type">i0</span>, <span class="tok-type">u8</span>, <span class="tok-type">i16</span>, <span class="tok-type">u32</span>, <span class="tok-type">i64</span> }) |T| {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(T));
    }
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> ([_]<span class="tok-type">type</span>{ <span class="tok-type">i1</span>, <span class="tok-type">u9</span>, <span class="tok-type">i17</span>, <span class="tok-type">u33</span>, <span class="tok-type">i24</span> }) |T| {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(T));
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(*<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(*<span class="tok-kw">const</span> <span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(?*<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(?*<span class="tok-kw">const</span> <span class="tok-type">u8</span>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>([]<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(?[]<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(<span class="tok-builtin">@Vector</span>(<a href="std.html">std</a>.<a href="std.simd.html">simd</a>.<a href="std.simd.html#std.simd.suggestVectorLength">suggestVectorLength</a>(<span class="tok-type">u8</span>) <span class="tok-kw">orelse</span> <span class="tok-number">1</span>, <span class="tok-type">u8</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">u8</span>)) == <span class="tok-number">3</span> <span class="tok-kw">or</span> !<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">u8</span>)));

    <span class="tok-kw">const</span> StructWithComptimeFields = <span class="tok-kw">struct</span> {
        <span class="tok-kw">comptime</span> should_be_ignored: <span class="tok-type">u64</span> = <span class="tok-number">42</span>,
        <span class="tok-kw">comptime</span> should_also_be_ignored: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;hope you're having a good day :)&quot;</span>,
        field: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(StructWithComptimeFields));
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
