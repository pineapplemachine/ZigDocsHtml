<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">fs</a></li><li><a href="std.fs.Dir.html" class="active">Dir</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.fs.Dir" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.fs.Dir</span><a href="#src.zig-std.fs.Dir">[src]</a></h1><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.fs.Dir.Entry.html">std.fs.Dir.Entry</a></li><li><a href="std.fs.Dir.Walker.html">std.fs.Dir.Walker</a></li><li><a href="std.fs.Dir.OpenOptions.html">std.fs.Dir.OpenOptions</a></li><li><a href="std.fs.Dir.OpenOptions.html">std.fs.Dir.OpenOptions</a></li><li><a href="std.fs.Dir.SymLinkFlags.html">std.fs.Dir.SymLinkFlags</a></li><li><a href="std.fs.Dir.WriteFileOptions.html">std.fs.Dir.WriteFileOptions</a></li><li><a href="std.fs.Dir.CopyFileOptions.html">std.fs.Dir.CopyFileOptions</a></li><li><a href="std.fs.Dir.PrevStatus.html">std.fs.Dir.PrevStatus</a></li><li><a href="std.fs.Dir.AtomicFileOptions.html">std.fs.Dir.AtomicFileOptions</a></li><li><a href="std.fs.File.Stat.html">std.fs.File.Stat</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.fs.Dir.Iterator" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Iterator</span><a href="#src.zig-std.fs.Dir.Iterator">[src]</a></h2><div class="sectErrSets"><h3 class="sectionHeader">Error Sets</h3><div class="listErrSets"><div class="decl"><h3 id="std.fs.Dir.IteratorError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">IteratorError</span><a href="#src.zig-std.fs.Dir.IteratorError">[src]</a></h3><div class="sectFnErrors"><h4 class="sectionHeader">Errors</h4><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only. The path of an entry could not be encoded as valid UTF-8.
WASI is unable to handle paths that cannot be encoded as well-formed UTF-8.
<a href="https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353">https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353</a></p>
</dd></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.fs.Dir.IteratorError">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> IteratorError = <span class="tok-kw">error</span>{
    AccessDenied,
    SystemResources,
    <span class="tok-comment">/// WASI-only. The path of an entry could not be encoded as valid UTF-8.</span>
    <span class="tok-comment">/// WASI is unable to handle paths that cannot be encoded as well-formed UTF-8.</span>
    <span class="tok-comment">/// https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353</span>
    InvalidUtf8,
} || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h3 id="std.fs.Dir.IteratorError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">IteratorError</span><a href="#src.zig-std.fs.Dir.IteratorError">[src]</a></h3><div class="sectFnErrors"><h4 class="sectionHeader">Errors</h4><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only. The path of an entry could not be encoded as valid UTF-8.
WASI is unable to handle paths that cannot be encoded as well-formed UTF-8.
<a href="https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353">https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353</a></p>
</dd></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.fs.Dir.IteratorError">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> IteratorError = <span class="tok-kw">error</span>{
    AccessDenied,
    SystemResources,
    <span class="tok-comment">/// WASI-only. The path of an entry could not be encoded as valid UTF-8.</span>
    <span class="tok-comment">/// WASI is unable to handle paths that cannot be encoded as well-formed UTF-8.</span>
    <span class="tok-comment">/// https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353</span>
    InvalidUtf8,
} || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h3 id="std.fs.Dir.IteratorError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">IteratorError</span><a href="#src.zig-std.fs.Dir.IteratorError">[src]</a></h3><div class="sectFnErrors"><h4 class="sectionHeader">Errors</h4><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only. The path of an entry could not be encoded as valid UTF-8.
WASI is unable to handle paths that cannot be encoded as well-formed UTF-8.
<a href="https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353">https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353</a></p>
</dd></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.fs.Dir.IteratorError">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> IteratorError = <span class="tok-kw">error</span>{
    AccessDenied,
    SystemResources,
    <span class="tok-comment">/// WASI-only. The path of an entry could not be encoded as valid UTF-8.</span>
    <span class="tok-comment">/// WASI is unable to handle paths that cannot be encoded as well-formed UTF-8.</span>
    <span class="tok-comment">/// https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353</span>
    InvalidUtf8,
} || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h3 id="std.fs.Dir.Iterator.ErrorLinux" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ErrorLinux</span><a href="#src.zig-std.fs.Dir.Iterator.ErrorLinux">[src]</a></h3><div class="sectFnErrors"><h4 class="sectionHeader">Errors</h4><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a></dt></div><div><dt>DirNotFound</dt></div><div><dt>InvalidUtf8 <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a></dt><dd><p>WASI-only. The path of an entry could not be encoded as valid UTF-8.
WASI is unable to handle paths that cannot be encoded as well-formed UTF-8.
<a href="https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353">https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353</a></p>
</dd></div><div><dt>SystemResources <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.fs.Dir.Iterator.ErrorLinux">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorLinux = <span class="tok-kw">error</span>{DirNotFound} || <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a></code></pre></details></div></div><div class="decl"><h3 id="std.fs.Dir.IteratorError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">IteratorError</span><a href="#src.zig-std.fs.Dir.IteratorError">[src]</a></h3><div class="sectFnErrors"><h4 class="sectionHeader">Errors</h4><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only. The path of an entry could not be encoded as valid UTF-8.
WASI is unable to handle paths that cannot be encoded as well-formed UTF-8.
<a href="https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353">https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353</a></p>
</dd></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.fs.Dir.IteratorError">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> IteratorError = <span class="tok-kw">error</span>{
    AccessDenied,
    SystemResources,
    <span class="tok-comment">/// WASI-only. The path of an entry could not be encoded as valid UTF-8.</span>
    <span class="tok-comment">/// WASI is unable to handle paths that cannot be encoded as well-formed UTF-8.</span>
    <span class="tok-comment">/// https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353</span>
    InvalidUtf8,
} || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h3 id="std.fs.Dir.IteratorError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">IteratorError</span><a href="#src.zig-std.fs.Dir.IteratorError">[src]</a></h3><div class="sectFnErrors"><h4 class="sectionHeader">Errors</h4><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only. The path of an entry could not be encoded as valid UTF-8.
WASI is unable to handle paths that cannot be encoded as well-formed UTF-8.
<a href="https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353">https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353</a></p>
</dd></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.fs.Dir.IteratorError">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> IteratorError = <span class="tok-kw">error</span>{
    AccessDenied,
    SystemResources,
    <span class="tok-comment">/// WASI-only. The path of an entry could not be encoded as valid UTF-8.</span>
    <span class="tok-comment">/// WASI is unable to handle paths that cannot be encoded as well-formed UTF-8.</span>
    <span class="tok-comment">/// https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353</span>
    InvalidUtf8,
} || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h3 id="std.fs.Dir.Iterator.ErrorWasi" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ErrorWasi</span><a href="#src.zig-std.fs.Dir.Iterator.ErrorWasi">[src]</a></h3><div class="sectFnErrors"><h4 class="sectionHeader">Errors</h4><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a></dt></div><div><dt>DirNotFound</dt></div><div><dt>InvalidUtf8 <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a></dt><dd><p>WASI-only. The path of an entry could not be encoded as valid UTF-8.
WASI is unable to handle paths that cannot be encoded as well-formed UTF-8.
<a href="https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353">https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353</a></p>
</dd></div><div><dt>SystemResources <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.fs.Dir.Iterator.ErrorWasi">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorWasi = <span class="tok-kw">error</span>{DirNotFound} || <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a></code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.fs.Dir.Iterator.next" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">next</span><a href="#src.zig-std.fs.Dir.Iterator.next">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">Error</a>!?<a href="std.fs.Dir.Entry.html">Entry</a></code></pre></div><div class="tldDocs"><p>Memory such as file names referenced in this returned entry becomes invalid
with subsequent calls to <code>next</code>, as well as when this <code>Dir</code> is deinitialized.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.fs.Dir.Iterator.next">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">Error</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {
    <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {
        .macos, .ios =&gt; <span class="tok-kw">return</span> self.nextDarwin(),
        .freebsd, .netbsd, .dragonfly, .openbsd =&gt; <span class="tok-kw">return</span> self.nextBsd(),
        .solaris, .illumos =&gt; <span class="tok-kw">return</span> self.nextSolaris(),
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unimplemented&quot;</span>),
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.fs.Dir.Iterator.reset" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reset</span><a href="#src.zig-std.fs.Dir.Iterator.reset">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.fs.Dir.Iterator.reset">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <span class="tok-type">void</span> {
    self.index = <span class="tok-number">0</span>;
    self.end_index = <span class="tok-number">0</span>;
    self.first_iter = <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.fs.Dir.Iterator.next" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">next</span><a href="#src.zig-std.fs.Dir.Iterator.next">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">Error</a>!?<a href="std.fs.Dir.Entry.html">Entry</a></code></pre></div><div class="tldDocs"><p>Memory such as file names referenced in this returned entry becomes invalid
with subsequent calls to <code>next</code>, as well as when this <code>Dir</code> is deinitialized.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.fs.Dir.Iterator.next">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">Error</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {
            <span class="tok-kw">if</span> (self.first_iter) {
                <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>, <span class="tok-builtin">@enumFromInt</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">_kern_rewind_dir</a>(self.dir.fd)))) {
                    .SUCCESS =&gt; {},
                    .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid
                    </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
                    .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
                    .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                    .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                    .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                }
                self.first_iter = <span class="tok-null">false</span>;
            }
            <span class="tok-kw">const</span> rc = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">_kern_read_dir</a>(
                self.dir.fd,
                &amp;self.buf,
                self.buf.len,
                self.buf.len / <span class="tok-builtin">@sizeOf</span>(<a href="std.fs.Dir.html#std.fs.Dir.Iterator.DirEnt">DirEnt</a>),
            );
            <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (rc &lt; <span class="tok-number">0</span>) {
                <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>, <span class="tok-builtin">@enumFromInt</span>(rc))) {
                    .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid
                    </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
                    .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
                    .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                    .OVERFLOW =&gt; <span class="tok-kw">unreachable</span>,
                    .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                    .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                }
            }
            self.offset = <span class="tok-number">0</span>;
            self.index = <span class="tok-number">0</span>;
            self.end_index = <span class="tok-builtin">@intCast</span>(rc);
        }
        <span class="tok-kw">const</span> dirent: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator.DirEnt">DirEnt</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;self.buf[self.offset]));
        self.offset += dirent.reclen;
        self.index += <span class="tok-number">1</span>;
        <span class="tok-kw">const</span> name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(dirent.getName());
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>) <span class="tok-kw">or</span> dirent.ino == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;

        <span class="tok-kw">var</span> stat_info: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.Stat">Stat</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>, <span class="tok-builtin">@enumFromInt</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">_kern_read_stat</a>(
            self.dir.fd,
            name,
            <span class="tok-null">false</span>,
            &amp;stat_info,
            <span class="tok-number">0</span>,
        )))) {
            .SUCCESS =&gt; {},
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid
            </span>.NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .NAMETOOLONG =&gt; <span class="tok-kw">unreachable</span>,
            .LOOP =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">continue</span>,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
        <span class="tok-kw">const</span> statmode = stat_info.mode &amp; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFMT</a>;

        <span class="tok-kw">const</span> entry_kind: <a href="std.fs.Dir.Entry.html">Entry</a>.<a href="std.fs.File.Kind.html">Kind</a> = <span class="tok-kw">switch</span> (statmode) {
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFDIR</a> =&gt; .directory,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFBLK</a> =&gt; .block_device,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFCHR</a> =&gt; .character_device,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFLNK</a> =&gt; .sym_link,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFREG</a> =&gt; .file,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFIFO</a> =&gt; .named_pipe,
            <span class="tok-kw">else</span> =&gt; .unknown,
        };

        <span class="tok-kw">return</span> <a href="std.fs.Dir.Entry.html">Entry</a>{
            .name = name,
            .kind = entry_kind,
        };
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.fs.Dir.Iterator.reset" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reset</span><a href="#src.zig-std.fs.Dir.Iterator.reset">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.fs.Dir.Iterator.reset">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <span class="tok-type">void</span> {
    self.index = <span class="tok-number">0</span>;
    self.end_index = <span class="tok-number">0</span>;
    self.first_iter = <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.fs.Dir.Iterator.next" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">next</span><a href="#src.zig-std.fs.Dir.Iterator.next">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">Error</a>!?<a href="std.fs.Dir.Entry.html">Entry</a></code></pre></div><div class="tldDocs"><p>Memory such as file names referenced in this returned entry becomes invalid
with subsequent calls to <code>next</code>, as well as when this <code>Dir</code> is deinitialized.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.fs.Dir.Iterator.next">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">Error</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {
    <span class="tok-kw">return</span> self.nextLinux() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {<span class="tok-comment">
        // To be consistent across platforms, iteration ends if the directory being iterated is deleted during iteration.
        // This matches the behavior of non-Linux UNIX platforms.
        </span><span class="tok-kw">error</span>.DirNotFound =&gt; <span class="tok-null">null</span>,
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.fs.Dir.Iterator.nextLinux" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">nextLinux</span><a href="#src.zig-std.fs.Dir.Iterator.nextLinux">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextLinux</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.Iterator.ErrorLinux">ErrorLinux</a>!?<a href="std.fs.Dir.Entry.html">Entry</a></code></pre></div><div class="tldDocs"><p>Implementation of <code>next</code> that can return <code>error.DirNotFound</code> if the directory being
iterated was deleted during iteration (this error is Linux specific).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.fs.Dir.Iterator.nextLinux">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextLinux</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.Iterator.ErrorLinux">ErrorLinux</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {
    start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {
            <span class="tok-kw">if</span> (self.first_iter) {
                <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.lseek_SET">lseek_SET</a>(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // EBADF here likely means that the Dir was not opened with iteration permissions
                </span>self.first_iter = <span class="tok-null">false</span>;
            }
            <span class="tok-kw">const</span> rc = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.getdents64">getdents64</a>(self.dir.fd, &amp;self.buf, self.buf.len);
            <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(rc)) {
                .SUCCESS =&gt; {},
                .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid or was opened without iteration ability
                </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
                .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
                .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotFound,<span class="tok-comment"> // The directory being iterated was deleted during iteration.
                </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,<span class="tok-comment"> // Linux may in some cases return EINVAL when reading /proc/$PID/net.
                </span>.ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,<span class="tok-comment"> // Do not have permission to iterate this directory.
                </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
            <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            self.index = <span class="tok-number">0</span>;
            self.end_index = rc;
        }
        <span class="tok-kw">const</span> linux_entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.dirent64.html">dirent64</a>, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));
        <span class="tok-kw">const</span> next_index = self.index + linux_entry.reclen;
        self.index = next_index;

        <span class="tok-kw">const</span> name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;linux_entry.name)), <span class="tok-number">0</span>);<span class="tok-comment">

        // skip . and .. entries
        </span><span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>)) {
            <span class="tok-kw">continue</span> :start_over;
        }

        <span class="tok-kw">const</span> entry_kind: <a href="std.fs.Dir.Entry.html">Entry</a>.<a href="std.fs.File.Kind.html">Kind</a> = <span class="tok-kw">switch</span> (linux_entry.<span class="tok-type">type</span>) {
            <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.BLK">BLK</a> =&gt; .block_device,
            <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.CHR">CHR</a> =&gt; .character_device,
            <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.DIR">DIR</a> =&gt; .directory,
            <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.FIFO">FIFO</a> =&gt; .named_pipe,
            <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.LNK">LNK</a> =&gt; .sym_link,
            <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.REG">REG</a> =&gt; .file,
            <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.SOCK">SOCK</a> =&gt; .unix_domain_socket,
            <span class="tok-kw">else</span> =&gt; .unknown,
        };
        <span class="tok-kw">return</span> <a href="std.fs.Dir.Entry.html">Entry</a>{
            .name = name,
            .kind = entry_kind,
        };
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.fs.Dir.Iterator.reset" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reset</span><a href="#src.zig-std.fs.Dir.Iterator.reset">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.fs.Dir.Iterator.reset">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <span class="tok-type">void</span> {
    self.index = <span class="tok-number">0</span>;
    self.end_index = <span class="tok-number">0</span>;
    self.first_iter = <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.fs.Dir.Iterator.next" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">next</span><a href="#src.zig-std.fs.Dir.Iterator.next">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">Error</a>!?<a href="std.fs.Dir.Entry.html">Entry</a></code></pre></div><div class="tldDocs"><p>Memory such as file names referenced in this returned entry becomes invalid
with subsequent calls to <code>next</code>, as well as when this <code>Dir</code> is deinitialized.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.fs.Dir.Iterator.next">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">Error</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {
    <span class="tok-kw">const</span> w = <a href="std.os.windows.html">windows</a>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {
            <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> rc = w.ntdll.NtQueryDirectoryFile(
                self.dir.fd,
                <span class="tok-null">null</span>,
                <span class="tok-null">null</span>,
                <span class="tok-null">null</span>,
                &amp;io,
                &amp;self.buf,
                self.buf.len,
                .FileBothDirectoryInformation,
                w.FALSE,
                <span class="tok-null">null</span>,
                <span class="tok-kw">if</span> (self.first_iter) <span class="tok-builtin">@as</span>(w.BOOLEAN, w.TRUE) <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(w.BOOLEAN, w.FALSE),
            );
            self.first_iter = <span class="tok-null">false</span>;
            <span class="tok-kw">if</span> (io.Information == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            self.index = <span class="tok-number">0</span>;
            self.end_index = io.Information;
            <span class="tok-kw">switch</span> (rc) {
                .SUCCESS =&gt; {},
                .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,<span class="tok-comment"> // Double-check that the Dir was opened with iteration ability

                </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> w.unexpectedStatus(rc),
            }
        }<span class="tok-comment">

        // While the official api docs guarantee FILE_BOTH_DIR_INFORMATION to be aligned properly
        // this may not always be the case (e.g. due to faulty VM/Sandboxing tools)
        </span><span class="tok-kw">const</span> dir_info: *<span class="tok-kw">align</span>(<span class="tok-number">2</span>) w.FILE_BOTH_DIR_INFORMATION = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;self.buf[self.index]));
        <span class="tok-kw">if</span> (dir_info.NextEntryOffset != <span class="tok-number">0</span>) {
            self.index += dir_info.NextEntryOffset;
        } <span class="tok-kw">else</span> {
            self.index = self.buf.len;
        }

        <span class="tok-kw">const</span> name_wtf16le = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u16</span>, <span class="tok-builtin">@ptrCast</span>(&amp;dir_info.FileName))[<span class="tok-number">0</span> .. dir_info.FileNameLength / <span class="tok-number">2</span>];

        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, name_wtf16le, &amp;[_]<span class="tok-type">u16</span>{<span class="tok-str">'.'</span>}) <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, name_wtf16le, &amp;[_]<span class="tok-type">u16</span>{ <span class="tok-str">'.'</span>, <span class="tok-str">'.'</span> }))
            <span class="tok-kw">continue</span>;
        <span class="tok-kw">const</span> name_wtf8_len = <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf16LeToWtf8">wtf16LeToWtf8</a>(self.name_data[<span class="tok-number">0</span>..], name_wtf16le);
        <span class="tok-kw">const</span> name_wtf8 = self.name_data[<span class="tok-number">0</span>..name_wtf8_len];
        <span class="tok-kw">const</span> kind: <a href="std.fs.Dir.Entry.html">Entry</a>.<a href="std.fs.File.Kind.html">Kind</a> = blk: {
            <span class="tok-kw">const</span> attrs = dir_info.FileAttributes;
            <span class="tok-kw">if</span> (attrs &amp; w.FILE_ATTRIBUTE_DIRECTORY != <span class="tok-number">0</span>) <span class="tok-kw">break</span> :blk .directory;
            <span class="tok-kw">if</span> (attrs &amp; w.FILE_ATTRIBUTE_REPARSE_POINT != <span class="tok-number">0</span>) <span class="tok-kw">break</span> :blk .sym_link;
            <span class="tok-kw">break</span> :blk .file;
        };
        <span class="tok-kw">return</span> <a href="std.fs.Dir.Entry.html">Entry</a>{
            .name = name_wtf8,
            .kind = kind,
        };
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.fs.Dir.Iterator.reset" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reset</span><a href="#src.zig-std.fs.Dir.Iterator.reset">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.fs.Dir.Iterator.reset">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <span class="tok-type">void</span> {
    self.index = <span class="tok-number">0</span>;
    self.end_index = <span class="tok-number">0</span>;
    self.first_iter = <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.fs.Dir.Iterator.next" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">next</span><a href="#src.zig-std.fs.Dir.Iterator.next">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">Error</a>!?<a href="std.fs.Dir.Entry.html">Entry</a></code></pre></div><div class="tldDocs"><p>Memory such as file names referenced in this returned entry becomes invalid
with subsequent calls to <code>next</code>, as well as when this <code>Dir</code> is deinitialized.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.fs.Dir.Iterator.next">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">Error</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {
    <span class="tok-kw">return</span> self.nextWasi() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {<span class="tok-comment">
        // To be consistent across platforms, iteration ends if the directory being iterated is deleted during iteration.
        // This matches the behavior of non-Linux UNIX platforms.
        </span><span class="tok-kw">error</span>.DirNotFound =&gt; <span class="tok-null">null</span>,
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.fs.Dir.Iterator.nextWasi" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">nextWasi</span><a href="#src.zig-std.fs.Dir.Iterator.nextWasi">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextWasi</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.Iterator.ErrorWasi">ErrorWasi</a>!?<a href="std.fs.Dir.Entry.html">Entry</a></code></pre></div><div class="tldDocs"><p>Implementation of <code>next</code> that can return platform-dependent errors depending on the host platform.
When the host platform is Linux, <code>error.DirNotFound</code> can be returned if the directory being
iterated was deleted during iteration.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.fs.Dir.Iterator.nextWasi">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextWasi</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.Iterator.ErrorWasi">ErrorWasi</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {<span class="tok-comment">
    // We intentinally use fd_readdir even when linked with libc,
    // since its implementation is exactly the same as below,
    // and we avoid the code complexity here.
    </span><span class="tok-kw">const</span> w = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>;
    start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment">
        // According to the WASI spec, the last entry might be truncated,
        // so we need to check if the left buffer contains the whole dirent.
        </span><span class="tok-kw">if</span> (self.end_index - self.index &lt; <span class="tok-builtin">@sizeOf</span>(w.dirent_t)) {
            <span class="tok-kw">var</span> bufused: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">switch</span> (w.fd_readdir(self.dir.fd, &amp;self.buf, self.buf.len, self.cookie, &amp;bufused)) {
                .SUCCESS =&gt; {},
                .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid or was opened without iteration ability
                </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
                .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
                .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotFound,<span class="tok-comment"> // The directory being iterated was deleted during iteration.
                </span>.NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                .ILSEQ =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8,<span class="tok-comment"> // An entry's name cannot be encoded as UTF-8.
                </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
            <span class="tok-kw">if</span> (bufused == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            self.index = <span class="tok-number">0</span>;
            self.end_index = bufused;
        }
        <span class="tok-kw">const</span> entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) w.dirent_t, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));
        <span class="tok-kw">const</span> entry_size = <span class="tok-builtin">@sizeOf</span>(w.dirent_t);
        <span class="tok-kw">const</span> name_index = self.index + entry_size;
        <span class="tok-kw">if</span> (name_index + entry.namlen &gt; self.end_index) {<span class="tok-comment">
            // This case, the name is truncated, so we need to call readdir to store the entire name.
            </span>self.end_index = self.index;<span class="tok-comment"> // Force fd_readdir in the next loop.
            </span><span class="tok-kw">continue</span> :start_over;
        }
        <span class="tok-kw">const</span> name = self.buf[name_index .. name_index + entry.namlen];

        <span class="tok-kw">const</span> next_index = name_index + entry.namlen;
        self.index = next_index;
        self.cookie = entry.next;<span class="tok-comment">

        // skip . and .. entries
        </span><span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>)) {
            <span class="tok-kw">continue</span> :start_over;
        }

        <span class="tok-kw">const</span> entry_kind: <a href="std.fs.Dir.Entry.html">Entry</a>.<a href="std.fs.File.Kind.html">Kind</a> = <span class="tok-kw">switch</span> (entry.<span class="tok-type">type</span>) {
            .BLOCK_DEVICE =&gt; .block_device,
            .CHARACTER_DEVICE =&gt; .character_device,
            .DIRECTORY =&gt; .directory,
            .SYMBOLIC_LINK =&gt; .sym_link,
            .REGULAR_FILE =&gt; .file,
            .SOCKET_STREAM, .SOCKET_DGRAM =&gt; .unix_domain_socket,
            <span class="tok-kw">else</span> =&gt; .unknown,
        };
        <span class="tok-kw">return</span> <a href="std.fs.Dir.Entry.html">Entry</a>{
            .name = name,
            .kind = entry_kind,
        };
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.fs.Dir.Iterator.reset" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reset</span><a href="#src.zig-std.fs.Dir.Iterator.reset">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.fs.Dir.Iterator.reset">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <span class="tok-type">void</span> {
    self.index = <span class="tok-number">0</span>;
    self.end_index = <span class="tok-number">0</span>;
    self.cookie = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.DIRCOOKIE_START">DIRCOOKIE_START</a>;
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.Iterator">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {
    .macos, .ios, .freebsd, .netbsd, .dragonfly, .openbsd, .solaris, .illumos =&gt; <span class="tok-kw">struct</span> {
        dir: <a href="std.fs.Dir.html">Dir</a>,
        seek: <span class="tok-type">i64</span>,
        buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span>,<span class="tok-comment"> // TODO align(@alignOf(posix.system.dirent)),
        </span>index: <span class="tok-type">usize</span>,
        end_index: <span class="tok-type">usize</span>,
        first_iter: <span class="tok-type">bool</span>,

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a>;

        <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span>
        <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">Error</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {
            <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {
                .macos, .ios =&gt; <span class="tok-kw">return</span> self.nextDarwin(),
                .freebsd, .netbsd, .dragonfly, .openbsd =&gt; <span class="tok-kw">return</span> self.nextBsd(),
                .solaris, .illumos =&gt; <span class="tok-kw">return</span> self.nextSolaris(),
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unimplemented&quot;</span>),
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">nextDarwin</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) !?<a href="std.fs.Dir.Entry.html">Entry</a> {
            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {
                    <span class="tok-kw">if</span> (self.first_iter) {
                        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.lseek_SET">lseek_SET</a>(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // EBADF here likely means that the Dir was not opened with iteration permissions
                        </span>self.first_iter = <span class="tok-null">false</span>;
                    }
                    <span class="tok-kw">const</span> rc = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">getdirentries</a>(
                        self.dir.fd,
                        &amp;self.buf,
                        self.buf.len,
                        &amp;self.seek,
                    );
                    <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    <span class="tok-kw">if</span> (rc &lt; <span class="tok-number">0</span>) {
                        <span class="tok-kw">switch</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid or was opened without iteration ability
                            </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
                            .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
                            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                        }
                    }
                    self.index = <span class="tok-number">0</span>;
                    self.end_index = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(rc));
                }
                <span class="tok-kw">const</span> darwin_entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">dirent</a>, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));
                <span class="tok-kw">const</span> next_index = self.index + darwin_entry.reclen;
                self.index = next_index;

                <span class="tok-kw">const</span> name = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;darwin_entry.name))[<span class="tok-number">0</span>..darwin_entry.namlen];

                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>) <span class="tok-kw">or</span> (darwin_entry.ino == <span class="tok-number">0</span>)) {
                    <span class="tok-kw">continue</span> :start_over;
                }

                <span class="tok-kw">const</span> entry_kind: <a href="std.fs.Dir.Entry.html">Entry</a>.<a href="std.fs.File.Kind.html">Kind</a> = <span class="tok-kw">switch</span> (darwin_entry.<span class="tok-type">type</span>) {
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">BLK</a> =&gt; .block_device,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">CHR</a> =&gt; .character_device,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">DIR</a> =&gt; .directory,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">FIFO</a> =&gt; .named_pipe,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">LNK</a> =&gt; .sym_link,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">REG</a> =&gt; .file,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">SOCK</a> =&gt; .unix_domain_socket,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">WHT</a> =&gt; .whiteout,
                    <span class="tok-kw">else</span> =&gt; .unknown,
                };
                <span class="tok-kw">return</span> <a href="std.fs.Dir.Entry.html">Entry</a>{
                    .name = name,
                    .kind = entry_kind,
                };
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">nextSolaris</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) !?<a href="std.fs.Dir.Entry.html">Entry</a> {
            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {
                    <span class="tok-kw">if</span> (self.first_iter) {
                        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.lseek_SET">lseek_SET</a>(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // EBADF here likely means that the Dir was not opened with iteration permissions
                        </span>self.first_iter = <span class="tok-null">false</span>;
                    }
                    <span class="tok-kw">const</span> rc = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">getdents</a>(self.dir.fd, &amp;self.buf, self.buf.len);
                    <span class="tok-kw">switch</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                        .SUCCESS =&gt; {},
                        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid or was opened without iteration ability
                        </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
                        .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
                        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                    }
                    <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    self.index = <span class="tok-number">0</span>;
                    self.end_index = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(rc));
                }
                <span class="tok-kw">const</span> entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">dirent</a>, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));
                <span class="tok-kw">const</span> next_index = self.index + entry.reclen;
                self.index = next_index;

                <span class="tok-kw">const</span> name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;entry.name)), <span class="tok-number">0</span>);
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>))
                    <span class="tok-kw">continue</span> :start_over;<span class="tok-comment">

                // Solaris dirent doesn't expose type, so we have to call stat to get it.
                </span><span class="tok-kw">const</span> stat_info = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fstatat">fstatat</a>(
                    self.dir.fd,
                    name,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">SYMLINK_NOFOLLOW</a>,
                ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,
                    <span class="tok-kw">error</span>.SymLinkLoop =&gt; <span class="tok-kw">unreachable</span>,
                    <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // lost the race
                    </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
                };
                <span class="tok-kw">const</span> entry_kind: <a href="std.fs.Dir.Entry.html">Entry</a>.<a href="std.fs.File.Kind.html">Kind</a> = <span class="tok-kw">switch</span> (stat_info.mode &amp; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFMT</a>) {
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFIFO</a> =&gt; .named_pipe,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFCHR</a> =&gt; .character_device,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFDIR</a> =&gt; .directory,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFBLK</a> =&gt; .block_device,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFREG</a> =&gt; .file,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFLNK</a> =&gt; .sym_link,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFSOCK</a> =&gt; .unix_domain_socket,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFDOOR</a> =&gt; .door,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFPORT</a> =&gt; .event_port,
                    <span class="tok-kw">else</span> =&gt; .unknown,
                };
                <span class="tok-kw">return</span> <a href="std.fs.Dir.Entry.html">Entry</a>{
                    .name = name,
                    .kind = entry_kind,
                };
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">nextBsd</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) !?<a href="std.fs.Dir.Entry.html">Entry</a> {
            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {
                    <span class="tok-kw">if</span> (self.first_iter) {
                        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.lseek_SET">lseek_SET</a>(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // EBADF here likely means that the Dir was not opened with iteration permissions
                        </span>self.first_iter = <span class="tok-null">false</span>;
                    }
                    <span class="tok-kw">const</span> rc = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">getdents</a>(self.dir.fd, &amp;self.buf, self.buf.len);
                    <span class="tok-kw">switch</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                        .SUCCESS =&gt; {},
                        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid or was opened without iteration ability
                        </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
                        .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
                        .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment">
                        // Introduced in freebsd 13.2: directory unlinked but still open.
                        // To be consistent, iteration ends if the directory being iterated is deleted during iteration.
                        </span>.NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
                        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                    }
                    <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    self.index = <span class="tok-number">0</span>;
                    self.end_index = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(rc));
                }
                <span class="tok-kw">const</span> bsd_entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">dirent</a>, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));
                <span class="tok-kw">const</span> next_index = self.index +
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">dirent</a>, <span class="tok-str">&quot;reclen&quot;</span>)) bsd_entry.reclen <span class="tok-kw">else</span> bsd_entry.reclen();
                self.index = next_index;

                <span class="tok-kw">const</span> name = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;bsd_entry.name))[<span class="tok-number">0</span>..bsd_entry.namlen];

                <span class="tok-kw">const</span> skip_zero_fileno = <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {<span class="tok-comment">
                    // fileno=0 is used to mark invalid entries or deleted files.
                    </span>.openbsd, .netbsd =&gt; <span class="tok-null">true</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
                };
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>) <span class="tok-kw">or</span>
                    (skip_zero_fileno <span class="tok-kw">and</span> bsd_entry.fileno == <span class="tok-number">0</span>))
                {
                    <span class="tok-kw">continue</span> :start_over;
                }

                <span class="tok-kw">const</span> entry_kind: <a href="std.fs.Dir.Entry.html">Entry</a>.<a href="std.fs.File.Kind.html">Kind</a> = <span class="tok-kw">switch</span> (bsd_entry.<span class="tok-type">type</span>) {
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">BLK</a> =&gt; .block_device,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">CHR</a> =&gt; .character_device,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">DIR</a> =&gt; .directory,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">FIFO</a> =&gt; .named_pipe,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">LNK</a> =&gt; .sym_link,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">REG</a> =&gt; .file,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">SOCK</a> =&gt; .unix_domain_socket,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">WHT</a> =&gt; .whiteout,
                    <span class="tok-kw">else</span> =&gt; .unknown,
                };
                <span class="tok-kw">return</span> <a href="std.fs.Dir.Entry.html">Entry</a>{
                    .name = name,
                    .kind = entry_kind,
                };
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <span class="tok-type">void</span> {
            self.index = <span class="tok-number">0</span>;
            self.end_index = <span class="tok-number">0</span>;
            self.first_iter = <span class="tok-null">true</span>;
        }
    },
    .haiku =&gt; <span class="tok-kw">struct</span> {
        dir: <a href="std.fs.Dir.html">Dir</a>,
        buf: [<span class="tok-builtin">@sizeOf</span>(<a href="std.fs.Dir.html#std.fs.Dir.Iterator.DirEnt">DirEnt</a>) + <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PATH_MAX">PATH_MAX</a>]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.fs.Dir.html#std.fs.Dir.Iterator.DirEnt">DirEnt</a>)),
        offset: <span class="tok-type">usize</span>,
        index: <span class="tok-type">usize</span>,
        end_index: <span class="tok-type">usize</span>,
        first_iter: <span class="tok-type">bool</span>,

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();
        <span class="tok-kw">const</span> DirEnt = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">DirEnt</a>;

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a>;

        <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span>
        <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">Error</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {
                    <span class="tok-kw">if</span> (self.first_iter) {
                        <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>, <span class="tok-builtin">@enumFromInt</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">_kern_rewind_dir</a>(self.dir.fd)))) {
                            .SUCCESS =&gt; {},
                            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid
                            </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
                            .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
                            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                        }
                        self.first_iter = <span class="tok-null">false</span>;
                    }
                    <span class="tok-kw">const</span> rc = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">_kern_read_dir</a>(
                        self.dir.fd,
                        &amp;self.buf,
                        self.buf.len,
                        self.buf.len / <span class="tok-builtin">@sizeOf</span>(<a href="std.fs.Dir.html#std.fs.Dir.Iterator.DirEnt">DirEnt</a>),
                    );
                    <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    <span class="tok-kw">if</span> (rc &lt; <span class="tok-number">0</span>) {
                        <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>, <span class="tok-builtin">@enumFromInt</span>(rc))) {
                            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid
                            </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
                            .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
                            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                            .OVERFLOW =&gt; <span class="tok-kw">unreachable</span>,
                            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                        }
                    }
                    self.offset = <span class="tok-number">0</span>;
                    self.index = <span class="tok-number">0</span>;
                    self.end_index = <span class="tok-builtin">@intCast</span>(rc);
                }
                <span class="tok-kw">const</span> dirent: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator.DirEnt">DirEnt</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;self.buf[self.offset]));
                self.offset += dirent.reclen;
                self.index += <span class="tok-number">1</span>;
                <span class="tok-kw">const</span> name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(dirent.getName());
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>) <span class="tok-kw">or</span> dirent.ino == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;

                <span class="tok-kw">var</span> stat_info: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.Stat">Stat</a> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>, <span class="tok-builtin">@enumFromInt</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">_kern_read_stat</a>(
                    self.dir.fd,
                    name,
                    <span class="tok-null">false</span>,
                    &amp;stat_info,
                    <span class="tok-number">0</span>,
                )))) {
                    .SUCCESS =&gt; {},
                    .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                    .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid
                    </span>.NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                    .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                    .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                    .FAULT =&gt; <span class="tok-kw">unreachable</span>,
                    .NAMETOOLONG =&gt; <span class="tok-kw">unreachable</span>,
                    .LOOP =&gt; <span class="tok-kw">unreachable</span>,
                    .NOENT =&gt; <span class="tok-kw">continue</span>,
                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                }
                <span class="tok-kw">const</span> statmode = stat_info.mode &amp; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFMT</a>;

                <span class="tok-kw">const</span> entry_kind: <a href="std.fs.Dir.Entry.html">Entry</a>.<a href="std.fs.File.Kind.html">Kind</a> = <span class="tok-kw">switch</span> (statmode) {
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFDIR</a> =&gt; .directory,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFBLK</a> =&gt; .block_device,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFCHR</a> =&gt; .character_device,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFLNK</a> =&gt; .sym_link,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFREG</a> =&gt; .file,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFIFO</a> =&gt; .named_pipe,
                    <span class="tok-kw">else</span> =&gt; .unknown,
                };

                <span class="tok-kw">return</span> <a href="std.fs.Dir.Entry.html">Entry</a>{
                    .name = name,
                    .kind = entry_kind,
                };
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <span class="tok-type">void</span> {
            self.index = <span class="tok-number">0</span>;
            self.end_index = <span class="tok-number">0</span>;
            self.first_iter = <span class="tok-null">true</span>;
        }
    },
    .linux =&gt; <span class="tok-kw">struct</span> {
        dir: <a href="std.fs.Dir.html">Dir</a>,<span class="tok-comment">
        // The if guard is solely there to prevent compile errors from missing `linux.dirent64`
        // definition when compiling for other OSes. It doesn't do anything when compiling for Linux.
        </span>buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.dirent64.html">dirent64</a>)),
        index: <span class="tok-type">usize</span>,
        end_index: <span class="tok-type">usize</span>,
        first_iter: <span class="tok-type">bool</span>,

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a>;

        <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span>
        <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">Error</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {
            <span class="tok-kw">return</span> self.nextLinux() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {<span class="tok-comment">
                // To be consistent across platforms, iteration ends if the directory being iterated is deleted during iteration.
                // This matches the behavior of non-Linux UNIX platforms.
                </span><span class="tok-kw">error</span>.DirNotFound =&gt; <span class="tok-null">null</span>,
                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorLinux = <span class="tok-kw">error</span>{DirNotFound} || <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a>;

        <span class="tok-comment">/// Implementation of `next` that can return `error.DirNotFound` if the directory being</span>
        <span class="tok-comment">/// iterated was deleted during iteration (this error is Linux specific).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextLinux</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.Iterator.ErrorLinux">ErrorLinux</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {
            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {
                    <span class="tok-kw">if</span> (self.first_iter) {
                        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.lseek_SET">lseek_SET</a>(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // EBADF here likely means that the Dir was not opened with iteration permissions
                        </span>self.first_iter = <span class="tok-null">false</span>;
                    }
                    <span class="tok-kw">const</span> rc = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.getdents64">getdents64</a>(self.dir.fd, &amp;self.buf, self.buf.len);
                    <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(rc)) {
                        .SUCCESS =&gt; {},
                        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid or was opened without iteration ability
                        </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
                        .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
                        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotFound,<span class="tok-comment"> // The directory being iterated was deleted during iteration.
                        </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,<span class="tok-comment"> // Linux may in some cases return EINVAL when reading /proc/$PID/net.
                        </span>.ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,<span class="tok-comment"> // Do not have permission to iterate this directory.
                        </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                    }
                    <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    self.index = <span class="tok-number">0</span>;
                    self.end_index = rc;
                }
                <span class="tok-kw">const</span> linux_entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.dirent64.html">dirent64</a>, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));
                <span class="tok-kw">const</span> next_index = self.index + linux_entry.reclen;
                self.index = next_index;

                <span class="tok-kw">const</span> name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;linux_entry.name)), <span class="tok-number">0</span>);<span class="tok-comment">

                // skip . and .. entries
                </span><span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>)) {
                    <span class="tok-kw">continue</span> :start_over;
                }

                <span class="tok-kw">const</span> entry_kind: <a href="std.fs.Dir.Entry.html">Entry</a>.<a href="std.fs.File.Kind.html">Kind</a> = <span class="tok-kw">switch</span> (linux_entry.<span class="tok-type">type</span>) {
                    <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.BLK">BLK</a> =&gt; .block_device,
                    <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.CHR">CHR</a> =&gt; .character_device,
                    <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.DIR">DIR</a> =&gt; .directory,
                    <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.FIFO">FIFO</a> =&gt; .named_pipe,
                    <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.LNK">LNK</a> =&gt; .sym_link,
                    <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.REG">REG</a> =&gt; .file,
                    <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.SOCK">SOCK</a> =&gt; .unix_domain_socket,
                    <span class="tok-kw">else</span> =&gt; .unknown,
                };
                <span class="tok-kw">return</span> <a href="std.fs.Dir.Entry.html">Entry</a>{
                    .name = name,
                    .kind = entry_kind,
                };
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <span class="tok-type">void</span> {
            self.index = <span class="tok-number">0</span>;
            self.end_index = <span class="tok-number">0</span>;
            self.first_iter = <span class="tok-null">true</span>;
        }
    },
    .windows =&gt; <span class="tok-kw">struct</span> {
        dir: <a href="std.fs.Dir.html">Dir</a>,
        buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_BOTH_DIR_INFORMATION.html">FILE_BOTH_DIR_INFORMATION</a>)),
        index: <span class="tok-type">usize</span>,
        end_index: <span class="tok-type">usize</span>,
        first_iter: <span class="tok-type">bool</span>,
        name_data: [<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_name_bytes">max_name_bytes</a>]<span class="tok-type">u8</span>,

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a>;

        <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span>
        <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">Error</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {
            <span class="tok-kw">const</span> w = <a href="std.os.windows.html">windows</a>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {
                    <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;
                    <span class="tok-kw">const</span> rc = w.ntdll.NtQueryDirectoryFile(
                        self.dir.fd,
                        <span class="tok-null">null</span>,
                        <span class="tok-null">null</span>,
                        <span class="tok-null">null</span>,
                        &amp;io,
                        &amp;self.buf,
                        self.buf.len,
                        .FileBothDirectoryInformation,
                        w.FALSE,
                        <span class="tok-null">null</span>,
                        <span class="tok-kw">if</span> (self.first_iter) <span class="tok-builtin">@as</span>(w.BOOLEAN, w.TRUE) <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(w.BOOLEAN, w.FALSE),
                    );
                    self.first_iter = <span class="tok-null">false</span>;
                    <span class="tok-kw">if</span> (io.Information == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    self.index = <span class="tok-number">0</span>;
                    self.end_index = io.Information;
                    <span class="tok-kw">switch</span> (rc) {
                        .SUCCESS =&gt; {},
                        .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,<span class="tok-comment"> // Double-check that the Dir was opened with iteration ability

                        </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> w.unexpectedStatus(rc),
                    }
                }<span class="tok-comment">

                // While the official api docs guarantee FILE_BOTH_DIR_INFORMATION to be aligned properly
                // this may not always be the case (e.g. due to faulty VM/Sandboxing tools)
                </span><span class="tok-kw">const</span> dir_info: *<span class="tok-kw">align</span>(<span class="tok-number">2</span>) w.FILE_BOTH_DIR_INFORMATION = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;self.buf[self.index]));
                <span class="tok-kw">if</span> (dir_info.NextEntryOffset != <span class="tok-number">0</span>) {
                    self.index += dir_info.NextEntryOffset;
                } <span class="tok-kw">else</span> {
                    self.index = self.buf.len;
                }

                <span class="tok-kw">const</span> name_wtf16le = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u16</span>, <span class="tok-builtin">@ptrCast</span>(&amp;dir_info.FileName))[<span class="tok-number">0</span> .. dir_info.FileNameLength / <span class="tok-number">2</span>];

                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, name_wtf16le, &amp;[_]<span class="tok-type">u16</span>{<span class="tok-str">'.'</span>}) <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, name_wtf16le, &amp;[_]<span class="tok-type">u16</span>{ <span class="tok-str">'.'</span>, <span class="tok-str">'.'</span> }))
                    <span class="tok-kw">continue</span>;
                <span class="tok-kw">const</span> name_wtf8_len = <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf16LeToWtf8">wtf16LeToWtf8</a>(self.name_data[<span class="tok-number">0</span>..], name_wtf16le);
                <span class="tok-kw">const</span> name_wtf8 = self.name_data[<span class="tok-number">0</span>..name_wtf8_len];
                <span class="tok-kw">const</span> kind: <a href="std.fs.Dir.Entry.html">Entry</a>.<a href="std.fs.File.Kind.html">Kind</a> = blk: {
                    <span class="tok-kw">const</span> attrs = dir_info.FileAttributes;
                    <span class="tok-kw">if</span> (attrs &amp; w.FILE_ATTRIBUTE_DIRECTORY != <span class="tok-number">0</span>) <span class="tok-kw">break</span> :blk .directory;
                    <span class="tok-kw">if</span> (attrs &amp; w.FILE_ATTRIBUTE_REPARSE_POINT != <span class="tok-number">0</span>) <span class="tok-kw">break</span> :blk .sym_link;
                    <span class="tok-kw">break</span> :blk .file;
                };
                <span class="tok-kw">return</span> <a href="std.fs.Dir.Entry.html">Entry</a>{
                    .name = name_wtf8,
                    .kind = kind,
                };
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <span class="tok-type">void</span> {
            self.index = <span class="tok-number">0</span>;
            self.end_index = <span class="tok-number">0</span>;
            self.first_iter = <span class="tok-null">true</span>;
        }
    },
    .wasi =&gt; <span class="tok-kw">struct</span> {
        dir: <a href="std.fs.Dir.html">Dir</a>,
        buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span>,<span class="tok-comment"> // TODO align(@alignOf(posix.wasi.dirent_t)),
        </span>cookie: <span class="tok-type">u64</span>,
        index: <span class="tok-type">usize</span>,
        end_index: <span class="tok-type">usize</span>,

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a>;

        <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span>
        <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">Error</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {
            <span class="tok-kw">return</span> self.nextWasi() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {<span class="tok-comment">
                // To be consistent across platforms, iteration ends if the directory being iterated is deleted during iteration.
                // This matches the behavior of non-Linux UNIX platforms.
                </span><span class="tok-kw">error</span>.DirNotFound =&gt; <span class="tok-null">null</span>,
                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorWasi = <span class="tok-kw">error</span>{DirNotFound} || <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a>;

        <span class="tok-comment">/// Implementation of `next` that can return platform-dependent errors depending on the host platform.</span>
        <span class="tok-comment">/// When the host platform is Linux, `error.DirNotFound` can be returned if the directory being</span>
        <span class="tok-comment">/// iterated was deleted during iteration.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextWasi</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.Iterator.ErrorWasi">ErrorWasi</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {<span class="tok-comment">
            // We intentinally use fd_readdir even when linked with libc,
            // since its implementation is exactly the same as below,
            // and we avoid the code complexity here.
            </span><span class="tok-kw">const</span> w = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>;
            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment">
                // According to the WASI spec, the last entry might be truncated,
                // so we need to check if the left buffer contains the whole dirent.
                </span><span class="tok-kw">if</span> (self.end_index - self.index &lt; <span class="tok-builtin">@sizeOf</span>(w.dirent_t)) {
                    <span class="tok-kw">var</span> bufused: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
                    <span class="tok-kw">switch</span> (w.fd_readdir(self.dir.fd, &amp;self.buf, self.buf.len, self.cookie, &amp;bufused)) {
                        .SUCCESS =&gt; {},
                        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid or was opened without iteration ability
                        </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
                        .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
                        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotFound,<span class="tok-comment"> // The directory being iterated was deleted during iteration.
                        </span>.NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                        .ILSEQ =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8,<span class="tok-comment"> // An entry's name cannot be encoded as UTF-8.
                        </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                    }
                    <span class="tok-kw">if</span> (bufused == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    self.index = <span class="tok-number">0</span>;
                    self.end_index = bufused;
                }
                <span class="tok-kw">const</span> entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) w.dirent_t, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));
                <span class="tok-kw">const</span> entry_size = <span class="tok-builtin">@sizeOf</span>(w.dirent_t);
                <span class="tok-kw">const</span> name_index = self.index + entry_size;
                <span class="tok-kw">if</span> (name_index + entry.namlen &gt; self.end_index) {<span class="tok-comment">
                    // This case, the name is truncated, so we need to call readdir to store the entire name.
                    </span>self.end_index = self.index;<span class="tok-comment"> // Force fd_readdir in the next loop.
                    </span><span class="tok-kw">continue</span> :start_over;
                }
                <span class="tok-kw">const</span> name = self.buf[name_index .. name_index + entry.namlen];

                <span class="tok-kw">const</span> next_index = name_index + entry.namlen;
                self.index = next_index;
                self.cookie = entry.next;<span class="tok-comment">

                // skip . and .. entries
                </span><span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>)) {
                    <span class="tok-kw">continue</span> :start_over;
                }

                <span class="tok-kw">const</span> entry_kind: <a href="std.fs.Dir.Entry.html">Entry</a>.<a href="std.fs.File.Kind.html">Kind</a> = <span class="tok-kw">switch</span> (entry.<span class="tok-type">type</span>) {
                    .BLOCK_DEVICE =&gt; .block_device,
                    .CHARACTER_DEVICE =&gt; .character_device,
                    .DIRECTORY =&gt; .directory,
                    .SYMBOLIC_LINK =&gt; .sym_link,
                    .REGULAR_FILE =&gt; .file,
                    .SOCKET_STREAM, .SOCKET_DGRAM =&gt; .unix_domain_socket,
                    <span class="tok-kw">else</span> =&gt; .unknown,
                };
                <span class="tok-kw">return</span> <a href="std.fs.Dir.Entry.html">Entry</a>{
                    .name = name,
                    .kind = entry_kind,
                };
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <span class="tok-type">void</span> {
            self.index = <span class="tok-number">0</span>;
            self.end_index = <span class="tok-number">0</span>;
            self.cookie = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.DIRCOOKIE_START">DIRCOOKIE_START</a>;
        }
    },
    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unimplemented&quot;</span>),
}</code></pre></details></div></div></div></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">Handle</a></code></pre></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.posix.fd_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">fd_t</span><a href="#src.zig-std.posix.fd_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.fd_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> fd_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="std.posix.html#std.posix.system.fd_t">fd_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.default_mode" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">default_mode</span><a href="#src.zig-std.fs.Dir.default_mode">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.default_mode">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_mode = <span class="tok-number">0o755</span></code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.writeFile2" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">writeFile2</span><a href="#src.zig-std.fs.Dir.writeFile2">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.writeFile2">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> writeFile2 = <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;deprecated; renamed to writeFile&quot;</span>)</code></pre></details></div></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.fs.Dir.OpenError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">OpenError</span><a href="#src.zig-std.fs.Dir.OpenError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>BadPathName</dt></div><div><dt>DeviceBusy</dt></div><div><dt>FileNotFound</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>NameTooLong</dt></div><div><dt>NetworkNotFound</dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NoDevice</dt></div><div><dt>NotDir</dt></div><div><dt>ProcessFdQuotaExceeded</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemFdQuotaExceeded</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.OpenError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenError = <span class="tok-kw">error</span>{
    FileNotFound,
    NotDir,
    AccessDenied,
    SymLinkLoop,
    ProcessFdQuotaExceeded,
    NameTooLong,
    SystemFdQuotaExceeded,
    NoDevice,
    SystemResources,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
    BadPathName,
    DeviceBusy,
    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
} || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.MakeDirError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">MakeDirError</span><a href="#src.zig-std.posix.MakeDirError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to create a new directory relative to it.</p>
</dd></div><div><dt>BadPathName</dt></div><div><dt>DiskQuota</dt></div><div><dt>FileNotFound</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>LinkQuotaExceeded</dt></div><div><dt>NameTooLong</dt></div><div><dt>NetworkNotFound</dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NoDevice</dt></div><div><dt>NoSpaceLeft</dt></div><div><dt>NotDir</dt></div><div><dt>PathAlreadyExists</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.MakeDirError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MakeDirError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to create a new directory relative to it.</span>
    AccessDenied,
    DiskQuota,
    PathAlreadyExists,
    SymLinkLoop,
    LinkQuotaExceeded,
    NameTooLong,
    FileNotFound,
    SystemResources,
    NoSpaceLeft,
    NotDir,
    ReadOnlyFileSystem,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
    BadPathName,
    NoDevice,
    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.RealPathError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">RealPathError</span><a href="#src.zig-std.posix.RealPathError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>AntivirusInterference</dt><dd><p>On Windows, antivirus software is enabled by default. It can be
disabled, but Windows Update sometimes ignores the user's preference
and re-enables it. When enabled, antivirus software on Windows
intercepts file system operations and makes them significantly slower
in addition to possibly failing with this error code.</p>
</dd></div><div><dt>BadPathName</dt></div><div><dt>DeviceBusy</dt></div><div><dt>FileNotFound</dt></div><div><dt>FileSystem</dt></div><div><dt>FileTooBig</dt></div><div><dt>InputOutput</dt></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir</dt></div><div><dt>NameTooLong</dt></div><div><dt>NetworkNotFound</dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NoDevice</dt></div><div><dt>NoSpaceLeft</dt></div><div><dt>NotDir</dt></div><div><dt>NotSupported</dt></div><div><dt>PathAlreadyExists</dt></div><div><dt>PipeBusy</dt></div><div><dt>ProcessFdQuotaExceeded</dt></div><div><dt>SharingViolation</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemFdQuotaExceeded</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>UnrecognizedVolume</dt><dd><p>On Windows, the volume does not contain a recognized file system. File
system drivers might not be loaded, or the volume may be corrupt.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.RealPathError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RealPathError = <span class="tok-kw">error</span>{
    FileNotFound,
    AccessDenied,
    NameTooLong,
    NotSupported,
    NotDir,
    SymLinkLoop,
    InputOutput,
    FileTooBig,
    IsDir,
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    NoDevice,
    SystemResources,
    NoSpaceLeft,
    FileSystem,
    BadPathName,
    DeviceBusy,

    SharingViolation,
    PipeBusy,

    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,

    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,

    PathAlreadyExists,

    <span class="tok-comment">/// On Windows, antivirus software is enabled by default. It can be</span>
    <span class="tok-comment">/// disabled, but Windows Update sometimes ignores the user's preference</span>
    <span class="tok-comment">/// and re-enables it. When enabled, antivirus software on Windows</span>
    <span class="tok-comment">/// intercepts file system operations and makes them significantly slower</span>
    <span class="tok-comment">/// in addition to possibly failing with this error code.</span>
    AntivirusInterference,

    <span class="tok-comment">/// On Windows, the volume does not contain a recognized file system. File</span>
    <span class="tok-comment">/// system drivers might not be loaded, or the volume may be corrupt.</span>
    UnrecognizedVolume,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.RealPathAllocError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">RealPathAllocError</span><a href="#src.zig-std.fs.Dir.RealPathAllocError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt></div><div><dt>AntivirusInterference <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt><dd><p>On Windows, antivirus software is enabled by default. It can be
disabled, but Windows Update sometimes ignores the user's preference
and re-enables it. When enabled, antivirus software on Windows
intercepts file system operations and makes them significantly slower
in addition to possibly failing with this error code.</p>
</dd></div><div><dt>BadPathName <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt></div><div><dt>DeviceBusy <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt></div><div><dt>FileSystem <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt></div><div><dt>FileTooBig <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt></div><div><dt>InputOutput <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt></div><div><dt>InvalidWtf8 <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt></div><div><dt>NameTooLong <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt></div><div><dt>NetworkNotFound <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NoDevice <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt></div><div><dt>NoSpaceLeft <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt></div><div><dt>NotDir <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt></div><div><dt>NotSupported <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt></div><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>PathAlreadyExists <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt></div><div><dt>PipeBusy <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt></div><div><dt>ProcessFdQuotaExceeded <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt></div><div><dt>SharingViolation <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt></div><div><dt>SymLinkLoop <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt></div><div><dt>SystemFdQuotaExceeded <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>UnrecognizedVolume <a href="std.posix.html#std.posix.RealPathError">RealPathError</a></dt><dd><p>On Windows, the volume does not contain a recognized file system. File
system drivers might not be loaded, or the volume may be corrupt.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.RealPathAllocError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RealPathAllocError = <a href="std.posix.html#std.posix.RealPathError">RealPathError</a> || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.UnlinkError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">UnlinkError</span><a href="#src.zig-std.posix.UnlinkError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to unlink a resource by path relative to it.</p>
</dd></div><div><dt>BadPathName</dt><dd><p>On Windows, file paths cannot contain these characters:
'/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</p>
</dd></div><div><dt>FileBusy</dt></div><div><dt>FileNotFound</dt></div><div><dt>FileSystem</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir</dt></div><div><dt>NameTooLong</dt></div><div><dt>NetworkNotFound</dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NotDir</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.UnlinkError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnlinkError = <span class="tok-kw">error</span>{
    FileNotFound,

    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to unlink a resource by path relative to it.</span>
    AccessDenied,
    FileBusy,
    FileSystem,
    IsDir,
    SymLinkLoop,
    NameTooLong,
    NotDir,
    SystemResources,
    ReadOnlyFileSystem,

    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,

    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,

    <span class="tok-comment">/// On Windows, file paths cannot contain these characters:</span>
    <span class="tok-comment">/// '/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</span>
    BadPathName,

    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.DeleteDirError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">DeleteDirError</span><a href="#src.zig-std.fs.Dir.DeleteDirError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>BadPathName</dt></div><div><dt>DirNotEmpty</dt></div><div><dt>FileBusy</dt></div><div><dt>FileNotFound</dt></div><div><dt>FileSystem</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>NameTooLong</dt></div><div><dt>NetworkNotFound</dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NotDir</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.DeleteDirError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeleteDirError = <span class="tok-kw">error</span>{
    DirNotEmpty,
    FileNotFound,
    AccessDenied,
    FileBusy,
    FileSystem,
    SymLinkLoop,
    NameTooLong,
    NotDir,
    SystemResources,
    ReadOnlyFileSystem,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
    BadPathName,
    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
    Unexpected,
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.RenameError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">RenameError</span><a href="#src.zig-std.posix.RenameError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to rename a resource by path relative to it.</p>
<p>On Windows, this error may be returned instead of PathAlreadyExists when
renaming a directory over an existing directory.</p>
</dd></div><div><dt>AntivirusInterference</dt><dd><p>On Windows, antivirus software is enabled by default. It can be
disabled, but Windows Update sometimes ignores the user's preference
and re-enables it. When enabled, antivirus software on Windows
intercepts file system operations and makes them significantly slower
in addition to possibly failing with this error code.</p>
</dd></div><div><dt>BadPathName</dt></div><div><dt>DiskQuota</dt></div><div><dt>FileBusy</dt></div><div><dt>FileNotFound</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir</dt></div><div><dt>LinkQuotaExceeded</dt></div><div><dt>NameTooLong</dt></div><div><dt>NetworkNotFound</dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NoDevice</dt></div><div><dt>NoSpaceLeft</dt></div><div><dt>NotDir</dt></div><div><dt>PathAlreadyExists</dt></div><div><dt>PipeBusy</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>RenameAcrossMountPoints</dt></div><div><dt>SharingViolation</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.RenameError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RenameError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to rename a resource by path relative to it.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// On Windows, this error may be returned instead of PathAlreadyExists when</span>
    <span class="tok-comment">/// renaming a directory over an existing directory.</span>
    AccessDenied,
    FileBusy,
    DiskQuota,
    IsDir,
    SymLinkLoop,
    LinkQuotaExceeded,
    NameTooLong,
    FileNotFound,
    NotDir,
    SystemResources,
    NoSpaceLeft,
    PathAlreadyExists,
    ReadOnlyFileSystem,
    RenameAcrossMountPoints,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
    BadPathName,
    NoDevice,
    SharingViolation,
    PipeBusy,
    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
    <span class="tok-comment">/// On Windows, antivirus software is enabled by default. It can be</span>
    <span class="tok-comment">/// disabled, but Windows Update sometimes ignores the user's preference</span>
    <span class="tok-comment">/// and re-enables it. When enabled, antivirus software on Windows</span>
    <span class="tok-comment">/// intercepts file system operations and makes them significantly slower</span>
    <span class="tok-comment">/// in addition to possibly failing with this error code.</span>
    AntivirusInterference,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.ReadLinkError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ReadLinkError</span><a href="#src.zig-std.posix.ReadLinkError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to read value of a symbolic link relative to it.</p>
</dd></div><div><dt>BadPathName</dt></div><div><dt>FileNotFound</dt></div><div><dt>FileSystem</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>NameTooLong</dt></div><div><dt>NetworkNotFound</dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NotDir</dt></div><div><dt>NotLink</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>UnsupportedReparsePointType</dt><dd><p>Windows-only. This error may occur if the opened reparse point is
of unsupported type.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.ReadLinkError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadLinkError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to read value of a symbolic link relative to it.</span>
    AccessDenied,
    FileSystem,
    SymLinkLoop,
    NameTooLong,
    FileNotFound,
    SystemResources,
    NotLink,
    NotDir,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
    BadPathName,
    <span class="tok-comment">/// Windows-only. This error may occur if the opened reparse point is</span>
    <span class="tok-comment">/// of unsupported type.</span>
    UnsupportedReparsePointType,
    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.DeleteTreeError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">DeleteTreeError</span><a href="#src.zig-std.fs.Dir.DeleteTreeError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>BadPathName</dt><dd><p>On Windows, file paths cannot contain these characters:
'/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</p>
</dd></div><div><dt>DeviceBusy</dt></div><div><dt>FileBusy</dt></div><div><dt>FileSystem</dt></div><div><dt>FileTooBig</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>NameTooLong</dt></div><div><dt>NetworkNotFound</dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NoDevice</dt></div><div><dt>NotDir</dt><dd><p>One of the path components was not a directory.
This error is unreachable if <code>sub_path</code> does not contain a path separator.</p>
</dd></div><div><dt>ProcessFdQuotaExceeded</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemFdQuotaExceeded</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.DeleteTreeError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeleteTreeError = <span class="tok-kw">error</span>{
    AccessDenied,
    FileTooBig,
    SymLinkLoop,
    ProcessFdQuotaExceeded,
    NameTooLong,
    SystemFdQuotaExceeded,
    NoDevice,
    SystemResources,
    ReadOnlyFileSystem,
    FileSystem,
    FileBusy,
    DeviceBusy,

    <span class="tok-comment">/// One of the path components was not a directory.</span>
    <span class="tok-comment">/// This error is unreachable if `sub_path` does not contain a path separator.</span>
    NotDir,

    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,

    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,

    <span class="tok-comment">/// On Windows, file paths cannot contain these characters:</span>
    <span class="tok-comment">/// '/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</span>
    BadPathName,

    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
} || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.WriteFileError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">WriteFileError</span><a href="#src.zig-std.fs.Dir.WriteFileError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>File descriptor does not hold the required rights to write to it.</p>
</dd></div><div><dt>AntivirusInterference <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, antivirus software is enabled by default. It can be
disabled, but Windows Update sometimes ignores the user's preference
and re-enables it. When enabled, antivirus software on Windows
intercepts file system operations and makes them significantly slower
in addition to possibly failing with this error code.</p>
</dd></div><div><dt>BadPathName <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, file paths cannot contain these characters:
'/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</p>
</dd></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>Connection reset by peer.</p>
</dd></div><div><dt>DeviceBusy <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>DiskQuota <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>FileBusy <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>One of these three things:</p>
<ul>
<li>pathname  refers to an executable image which is currently being
executed and write access was requested.</li>
<li>pathname refers to a file that is currently in  use  as  a  swap
file, and the O_TRUNC flag was specified.</li>
<li>pathname  refers  to  a file that is currently being read by the
kernel (e.g., for module/firmware loading), and write access was
requested.</li>
</ul>
</dd></div><div><dt>FileLocksNotSupported <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The underlying filesystem does not support file locks</p>
</dd></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Either:</p>
<ul>
<li>One of the path components does not exist.</li>
<li>Cwd was used, but cwd has been deleted.</li>
<li>The path associated with the open directory handle has been deleted.</li>
<li>On macOS, multiple processes or threads raced to create the same file
with <code>O.EXCL</code> set to <code>false</code>.</li>
</ul>
</dd></div><div><dt>FileTooBig <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The file is too large to be opened. This error is unreachable
for 64-bit targets, as well as when opening directories.</p>
</dd></div><div><dt>InputOutput <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>InvalidArgument <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>InvalidUtf8 <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8 <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path refers to directory but the <code>DIRECTORY</code> flag was not provided.</p>
</dd></div><div><dt>LockViolation <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>The process cannot access the file because another process has locked
a portion of the file. Windows-only.</p>
</dd></div><div><dt>NameTooLong <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path exceeded <code><a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a></code> bytes.</p>
</dd></div><div><dt>NetworkNotFound <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NoDevice <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>This error occurs when a device gets disconnected before or mid-flush
while it's being written to - errno(6): No such device or address.</p>
</dd></div><div><dt>NoSpaceLeft <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>A new path cannot be created because the device has no room for the new file.
This error is only reachable when the <code>CREAT</code> flag is provided.</p>
</dd></div><div><dt>NotDir <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>A component used as a directory in the path was not, in fact, a directory, or
<code>DIRECTORY</code> was specified and the path was not a directory.</p>
</dd></div><div><dt>NotOpenForWriting <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>OperationAborted <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>PathAlreadyExists <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path already exists and the <code>CREAT</code> and <code>EXCL</code> flags were provided.</p>
</dd></div><div><dt>PipeBusy <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>ProcessFdQuotaExceeded <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>This error occurs in Linux if the process being written to
no longer exists.</p>
</dd></div><div><dt>SharingViolation <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>SymLinkLoop <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SystemFdQuotaExceeded <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Insufficient kernel memory was available, or
the named file is a FIFO and per-user hard limit on
memory allocation for pipes has been reached.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.WriteFileError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteFileError = <a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.WriteError">WriteError</a> || <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.AccessError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">AccessError</span><a href="#src.zig-std.posix.AccessError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>BadPathName</dt></div><div><dt>FileBusy</dt></div><div><dt>FileNotFound</dt></div><div><dt>InputOutput</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>NameTooLong</dt></div><div><dt>PermissionDenied</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.AccessError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AccessError = <span class="tok-kw">error</span>{
    PermissionDenied,
    FileNotFound,
    NameTooLong,
    InputOutput,
    SystemResources,
    BadPathName,
    FileBusy,
    SymLinkLoop,
    ReadOnlyFileSystem,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.CopyFileError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">CopyFileError</span><a href="#src.zig-std.fs.Dir.CopyFileError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to open a new resource relative to it.</p>
</dd></div><div><dt>AntivirusInterference <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, antivirus software is enabled by default. It can be
disabled, but Windows Update sometimes ignores the user's preference
and re-enables it. When enabled, antivirus software on Windows
intercepts file system operations and makes them significantly slower
in addition to possibly failing with this error code.</p>
</dd></div><div><dt>BadPathName <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, file paths cannot contain these characters:
'/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</p>
</dd></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>The  local  end  has been shut down on a connection oriented socket.  In this case, the
process will also receive a SIGPIPE unless MSG.NOSIGNAL is set.</p>
</dd></div><div><dt>Canceled <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>reading a timerfd with CANCEL_ON_SET will lead to this error
when the clock goes through a discontinuous change</p>
</dd></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>Connection reset by peer.</p>
</dd></div><div><dt>ConnectionTimedOut <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>CorruptedData <a href="std.posix.html#std.posix.CopyFileRangeError">CopyFileRangeError</a></dt></div><div><dt>DeviceBusy <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>DiskQuota <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>FastOpenAlreadyInProgress <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>Another Fast Open is already in progress.</p>
</dd></div><div><dt>FileBusy <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>One of these three things:</p>
<ul>
<li>pathname  refers to an executable image which is currently being
executed and write access was requested.</li>
<li>pathname refers to a file that is currently in  use  as  a  swap
file, and the O_TRUNC flag was specified.</li>
<li>pathname  refers  to  a file that is currently being read by the
kernel (e.g., for module/firmware loading), and write access was
requested.</li>
</ul>
</dd></div><div><dt>FileDescriptorNotASocket <a href="std.posix.html#std.posix.SendError">SendError</a></dt></div><div><dt>FileLocksNotSupported <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The underlying filesystem does not support file locks</p>
</dd></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Either:</p>
<ul>
<li>One of the path components does not exist.</li>
<li>Cwd was used, but cwd has been deleted.</li>
<li>The path associated with the open directory handle has been deleted.</li>
<li>On macOS, multiple processes or threads raced to create the same file
with <code>O.EXCL</code> set to <code>false</code>.</li>
</ul>
</dd></div><div><dt>FileTooBig <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The file is too large to be opened. This error is unreachable
for 64-bit targets, as well as when opening directories.</p>
</dd></div><div><dt>FilesOpenedWithWrongFlags <a href="std.posix.html#std.posix.CopyFileRangeError">CopyFileRangeError</a></dt><dd><p><code>fd_in</code> is not open for reading; or <code>fd_out</code> is not open  for  writing;
or the  <code>APPEND</code>  flag  is  set  for <code>fd_out</code>.</p>
</dd></div><div><dt>InputOutput <a href="std.posix.html#std.posix.CopyFileRangeError">CopyFileRangeError</a></dt></div><div><dt>InvalidArgument <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>InvalidUtf8 <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8 <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path refers to directory but the <code>DIRECTORY</code> flag was not provided.</p>
</dd></div><div><dt>LinkQuotaExceeded <a href="std.posix.html#std.posix.RenameError">RenameError</a></dt></div><div><dt>LockViolation <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>Unable to read file due to lock.</p>
</dd></div><div><dt>MessageTooBig <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>The  socket  type requires that message be sent atomically, and the size of the message
to be sent made this impossible. The message is not transmitted.</p>
</dd></div><div><dt>NameTooLong <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path exceeded <code><a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a></code> bytes.</p>
</dd></div><div><dt>NetworkNotFound <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NetworkSubsystemFailed <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>The local network interface used to reach the destination is down.</p>
</dd></div><div><dt>NetworkUnreachable <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>Network is unreachable.</p>
</dd></div><div><dt>NoDevice <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>This error occurs when a device gets disconnected before or mid-flush
while it's being written to - errno(6): No such device or address.</p>
</dd></div><div><dt>NoSpaceLeft <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>A new path cannot be created because the device has no room for the new file.
This error is only reachable when the <code>CREAT</code> flag is provided.</p>
</dd></div><div><dt>NotDir <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>A component used as a directory in the path was not, in fact, a directory, or
<code>DIRECTORY</code> was specified and the path was not a directory.</p>
</dd></div><div><dt>NotOpenForReading <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>NotOpenForWriting <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>OperationAborted <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>OutOfMemory <a href="std.posix.html#std.posix.CopyFileRangeError">CopyFileRangeError</a></dt></div><div><dt>PathAlreadyExists <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path already exists and the <code>CREAT</code> and <code>EXCL</code> flags were provided.</p>
</dd></div><div><dt>PermissionDenied <a href="std.posix.html#std.posix.CopyFileRangeError">CopyFileRangeError</a></dt></div><div><dt>PipeBusy <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>ProcessFdQuotaExceeded <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs in Linux if the process to be read from
no longer exists.</p>
</dd></div><div><dt>ReadOnlyFileSystem <a href="std.posix.html#std.posix.RenameError">RenameError</a></dt></div><div><dt>RenameAcrossMountPoints <a href="std.posix.html#std.posix.RenameError">RenameError</a></dt></div><div><dt>SharingViolation <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>SocketNotConnected <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>SwapFile <a href="std.posix.html#std.posix.CopyFileRangeError">CopyFileRangeError</a></dt></div><div><dt>SymLinkLoop <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SystemFdQuotaExceeded <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Insufficient kernel memory was available, or
the named file is a FIFO and per-user hard limit on
memory allocation for pipes has been reached.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>Unseekable <a href="std.posix.html#std.posix.CopyFileRangeError">CopyFileRangeError</a></dt></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.CopyFileError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CopyFileError = <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a> || <a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.FStatError">StatError</a> ||
    <a href="std.fs.AtomicFile.html">AtomicFile</a>.<a href="std.fs.File.html#std.fs.File.OpenError">InitError</a> || <a href="std.fs.Dir.html#std.fs.Dir.CopyFileRawError">CopyFileRawError</a> || <a href="std.fs.AtomicFile.html">AtomicFile</a>.<a href="std.posix.html#std.posix.RenameError">FinishError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FStatError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FStatError</span><a href="#src.zig-std.posix.FStatError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to get its filestat information.</p>
</dd></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FStatError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FStatError = <span class="tok-kw">error</span>{
    SystemResources,

    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to get its filestat information.</span>
    AccessDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.StatFileError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">StatFileError</span><a href="#src.zig-std.fs.Dir.StatFileError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to open a new resource relative to it.</p>
</dd></div><div><dt>AntivirusInterference <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, antivirus software is enabled by default. It can be
disabled, but Windows Update sometimes ignores the user's preference
and re-enables it. When enabled, antivirus software on Windows
intercepts file system operations and makes them significantly slower
in addition to possibly failing with this error code.</p>
</dd></div><div><dt>BadPathName <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, file paths cannot contain these characters:
'/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</p>
</dd></div><div><dt>DeviceBusy <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>FileBusy <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>One of these three things:</p>
<ul>
<li>pathname  refers to an executable image which is currently being
executed and write access was requested.</li>
<li>pathname refers to a file that is currently in  use  as  a  swap
file, and the O_TRUNC flag was specified.</li>
<li>pathname  refers  to  a file that is currently being read by the
kernel (e.g., for module/firmware loading), and write access was
requested.</li>
</ul>
</dd></div><div><dt>FileLocksNotSupported <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The underlying filesystem does not support file locks</p>
</dd></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Either:</p>
<ul>
<li>One of the path components does not exist.</li>
<li>Cwd was used, but cwd has been deleted.</li>
<li>The path associated with the open directory handle has been deleted.</li>
<li>On macOS, multiple processes or threads raced to create the same file
with <code>O.EXCL</code> set to <code>false</code>.</li>
</ul>
</dd></div><div><dt>FileTooBig <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The file is too large to be opened. This error is unreachable
for 64-bit targets, as well as when opening directories.</p>
</dd></div><div><dt>InvalidUtf8 <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8 <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path refers to directory but the <code>DIRECTORY</code> flag was not provided.</p>
</dd></div><div><dt>NameTooLong <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path exceeded <code><a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a></code> bytes.</p>
</dd></div><div><dt>NetworkNotFound <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NoDevice <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>NoSpaceLeft <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>A new path cannot be created because the device has no room for the new file.
This error is only reachable when the <code>CREAT</code> flag is provided.</p>
</dd></div><div><dt>NotDir <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>A component used as a directory in the path was not, in fact, a directory, or
<code>DIRECTORY</code> was specified and the path was not a directory.</p>
</dd></div><div><dt>PathAlreadyExists <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path already exists and the <code>CREAT</code> and <code>EXCL</code> flags were provided.</p>
</dd></div><div><dt>PipeBusy <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>ProcessFdQuotaExceeded <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SharingViolation <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>SymLinkLoop <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SystemFdQuotaExceeded <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Insufficient kernel memory was available, or
the named file is a FIFO and per-user hard limit on
memory allocation for pipes has been reached.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.StatFileError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> StatFileError = <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a> || <a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.FStatError">StatError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.FStatAtError">FStatAtError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FChmodError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FChmodError</span><a href="#src.zig-std.posix.FChmodError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>FileNotFound</dt></div><div><dt>InputOutput</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FChmodError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FChmodError = <span class="tok-kw">error</span>{
    AccessDenied,
    InputOutput,
    SymLinkLoop,
    FileNotFound,
    SystemResources,
    ReadOnlyFileSystem,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FChownError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FChownError</span><a href="#src.zig-std.posix.FChownError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>FileNotFound</dt></div><div><dt>InputOutput</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FChownError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FChownError = <span class="tok-kw">error</span>{
    AccessDenied,
    InputOutput,
    SymLinkLoop,
    FileNotFound,
    SystemResources,
    ReadOnlyFileSystem,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FChmodError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FChmodError</span><a href="#src.zig-std.posix.FChmodError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>FileNotFound</dt></div><div><dt>InputOutput</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FChmodError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FChmodError = <span class="tok-kw">error</span>{
    AccessDenied,
    InputOutput,
    SymLinkLoop,
    FileNotFound,
    SystemResources,
    ReadOnlyFileSystem,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FStatError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FStatError</span><a href="#src.zig-std.posix.FStatError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to get its filestat information.</p>
</dd></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FStatError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FStatError = <span class="tok-kw">error</span>{
    SystemResources,

    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to get its filestat information.</span>
    AccessDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.fs.Dir.iterate" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterate</span><a href="#src.zig-std.fs.Dir.iterate">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterate</span>(self: <a href="std.fs.Dir.html">Dir</a>) <a href="std.fs.Dir.html#std.fs.Dir.Iterator">Iterator</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.iterate">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterate</span>(self: <a href="std.fs.Dir.html">Dir</a>) <a href="std.fs.Dir.html#std.fs.Dir.Iterator">Iterator</a> {
    <span class="tok-kw">return</span> self.iterateImpl(<span class="tok-null">true</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.iterateAssumeFirstIteration" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterateAssumeFirstIteration</span><a href="#src.zig-std.fs.Dir.iterateAssumeFirstIteration">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterateAssumeFirstIteration</span>(self: <a href="std.fs.Dir.html">Dir</a>) <a href="std.fs.Dir.html#std.fs.Dir.Iterator">Iterator</a></code></pre></div><div class="tldDocs"><p>Like <code><a href="std.fs.Dir.html#std.fs.Dir.iterate">iterate</a></code>, but will not reset the directory cursor before the first
iteration. This should only be used in cases where it is known that the
<code><a href="std.fs.Dir.html">Dir</a></code> has not had its cursor modified yet (e.g. it was just opened).</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.iterateAssumeFirstIteration">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterateAssumeFirstIteration</span>(self: <a href="std.fs.Dir.html">Dir</a>) <a href="std.fs.Dir.html#std.fs.Dir.Iterator">Iterator</a> {
    <span class="tok-kw">return</span> self.iterateImpl(<span class="tok-null">false</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.walk" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">walk</span><a href="#src.zig-std.fs.Dir.walk">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">walk</span>(self: <a href="std.fs.Dir.html">Dir</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.fs.Dir.Walker.html">Walker</a></code></pre></div><div class="tldDocs"><p>Recursively iterates over a directory.</p>
<p><code>self</code> must have been opened with <code>OpenOptions{.iterate = true}</code>.</p>
<p><code><a href="std.fs.Dir.Walker.html#std.fs.Dir.Walker.deinit">Walker.deinit</a></code> releases allocated memory and directory handles.</p>
<p>The order of returned file system entries is undefined.</p>
<p><code>self</code> will not be closed after walking it.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.walk">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">walk</span>(self: <a href="std.fs.Dir.html">Dir</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.fs.Dir.Walker.html">Walker</a> {
    <span class="tok-kw">var</span> stack: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.fs.Dir.Walker.html">Walker</a>.<a href="std.fs.Dir.Walker.StackItem.html">StackItem</a>) = .empty;

    <span class="tok-kw">try</span> stack.append(allocator, .{
        .iter = self.iterate(),
        .dirname_len = <span class="tok-number">0</span>,
    });

    <span class="tok-kw">return</span> .{
        .stack = stack,
        .name_buffer = .{},
        .allocator = allocator,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.close" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">close</span><a href="#src.zig-std.fs.Dir.close">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close</span>(self: *<a href="std.fs.Dir.html">Dir</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.fs.Dir.html">Dir</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.close">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close</span>(self: *<a href="std.fs.Dir.html">Dir</a>) <span class="tok-type">void</span> {
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(self.fd);
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.openFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">openFile</span><a href="#src.zig-std.fs.Dir.openFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a></code></pre></div><div class="tldDocs"><p>Opens a file for reading or writing, without attempting to create a new file.
To create a new file, see <code><a href="std.fs.Dir.html#std.fs.Dir.createFile">createFile</a></code>.
Call <code><a href="std.fs.File.html#std.fs.File.close">File.close</a></code> to release the resource.
Asserts that the path parameter has no null bytes.
On Windows, <code>sub_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>sub_path</code> should be encoded as valid UTF-8.
On other platforms, <code>sub_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.openFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(self.fd, sub_path);
        <span class="tok-kw">return</span> self.openFileW(path_w.span(), flags);
    }
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> base: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.rights_t.html">rights_t</a> = .{};<span class="tok-comment">
        // POLL_FD_READWRITE only grants extra rights if the corresponding FD_READ and/or FD_WRITE
        // is also set.
        </span><span class="tok-kw">if</span> (flags.isRead()) {
            base.FD_READ = <span class="tok-null">true</span>;
            base.FD_TELL = <span class="tok-null">true</span>;
            base.FD_SEEK = <span class="tok-null">true</span>;
            base.FD_FILESTAT_GET = <span class="tok-null">true</span>;
            base.POLL_FD_READWRITE = <span class="tok-null">true</span>;
        }
        <span class="tok-kw">if</span> (flags.isWrite()) {
            base.FD_WRITE = <span class="tok-null">true</span>;
            base.FD_TELL = <span class="tok-null">true</span>;
            base.FD_SEEK = <span class="tok-null">true</span>;
            base.FD_DATASYNC = <span class="tok-null">true</span>;
            base.FD_FDSTAT_SET_FLAGS = <span class="tok-null">true</span>;
            base.FD_SYNC = <span class="tok-null">true</span>;
            base.FD_ALLOCATE = <span class="tok-null">true</span>;
            base.FD_ADVISE = <span class="tok-null">true</span>;
            base.FD_FILESTAT_SET_TIMES = <span class="tok-null">true</span>;
            base.FD_FILESTAT_SET_SIZE = <span class="tok-null">true</span>;
            base.POLL_FD_READWRITE = <span class="tok-null">true</span>;
        }
        <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.openatWasi">openatWasi</a>(self.fd, sub_path, .{}, .{}, .{}, base, .{});
        <span class="tok-kw">return</span> .{ .handle = fd };
    }
    <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sub_path);
    <span class="tok-kw">return</span> self.openFileZ(&amp;path_c, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.openFileZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">openFileZ</span><a href="#src.zig-std.fs.Dir.openFileZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.openFile">openFile</a></code> but the path parameter is null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.openFileZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {
        .windows =&gt; {
            <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(self.fd, sub_path);
            <span class="tok-kw">return</span> self.openFileW(path_w.span(), flags);
        },<span class="tok-comment">
        // Use the libc API when libc is linked because it implements things
        // such as opening absolute file paths.
        </span>.wasi =&gt; <span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
            <span class="tok-kw">return</span> <a href="std.fs.Dir.html#std.fs.Dir.openFile">openFile</a>(self, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sub_path, <span class="tok-number">0</span>), flags);
        },
        <span class="tok-kw">else</span> =&gt; {},
    }

    <span class="tok-kw">var</span> os_flags: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a> = <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {
        .wasi =&gt; .{
            .read = flags.mode != .write_only,
            .write = flags.mode != .read_only,
        },
        <span class="tok-kw">else</span> =&gt; .{
            .ACCMODE = <span class="tok-kw">switch</span> (flags.mode) {
                .read_only =&gt; .RDONLY,
                .write_only =&gt; .WRONLY,
                .read_write =&gt; .RDWR,
            },
        },
    };
    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;CLOEXEC&quot;</span>)) os_flags.CLOEXEC = <span class="tok-null">true</span>;
    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;LARGEFILE&quot;</span>)) os_flags.LARGEFILE = <span class="tok-null">true</span>;
    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;NOCTTY&quot;</span>)) os_flags.NOCTTY = !flags.allow_ctty;<span class="tok-comment">

    // Use the O locking flags if the os supports them to acquire the lock
    // atomically.
    </span><span class="tok-kw">const</span> has_flock_open_flags = <span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;EXLOCK&quot;</span>);
    <span class="tok-kw">if</span> (has_flock_open_flags) {<span class="tok-comment">
        // Note that the NONBLOCK flag is removed after the openat() call
        // is successful.
        </span><span class="tok-kw">switch</span> (flags.lock) {
            .none =&gt; {},
            .shared =&gt; {
                os_flags.SHLOCK = <span class="tok-null">true</span>;
                os_flags.NONBLOCK = flags.lock_nonblocking;
            },
            .exclusive =&gt; {
                os_flags.EXLOCK = <span class="tok-null">true</span>;
                os_flags.NONBLOCK = flags.lock_nonblocking;
            },
        }
    }
    <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.openatZ">openatZ</a>(self.fd, sub_path, os_flags, <span class="tok-number">0</span>);
    <span class="tok-kw">errdefer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(fd);

    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.have_flock">have_flock</a> <span class="tok-kw">and</span> !has_flock_open_flags <span class="tok-kw">and</span> flags.lock != .none) {<span class="tok-comment">
        // TODO: integrate async I/O
        </span><span class="tok-kw">const</span> lock_nonblocking: <span class="tok-type">i32</span> = <span class="tok-kw">if</span> (flags.lock_nonblocking) <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.NB">NB</a> <span class="tok-kw">else</span> <span class="tok-number">0</span>;
        <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.flock">flock</a>(fd, <span class="tok-kw">switch</span> (flags.lock) {
            .none =&gt; <span class="tok-kw">unreachable</span>,
            .shared =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.SH">SH</a> | lock_nonblocking,
            .exclusive =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.EX">EX</a> | lock_nonblocking,
        });
    }

    <span class="tok-kw">if</span> (has_flock_open_flags <span class="tok-kw">and</span> flags.lock_nonblocking) {
        <span class="tok-kw">var</span> fl_flags = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fcntl">fcntl</a>(fd, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.F">F</a>.<a href="#">GETFL</a>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        fl_flags &amp;= ~<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span> &lt;&lt; <span class="tok-builtin">@bitOffsetOf</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;NONBLOCK&quot;</span>));
        _ = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fcntl">fcntl</a>(fd, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.F">F</a>.<a href="#">SETFL</a>, fl_flags) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    }

    <span class="tok-kw">return</span> .{ .handle = fd };
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.openFileW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">openFileW</span><a href="#src.zig-std.fs.Dir.openFileW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.openFile">openFile</a></code> but Windows-only and the path parameter is
<a href="https://simonsapin.github.io/wtf-8/#potentially-ill-formed-utf-16">WTF-16</a> encoded.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.openFileW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <span class="tok-kw">const</span> w = <a href="std.os.windows.html">windows</a>;
    <span class="tok-kw">const</span> file: <a href="std.fs.File.html">File</a> = .{
        .handle = <span class="tok-kw">try</span> w.OpenFile(sub_path_w, .{
            .dir = self.fd,
            .access_mask = w.SYNCHRONIZE |
                (<span class="tok-kw">if</span> (flags.isRead()) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.GENERIC_READ) <span class="tok-kw">else</span> <span class="tok-number">0</span>) |
                (<span class="tok-kw">if</span> (flags.isWrite()) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.GENERIC_WRITE) <span class="tok-kw">else</span> <span class="tok-number">0</span>),
            .creation = w.FILE_OPEN,
        }),
    };
    <span class="tok-kw">errdefer</span> file.close();
    <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> range_off: w.LARGE_INTEGER = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> range_len: w.LARGE_INTEGER = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> exclusive = <span class="tok-kw">switch</span> (flags.lock) {
        .none =&gt; <span class="tok-kw">return</span> file,
        .shared =&gt; <span class="tok-null">false</span>,
        .exclusive =&gt; <span class="tok-null">true</span>,
    };
    <span class="tok-kw">try</span> w.LockFile(
        file.handle,
        <span class="tok-null">null</span>,
        <span class="tok-null">null</span>,
        <span class="tok-null">null</span>,
        &amp;io,
        &amp;range_off,
        &amp;range_len,
        <span class="tok-null">null</span>,
        <span class="tok-builtin">@intFromBool</span>(flags.lock_nonblocking),
        <span class="tok-builtin">@intFromBool</span>(exclusive),
    );
    <span class="tok-kw">return</span> file;
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.createFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">createFile</span><a href="#src.zig-std.fs.Dir.createFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a></code></pre></div><div class="tldDocs"><p>Creates, opens, or overwrites a file with write access.
Call <code><a href="std.fs.File.html#std.fs.File.close">File.close</a></code> on the result when done.
Asserts that the path parameter has no null bytes.
On Windows, <code>sub_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>sub_path</code> should be encoded as valid UTF-8.
On other platforms, <code>sub_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.createFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(self.fd, sub_path);
        <span class="tok-kw">return</span> self.createFileW(path_w.span(), flags);
    }
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .wasi) {
        <span class="tok-kw">return</span> .{
            .handle = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.openatWasi">openatWasi</a>(self.fd, sub_path, .{}, .{
                .CREAT = <span class="tok-null">true</span>,
                .TRUNC = flags.truncate,
                .EXCL = flags.exclusive,
            }, .{}, .{
                .FD_READ = flags.read,
                .FD_WRITE = <span class="tok-null">true</span>,
                .FD_DATASYNC = <span class="tok-null">true</span>,
                .FD_SEEK = <span class="tok-null">true</span>,
                .FD_TELL = <span class="tok-null">true</span>,
                .FD_FDSTAT_SET_FLAGS = <span class="tok-null">true</span>,
                .FD_SYNC = <span class="tok-null">true</span>,
                .FD_ALLOCATE = <span class="tok-null">true</span>,
                .FD_ADVISE = <span class="tok-null">true</span>,
                .FD_FILESTAT_SET_TIMES = <span class="tok-null">true</span>,
                .FD_FILESTAT_SET_SIZE = <span class="tok-null">true</span>,
                .FD_FILESTAT_GET = <span class="tok-null">true</span>,<span class="tok-comment">
                // POLL_FD_READWRITE only grants extra rights if the corresponding FD_READ and/or
                // FD_WRITE is also set.
                </span>.POLL_FD_READWRITE = <span class="tok-null">true</span>,
            }, .{}),
        };
    }
    <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sub_path);
    <span class="tok-kw">return</span> self.createFileZ(&amp;path_c, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.createFileZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">createFileZ</span><a href="#src.zig-std.fs.Dir.createFileZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.createFile">createFile</a></code> but the path parameter is null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.createFileZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {
        .windows =&gt; {
            <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(self.fd, sub_path_c);
            <span class="tok-kw">return</span> self.createFileW(path_w.span(), flags);
        },
        .wasi =&gt; {
            <span class="tok-kw">return</span> <a href="std.fs.Dir.html#std.fs.Dir.createFile">createFile</a>(self, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sub_path_c, <span class="tok-number">0</span>), flags);
        },
        <span class="tok-kw">else</span> =&gt; {},
    }

    <span class="tok-kw">var</span> os_flags: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a> = .{
        .ACCMODE = <span class="tok-kw">if</span> (flags.read) .RDWR <span class="tok-kw">else</span> .WRONLY,
        .CREAT = <span class="tok-null">true</span>,
        .TRUNC = flags.truncate,
        .EXCL = flags.exclusive,
    };
    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;LARGEFILE&quot;</span>)) os_flags.LARGEFILE = <span class="tok-null">true</span>;
    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;CLOEXEC&quot;</span>)) os_flags.CLOEXEC = <span class="tok-null">true</span>;<span class="tok-comment">

    // Use the O locking flags if the os supports them to acquire the lock
    // atomically. Note that the NONBLOCK flag is removed after the openat()
    // call is successful.
    </span><span class="tok-kw">const</span> has_flock_open_flags = <span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;EXLOCK&quot;</span>);
    <span class="tok-kw">if</span> (has_flock_open_flags) <span class="tok-kw">switch</span> (flags.lock) {
        .none =&gt; {},
        .shared =&gt; {
            os_flags.SHLOCK = <span class="tok-null">true</span>;
            os_flags.NONBLOCK = flags.lock_nonblocking;
        },
        .exclusive =&gt; {
            os_flags.EXLOCK = <span class="tok-null">true</span>;
            os_flags.NONBLOCK = flags.lock_nonblocking;
        },
    };

    <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.openatZ">openatZ</a>(self.fd, sub_path_c, os_flags, flags.mode);
    <span class="tok-kw">errdefer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(fd);

    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.have_flock">have_flock</a> <span class="tok-kw">and</span> !has_flock_open_flags <span class="tok-kw">and</span> flags.lock != .none) {<span class="tok-comment">
        // TODO: integrate async I/O
        </span><span class="tok-kw">const</span> lock_nonblocking: <span class="tok-type">i32</span> = <span class="tok-kw">if</span> (flags.lock_nonblocking) <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.NB">NB</a> <span class="tok-kw">else</span> <span class="tok-number">0</span>;
        <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.flock">flock</a>(fd, <span class="tok-kw">switch</span> (flags.lock) {
            .none =&gt; <span class="tok-kw">unreachable</span>,
            .shared =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.SH">SH</a> | lock_nonblocking,
            .exclusive =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.EX">EX</a> | lock_nonblocking,
        });
    }

    <span class="tok-kw">if</span> (has_flock_open_flags <span class="tok-kw">and</span> flags.lock_nonblocking) {
        <span class="tok-kw">var</span> fl_flags = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fcntl">fcntl</a>(fd, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.F">F</a>.<a href="#">GETFL</a>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        fl_flags &amp;= ~<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span> &lt;&lt; <span class="tok-builtin">@bitOffsetOf</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;NONBLOCK&quot;</span>));
        _ = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fcntl">fcntl</a>(fd, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.F">F</a>.<a href="#">SETFL</a>, fl_flags) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    }

    <span class="tok-kw">return</span> .{ .handle = fd };
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.createFileW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">createFileW</span><a href="#src.zig-std.fs.Dir.createFileW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.createFile">createFile</a></code> but Windows-only and the path parameter is
<a href="https://simonsapin.github.io/wtf-8/#potentially-ill-formed-utf-16">WTF-16</a> encoded.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.createFileW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <span class="tok-kw">const</span> w = <a href="std.os.windows.html">windows</a>;
    <span class="tok-kw">const</span> read_flag = <span class="tok-kw">if</span> (flags.read) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.GENERIC_READ) <span class="tok-kw">else</span> <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> file: <a href="std.fs.File.html">File</a> = .{
        .handle = <span class="tok-kw">try</span> w.OpenFile(sub_path_w, .{
            .dir = self.fd,
            .access_mask = w.SYNCHRONIZE | w.GENERIC_WRITE | read_flag,
            .creation = <span class="tok-kw">if</span> (flags.exclusive)
                <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.FILE_CREATE)
            <span class="tok-kw">else</span> <span class="tok-kw">if</span> (flags.truncate)
                <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.FILE_OVERWRITE_IF)
            <span class="tok-kw">else</span>
                <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.FILE_OPEN_IF),
        }),
    };
    <span class="tok-kw">errdefer</span> file.close();
    <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> range_off: w.LARGE_INTEGER = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> range_len: w.LARGE_INTEGER = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> exclusive = <span class="tok-kw">switch</span> (flags.lock) {
        .none =&gt; <span class="tok-kw">return</span> file,
        .shared =&gt; <span class="tok-null">false</span>,
        .exclusive =&gt; <span class="tok-null">true</span>,
    };
    <span class="tok-kw">try</span> w.LockFile(
        file.handle,
        <span class="tok-null">null</span>,
        <span class="tok-null">null</span>,
        <span class="tok-null">null</span>,
        &amp;io,
        &amp;range_off,
        &amp;range_len,
        <span class="tok-null">null</span>,
        <span class="tok-builtin">@intFromBool</span>(flags.lock_nonblocking),
        <span class="tok-builtin">@intFromBool</span>(exclusive),
    );
    <span class="tok-kw">return</span> file;
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.makeDir" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">makeDir</span><a href="#src.zig-std.fs.Dir.makeDir">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDir</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.MakeDirError">MakeError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Creates a single directory with a relative or absolute path.
To create multiple directories to make an entire path, see <code><a href="std.fs.Dir.html#std.fs.Dir.makePath">makePath</a></code>.
To operate on only absolute paths, see <code>makeDirAbsolute</code>.
On Windows, <code>sub_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>sub_path</code> should be encoded as valid UTF-8.
On other platforms, <code>sub_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.makeDir">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDir</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.MakeDirError">MakeError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mkdirat">mkdirat</a>(self.fd, sub_path, <a href="std.fs.Dir.html#std.fs.Dir.default_mode">default_mode</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.makeDirZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">makeDirZ</span><a href="#src.zig-std.fs.Dir.makeDirZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.MakeDirError">MakeError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.makeDir">makeDir</a></code>, but <code>sub_path</code> is null-terminated.
To create multiple directories to make an entire path, see <code><a href="std.fs.Dir.html#std.fs.Dir.makePath">makePath</a></code>.
To operate on only absolute paths, see <code>makeDirAbsoluteZ</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.makeDirZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.MakeDirError">MakeError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mkdiratZ">mkdiratZ</a>(self.fd, sub_path, <a href="std.fs.Dir.html#std.fs.Dir.default_mode">default_mode</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.makeDirW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">makeDirW</span><a href="#src.zig-std.fs.Dir.makeDirW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.MakeDirError">MakeError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Creates a single directory with a relative or absolute null-terminated WTF-16 LE-encoded path.
To create multiple directories to make an entire path, see <code><a href="std.fs.Dir.html#std.fs.Dir.makePath">makePath</a></code>.
To operate on only absolute paths, see <code>makeDirAbsoluteW</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.makeDirW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.MakeDirError">MakeError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mkdiratW">mkdiratW</a>(self.fd, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(sub_path), <a href="std.fs.Dir.html#std.fs.Dir.default_mode">default_mode</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.makePath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">makePath</span><a href="#src.zig-std.fs.Dir.makePath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makePath</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) (<a href="std.posix.html#std.posix.MakeDirError">MakeError</a> || <a href="std.fs.Dir.html#std.fs.Dir.StatFileError">StatFileError</a>)!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Calls makeDir iteratively to make an entire path
(i.e. creating any parent directories that do not exist).
Returns success if the path already exists and is a directory.
This function is not atomic, and if it returns an error, the file system may
have been modified regardless.
On Windows, <code>sub_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>sub_path</code> should be encoded as valid UTF-8.
On other platforms, <code>sub_path</code> is an opaque sequence of bytes with no particular encoding.</p>
<p>Paths containing <code>..</code> components are handled differently depending on the platform:</p>
<ul>
<li>On Windows, <code>..</code> are resolved before the path is passed to NtCreateFile, meaning
a <code>sub_path</code> like &quot;first/../second&quot; will resolve to &quot;second&quot; and only a
<code>./second</code> directory will be created.</li>
<li>On other platforms, <code>..</code> are not resolved before the path is passed to <code>mkdirat</code>,
meaning a <code>sub_path</code> like &quot;first/../second&quot; will create both a <code>./first</code>
and a <code>./second</code> directory.</li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.makePath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makePath</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) (<a href="std.posix.html#std.posix.MakeDirError">MakeError</a> || <a href="std.fs.Dir.html#std.fs.Dir.StatFileError">StatFileError</a>)!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> it = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.componentIterator">componentIterator</a>(sub_path);
    <span class="tok-kw">var</span> component = it.last() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        self.makeDir(component.path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.PathAlreadyExists =&gt; {<span class="tok-comment">
                // stat the file and return an error if it's not a directory
                // this is important because otherwise a dangling symlink
                // could cause an infinite loop
                </span>check_dir: {<span class="tok-comment">
                    // workaround for windows, see https://github.com/ziglang/zig/issues/16738
                    </span><span class="tok-kw">const</span> fstat = self.statFile(component.path) <span class="tok-kw">catch</span> |stat_err| <span class="tok-kw">switch</span> (stat_err) {
                        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">break</span> :check_dir,
                        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
                    };
                    <span class="tok-kw">if</span> (fstat.kind != .directory) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir;
                }
            },
            <span class="tok-kw">error</span>.FileNotFound =&gt; |e| {
                component = it.previous() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> e;
                <span class="tok-kw">continue</span>;
            },
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        component = it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.makeOpenPath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">makeOpenPath</span><a href="#src.zig-std.fs.Dir.makeOpenPath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeOpenPath</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, open_dir_options: <a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) (<a href="std.posix.html#std.posix.MakeDirError">MakeError</a> || <a href="std.fs.Dir.html#std.fs.Dir.OpenError">OpenError</a> || <a href="std.fs.Dir.html#std.fs.Dir.StatFileError">StatFileError</a>)!<a href="std.fs.Dir.html">Dir</a></code></pre></div><div class="tldDocs"><p>This function performs <code><a href="std.fs.Dir.html#std.fs.Dir.makePath">makePath</a></code>, followed by <code><a href="std.fs.Dir.html#std.fs.Dir.openDir">openDir</a></code>.
If supported by the OS, this operation is atomic. It is not atomic on
all operating systems.
On Windows, <code>sub_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>sub_path</code> should be encoded as valid UTF-8.
On other platforms, <code>sub_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>open_dir_options: <a href="std.fs.Dir.OpenOptions.html">OpenOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.makeOpenPath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeOpenPath</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, open_dir_options: <a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) (<a href="std.posix.html#std.posix.MakeDirError">MakeError</a> || <a href="std.fs.Dir.html#std.fs.Dir.OpenError">OpenError</a> || <a href="std.fs.Dir.html#std.fs.Dir.StatFileError">StatFileError</a>)!<a href="std.fs.Dir.html">Dir</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {
        .windows =&gt; {
            <span class="tok-kw">const</span> w = <a href="std.os.windows.html">windows</a>;
            <span class="tok-kw">const</span> base_flags = w.STANDARD_RIGHTS_READ | w.FILE_READ_ATTRIBUTES | w.FILE_READ_EA |
                w.SYNCHRONIZE | w.FILE_TRAVERSE |
                (<span class="tok-kw">if</span> (open_dir_options.iterate) w.FILE_LIST_DIRECTORY <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>));

            <span class="tok-kw">return</span> self.makeOpenPathAccessMaskW(sub_path, base_flags, open_dir_options.no_follow);
        },
        <span class="tok-kw">else</span> =&gt; {
            <span class="tok-kw">return</span> self.openDir(sub_path, open_dir_options) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.FileNotFound =&gt; {
                    <span class="tok-kw">try</span> self.makePath(sub_path);
                    <span class="tok-kw">return</span> self.openDir(sub_path, open_dir_options);
                },
                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.realpath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">realpath</span><a href="#src.zig-std.fs.Dir.realpath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpath</span>(self: <a href="std.fs.Dir.html">Dir</a>, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>This function returns the canonicalized absolute pathname of
<code>pathname</code> relative to this <code><a href="std.fs.Dir.html">Dir</a></code>. If <code>pathname</code> is absolute, ignores this
<code><a href="std.fs.Dir.html">Dir</a></code> handle and returns the canonicalized absolute pathname of <code>pathname</code>
argument.
On Windows, <code>sub_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On other platforms, <code>sub_path</code> is an opaque sequence of bytes with no particular encoding.
On Windows, the result is encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On other platforms, the result is an opaque sequence of bytes with no particular encoding.
This function is not universally supported by all platforms.
Currently supported hosts are: Linux, macOS, and Windows.
See also <code><a href="std.fs.Dir.html#std.fs.Dir.realpathZ">Dir.realpathZ</a></code>, <code><a href="std.fs.Dir.html#std.fs.Dir.realpathW">Dir.realpathW</a></code>, and <code><a href="std.fs.Dir.html#std.fs.Dir.realpathAlloc">Dir.realpathAlloc</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>out_buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.realpath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpath</span>(self: <a href="std.fs.Dir.html">Dir</a>, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .wasi) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;realpath is not available on WASI&quot;</span>);
    }
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> pathname_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(self.fd, pathname);
        <span class="tok-kw">return</span> self.realpathW(pathname_w.span(), out_buffer);
    }
    <span class="tok-kw">const</span> pathname_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(pathname);
    <span class="tok-kw">return</span> self.realpathZ(&amp;pathname_c, out_buffer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.realpathZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">realpathZ</span><a href="#src.zig-std.fs.Dir.realpathZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.realpath">Dir.realpath</a></code> except <code>pathname</code> is null-terminated.
See also <code><a href="std.fs.Dir.html#std.fs.Dir.realpath">Dir.realpath</a></code>, <code><a href="std.fs.Dir.html#std.fs.Dir.realpathZ">realpathZ</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>out_buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.realpathZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> pathname_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(self.fd, pathname);
        <span class="tok-kw">return</span> self.realpathW(pathname_w.span(), out_buffer);
    }

    <span class="tok-kw">var</span> flags: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a> = .{};
    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;NONBLOCK&quot;</span>)) flags.NONBLOCK = <span class="tok-null">true</span>;
    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;CLOEXEC&quot;</span>)) flags.CLOEXEC = <span class="tok-null">true</span>;
    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;PATH&quot;</span>)) flags.PATH = <span class="tok-null">true</span>;

    <span class="tok-kw">const</span> fd = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.openatZ">openatZ</a>(self.fd, pathname, flags, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // WASI-only
        </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
    <span class="tok-kw">defer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(fd);

    <span class="tok-kw">var</span> buffer: [<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> out_path = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.getFdPath">getFdPath</a>(fd, &amp;buffer);

    <span class="tok-kw">if</span> (out_path.len &gt; out_buffer.len) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
    }

    <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..out_path.len];
    <span class="tok-builtin">@memcpy</span>(result, out_path);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.realpathW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">realpathW</span><a href="#src.zig-std.fs.Dir.realpathW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathW</span>(self: <a href="std.fs.Dir.html">Dir</a>, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Windows-only. Same as <code><a href="std.fs.Dir.html#std.fs.Dir.realpath">Dir.realpath</a></code> except <code>pathname</code> is WTF16 LE encoded.
The result is encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
See also <code><a href="std.fs.Dir.html#std.fs.Dir.realpath">Dir.realpath</a></code>, <code><a href="std.fs.Dir.html#std.fs.Dir.realpathW">realpathW</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>pathname: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>out_buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.realpathW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathW</span>(self: <a href="std.fs.Dir.html">Dir</a>, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> w = <a href="std.os.windows.html">windows</a>;

    <span class="tok-kw">const</span> access_mask = w.GENERIC_READ | w.SYNCHRONIZE;
    <span class="tok-kw">const</span> share_access = w.FILE_SHARE_READ | w.FILE_SHARE_WRITE | w.FILE_SHARE_DELETE;
    <span class="tok-kw">const</span> creation = w.FILE_OPEN;
    <span class="tok-kw">const</span> h_file = blk: {
        <span class="tok-kw">const</span> res = w.OpenFile(pathname, .{
            .dir = self.fd,
            .access_mask = access_mask,
            .share_access = share_access,
            .creation = creation,
            .filter = .any,
        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        <span class="tok-kw">break</span> :blk res;
    };
    <span class="tok-kw">defer</span> w.CloseHandle(h_file);

    <span class="tok-kw">var</span> wide_buf: [w.PATH_MAX_WIDE]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> wide_slice = <span class="tok-kw">try</span> w.GetFinalPathNameByHandle(h_file, .{}, &amp;wide_buf);
    <span class="tok-kw">const</span> len = <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.calcWtf8Len">calcWtf8Len</a>(wide_slice);
    <span class="tok-kw">if</span> (len &gt; out_buffer.len)
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
    <span class="tok-kw">const</span> end_index = <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf16LeToWtf8">wtf16LeToWtf8</a>(out_buffer, wide_slice);
    <span class="tok-kw">return</span> out_buffer[<span class="tok-number">0</span>..end_index];
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.realpathAlloc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">realpathAlloc</span><a href="#src.zig-std.fs.Dir.realpathAlloc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathAlloc</span>(self: <a href="std.fs.Dir.html">Dir</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html#std.fs.Dir.RealPathAllocError">RealPathAllocError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.realpath">Dir.realpath</a></code> except caller must free the returned memory.
See also <code><a href="std.fs.Dir.html#std.fs.Dir.realpath">Dir.realpath</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.realpathAlloc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathAlloc</span>(self: <a href="std.fs.Dir.html">Dir</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html#std.fs.Dir.RealPathAllocError">RealPathAllocError</a>![]<span class="tok-type">u8</span> {<span class="tok-comment">
    // Use of max_path_bytes here is valid as the realpath function does not
    // have a variant that takes an arbitrary-size buffer.
    // TODO(#4812): Consider reimplementing realpath or using the POSIX.1-2008
    // NULL out parameter (GNU's canonicalize_file_name) to handle overelong
    // paths. musl supports passing NULL but restricts the output to PATH_MAX
    // anyway.
    </span><span class="tok-kw">var</span> buf: [<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> self.realpath(pathname, buf[<span class="tok-number">0</span>..]));
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.setAsCwd" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setAsCwd</span><a href="#src.zig-std.fs.Dir.setAsCwd">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setAsCwd</span>(self: <a href="std.fs.Dir.html">Dir</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Changes the current working directory to the open directory handle.
This modifies global state and can have surprising effects in multi-
threaded applications. Most applications and especially libraries should
not call this function as a general rule, however it can have use cases
in, for example, implementing a shell, or child process execution.
Not all targets support this. For example, WASI does not have the concept
of a current working directory.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.setAsCwd">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setAsCwd</span>(self: <a href="std.fs.Dir.html">Dir</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .wasi) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;changing cwd is not currently possible in WASI&quot;</span>);
    }
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">var</span> dir_path_buffer: [<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PATH_MAX_WIDE">PATH_MAX_WIDE</a>]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> dir_path = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetFinalPathNameByHandle">GetFinalPathNameByHandle</a>(self.fd, .{}, &amp;dir_path_buffer);
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
            <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.chdirW">chdirW</a>(dir_path);
        }
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SetCurrentDirectory">SetCurrentDirectory</a>(dir_path);
    }
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fchdir">fchdir</a>(self.fd);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.openDir" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">openDir</span><a href="#src.zig-std.fs.Dir.openDir">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDir</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) <a href="std.fs.Dir.html#std.fs.Dir.OpenError">OpenError</a>!<a href="std.fs.Dir.html">Dir</a></code></pre></div><div class="tldDocs"><p>Opens a directory at the given path. The directory is a system resource that remains
open until <code><a href="std.fs.Dir.html#std.fs.Dir.close">close</a></code> is called on the result.
The directory cannot be iterated unless the <code><a href="std.fs.Dir.html#std.fs.Dir.iterate">iterate</a></code> option is set to <code>true</code>.</p>
<p>On Windows, <code>sub_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>sub_path</code> should be encoded as valid UTF-8.
On other platforms, <code>sub_path</code> is an opaque sequence of bytes with no particular encoding.
Asserts that the path parameter has no null bytes.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>args: <a href="std.fs.Dir.OpenOptions.html">OpenOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.openDir">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDir</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) <a href="std.fs.Dir.html#std.fs.Dir.OpenError">OpenError</a>!<a href="std.fs.Dir.html">Dir</a> {
    <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {
        .windows =&gt; {
            <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(self.fd, sub_path);
            <span class="tok-kw">return</span> self.openDirW(sub_path_w.span().ptr, args);
        },
        .wasi =&gt; <span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
            <span class="tok-kw">var</span> base: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.rights_t.html">rights_t</a> = .{
                .FD_FILESTAT_GET = <span class="tok-null">true</span>,
                .FD_FDSTAT_SET_FLAGS = <span class="tok-null">true</span>,
                .FD_FILESTAT_SET_TIMES = <span class="tok-null">true</span>,
            };
            <span class="tok-kw">if</span> (args.access_sub_paths) {
                base.FD_READDIR = <span class="tok-null">true</span>;
                base.PATH_CREATE_DIRECTORY = <span class="tok-null">true</span>;
                base.PATH_CREATE_FILE = <span class="tok-null">true</span>;
                base.PATH_LINK_SOURCE = <span class="tok-null">true</span>;
                base.PATH_LINK_TARGET = <span class="tok-null">true</span>;
                base.PATH_OPEN = <span class="tok-null">true</span>;
                base.PATH_READLINK = <span class="tok-null">true</span>;
                base.PATH_RENAME_SOURCE = <span class="tok-null">true</span>;
                base.PATH_RENAME_TARGET = <span class="tok-null">true</span>;
                base.PATH_FILESTAT_GET = <span class="tok-null">true</span>;
                base.PATH_FILESTAT_SET_SIZE = <span class="tok-null">true</span>;
                base.PATH_FILESTAT_SET_TIMES = <span class="tok-null">true</span>;
                base.PATH_SYMLINK = <span class="tok-null">true</span>;
                base.PATH_REMOVE_DIRECTORY = <span class="tok-null">true</span>;
                base.PATH_UNLINK_FILE = <span class="tok-null">true</span>;
            }

            <span class="tok-kw">const</span> result = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.openatWasi">openatWasi</a>(
                self.fd,
                sub_path,
                .{ .SYMLINK_FOLLOW = !args.no_follow },
                .{ .DIRECTORY = <span class="tok-null">true</span> },
                .{},
                base,
                base,
            );
            <span class="tok-kw">const</span> fd = result <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.FileTooBig =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // can't happen for directories
                </span><span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // we're setting DIRECTORY
                </span><span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not setting CREAT
                </span><span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not setting CREAT
                </span><span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // locking folders is not supported
                </span><span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // can't happen for directories
                </span><span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // can't happen for directories
                </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };
            <span class="tok-kw">return</span> .{ .fd = fd };
        },
        <span class="tok-kw">else</span> =&gt; {},
    }
    <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sub_path);
    <span class="tok-kw">return</span> self.openDirZ(&amp;sub_path_c, args);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.openDirZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">openDirZ</span><a href="#src.zig-std.fs.Dir.openDirZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) <a href="std.fs.Dir.html#std.fs.Dir.OpenError">OpenError</a>!<a href="std.fs.Dir.html">Dir</a></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.openDir">openDir</a></code> except the parameter is null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>args: <a href="std.fs.Dir.OpenOptions.html">OpenOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.openDirZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) <a href="std.fs.Dir.html#std.fs.Dir.OpenError">OpenError</a>!<a href="std.fs.Dir.html">Dir</a> {
    <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {
        .windows =&gt; {
            <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(self.fd, sub_path_c);
            <span class="tok-kw">return</span> self.openDirW(sub_path_w.span().ptr, args);
        },<span class="tok-comment">
        // Use the libc API when libc is linked because it implements things
        // such as opening absolute directory paths.
        </span>.wasi =&gt; <span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
            <span class="tok-kw">return</span> <a href="std.fs.Dir.html#std.fs.Dir.openDir">openDir</a>(self, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sub_path_c, <span class="tok-number">0</span>), args);
        },
        .haiku =&gt; {
            <span class="tok-kw">const</span> rc = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">_kern_open_dir</a>(self.fd, sub_path_c);
            <span class="tok-kw">if</span> (rc &gt;= <span class="tok-number">0</span>) <span class="tok-kw">return</span> .{ .fd = rc };
            <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>, <span class="tok-builtin">@enumFromInt</span>(rc))) {
                .FAULT =&gt; <span class="tok-kw">unreachable</span>,
                .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                .BADF =&gt; <span class="tok-kw">unreachable</span>,
                .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
                .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
                .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
                .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
                .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoDevice,
                .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
                .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
                .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeviceBusy,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
        },
        <span class="tok-kw">else</span> =&gt; {},
    }

    <span class="tok-kw">var</span> symlink_flags: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a> = <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {
        .wasi =&gt; .{
            .read = <span class="tok-null">true</span>,
            .NOFOLLOW = args.no_follow,
            .DIRECTORY = <span class="tok-null">true</span>,
        },
        <span class="tok-kw">else</span> =&gt; .{
            .ACCMODE = .RDONLY,
            .NOFOLLOW = args.no_follow,
            .DIRECTORY = <span class="tok-null">true</span>,
            .CLOEXEC = <span class="tok-null">true</span>,
        },
    };

    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;PATH&quot;</span>) <span class="tok-kw">and</span> !args.iterate)
        symlink_flags.PATH = <span class="tok-null">true</span>;

    <span class="tok-kw">return</span> self.openDirFlagsZ(sub_path_c, symlink_flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.openDirW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">openDirW</span><a href="#src.zig-std.fs.Dir.openDirW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, args: <a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) <a href="std.fs.Dir.html#std.fs.Dir.OpenError">OpenError</a>!<a href="std.fs.Dir.html">Dir</a></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.openDir">openDir</a></code> except the path parameter is WTF-16 LE encoded, NT-prefixed.
This function asserts the target OS is Windows.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>args: <a href="std.fs.Dir.OpenOptions.html">OpenOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.openDirW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, args: <a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) <a href="std.fs.Dir.html#std.fs.Dir.OpenError">OpenError</a>!<a href="std.fs.Dir.html">Dir</a> {
    <span class="tok-kw">const</span> w = <a href="std.os.windows.html">windows</a>;<span class="tok-comment">
    // TODO remove some of these flags if args.access_sub_paths is false
    </span><span class="tok-kw">const</span> base_flags = w.STANDARD_RIGHTS_READ | w.FILE_READ_ATTRIBUTES | w.FILE_READ_EA |
        w.SYNCHRONIZE | w.FILE_TRAVERSE;
    <span class="tok-kw">const</span> flags: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (args.iterate) base_flags | w.FILE_LIST_DIRECTORY <span class="tok-kw">else</span> base_flags;
    <span class="tok-kw">const</span> dir = self.makeOpenDirAccessMaskW(sub_path_w, flags, .{
        .no_follow = args.no_follow,
        .create_disposition = w.FILE_OPEN,
    }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.ReadOnlyFileSystem =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.DiskQuota =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.LinkQuotaExceeded =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
    <span class="tok-kw">return</span> dir;
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.deleteFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deleteFile</span><a href="#src.zig-std.fs.Dir.deleteFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.UnlinkError">DeleteFileError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Delete a file name and possibly the file it refers to, based on an open directory handle.
On Windows, <code>sub_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>sub_path</code> should be encoded as valid UTF-8.
On other platforms, <code>sub_path</code> is an opaque sequence of bytes with no particular encoding.
Asserts that the path parameter has no null bytes.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.deleteFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.UnlinkError">DeleteFileError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(self.fd, sub_path);
        <span class="tok-kw">return</span> self.deleteFileW(sub_path_w.span());
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unlinkat">unlinkat</a>(self.fd, sub_path, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not passing AT.REMOVEDIR
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sub_path);
        <span class="tok-kw">return</span> self.deleteFileZ(&amp;sub_path_c);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.deleteFileZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deleteFileZ</span><a href="#src.zig-std.fs.Dir.deleteFileZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.UnlinkError">DeleteFileError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.deleteFile">deleteFile</a></code> except the parameter is null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.deleteFileZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.UnlinkError">DeleteFileError</a>!<span class="tok-type">void</span> {
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unlinkatZ">unlinkatZ</a>(self.fd, sub_path_c, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not passing AT.REMOVEDIR
        </span><span class="tok-kw">error</span>.AccessDenied =&gt; |e| <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {<span class="tok-comment">
            // non-Linux POSIX systems return EPERM when trying to delete a directory, so
            // we need to handle that case specifically and translate the error
            </span>.macos, .ios, .freebsd, .netbsd, .dragonfly, .openbsd, .solaris, .illumos =&gt; {<span class="tok-comment">
                // Don't follow symlinks to match unlinkat (which acts on symlinks rather than follows them)
                </span><span class="tok-kw">const</span> fstat = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fstatatZ">fstatatZ</a>(self.fd, sub_path_c, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">SYMLINK_NOFOLLOW</a>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> e;
                <span class="tok-kw">const</span> is_dir = fstat.mode &amp; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFMT</a> == <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFDIR</a>;
                <span class="tok-kw">return</span> <span class="tok-kw">if</span> (is_dir) <span class="tok-kw">error</span>.IsDir <span class="tok-kw">else</span> e;
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> e,
        },
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.deleteFileW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deleteFileW</span><a href="#src.zig-std.fs.Dir.deleteFileW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.UnlinkError">DeleteFileError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.deleteFile">deleteFile</a></code> except the parameter is WTF-16 LE encoded.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.deleteFileW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.UnlinkError">DeleteFileError</a>!<span class="tok-type">void</span> {
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unlinkatW">unlinkatW</a>(self.fd, sub_path_w, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not passing AT.REMOVEDIR
        </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.deleteDir" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deleteDir</span><a href="#src.zig-std.fs.Dir.deleteDir">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDir</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html#std.fs.Dir.DeleteDirError">DeleteDirError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Returns <code>error.DirNotEmpty</code> if the directory is not empty.
To delete a directory recursively, see <code><a href="std.fs.Dir.html#std.fs.Dir.deleteTree">deleteTree</a></code>.
On Windows, <code>sub_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>sub_path</code> should be encoded as valid UTF-8.
On other platforms, <code>sub_path</code> is an opaque sequence of bytes with no particular encoding.
Asserts that the path parameter has no null bytes.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.deleteDir">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDir</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html#std.fs.Dir.DeleteDirError">DeleteDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(self.fd, sub_path);
        <span class="tok-kw">return</span> self.deleteDirW(sub_path_w.span());
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unlinkat">unlinkat</a>(self.fd, sub_path, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">REMOVEDIR</a>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not possible since we pass AT.REMOVEDIR
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sub_path);
        <span class="tok-kw">return</span> self.deleteDirZ(&amp;sub_path_c);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.deleteDirZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deleteDirZ</span><a href="#src.zig-std.fs.Dir.deleteDirZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html#std.fs.Dir.DeleteDirError">DeleteDirError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.deleteDir">deleteDir</a></code> except the parameter is null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.deleteDirZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html#std.fs.Dir.DeleteDirError">DeleteDirError</a>!<span class="tok-type">void</span> {
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unlinkatZ">unlinkatZ</a>(self.fd, sub_path_c, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">REMOVEDIR</a>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not possible since we pass AT.REMOVEDIR
        </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.deleteDirW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deleteDirW</span><a href="#src.zig-std.fs.Dir.deleteDirW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.fs.Dir.html#std.fs.Dir.DeleteDirError">DeleteDirError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.deleteDir">deleteDir</a></code> except the parameter is WTF16LE, NT prefixed.
This function is Windows-only.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.deleteDirW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.fs.Dir.html#std.fs.Dir.DeleteDirError">DeleteDirError</a>!<span class="tok-type">void</span> {
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unlinkatW">unlinkatW</a>(self.fd, sub_path_w, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">REMOVEDIR</a>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not possible since we pass AT.REMOVEDIR
        </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.rename" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rename</span><a href="#src.zig-std.fs.Dir.rename">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rename</span>(self: <a href="std.fs.Dir.html">Dir</a>, old_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Change the name or location of a file or directory.
If new_sub_path already exists, it will be replaced.
Renaming a file over an existing directory or a directory
over an existing file will fail with <code>error.IsDir</code> or <code>error.NotDir</code>
On Windows, both paths should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, both paths should be encoded as valid UTF-8.
On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>old_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>new_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.rename">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rename</span>(self: <a href="std.fs.Dir.html">Dir</a>, old_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.renameat">renameat</a>(self.fd, old_sub_path, self.fd, new_sub_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.renameZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">renameZ</span><a href="#src.zig-std.fs.Dir.renameZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, old_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.rename">rename</a></code> except the parameters are null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>old_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>new_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.renameZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, old_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.renameatZ">renameatZ</a>(self.fd, old_sub_path_z, self.fd, new_sub_path_z);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.renameW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">renameW</span><a href="#src.zig-std.fs.Dir.renameW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameW</span>(self: <a href="std.fs.Dir.html">Dir</a>, old_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, new_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.rename">rename</a></code> except the parameters are WTF16LE, NT prefixed.
This function is Windows-only.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>old_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>new_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.renameW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameW</span>(self: <a href="std.fs.Dir.html">Dir</a>, old_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, new_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.renameatW">renameatW</a>(self.fd, old_sub_path_w, self.fd, new_sub_path_w, <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TRUE">TRUE</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.symLink" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">symLink</span><a href="#src.zig-std.fs.Dir.symLink">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLink</span>( self: <a href="std.fs.Dir.html">Dir</a>, target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>, ) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Creates a symbolic link named <code>sym_link_path</code> which contains the string <code>target_path</code>.
A symbolic link (also known as a soft link) may point to an existing file or to a nonexistent
one; the latter case is known as a dangling link.
If <code>sym_link_path</code> exists, it will not be overwritten.
On Windows, both paths should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, both paths should be encoded as valid UTF-8.
On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.symLink">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLink</span>(
    self: <a href="std.fs.Dir.html">Dir</a>,
    target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> self.symLinkWasi(target_path, sym_link_path, flags);
    }
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {<span class="tok-comment">
        // Target path does not use sliceToPrefixedFileW because certain paths
        // are handled differently when creating a symlink than they would be
        // when converting to an NT namespaced path. CreateSymbolicLink in
        // symLinkW will handle the necessary conversion.
        </span><span class="tok-kw">var</span> target_path_w: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.PathSpace.html">PathSpace</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.checkWtf8ToWtf16LeOverflow">checkWtf8ToWtf16LeOverflow</a>(target_path, &amp;target_path_w.data)) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
        }
        target_path_w.len = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16Le">wtf8ToWtf16Le</a>(&amp;target_path_w.data, target_path);
        target_path_w.data[target_path_w.len] = <span class="tok-number">0</span>;<span class="tok-comment">
        // However, we need to canonicalize any path separators to `\`, since if
        // the target path is relative, then it must use `\` as the path separator.
        </span><a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.replaceScalar">replaceScalar</a>(
            <span class="tok-type">u16</span>,
            target_path_w.data[<span class="tok-number">0</span>..target_path_w.len],
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.nativeToLittle">nativeToLittle</a>(<span class="tok-type">u16</span>, <span class="tok-str">'/'</span>),
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.nativeToLittle">nativeToLittle</a>(<span class="tok-type">u16</span>, <span class="tok-str">'\\'</span>),
        );

        <span class="tok-kw">const</span> sym_link_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(self.fd, sym_link_path);
        <span class="tok-kw">return</span> self.symLinkW(target_path_w.span(), sym_link_path_w.span(), flags);
    }
    <span class="tok-kw">const</span> target_path_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(target_path);
    <span class="tok-kw">const</span> sym_link_path_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sym_link_path);
    <span class="tok-kw">return</span> self.symLinkZ(&amp;target_path_c, &amp;sym_link_path_c, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.symLinkWasi" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">symLinkWasi</span><a href="#src.zig-std.fs.Dir.symLinkWasi">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkWasi</span>( self: <a href="std.fs.Dir.html">Dir</a>, target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, _: <a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>, ) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>WASI-only. Same as <code><a href="std.fs.Dir.html#std.fs.Dir.symLink">symLink</a></code> except targeting WASI.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>_: <a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.symLinkWasi">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkWasi</span>(
    self: <a href="std.fs.Dir.html">Dir</a>,
    target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    _: <a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.symlinkat">symlinkat</a>(target_path, self.fd, sym_link_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.symLinkZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">symLinkZ</span><a href="#src.zig-std.fs.Dir.symLinkZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkZ</span>( self: <a href="std.fs.Dir.html">Dir</a>, target_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, sym_link_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>, ) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.symLink">symLink</a></code>, except the pathname parameters are null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>target_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>sym_link_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.symLinkZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkZ</span>(
    self: <a href="std.fs.Dir.html">Dir</a>,
    target_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    sym_link_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> target_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(self.fd, target_path_c);
        <span class="tok-kw">const</span> sym_link_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(self.fd, sym_link_path_c);
        <span class="tok-kw">return</span> self.symLinkW(target_path_w.span(), sym_link_path_w.span(), flags);
    }
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.symlinkatZ">symlinkatZ</a>(target_path_c, self.fd, sym_link_path_c);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.symLinkW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">symLinkW</span><a href="#src.zig-std.fs.Dir.symLinkW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkW</span>( self: <a href="std.fs.Dir.html">Dir</a>, target_path_w: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, sym_link_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>, ) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Windows-only. Same as <code><a href="std.fs.Dir.html#std.fs.Dir.symLink">symLink</a></code> except the pathname parameters
are WTF16 LE encoded.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>target_path_w: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre><div class="fieldDocs"><p>WTF-16, does not need to be NT-prefixed. The NT-prefixing
of this path is handled by CreateSymbolicLink.
Any path separators must be <code>\</code>, not <code>/</code>.</p>
</div></div><div><pre><code>sym_link_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre><div class="fieldDocs"><p>WTF-16, must be NT-prefixed or relative</p>
</div></div><div><pre><code>flags: <a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.symLinkW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkW</span>(
    self: <a href="std.fs.Dir.html">Dir</a>,
    <span class="tok-comment">/// WTF-16, does not need to be NT-prefixed. The NT-prefixing</span>
    <span class="tok-comment">/// of this path is handled by CreateSymbolicLink.</span>
    <span class="tok-comment">/// Any path separators must be `\`, not `/`.</span>
    target_path_w: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>,
    <span class="tok-comment">/// WTF-16, must be NT-prefixed or relative</span>
    sym_link_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>,
    flags: <a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CreateSymbolicLink">CreateSymbolicLink</a>(self.fd, sym_link_path_w, target_path_w, flags.is_directory);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.atomicSymLink" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">atomicSymLink</span><a href="#src.zig-std.fs.Dir.atomicSymLink">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">atomicSymLink</span>( dir: <a href="std.fs.Dir.html">Dir</a>, target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>, ) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.symLink">symLink</a></code>, except tries to create the symbolic link until it
succeeds or encounters an error other than <code>error.PathAlreadyExists</code>.
On Windows, both paths should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, both paths should be encoded as valid UTF-8.
On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.atomicSymLink">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">atomicSymLink</span>(
    dir: <a href="std.fs.Dir.html">Dir</a>,
    target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (dir.symLink(target_path, sym_link_path, flags)) {
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.PathAlreadyExists =&gt; {},
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    }

    <span class="tok-kw">const</span> dirname = <a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(sym_link_path) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;.&quot;</span>;

    <span class="tok-kw">var</span> rand_buf: [<a href="std.fs.AtomicFile.html">AtomicFile</a>.<a href="std.fs.AtomicFile.html#std.fs.AtomicFile.random_bytes_len">random_bytes_len</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">const</span> temp_path_len = dirname.len + <span class="tok-number">1</span> + <a href="std.fs.html#std.fs.base64_encoder">base64_encoder</a>.<a href="#">calcSize</a>(rand_buf.len);
    <span class="tok-kw">var</span> temp_path_buf: [<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">if</span> (temp_path_len &gt; temp_path_buf.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
    <span class="tok-builtin">@memcpy</span>(temp_path_buf[<span class="tok-number">0</span>..dirname.len], dirname);
    temp_path_buf[dirname.len] = <a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep">sep</a>;

    <span class="tok-kw">const</span> temp_path = temp_path_buf[<span class="tok-number">0</span>..temp_path_len];

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <a href="std.crypto.html">crypto</a>.<a href="std.crypto.tlcsprng.html#std.crypto.tlcsprng.interface">random</a>.<a href="#">bytes</a>(rand_buf[<span class="tok-number">0</span>..]);
        _ = <a href="std.fs.html#std.fs.base64_encoder">base64_encoder</a>.<a href="#">encode</a>(temp_path[dirname.len + <span class="tok-number">1</span> ..], rand_buf[<span class="tok-number">0</span>..]);

        <span class="tok-kw">if</span> (dir.symLink(target_path, temp_path, flags)) {
            <span class="tok-kw">return</span> dir.rename(temp_path, sym_link_path);
        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">continue</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.readLink" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readLink</span><a href="#src.zig-std.fs.Dir.readLink">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLink</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Read value of a symbolic link.
The return value is a slice of <code>buffer</code>, from index <code>0</code>.
Asserts that the path parameter has no null bytes.
On Windows, <code>sub_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>sub_path</code> should be encoded as valid UTF-8.
On other platforms, <code>sub_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.readLink">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLink</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> self.readLinkWasi(sub_path, buffer);
    }
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(self.fd, sub_path);
        <span class="tok-kw">return</span> self.readLinkW(sub_path_w.span(), buffer);
    }
    <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sub_path);
    <span class="tok-kw">return</span> self.readLinkZ(&amp;sub_path_c, buffer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.readLinkWasi" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readLinkWasi</span><a href="#src.zig-std.fs.Dir.readLinkWasi">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkWasi</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>WASI-only. Same as <code><a href="std.fs.Dir.html#std.fs.Dir.readLink">readLink</a></code> except targeting WASI.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.readLinkWasi">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkWasi</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.readlinkat">readlinkat</a>(self.fd, sub_path, buffer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.readLinkZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readLinkZ</span><a href="#src.zig-std.fs.Dir.readLinkZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.readLink">readLink</a></code>, except the <code>sub_path_c</code> parameter is null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.readLinkZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(self.fd, sub_path_c);
        <span class="tok-kw">return</span> self.readLinkW(sub_path_w.span(), buffer);
    }
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.readlinkatZ">readlinkatZ</a>(self.fd, sub_path_c, buffer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.readLinkW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readLinkW</span><a href="#src.zig-std.fs.Dir.readLinkW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Windows-only. Same as <code><a href="std.fs.Dir.html#std.fs.Dir.readLink">readLink</a></code> except the pathname parameter
is WTF16 LE encoded.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.readLinkW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ReadLink">ReadLink</a>(self.fd, sub_path_w, buffer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.readFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readFile</span><a href="#src.zig-std.fs.Dir.readFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Read all of file contents using a preallocated buffer.
The returned slice has the same pointer as <code>buffer</code>. If the length matches <code>buffer.len</code>
the situation is ambiguous. It could either mean that the entire file was read, and
it exactly fits the buffer, or it could mean the buffer was not big enough for the
entire file.
On Windows, <code>file_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>file_path</code> should be encoded as valid UTF-8.
On other platforms, <code>file_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.readFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> self.openFile(file_path, .{});
    <span class="tok-kw">defer</span> file.close();

    <span class="tok-kw">const</span> end_index = <span class="tok-kw">try</span> file.readAll(buffer);
    <span class="tok-kw">return</span> buffer[<span class="tok-number">0</span>..end_index];
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.readFileAlloc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readFileAlloc</span><a href="#src.zig-std.fs.Dir.readFileAlloc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFileAlloc</span>(self: <a href="std.fs.Dir.html">Dir</a>, allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_bytes: <span class="tok-type">usize</span>) ![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>On success, caller owns returned buffer.
If the file is larger than <code>max_bytes</code>, returns <code>error.FileTooBig</code>.
On Windows, <code>file_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>file_path</code> should be encoded as valid UTF-8.
On other platforms, <code>file_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>max_bytes: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.readFileAlloc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFileAlloc</span>(self: <a href="std.fs.Dir.html">Dir</a>, allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_bytes: <span class="tok-type">usize</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> self.readFileAllocOptions(allocator, file_path, max_bytes, <span class="tok-null">null</span>, <span class="tok-builtin">@alignOf</span>(<span class="tok-type">u8</span>), <span class="tok-null">null</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.readFileAllocOptions" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readFileAllocOptions</span><a href="#src.zig-std.fs.Dir.readFileAllocOptions">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFileAllocOptions</span>( self: <a href="std.fs.Dir.html">Dir</a>, allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_bytes: <span class="tok-type">usize</span>, size_hint: ?<span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> alignment: <span class="tok-type">u29</span>, <span class="tok-kw">comptime</span> optional_sentinel: ?<span class="tok-type">u8</span>, ) !(<span class="tok-kw">if</span> (optional_sentinel) |s| [:s]<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span> <span class="tok-kw">else</span> []<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span>)</code></pre></div><div class="tldDocs"><p>On success, caller owns returned buffer.
If the file is larger than <code>max_bytes</code>, returns <code>error.FileTooBig</code>.
If <code>size_hint</code> is specified the initial buffer size is calculated using
that value, otherwise the effective file size is used instead.
Allows specifying alignment and a sentinel value.
On Windows, <code>file_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>file_path</code> should be encoded as valid UTF-8.
On other platforms, <code>file_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>max_bytes: <span class="tok-type">usize</span></code></pre></div><div><pre><code>size_hint: ?<span class="tok-type">usize</span></code></pre></div><div><pre><code>alignment: <span class="tok-type">u29</span></code></pre></div><div><pre><code>optional_sentinel: ?<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.readFileAllocOptions">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFileAllocOptions</span>(
    self: <a href="std.fs.Dir.html">Dir</a>,
    allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>,
    file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    max_bytes: <span class="tok-type">usize</span>,
    size_hint: ?<span class="tok-type">usize</span>,
    <span class="tok-kw">comptime</span> alignment: <span class="tok-type">u29</span>,
    <span class="tok-kw">comptime</span> optional_sentinel: ?<span class="tok-type">u8</span>,
) !(<span class="tok-kw">if</span> (optional_sentinel) |s| [:s]<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span> <span class="tok-kw">else</span> []<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span>) {
    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> self.openFile(file_path, .{});
    <span class="tok-kw">defer</span> file.close();<span class="tok-comment">

    // If the file size doesn't fit a usize it'll be certainly greater than
    // `max_bytes`
    </span><span class="tok-kw">const</span> stat_size = size_hint <span class="tok-kw">orelse</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> file.getEndPos()) <span class="tok-kw">orelse</span>
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig;

    <span class="tok-kw">return</span> file.readToEndAllocOptions(allocator, max_bytes, stat_size, alignment, optional_sentinel);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.deleteTree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deleteTree</span><a href="#src.zig-std.fs.Dir.deleteTree">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteTree</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html#std.fs.Dir.DeleteTreeError">DeleteTreeError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Whether <code>sub_path</code> describes a symlink, file, or directory, this function
removes it. If it cannot be removed because it is a non-empty directory,
this function recursively removes its entries and then tries again.
This operation is not atomic on most file systems.
On Windows, <code>sub_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>sub_path</code> should be encoded as valid UTF-8.
On other platforms, <code>sub_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.deleteTree">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteTree</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html#std.fs.Dir.DeleteTreeError">DeleteTreeError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> initial_iterable_dir = (<span class="tok-kw">try</span> self.deleteTreeOpenInitialSubpath(sub_path, .file)) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;

    <span class="tok-kw">const</span> StackItem = <span class="tok-kw">struct</span> {
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        parent_dir: <a href="std.fs.Dir.html">Dir</a>,
        iter: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Iterator</a>,

        <span class="tok-kw">fn</span> <span class="tok-fn">closeAll</span>(items: []<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
            <span class="tok-kw">for</span> (items) |*item| item.iter.dir.close();
        }
    };

    <span class="tok-kw">var</span> stack_buffer: [<span class="tok-number">16</span>]StackItem = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> stack = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(StackItem).initBuffer(&amp;stack_buffer);
    <span class="tok-kw">defer</span> StackItem.closeAll(stack.items);

    stack.appendAssumeCapacity(.{
        .name = sub_path,
        .parent_dir = self,
        .iter = initial_iterable_dir.iterateAssumeFirstIteration(),
    });

    process_stack: <span class="tok-kw">while</span> (stack.items.len != <span class="tok-number">0</span>) {
        <span class="tok-kw">var</span> top = &amp;stack.items[stack.items.len - <span class="tok-number">1</span>];
        <span class="tok-kw">while</span> (<span class="tok-kw">try</span> top.iter.next()) |entry| {
            <span class="tok-kw">var</span> treat_as_dir = entry.kind == .directory;
            handle_entry: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">if</span> (treat_as_dir) {
                    <span class="tok-kw">if</span> (stack.unusedCapacitySlice().len &gt;= <span class="tok-number">1</span>) {
                        <span class="tok-kw">var</span> iterable_dir = top.iter.dir.openDir(entry.name, .{
                            .no_follow = <span class="tok-null">true</span>,
                            .iterate = <span class="tok-null">true</span>,
                        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                            <span class="tok-kw">error</span>.NotDir =&gt; {
                                treat_as_dir = <span class="tok-null">false</span>;
                                <span class="tok-kw">continue</span> :handle_entry;
                            },
                            <span class="tok-kw">error</span>.FileNotFound =&gt; {<span class="tok-comment">
                                // That's fine, we were trying to remove this directory anyway.
                                </span><span class="tok-kw">break</span> :handle_entry;
                            },

                            <span class="tok-kw">error</span>.AccessDenied,
                            <span class="tok-kw">error</span>.SymLinkLoop,
                            <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
                            <span class="tok-kw">error</span>.NameTooLong,
                            <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
                            <span class="tok-kw">error</span>.NoDevice,
                            <span class="tok-kw">error</span>.SystemResources,
                            <span class="tok-kw">error</span>.Unexpected,
                            <span class="tok-kw">error</span>.InvalidUtf8,
                            <span class="tok-kw">error</span>.InvalidWtf8,
                            <span class="tok-kw">error</span>.BadPathName,
                            <span class="tok-kw">error</span>.NetworkNotFound,
                            <span class="tok-kw">error</span>.DeviceBusy,
                            =&gt; |e| <span class="tok-kw">return</span> e,
                        };
                        stack.appendAssumeCapacity(.{
                            .name = entry.name,
                            .parent_dir = top.iter.dir,
                            .iter = iterable_dir.iterateAssumeFirstIteration(),
                        });
                        <span class="tok-kw">continue</span> :process_stack;
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">try</span> top.iter.dir.deleteTreeMinStackSizeWithKindHint(entry.name, entry.kind);
                        <span class="tok-kw">break</span> :handle_entry;
                    }
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">if</span> (top.iter.dir.deleteFile(entry.name)) {
                        <span class="tok-kw">break</span> :handle_entry;
                    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                        <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">break</span> :handle_entry,<span class="tok-comment">

                        // Impossible because we do not pass any path separators.
                        </span><span class="tok-kw">error</span>.NotDir =&gt; <span class="tok-kw">unreachable</span>,

                        <span class="tok-kw">error</span>.IsDir =&gt; {
                            treat_as_dir = <span class="tok-null">true</span>;
                            <span class="tok-kw">continue</span> :handle_entry;
                        },

                        <span class="tok-kw">error</span>.AccessDenied,
                        <span class="tok-kw">error</span>.InvalidUtf8,
                        <span class="tok-kw">error</span>.InvalidWtf8,
                        <span class="tok-kw">error</span>.SymLinkLoop,
                        <span class="tok-kw">error</span>.NameTooLong,
                        <span class="tok-kw">error</span>.SystemResources,
                        <span class="tok-kw">error</span>.ReadOnlyFileSystem,
                        <span class="tok-kw">error</span>.FileSystem,
                        <span class="tok-kw">error</span>.FileBusy,
                        <span class="tok-kw">error</span>.BadPathName,
                        <span class="tok-kw">error</span>.NetworkNotFound,
                        <span class="tok-kw">error</span>.Unexpected,
                        =&gt; |e| <span class="tok-kw">return</span> e,
                    }
                }
            }
        }<span class="tok-comment">

        // On Windows, we can't delete until the dir's handle has been closed, so
        // close it before we try to delete.
        </span>top.iter.dir.close();<span class="tok-comment">

        // In order to avoid double-closing the directory when cleaning up
        // the stack in the case of an error, we save the relevant portions and
        // pop the value from the stack.
        </span><span class="tok-kw">const</span> parent_dir = top.parent_dir;
        <span class="tok-kw">const</span> name = top.name;
        stack.items.len -= <span class="tok-number">1</span>;

        <span class="tok-kw">var</span> need_to_retry: <span class="tok-type">bool</span> = <span class="tok-null">false</span>;
        parent_dir.deleteDir(name) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileNotFound =&gt; {},
            <span class="tok-kw">error</span>.DirNotEmpty =&gt; need_to_retry = <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };

        <span class="tok-kw">if</span> (need_to_retry) {<span class="tok-comment">
            // Since we closed the handle that the previous iterator used, we
            // need to re-open the dir and re-create the iterator.
            </span><span class="tok-kw">var</span> iterable_dir = iterable_dir: {
                <span class="tok-kw">var</span> treat_as_dir = <span class="tok-null">true</span>;
                handle_entry: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                    <span class="tok-kw">if</span> (treat_as_dir) {
                        <span class="tok-kw">break</span> :iterable_dir parent_dir.openDir(name, .{
                            .no_follow = <span class="tok-null">true</span>,
                            .iterate = <span class="tok-null">true</span>,
                        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                            <span class="tok-kw">error</span>.NotDir =&gt; {
                                treat_as_dir = <span class="tok-null">false</span>;
                                <span class="tok-kw">continue</span> :handle_entry;
                            },
                            <span class="tok-kw">error</span>.FileNotFound =&gt; {<span class="tok-comment">
                                // That's fine, we were trying to remove this directory anyway.
                                </span><span class="tok-kw">continue</span> :process_stack;
                            },

                            <span class="tok-kw">error</span>.AccessDenied,
                            <span class="tok-kw">error</span>.SymLinkLoop,
                            <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
                            <span class="tok-kw">error</span>.NameTooLong,
                            <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
                            <span class="tok-kw">error</span>.NoDevice,
                            <span class="tok-kw">error</span>.SystemResources,
                            <span class="tok-kw">error</span>.Unexpected,
                            <span class="tok-kw">error</span>.InvalidUtf8,
                            <span class="tok-kw">error</span>.InvalidWtf8,
                            <span class="tok-kw">error</span>.BadPathName,
                            <span class="tok-kw">error</span>.NetworkNotFound,
                            <span class="tok-kw">error</span>.DeviceBusy,
                            =&gt; |e| <span class="tok-kw">return</span> e,
                        };
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">if</span> (parent_dir.deleteFile(name)) {
                            <span class="tok-kw">continue</span> :process_stack;
                        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                            <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">continue</span> :process_stack,<span class="tok-comment">

                            // Impossible because we do not pass any path separators.
                            </span><span class="tok-kw">error</span>.NotDir =&gt; <span class="tok-kw">unreachable</span>,

                            <span class="tok-kw">error</span>.IsDir =&gt; {
                                treat_as_dir = <span class="tok-null">true</span>;
                                <span class="tok-kw">continue</span> :handle_entry;
                            },

                            <span class="tok-kw">error</span>.AccessDenied,
                            <span class="tok-kw">error</span>.InvalidUtf8,
                            <span class="tok-kw">error</span>.InvalidWtf8,
                            <span class="tok-kw">error</span>.SymLinkLoop,
                            <span class="tok-kw">error</span>.NameTooLong,
                            <span class="tok-kw">error</span>.SystemResources,
                            <span class="tok-kw">error</span>.ReadOnlyFileSystem,
                            <span class="tok-kw">error</span>.FileSystem,
                            <span class="tok-kw">error</span>.FileBusy,
                            <span class="tok-kw">error</span>.BadPathName,
                            <span class="tok-kw">error</span>.NetworkNotFound,
                            <span class="tok-kw">error</span>.Unexpected,
                            =&gt; |e| <span class="tok-kw">return</span> e,
                        }
                    }
                }
            };<span class="tok-comment">
            // We know there is room on the stack since we are just re-adding
            // the StackItem that we previously popped.
            </span>stack.appendAssumeCapacity(.{
                .name = name,
                .parent_dir = parent_dir,
                .iter = iterable_dir.iterateAssumeFirstIteration(),
            });
            <span class="tok-kw">continue</span> :process_stack;
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.deleteTreeMinStackSize" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deleteTreeMinStackSize</span><a href="#src.zig-std.fs.Dir.deleteTreeMinStackSize">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteTreeMinStackSize</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html#std.fs.Dir.DeleteTreeError">DeleteTreeError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Like <code><a href="std.fs.Dir.html#std.fs.Dir.deleteTree">deleteTree</a></code>, but only keeps one <code><a href="std.fs.Dir.html#std.fs.Dir.Iterator">Iterator</a></code> active at a time to minimize the function's stack size.
This is slower than <code><a href="std.fs.Dir.html#std.fs.Dir.deleteTree">deleteTree</a></code> but uses less stack space.
On Windows, <code>sub_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>sub_path</code> should be encoded as valid UTF-8.
On other platforms, <code>sub_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.deleteTreeMinStackSize">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteTreeMinStackSize</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html#std.fs.Dir.DeleteTreeError">DeleteTreeError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.deleteTreeMinStackSizeWithKindHint(sub_path, .file);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.writeFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeFile</span><a href="#src.zig-std.fs.Dir.writeFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, options: <a href="std.fs.Dir.WriteFileOptions.html">WriteFileOptions</a>) <a href="std.fs.Dir.html#std.fs.Dir.WriteFileError">WriteFileError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Writes content to the file system, using the file creation flags provided.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>options: <a href="std.fs.Dir.WriteFileOptions.html">WriteFileOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.writeFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, options: <a href="std.fs.Dir.WriteFileOptions.html">WriteFileOptions</a>) <a href="std.fs.Dir.html#std.fs.Dir.WriteFileError">WriteFileError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> self.createFile(options.sub_path, options.flags);
    <span class="tok-kw">defer</span> file.close();
    <span class="tok-kw">try</span> file.writeAll(options.data);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.access" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">access</span><a href="#src.zig-std.fs.Dir.access">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">access</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Test accessing <code>sub_path</code>.
On Windows, <code>sub_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>sub_path</code> should be encoded as valid UTF-8.
On other platforms, <code>sub_path</code> is an opaque sequence of bytes with no particular encoding.
Be careful of Time-Of-Check-Time-Of-Use race conditions when using this function.
For example, instead of testing if a file exists and then opening it, just
open it and handle the error for file not found.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.access">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">access</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> sub_path_w = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(self.fd, sub_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        <span class="tok-kw">return</span> self.accessW(sub_path_w.span().ptr, flags);
    }
    <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sub_path);
    <span class="tok-kw">return</span> self.accessZ(&amp;path_c, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.accessZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">accessZ</span><a href="#src.zig-std.fs.Dir.accessZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.access">access</a></code> except the path parameter is null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.accessZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> sub_path_w = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(self.fd, sub_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        <span class="tok-kw">return</span> self.accessW(sub_path_w.span().ptr, flags);
    }
    <span class="tok-kw">const</span> os_mode = <span class="tok-kw">switch</span> (flags.mode) {
        .read_only =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.F_OK">F_OK</a>),
        .write_only =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.W_OK">W_OK</a>),
        .read_write =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.R_OK">R_OK</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.W_OK">W_OK</a>),
    };
    <span class="tok-kw">const</span> result = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.faccessatZ">faccessatZ</a>(self.fd, sub_path, os_mode, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.accessW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">accessW</span><a href="#src.zig-std.fs.Dir.accessW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.access">access</a></code> except asserts the target OS is Windows and the path parameter is</p>
<ul>
<li>WTF-16 LE encoded</li>
<li>null-terminated</li>
<li>relative or has the NT namespace prefix
TODO currently this ignores <code>flags</code>.</li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.accessW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    _ = flags;
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.faccessatW">faccessatW</a>(self.fd, sub_path_w);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.updateFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">updateFile</span><a href="#src.zig-std.fs.Dir.updateFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateFile</span>( source_dir: <a href="std.fs.Dir.html">Dir</a>, source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_dir: <a href="std.fs.Dir.html">Dir</a>, dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.fs.Dir.CopyFileOptions.html">CopyFileOptions</a>, ) !<a href="std.fs.Dir.PrevStatus.html">PrevStatus</a></code></pre></div><div class="tldDocs"><p>Check the file size, mtime, and mode of <code>source_path</code> and <code>dest_path</code>. If they are equal, does nothing.
Otherwise, atomically copies <code>source_path</code> to <code>dest_path</code>. The destination file gains the mtime,
atime, and mode of the source file so that the next call to <code><a href="std.fs.Dir.html#std.fs.Dir.updateFile">updateFile</a></code> will not need a copy.
Returns the previous status of the file before updating.
If any of the directories do not exist for dest_path, they are created.
On Windows, both paths should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, both paths should be encoded as valid UTF-8.
On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>source_dir: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>dest_dir: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.fs.Dir.CopyFileOptions.html">CopyFileOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.updateFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateFile</span>(
    source_dir: <a href="std.fs.Dir.html">Dir</a>,
    source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    dest_dir: <a href="std.fs.Dir.html">Dir</a>,
    dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    options: <a href="std.fs.Dir.CopyFileOptions.html">CopyFileOptions</a>,
) !<a href="std.fs.Dir.PrevStatus.html">PrevStatus</a> {
    <span class="tok-kw">var</span> src_file = <span class="tok-kw">try</span> source_dir.openFile(source_path, .{});
    <span class="tok-kw">defer</span> src_file.close();

    <span class="tok-kw">const</span> src_stat = <span class="tok-kw">try</span> src_file.stat();
    <span class="tok-kw">const</span> actual_mode = options.override_mode <span class="tok-kw">orelse</span> src_stat.mode;
    check_dest_stat: {
        <span class="tok-kw">const</span> dest_stat = blk: {
            <span class="tok-kw">var</span> dest_file = dest_dir.openFile(dest_path, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">break</span> :check_dest_stat,
                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };
            <span class="tok-kw">defer</span> dest_file.close();

            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> dest_file.stat();
        };

        <span class="tok-kw">if</span> (src_stat.size == dest_stat.size <span class="tok-kw">and</span>
            src_stat.mtime == dest_stat.mtime <span class="tok-kw">and</span>
            actual_mode == dest_stat.mode)
        {
            <span class="tok-kw">return</span> <a href="std.fs.Dir.PrevStatus.html">PrevStatus</a>.<a href="#">fresh</a>;
        }
    }

    <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(dest_path)) |dirname| {
        <span class="tok-kw">try</span> dest_dir.makePath(dirname);
    }

    <span class="tok-kw">var</span> atomic_file = <span class="tok-kw">try</span> dest_dir.atomicFile(dest_path, .{ .mode = actual_mode });
    <span class="tok-kw">defer</span> atomic_file.deinit();

    <span class="tok-kw">try</span> atomic_file.file.writeFileAll(src_file, .{ .in_len = src_stat.size });
    <span class="tok-kw">try</span> atomic_file.file.updateTimes(src_stat.atime, src_stat.mtime);
    <span class="tok-kw">try</span> atomic_file.finish();
    <span class="tok-kw">return</span> <a href="std.fs.Dir.PrevStatus.html">PrevStatus</a>.<a href="#">stale</a>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.copyFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">copyFile</span><a href="#src.zig-std.fs.Dir.copyFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyFile</span>( source_dir: <a href="std.fs.Dir.html">Dir</a>, source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_dir: <a href="std.fs.Dir.html">Dir</a>, dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.fs.Dir.CopyFileOptions.html">CopyFileOptions</a>, ) <a href="std.fs.Dir.html#std.fs.Dir.CopyFileError">CopyFileError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Guaranteed to be atomic.
On Linux, until <a href="https://patchwork.kernel.org/patch/9636735/">https://patchwork.kernel.org/patch/9636735/</a> is merged and readily available,
there is a possibility of power loss or application termination leaving temporary files present
in the same directory as dest_path.
On Windows, both paths should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, both paths should be encoded as valid UTF-8.
On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>source_dir: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>dest_dir: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.fs.Dir.CopyFileOptions.html">CopyFileOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.copyFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyFile</span>(
    source_dir: <a href="std.fs.Dir.html">Dir</a>,
    source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    dest_dir: <a href="std.fs.Dir.html">Dir</a>,
    dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    options: <a href="std.fs.Dir.CopyFileOptions.html">CopyFileOptions</a>,
) <a href="std.fs.Dir.html#std.fs.Dir.CopyFileError">CopyFileError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> in_file = <span class="tok-kw">try</span> source_dir.openFile(source_path, .{});
    <span class="tok-kw">defer</span> in_file.close();

    <span class="tok-kw">var</span> size: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> mode = options.override_mode <span class="tok-kw">orelse</span> blk: {
        <span class="tok-kw">const</span> st = <span class="tok-kw">try</span> in_file.stat();
        size = st.size;
        <span class="tok-kw">break</span> :blk st.mode;
    };

    <span class="tok-kw">var</span> atomic_file = <span class="tok-kw">try</span> dest_dir.atomicFile(dest_path, .{ .mode = mode });
    <span class="tok-kw">defer</span> atomic_file.deinit();

    <span class="tok-kw">try</span> <a href="std.fs.Dir.html#std.fs.Dir.copy_file">copy_file</a>(in_file.handle, atomic_file.file.handle, size);
    <span class="tok-kw">try</span> atomic_file.finish();
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.atomicFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">atomicFile</span><a href="#src.zig-std.fs.Dir.atomicFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">atomicFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.fs.Dir.AtomicFileOptions.html">AtomicFileOptions</a>) !<a href="std.fs.AtomicFile.html">AtomicFile</a></code></pre></div><div class="tldDocs"><p>Directly access the <code>.file</code> field, and then call <code><a href="std.fs.AtomicFile.html#std.fs.AtomicFile.finish">AtomicFile.finish</a></code> to
atomically replace <code>dest_path</code> with contents.
Always call <code><a href="std.fs.AtomicFile.html#std.fs.AtomicFile.deinit">AtomicFile.deinit</a></code> to clean up, regardless of whether
<code><a href="std.fs.AtomicFile.html#std.fs.AtomicFile.finish">AtomicFile.finish</a></code> succeeded. <code>dest_path</code> must remain valid until
<code><a href="std.fs.AtomicFile.html#std.fs.AtomicFile.deinit">AtomicFile.deinit</a></code> is called.
On Windows, <code>dest_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>dest_path</code> should be encoded as valid UTF-8.
On other platforms, <code>dest_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.fs.Dir.AtomicFileOptions.html">AtomicFileOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.atomicFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">atomicFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.fs.Dir.AtomicFileOptions.html">AtomicFileOptions</a>) !<a href="std.fs.AtomicFile.html">AtomicFile</a> {
    <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(dest_path)) |dirname| {
        <span class="tok-kw">const</span> dir = <span class="tok-kw">if</span> (options.make_path)
            <span class="tok-kw">try</span> self.makeOpenPath(dirname, .{})
        <span class="tok-kw">else</span>
            <span class="tok-kw">try</span> self.openDir(dirname, .{});

        <span class="tok-kw">return</span> <a href="std.fs.AtomicFile.html">AtomicFile</a>.<a href="std.fs.AtomicFile.html#std.fs.AtomicFile.init">init</a>(<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.basename">basename</a>(dest_path), options.mode, dir, <span class="tok-null">true</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <a href="std.fs.AtomicFile.html">AtomicFile</a>.<a href="std.fs.AtomicFile.html#std.fs.AtomicFile.init">init</a>(dest_path, options.mode, self, <span class="tok-null">false</span>);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.stat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">stat</span><a href="#src.zig-std.fs.Dir.stat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stat</span>(self: <a href="std.fs.Dir.html">Dir</a>) <a href="std.posix.html#std.posix.FStatError">StatError</a>!<a href="std.fs.File.Stat.html">Stat</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.stat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stat</span>(self: <a href="std.fs.Dir.html">Dir</a>) <a href="std.posix.html#std.posix.FStatError">StatError</a>!<a href="std.fs.File.Stat.html">Stat</a> {
    <span class="tok-kw">const</span> file: <a href="std.fs.File.html">File</a> = .{ .handle = self.fd };
    <span class="tok-kw">return</span> file.stat();
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.statFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">statFile</span><a href="#src.zig-std.fs.Dir.statFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">statFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html#std.fs.Dir.StatFileError">StatFileError</a>!<a href="std.fs.File.Stat.html">Stat</a></code></pre></div><div class="tldDocs"><p>Returns metadata for a file inside the directory.</p>
<p>On Windows, this requires three syscalls. On other operating systems, it
only takes one.</p>
<p>Symlinks are followed.</p>
<p><code>sub_path</code> may be absolute, in which case <code>self</code> is ignored.
On Windows, <code>sub_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>sub_path</code> should be encoded as valid UTF-8.
On other platforms, <code>sub_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.statFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">statFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html#std.fs.Dir.StatFileError">StatFileError</a>!<a href="std.fs.File.Stat.html">Stat</a> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> self.openFile(sub_path, .{});
        <span class="tok-kw">defer</span> file.close();
        <span class="tok-kw">return</span> file.stat();
    }
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> st = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.fstatat_wasi">fstatat_wasi</a>(self.fd, sub_path, .{ .SYMLINK_FOLLOW = <span class="tok-null">true</span> });
        <span class="tok-kw">return</span> <a href="std.fs.File.Stat.html">Stat</a>.<a href="std.fs.File.Stat.html#std.fs.File.Stat.fromWasi">fromWasi</a>(st);
    }
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .linux) {
        <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sub_path);
        <span class="tok-kw">var</span> stx = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroes">zeroes</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.Statx.html">Statx</a>);

        <span class="tok-kw">const</span> rc = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.statx">statx</a>(
            self.fd,
            &amp;sub_path_c,
            <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.AT.html">AT</a>.<a href="std.os.linux.AT.html#std.os.linux.AT.NO_AUTOMOUNT">NO_AUTOMOUNT</a>,
            <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_TYPE">STATX_TYPE</a> | <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_MODE">STATX_MODE</a> | <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_ATIME">STATX_ATIME</a> | <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_MTIME">STATX_MTIME</a> | <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_CTIME">STATX_CTIME</a>,
            &amp;stx,
        );

        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(rc)) {
            .SUCCESS =&gt; <a href="std.fs.File.Stat.html">Stat</a>.<a href="std.fs.File.Stat.html#std.fs.File.Stat.fromLinux">fromLinux</a>(stx),
            .ACCES =&gt; <span class="tok-kw">error</span>.AccessDenied,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .LOOP =&gt; <span class="tok-kw">error</span>.SymLinkLoop,
            .NAMETOOLONG =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handled by posix.toPosixPath() above.
            </span>.NOENT, .NOTDIR =&gt; <span class="tok-kw">error</span>.FileNotFound,
            .NOMEM =&gt; <span class="tok-kw">error</span>.SystemResources,
            <span class="tok-kw">else</span> =&gt; |err| <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        };
    }
    <span class="tok-kw">const</span> st = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fstatat">fstatat</a>(self.fd, sub_path, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> <a href="std.fs.File.Stat.html">Stat</a>.<a href="std.fs.File.Stat.html#std.fs.File.Stat.fromPosix">fromPosix</a>(st);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.chmod" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">chmod</span><a href="#src.zig-std.fs.Dir.chmod">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chmod</span>(self: <a href="std.fs.Dir.html">Dir</a>, new_mode: <a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.mode_t">Mode</a>) <a href="std.posix.html#std.posix.FChmodError">ChmodError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Changes the mode of the directory.
The process must have the correct privileges in order to do this
successfully, or must have the effective user ID matching the owner
of the directory. Additionally, the directory must have been opened
with <code>OpenOptions{ .iterate = true }</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>new_mode: <a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.mode_t">Mode</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.chmod">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chmod</span>(self: <a href="std.fs.Dir.html">Dir</a>, new_mode: <a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.mode_t">Mode</a>) <a href="std.posix.html#std.posix.FChmodError">ChmodError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> file: <a href="std.fs.File.html">File</a> = .{ .handle = self.fd };
    <span class="tok-kw">try</span> file.chmod(new_mode);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.chown" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">chown</span><a href="#src.zig-std.fs.Dir.chown">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chown</span>(self: <a href="std.fs.Dir.html">Dir</a>, owner: ?<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.uid_t">Uid</a>, group: ?<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.gid_t">Gid</a>) <a href="std.posix.html#std.posix.FChownError">ChownError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Changes the owner and group of the directory.
The process must have the correct privileges in order to do this
successfully. The group may be changed by the owner of the directory to
any group of which the owner is a member. Additionally, the directory
must have been opened with <code>OpenOptions{ .iterate = true }</code>. If the
owner or group is specified as <code>null</code>, the ID is not changed.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>owner: ?<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.uid_t">Uid</a></code></pre></div><div><pre><code>group: ?<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.gid_t">Gid</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.chown">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chown</span>(self: <a href="std.fs.Dir.html">Dir</a>, owner: ?<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.uid_t">Uid</a>, group: ?<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.gid_t">Gid</a>) <a href="std.posix.html#std.posix.FChownError">ChownError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> file: <a href="std.fs.File.html">File</a> = .{ .handle = self.fd };
    <span class="tok-kw">try</span> file.chown(owner, group);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.setPermissions" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setPermissions</span><a href="#src.zig-std.fs.Dir.setPermissions">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setPermissions</span>(self: <a href="std.fs.Dir.html">Dir</a>, permissions: <a href="std.fs.File.Permissions.html">Permissions</a>) <a href="std.posix.html#std.posix.FChmodError">SetPermissionsError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sets permissions according to the provided <code><a href="std.fs.File.Permissions.html">Permissions</a></code> struct.
This method is <em>NOT</em> available on WASI</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>permissions: <a href="std.fs.File.Permissions.html">Permissions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.setPermissions">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setPermissions</span>(self: <a href="std.fs.Dir.html">Dir</a>, permissions: <a href="std.fs.File.Permissions.html">Permissions</a>) <a href="std.posix.html#std.posix.FChmodError">SetPermissionsError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> file: <a href="std.fs.File.html">File</a> = .{ .handle = self.fd };
    <span class="tok-kw">try</span> file.setPermissions(permissions);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.Dir.metadata" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">metadata</span><a href="#src.zig-std.fs.Dir.metadata">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadata</span>(self: <a href="std.fs.Dir.html">Dir</a>) <a href="std.posix.html#std.posix.FStatError">MetadataError</a>!<a href="std.fs.File.Metadata.html">Metadata</a></code></pre></div><div class="tldDocs"><p>Returns a <code><a href="std.fs.File.Metadata.html">Metadata</a></code> struct, representing the permissions on the directory</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.Dir.html">Dir</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.Dir.metadata">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadata</span>(self: <a href="std.fs.Dir.html">Dir</a>) <a href="std.posix.html#std.posix.FStatError">MetadataError</a>!<a href="std.fs.File.Metadata.html">Metadata</a> {
    <span class="tok-kw">const</span> file: <a href="std.fs.File.html">File</a> = .{ .handle = self.fd };
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> file.metadata();
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.fs.Dir">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText">fd: <a href="std.posix.html#std.posix.fd_t">Handle</a>,

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Handle = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_mode = <span class="tok-number">0o755</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    kind: <a href="std.fs.File.Kind.html">Kind</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Kind = <a href="std.fs.File.html">File</a>.<a href="std.fs.File.Kind.html">Kind</a>;
};

<span class="tok-kw">const</span> IteratorError = <span class="tok-kw">error</span>{
    AccessDenied,
    SystemResources,
    <span class="tok-comment">/// WASI-only. The path of an entry could not be encoded as valid UTF-8.</span>
    <span class="tok-comment">/// WASI is unable to handle paths that cannot be encoded as well-formed UTF-8.</span>
    <span class="tok-comment">/// https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353</span>
    InvalidUtf8,
} || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {
    .macos, .ios, .freebsd, .netbsd, .dragonfly, .openbsd, .solaris, .illumos =&gt; <span class="tok-kw">struct</span> {
        dir: <a href="std.fs.Dir.html">Dir</a>,
        seek: <span class="tok-type">i64</span>,
        buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span>,<span class="tok-comment"> // TODO align(@alignOf(posix.system.dirent)),
        </span>index: <span class="tok-type">usize</span>,
        end_index: <span class="tok-type">usize</span>,
        first_iter: <span class="tok-type">bool</span>,

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a>;

        <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span>
        <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">Error</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {
            <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {
                .macos, .ios =&gt; <span class="tok-kw">return</span> self.nextDarwin(),
                .freebsd, .netbsd, .dragonfly, .openbsd =&gt; <span class="tok-kw">return</span> self.nextBsd(),
                .solaris, .illumos =&gt; <span class="tok-kw">return</span> self.nextSolaris(),
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unimplemented&quot;</span>),
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">nextDarwin</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) !?<a href="std.fs.Dir.Entry.html">Entry</a> {
            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {
                    <span class="tok-kw">if</span> (self.first_iter) {
                        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.lseek_SET">lseek_SET</a>(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // EBADF here likely means that the Dir was not opened with iteration permissions
                        </span>self.first_iter = <span class="tok-null">false</span>;
                    }
                    <span class="tok-kw">const</span> rc = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">getdirentries</a>(
                        self.dir.fd,
                        &amp;self.buf,
                        self.buf.len,
                        &amp;self.seek,
                    );
                    <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    <span class="tok-kw">if</span> (rc &lt; <span class="tok-number">0</span>) {
                        <span class="tok-kw">switch</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid or was opened without iteration ability
                            </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
                            .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
                            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                        }
                    }
                    self.index = <span class="tok-number">0</span>;
                    self.end_index = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(rc));
                }
                <span class="tok-kw">const</span> darwin_entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">dirent</a>, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));
                <span class="tok-kw">const</span> next_index = self.index + darwin_entry.reclen;
                self.index = next_index;

                <span class="tok-kw">const</span> name = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;darwin_entry.name))[<span class="tok-number">0</span>..darwin_entry.namlen];

                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>) <span class="tok-kw">or</span> (darwin_entry.ino == <span class="tok-number">0</span>)) {
                    <span class="tok-kw">continue</span> :start_over;
                }

                <span class="tok-kw">const</span> entry_kind: <a href="std.fs.Dir.Entry.html">Entry</a>.<a href="std.fs.File.Kind.html">Kind</a> = <span class="tok-kw">switch</span> (darwin_entry.<span class="tok-type">type</span>) {
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">BLK</a> =&gt; .block_device,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">CHR</a> =&gt; .character_device,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">DIR</a> =&gt; .directory,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">FIFO</a> =&gt; .named_pipe,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">LNK</a> =&gt; .sym_link,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">REG</a> =&gt; .file,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">SOCK</a> =&gt; .unix_domain_socket,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">WHT</a> =&gt; .whiteout,
                    <span class="tok-kw">else</span> =&gt; .unknown,
                };
                <span class="tok-kw">return</span> <a href="std.fs.Dir.Entry.html">Entry</a>{
                    .name = name,
                    .kind = entry_kind,
                };
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">nextSolaris</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) !?<a href="std.fs.Dir.Entry.html">Entry</a> {
            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {
                    <span class="tok-kw">if</span> (self.first_iter) {
                        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.lseek_SET">lseek_SET</a>(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // EBADF here likely means that the Dir was not opened with iteration permissions
                        </span>self.first_iter = <span class="tok-null">false</span>;
                    }
                    <span class="tok-kw">const</span> rc = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">getdents</a>(self.dir.fd, &amp;self.buf, self.buf.len);
                    <span class="tok-kw">switch</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                        .SUCCESS =&gt; {},
                        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid or was opened without iteration ability
                        </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
                        .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
                        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                    }
                    <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    self.index = <span class="tok-number">0</span>;
                    self.end_index = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(rc));
                }
                <span class="tok-kw">const</span> entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">dirent</a>, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));
                <span class="tok-kw">const</span> next_index = self.index + entry.reclen;
                self.index = next_index;

                <span class="tok-kw">const</span> name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;entry.name)), <span class="tok-number">0</span>);
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>))
                    <span class="tok-kw">continue</span> :start_over;<span class="tok-comment">

                // Solaris dirent doesn't expose type, so we have to call stat to get it.
                </span><span class="tok-kw">const</span> stat_info = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fstatat">fstatat</a>(
                    self.dir.fd,
                    name,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">SYMLINK_NOFOLLOW</a>,
                ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,
                    <span class="tok-kw">error</span>.SymLinkLoop =&gt; <span class="tok-kw">unreachable</span>,
                    <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // lost the race
                    </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
                };
                <span class="tok-kw">const</span> entry_kind: <a href="std.fs.Dir.Entry.html">Entry</a>.<a href="std.fs.File.Kind.html">Kind</a> = <span class="tok-kw">switch</span> (stat_info.mode &amp; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFMT</a>) {
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFIFO</a> =&gt; .named_pipe,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFCHR</a> =&gt; .character_device,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFDIR</a> =&gt; .directory,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFBLK</a> =&gt; .block_device,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFREG</a> =&gt; .file,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFLNK</a> =&gt; .sym_link,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFSOCK</a> =&gt; .unix_domain_socket,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFDOOR</a> =&gt; .door,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFPORT</a> =&gt; .event_port,
                    <span class="tok-kw">else</span> =&gt; .unknown,
                };
                <span class="tok-kw">return</span> <a href="std.fs.Dir.Entry.html">Entry</a>{
                    .name = name,
                    .kind = entry_kind,
                };
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">nextBsd</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) !?<a href="std.fs.Dir.Entry.html">Entry</a> {
            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {
                    <span class="tok-kw">if</span> (self.first_iter) {
                        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.lseek_SET">lseek_SET</a>(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // EBADF here likely means that the Dir was not opened with iteration permissions
                        </span>self.first_iter = <span class="tok-null">false</span>;
                    }
                    <span class="tok-kw">const</span> rc = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">getdents</a>(self.dir.fd, &amp;self.buf, self.buf.len);
                    <span class="tok-kw">switch</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                        .SUCCESS =&gt; {},
                        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid or was opened without iteration ability
                        </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
                        .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
                        .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment">
                        // Introduced in freebsd 13.2: directory unlinked but still open.
                        // To be consistent, iteration ends if the directory being iterated is deleted during iteration.
                        </span>.NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
                        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                    }
                    <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    self.index = <span class="tok-number">0</span>;
                    self.end_index = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(rc));
                }
                <span class="tok-kw">const</span> bsd_entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">dirent</a>, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));
                <span class="tok-kw">const</span> next_index = self.index +
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">dirent</a>, <span class="tok-str">&quot;reclen&quot;</span>)) bsd_entry.reclen <span class="tok-kw">else</span> bsd_entry.reclen();
                self.index = next_index;

                <span class="tok-kw">const</span> name = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;bsd_entry.name))[<span class="tok-number">0</span>..bsd_entry.namlen];

                <span class="tok-kw">const</span> skip_zero_fileno = <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {<span class="tok-comment">
                    // fileno=0 is used to mark invalid entries or deleted files.
                    </span>.openbsd, .netbsd =&gt; <span class="tok-null">true</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
                };
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>) <span class="tok-kw">or</span>
                    (skip_zero_fileno <span class="tok-kw">and</span> bsd_entry.fileno == <span class="tok-number">0</span>))
                {
                    <span class="tok-kw">continue</span> :start_over;
                }

                <span class="tok-kw">const</span> entry_kind: <a href="std.fs.Dir.Entry.html">Entry</a>.<a href="std.fs.File.Kind.html">Kind</a> = <span class="tok-kw">switch</span> (bsd_entry.<span class="tok-type">type</span>) {
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">BLK</a> =&gt; .block_device,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">CHR</a> =&gt; .character_device,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">DIR</a> =&gt; .directory,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">FIFO</a> =&gt; .named_pipe,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">LNK</a> =&gt; .sym_link,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">REG</a> =&gt; .file,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">SOCK</a> =&gt; .unix_domain_socket,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.DT">DT</a>.<a href="#">WHT</a> =&gt; .whiteout,
                    <span class="tok-kw">else</span> =&gt; .unknown,
                };
                <span class="tok-kw">return</span> <a href="std.fs.Dir.Entry.html">Entry</a>{
                    .name = name,
                    .kind = entry_kind,
                };
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <span class="tok-type">void</span> {
            self.index = <span class="tok-number">0</span>;
            self.end_index = <span class="tok-number">0</span>;
            self.first_iter = <span class="tok-null">true</span>;
        }
    },
    .haiku =&gt; <span class="tok-kw">struct</span> {
        dir: <a href="std.fs.Dir.html">Dir</a>,
        buf: [<span class="tok-builtin">@sizeOf</span>(<a href="std.fs.Dir.html#std.fs.Dir.Iterator.DirEnt">DirEnt</a>) + <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PATH_MAX">PATH_MAX</a>]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.fs.Dir.html#std.fs.Dir.Iterator.DirEnt">DirEnt</a>)),
        offset: <span class="tok-type">usize</span>,
        index: <span class="tok-type">usize</span>,
        end_index: <span class="tok-type">usize</span>,
        first_iter: <span class="tok-type">bool</span>,

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();
        <span class="tok-kw">const</span> DirEnt = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">DirEnt</a>;

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a>;

        <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span>
        <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">Error</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {
                    <span class="tok-kw">if</span> (self.first_iter) {
                        <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>, <span class="tok-builtin">@enumFromInt</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">_kern_rewind_dir</a>(self.dir.fd)))) {
                            .SUCCESS =&gt; {},
                            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid
                            </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
                            .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
                            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                        }
                        self.first_iter = <span class="tok-null">false</span>;
                    }
                    <span class="tok-kw">const</span> rc = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">_kern_read_dir</a>(
                        self.dir.fd,
                        &amp;self.buf,
                        self.buf.len,
                        self.buf.len / <span class="tok-builtin">@sizeOf</span>(<a href="std.fs.Dir.html#std.fs.Dir.Iterator.DirEnt">DirEnt</a>),
                    );
                    <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    <span class="tok-kw">if</span> (rc &lt; <span class="tok-number">0</span>) {
                        <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>, <span class="tok-builtin">@enumFromInt</span>(rc))) {
                            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid
                            </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
                            .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
                            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                            .OVERFLOW =&gt; <span class="tok-kw">unreachable</span>,
                            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                        }
                    }
                    self.offset = <span class="tok-number">0</span>;
                    self.index = <span class="tok-number">0</span>;
                    self.end_index = <span class="tok-builtin">@intCast</span>(rc);
                }
                <span class="tok-kw">const</span> dirent: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator.DirEnt">DirEnt</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;self.buf[self.offset]));
                self.offset += dirent.reclen;
                self.index += <span class="tok-number">1</span>;
                <span class="tok-kw">const</span> name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(dirent.getName());
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>) <span class="tok-kw">or</span> dirent.ino == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;

                <span class="tok-kw">var</span> stat_info: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.Stat">Stat</a> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>, <span class="tok-builtin">@enumFromInt</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">_kern_read_stat</a>(
                    self.dir.fd,
                    name,
                    <span class="tok-null">false</span>,
                    &amp;stat_info,
                    <span class="tok-number">0</span>,
                )))) {
                    .SUCCESS =&gt; {},
                    .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                    .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid
                    </span>.NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                    .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                    .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                    .FAULT =&gt; <span class="tok-kw">unreachable</span>,
                    .NAMETOOLONG =&gt; <span class="tok-kw">unreachable</span>,
                    .LOOP =&gt; <span class="tok-kw">unreachable</span>,
                    .NOENT =&gt; <span class="tok-kw">continue</span>,
                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                }
                <span class="tok-kw">const</span> statmode = stat_info.mode &amp; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFMT</a>;

                <span class="tok-kw">const</span> entry_kind: <a href="std.fs.Dir.Entry.html">Entry</a>.<a href="std.fs.File.Kind.html">Kind</a> = <span class="tok-kw">switch</span> (statmode) {
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFDIR</a> =&gt; .directory,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFBLK</a> =&gt; .block_device,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFCHR</a> =&gt; .character_device,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFLNK</a> =&gt; .sym_link,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFREG</a> =&gt; .file,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFIFO</a> =&gt; .named_pipe,
                    <span class="tok-kw">else</span> =&gt; .unknown,
                };

                <span class="tok-kw">return</span> <a href="std.fs.Dir.Entry.html">Entry</a>{
                    .name = name,
                    .kind = entry_kind,
                };
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <span class="tok-type">void</span> {
            self.index = <span class="tok-number">0</span>;
            self.end_index = <span class="tok-number">0</span>;
            self.first_iter = <span class="tok-null">true</span>;
        }
    },
    .linux =&gt; <span class="tok-kw">struct</span> {
        dir: <a href="std.fs.Dir.html">Dir</a>,<span class="tok-comment">
        // The if guard is solely there to prevent compile errors from missing `linux.dirent64`
        // definition when compiling for other OSes. It doesn't do anything when compiling for Linux.
        </span>buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.dirent64.html">dirent64</a>)),
        index: <span class="tok-type">usize</span>,
        end_index: <span class="tok-type">usize</span>,
        first_iter: <span class="tok-type">bool</span>,

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a>;

        <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span>
        <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">Error</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {
            <span class="tok-kw">return</span> self.nextLinux() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {<span class="tok-comment">
                // To be consistent across platforms, iteration ends if the directory being iterated is deleted during iteration.
                // This matches the behavior of non-Linux UNIX platforms.
                </span><span class="tok-kw">error</span>.DirNotFound =&gt; <span class="tok-null">null</span>,
                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorLinux = <span class="tok-kw">error</span>{DirNotFound} || <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a>;

        <span class="tok-comment">/// Implementation of `next` that can return `error.DirNotFound` if the directory being</span>
        <span class="tok-comment">/// iterated was deleted during iteration (this error is Linux specific).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextLinux</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.Iterator.ErrorLinux">ErrorLinux</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {
            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {
                    <span class="tok-kw">if</span> (self.first_iter) {
                        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.lseek_SET">lseek_SET</a>(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // EBADF here likely means that the Dir was not opened with iteration permissions
                        </span>self.first_iter = <span class="tok-null">false</span>;
                    }
                    <span class="tok-kw">const</span> rc = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.getdents64">getdents64</a>(self.dir.fd, &amp;self.buf, self.buf.len);
                    <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(rc)) {
                        .SUCCESS =&gt; {},
                        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid or was opened without iteration ability
                        </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
                        .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
                        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotFound,<span class="tok-comment"> // The directory being iterated was deleted during iteration.
                        </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,<span class="tok-comment"> // Linux may in some cases return EINVAL when reading /proc/$PID/net.
                        </span>.ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,<span class="tok-comment"> // Do not have permission to iterate this directory.
                        </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                    }
                    <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    self.index = <span class="tok-number">0</span>;
                    self.end_index = rc;
                }
                <span class="tok-kw">const</span> linux_entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.dirent64.html">dirent64</a>, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));
                <span class="tok-kw">const</span> next_index = self.index + linux_entry.reclen;
                self.index = next_index;

                <span class="tok-kw">const</span> name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;linux_entry.name)), <span class="tok-number">0</span>);<span class="tok-comment">

                // skip . and .. entries
                </span><span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>)) {
                    <span class="tok-kw">continue</span> :start_over;
                }

                <span class="tok-kw">const</span> entry_kind: <a href="std.fs.Dir.Entry.html">Entry</a>.<a href="std.fs.File.Kind.html">Kind</a> = <span class="tok-kw">switch</span> (linux_entry.<span class="tok-type">type</span>) {
                    <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.BLK">BLK</a> =&gt; .block_device,
                    <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.CHR">CHR</a> =&gt; .character_device,
                    <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.DIR">DIR</a> =&gt; .directory,
                    <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.FIFO">FIFO</a> =&gt; .named_pipe,
                    <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.LNK">LNK</a> =&gt; .sym_link,
                    <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.REG">REG</a> =&gt; .file,
                    <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.DT.html">DT</a>.<a href="std.os.linux.DT.html#std.os.linux.DT.SOCK">SOCK</a> =&gt; .unix_domain_socket,
                    <span class="tok-kw">else</span> =&gt; .unknown,
                };
                <span class="tok-kw">return</span> <a href="std.fs.Dir.Entry.html">Entry</a>{
                    .name = name,
                    .kind = entry_kind,
                };
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <span class="tok-type">void</span> {
            self.index = <span class="tok-number">0</span>;
            self.end_index = <span class="tok-number">0</span>;
            self.first_iter = <span class="tok-null">true</span>;
        }
    },
    .windows =&gt; <span class="tok-kw">struct</span> {
        dir: <a href="std.fs.Dir.html">Dir</a>,
        buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_BOTH_DIR_INFORMATION.html">FILE_BOTH_DIR_INFORMATION</a>)),
        index: <span class="tok-type">usize</span>,
        end_index: <span class="tok-type">usize</span>,
        first_iter: <span class="tok-type">bool</span>,
        name_data: [<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_name_bytes">max_name_bytes</a>]<span class="tok-type">u8</span>,

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a>;

        <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span>
        <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">Error</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {
            <span class="tok-kw">const</span> w = <a href="std.os.windows.html">windows</a>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {
                    <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;
                    <span class="tok-kw">const</span> rc = w.ntdll.NtQueryDirectoryFile(
                        self.dir.fd,
                        <span class="tok-null">null</span>,
                        <span class="tok-null">null</span>,
                        <span class="tok-null">null</span>,
                        &amp;io,
                        &amp;self.buf,
                        self.buf.len,
                        .FileBothDirectoryInformation,
                        w.FALSE,
                        <span class="tok-null">null</span>,
                        <span class="tok-kw">if</span> (self.first_iter) <span class="tok-builtin">@as</span>(w.BOOLEAN, w.TRUE) <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(w.BOOLEAN, w.FALSE),
                    );
                    self.first_iter = <span class="tok-null">false</span>;
                    <span class="tok-kw">if</span> (io.Information == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    self.index = <span class="tok-number">0</span>;
                    self.end_index = io.Information;
                    <span class="tok-kw">switch</span> (rc) {
                        .SUCCESS =&gt; {},
                        .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,<span class="tok-comment"> // Double-check that the Dir was opened with iteration ability

                        </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> w.unexpectedStatus(rc),
                    }
                }<span class="tok-comment">

                // While the official api docs guarantee FILE_BOTH_DIR_INFORMATION to be aligned properly
                // this may not always be the case (e.g. due to faulty VM/Sandboxing tools)
                </span><span class="tok-kw">const</span> dir_info: *<span class="tok-kw">align</span>(<span class="tok-number">2</span>) w.FILE_BOTH_DIR_INFORMATION = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;self.buf[self.index]));
                <span class="tok-kw">if</span> (dir_info.NextEntryOffset != <span class="tok-number">0</span>) {
                    self.index += dir_info.NextEntryOffset;
                } <span class="tok-kw">else</span> {
                    self.index = self.buf.len;
                }

                <span class="tok-kw">const</span> name_wtf16le = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u16</span>, <span class="tok-builtin">@ptrCast</span>(&amp;dir_info.FileName))[<span class="tok-number">0</span> .. dir_info.FileNameLength / <span class="tok-number">2</span>];

                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, name_wtf16le, &amp;[_]<span class="tok-type">u16</span>{<span class="tok-str">'.'</span>}) <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, name_wtf16le, &amp;[_]<span class="tok-type">u16</span>{ <span class="tok-str">'.'</span>, <span class="tok-str">'.'</span> }))
                    <span class="tok-kw">continue</span>;
                <span class="tok-kw">const</span> name_wtf8_len = <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf16LeToWtf8">wtf16LeToWtf8</a>(self.name_data[<span class="tok-number">0</span>..], name_wtf16le);
                <span class="tok-kw">const</span> name_wtf8 = self.name_data[<span class="tok-number">0</span>..name_wtf8_len];
                <span class="tok-kw">const</span> kind: <a href="std.fs.Dir.Entry.html">Entry</a>.<a href="std.fs.File.Kind.html">Kind</a> = blk: {
                    <span class="tok-kw">const</span> attrs = dir_info.FileAttributes;
                    <span class="tok-kw">if</span> (attrs &amp; w.FILE_ATTRIBUTE_DIRECTORY != <span class="tok-number">0</span>) <span class="tok-kw">break</span> :blk .directory;
                    <span class="tok-kw">if</span> (attrs &amp; w.FILE_ATTRIBUTE_REPARSE_POINT != <span class="tok-number">0</span>) <span class="tok-kw">break</span> :blk .sym_link;
                    <span class="tok-kw">break</span> :blk .file;
                };
                <span class="tok-kw">return</span> <a href="std.fs.Dir.Entry.html">Entry</a>{
                    .name = name_wtf8,
                    .kind = kind,
                };
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <span class="tok-type">void</span> {
            self.index = <span class="tok-number">0</span>;
            self.end_index = <span class="tok-number">0</span>;
            self.first_iter = <span class="tok-null">true</span>;
        }
    },
    .wasi =&gt; <span class="tok-kw">struct</span> {
        dir: <a href="std.fs.Dir.html">Dir</a>,
        buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span>,<span class="tok-comment"> // TODO align(@alignOf(posix.wasi.dirent_t)),
        </span>cookie: <span class="tok-type">u64</span>,
        index: <span class="tok-type">usize</span>,
        end_index: <span class="tok-type">usize</span>,

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a>;

        <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span>
        <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">Error</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {
            <span class="tok-kw">return</span> self.nextWasi() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {<span class="tok-comment">
                // To be consistent across platforms, iteration ends if the directory being iterated is deleted during iteration.
                // This matches the behavior of non-Linux UNIX platforms.
                </span><span class="tok-kw">error</span>.DirNotFound =&gt; <span class="tok-null">null</span>,
                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorWasi = <span class="tok-kw">error</span>{DirNotFound} || <a href="std.fs.Dir.html#std.fs.Dir.IteratorError">IteratorError</a>;

        <span class="tok-comment">/// Implementation of `next` that can return platform-dependent errors depending on the host platform.</span>
        <span class="tok-comment">/// When the host platform is Linux, `error.DirNotFound` can be returned if the directory being</span>
        <span class="tok-comment">/// iterated was deleted during iteration.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextWasi</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <a href="std.fs.Dir.html#std.fs.Dir.Iterator.ErrorWasi">ErrorWasi</a>!?<a href="std.fs.Dir.Entry.html">Entry</a> {<span class="tok-comment">
            // We intentinally use fd_readdir even when linked with libc,
            // since its implementation is exactly the same as below,
            // and we avoid the code complexity here.
            </span><span class="tok-kw">const</span> w = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>;
            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment">
                // According to the WASI spec, the last entry might be truncated,
                // so we need to check if the left buffer contains the whole dirent.
                </span><span class="tok-kw">if</span> (self.end_index - self.index &lt; <span class="tok-builtin">@sizeOf</span>(w.dirent_t)) {
                    <span class="tok-kw">var</span> bufused: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
                    <span class="tok-kw">switch</span> (w.fd_readdir(self.dir.fd, &amp;self.buf, self.buf.len, self.cookie, &amp;bufused)) {
                        .SUCCESS =&gt; {},
                        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Dir is invalid or was opened without iteration ability
                        </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
                        .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
                        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotFound,<span class="tok-comment"> // The directory being iterated was deleted during iteration.
                        </span>.NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                        .ILSEQ =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8,<span class="tok-comment"> // An entry's name cannot be encoded as UTF-8.
                        </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                    }
                    <span class="tok-kw">if</span> (bufused == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    self.index = <span class="tok-number">0</span>;
                    self.end_index = bufused;
                }
                <span class="tok-kw">const</span> entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) w.dirent_t, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));
                <span class="tok-kw">const</span> entry_size = <span class="tok-builtin">@sizeOf</span>(w.dirent_t);
                <span class="tok-kw">const</span> name_index = self.index + entry_size;
                <span class="tok-kw">if</span> (name_index + entry.namlen &gt; self.end_index) {<span class="tok-comment">
                    // This case, the name is truncated, so we need to call readdir to store the entire name.
                    </span>self.end_index = self.index;<span class="tok-comment"> // Force fd_readdir in the next loop.
                    </span><span class="tok-kw">continue</span> :start_over;
                }
                <span class="tok-kw">const</span> name = self.buf[name_index .. name_index + entry.namlen];

                <span class="tok-kw">const</span> next_index = name_index + entry.namlen;
                self.index = next_index;
                self.cookie = entry.next;<span class="tok-comment">

                // skip . and .. entries
                </span><span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>)) {
                    <span class="tok-kw">continue</span> :start_over;
                }

                <span class="tok-kw">const</span> entry_kind: <a href="std.fs.Dir.Entry.html">Entry</a>.<a href="std.fs.File.Kind.html">Kind</a> = <span class="tok-kw">switch</span> (entry.<span class="tok-type">type</span>) {
                    .BLOCK_DEVICE =&gt; .block_device,
                    .CHARACTER_DEVICE =&gt; .character_device,
                    .DIRECTORY =&gt; .directory,
                    .SYMBOLIC_LINK =&gt; .sym_link,
                    .REGULAR_FILE =&gt; .file,
                    .SOCKET_STREAM, .SOCKET_DGRAM =&gt; .unix_domain_socket,
                    <span class="tok-kw">else</span> =&gt; .unknown,
                };
                <span class="tok-kw">return</span> <a href="std.fs.Dir.Entry.html">Entry</a>{
                    .name = name,
                    .kind = entry_kind,
                };
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Self</a>) <span class="tok-type">void</span> {
            self.index = <span class="tok-number">0</span>;
            self.end_index = <span class="tok-number">0</span>;
            self.cookie = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.DIRCOOKIE_START">DIRCOOKIE_START</a>;
        }
    },
    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unimplemented&quot;</span>),
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterate</span>(self: <a href="std.fs.Dir.html">Dir</a>) <a href="std.fs.Dir.html#std.fs.Dir.Iterator">Iterator</a> {
    <span class="tok-kw">return</span> self.iterateImpl(<span class="tok-null">true</span>);
}

<span class="tok-comment">/// Like `iterate`, but will not reset the directory cursor before the first</span>
<span class="tok-comment">/// iteration. This should only be used in cases where it is known that the</span>
<span class="tok-comment">/// `Dir` has not had its cursor modified yet (e.g. it was just opened).</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterateAssumeFirstIteration</span>(self: <a href="std.fs.Dir.html">Dir</a>) <a href="std.fs.Dir.html#std.fs.Dir.Iterator">Iterator</a> {
    <span class="tok-kw">return</span> self.iterateImpl(<span class="tok-null">false</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">iterateImpl</span>(self: <a href="std.fs.Dir.html">Dir</a>, first_iter_start_value: <span class="tok-type">bool</span>) <a href="std.fs.Dir.html#std.fs.Dir.Iterator">Iterator</a> {
    <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {
        .macos,
        .ios,
        .freebsd,
        .netbsd,
        .dragonfly,
        .openbsd,
        .solaris,
        .illumos,
        =&gt; <span class="tok-kw">return</span> <a href="std.fs.Dir.html#std.fs.Dir.Iterator">Iterator</a>{
            .dir = self,
            .seek = <span class="tok-number">0</span>,
            .index = <span class="tok-number">0</span>,
            .end_index = <span class="tok-number">0</span>,
            .buf = <span class="tok-null">undefined</span>,
            .first_iter = first_iter_start_value,
        },
        .linux =&gt; <span class="tok-kw">return</span> <a href="std.fs.Dir.html#std.fs.Dir.Iterator">Iterator</a>{
            .dir = self,
            .index = <span class="tok-number">0</span>,
            .end_index = <span class="tok-number">0</span>,
            .buf = <span class="tok-null">undefined</span>,
            .first_iter = first_iter_start_value,
        },
        .haiku =&gt; <span class="tok-kw">return</span> <a href="std.fs.Dir.html#std.fs.Dir.Iterator">Iterator</a>{
            .dir = self,
            .offset = <span class="tok-number">0</span>,
            .index = <span class="tok-number">0</span>,
            .end_index = <span class="tok-number">0</span>,
            .buf = <span class="tok-null">undefined</span>,
            .first_iter = first_iter_start_value,
        },
        .windows =&gt; <span class="tok-kw">return</span> <a href="std.fs.Dir.html#std.fs.Dir.Iterator">Iterator</a>{
            .dir = self,
            .index = <span class="tok-number">0</span>,
            .end_index = <span class="tok-number">0</span>,
            .first_iter = first_iter_start_value,
            .buf = <span class="tok-null">undefined</span>,
            .name_data = <span class="tok-null">undefined</span>,
        },
        .wasi =&gt; <span class="tok-kw">return</span> <a href="std.fs.Dir.html#std.fs.Dir.Iterator">Iterator</a>{
            .dir = self,
            .cookie = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.DIRCOOKIE_START">DIRCOOKIE_START</a>,
            .index = <span class="tok-number">0</span>,
            .end_index = <span class="tok-number">0</span>,
            .buf = <span class="tok-null">undefined</span>,
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unimplemented&quot;</span>),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Walker = <span class="tok-kw">struct</span> {
    stack: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.fs.Dir.Walker.StackItem.html">StackItem</a>),
    name_buffer: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>),
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// The containing directory. This can be used to operate directly on `basename`</span>
        <span class="tok-comment">/// rather than `path`, avoiding `error.NameTooLong` for deeply nested paths.</span>
        <span class="tok-comment">/// The directory remains open until `next` or `deinit` is called.</span>
        dir: <a href="std.fs.Dir.html">Dir</a>,
        basename: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        path: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        kind: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.Entry.html">Entry</a>.<a href="std.fs.File.Kind.html">Kind</a>,
    };

    <span class="tok-kw">const</span> StackItem = <span class="tok-kw">struct</span> {
        iter: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Iterator</a>,
        dirname_len: <span class="tok-type">usize</span>,
    };

    <span class="tok-comment">/// After each call to this function, and on deinit(), the memory returned</span>
    <span class="tok-comment">/// from this function becomes invalid. A copy must be made in order to keep</span>
    <span class="tok-comment">/// a reference to the path.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.fs.Dir.Walker.html">Walker</a>) !?<a href="std.fs.Dir.Walker.html">Walker</a>.<a href="std.fs.Dir.Walker.Entry.html">Entry</a> {
        <span class="tok-kw">const</span> gpa = self.allocator;
        <span class="tok-kw">while</span> (self.stack.items.len != <span class="tok-number">0</span>) {<span class="tok-comment">
            // `top` and `containing` become invalid after appending to `self.stack`
            </span><span class="tok-kw">var</span> top = &amp;self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];
            <span class="tok-kw">var</span> containing = top;
            <span class="tok-kw">var</span> dirname_len = top.dirname_len;
            <span class="tok-kw">if</span> (top.iter.next() <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
                // If we get an error, then we want the user to be able to continue
                // walking if they want, which means that we need to pop the directory
                // that errored from the stack. Otherwise, all future `next` calls would
                // likely just fail with the same error.
                </span><span class="tok-kw">var</span> item = self.stack.pop().?;
                <span class="tok-kw">if</span> (self.stack.items.len != <span class="tok-number">0</span>) {
                    item.iter.dir.close();
                }
                <span class="tok-kw">return</span> err;
            }) |base| {
                self.name_buffer.shrinkRetainingCapacity(dirname_len);
                <span class="tok-kw">if</span> (self.name_buffer.items.len != <span class="tok-number">0</span>) {
                    <span class="tok-kw">try</span> self.name_buffer.append(gpa, <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep">sep</a>);
                    dirname_len += <span class="tok-number">1</span>;
                }
                <span class="tok-kw">try</span> self.name_buffer.ensureUnusedCapacity(gpa, base.name.len + <span class="tok-number">1</span>);
                self.name_buffer.appendSliceAssumeCapacity(base.name);
                self.name_buffer.appendAssumeCapacity(<span class="tok-number">0</span>);
                <span class="tok-kw">if</span> (base.kind == .directory) {
                    <span class="tok-kw">var</span> new_dir = top.iter.dir.openDir(base.name, .{ .iterate = <span class="tok-null">true</span> }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                        <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // no path sep in base.name
                        </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
                    };
                    {
                        <span class="tok-kw">errdefer</span> new_dir.close();
                        <span class="tok-kw">try</span> self.stack.append(gpa, .{
                            .iter = new_dir.iterateAssumeFirstIteration(),
                            .dirname_len = self.name_buffer.items.len - <span class="tok-number">1</span>,
                        });
                        top = &amp;self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];
                        containing = &amp;self.stack.items[self.stack.items.len - <span class="tok-number">2</span>];
                    }
                }
                <span class="tok-kw">return</span> .{
                    .dir = containing.iter.dir,
                    .basename = self.name_buffer.items[dirname_len .. self.name_buffer.items.len - <span class="tok-number">1</span> :<span class="tok-number">0</span>],
                    .path = self.name_buffer.items[<span class="tok-number">0</span> .. self.name_buffer.items.len - <span class="tok-number">1</span> :<span class="tok-number">0</span>],
                    .kind = base.kind,
                };
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">var</span> item = self.stack.pop().?;
                <span class="tok-kw">if</span> (self.stack.items.len != <span class="tok-number">0</span>) {
                    item.iter.dir.close();
                }
            }
        }
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.fs.Dir.Walker.html">Walker</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> gpa = self.allocator;<span class="tok-comment">
        // Close any remaining directories except the initial one (which is always at index 0)
        </span><span class="tok-kw">if</span> (self.stack.items.len &gt; <span class="tok-number">1</span>) {
            <span class="tok-kw">for</span> (self.stack.items[<span class="tok-number">1</span>..]) |*item| {
                item.iter.dir.close();
            }
        }
        self.stack.deinit(gpa);
        self.name_buffer.deinit(gpa);
    }
};

<span class="tok-comment">/// Recursively iterates over a directory.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `self` must have been opened with `OpenOptions{.iterate = true}`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `Walker.deinit` releases allocated memory and directory handles.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The order of returned file system entries is undefined.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `self` will not be closed after walking it.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">walk</span>(self: <a href="std.fs.Dir.html">Dir</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.fs.Dir.Walker.html">Walker</a> {
    <span class="tok-kw">var</span> stack: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.fs.Dir.Walker.html">Walker</a>.<a href="std.fs.Dir.Walker.StackItem.html">StackItem</a>) = .empty;

    <span class="tok-kw">try</span> stack.append(allocator, .{
        .iter = self.iterate(),
        .dirname_len = <span class="tok-number">0</span>,
    });

    <span class="tok-kw">return</span> .{
        .stack = stack,
        .name_buffer = .{},
        .allocator = allocator,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenError = <span class="tok-kw">error</span>{
    FileNotFound,
    NotDir,
    AccessDenied,
    SymLinkLoop,
    ProcessFdQuotaExceeded,
    NameTooLong,
    SystemFdQuotaExceeded,
    NoDevice,
    SystemResources,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
    BadPathName,
    DeviceBusy,
    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
} || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close</span>(self: *<a href="std.fs.Dir.html">Dir</a>) <span class="tok-type">void</span> {
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(self.fd);
    self.* = <span class="tok-null">undefined</span>;
}

<span class="tok-comment">/// Opens a file for reading or writing, without attempting to create a new file.</span>
<span class="tok-comment">/// To create a new file, see `createFile`.</span>
<span class="tok-comment">/// Call `File.close` to release the resource.</span>
<span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span>
<span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(self.fd, sub_path);
        <span class="tok-kw">return</span> self.openFileW(path_w.span(), flags);
    }
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> base: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.rights_t.html">rights_t</a> = .{};<span class="tok-comment">
        // POLL_FD_READWRITE only grants extra rights if the corresponding FD_READ and/or FD_WRITE
        // is also set.
        </span><span class="tok-kw">if</span> (flags.isRead()) {
            base.FD_READ = <span class="tok-null">true</span>;
            base.FD_TELL = <span class="tok-null">true</span>;
            base.FD_SEEK = <span class="tok-null">true</span>;
            base.FD_FILESTAT_GET = <span class="tok-null">true</span>;
            base.POLL_FD_READWRITE = <span class="tok-null">true</span>;
        }
        <span class="tok-kw">if</span> (flags.isWrite()) {
            base.FD_WRITE = <span class="tok-null">true</span>;
            base.FD_TELL = <span class="tok-null">true</span>;
            base.FD_SEEK = <span class="tok-null">true</span>;
            base.FD_DATASYNC = <span class="tok-null">true</span>;
            base.FD_FDSTAT_SET_FLAGS = <span class="tok-null">true</span>;
            base.FD_SYNC = <span class="tok-null">true</span>;
            base.FD_ALLOCATE = <span class="tok-null">true</span>;
            base.FD_ADVISE = <span class="tok-null">true</span>;
            base.FD_FILESTAT_SET_TIMES = <span class="tok-null">true</span>;
            base.FD_FILESTAT_SET_SIZE = <span class="tok-null">true</span>;
            base.POLL_FD_READWRITE = <span class="tok-null">true</span>;
        }
        <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.openatWasi">openatWasi</a>(self.fd, sub_path, .{}, .{}, .{}, base, .{});
        <span class="tok-kw">return</span> .{ .handle = fd };
    }
    <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sub_path);
    <span class="tok-kw">return</span> self.openFileZ(&amp;path_c, flags);
}

<span class="tok-comment">/// Same as `openFile` but the path parameter is null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {
        .windows =&gt; {
            <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(self.fd, sub_path);
            <span class="tok-kw">return</span> self.openFileW(path_w.span(), flags);
        },<span class="tok-comment">
        // Use the libc API when libc is linked because it implements things
        // such as opening absolute file paths.
        </span>.wasi =&gt; <span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
            <span class="tok-kw">return</span> <a href="std.fs.Dir.html#std.fs.Dir.openFile">openFile</a>(self, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sub_path, <span class="tok-number">0</span>), flags);
        },
        <span class="tok-kw">else</span> =&gt; {},
    }

    <span class="tok-kw">var</span> os_flags: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a> = <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {
        .wasi =&gt; .{
            .read = flags.mode != .write_only,
            .write = flags.mode != .read_only,
        },
        <span class="tok-kw">else</span> =&gt; .{
            .ACCMODE = <span class="tok-kw">switch</span> (flags.mode) {
                .read_only =&gt; .RDONLY,
                .write_only =&gt; .WRONLY,
                .read_write =&gt; .RDWR,
            },
        },
    };
    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;CLOEXEC&quot;</span>)) os_flags.CLOEXEC = <span class="tok-null">true</span>;
    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;LARGEFILE&quot;</span>)) os_flags.LARGEFILE = <span class="tok-null">true</span>;
    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;NOCTTY&quot;</span>)) os_flags.NOCTTY = !flags.allow_ctty;<span class="tok-comment">

    // Use the O locking flags if the os supports them to acquire the lock
    // atomically.
    </span><span class="tok-kw">const</span> has_flock_open_flags = <span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;EXLOCK&quot;</span>);
    <span class="tok-kw">if</span> (has_flock_open_flags) {<span class="tok-comment">
        // Note that the NONBLOCK flag is removed after the openat() call
        // is successful.
        </span><span class="tok-kw">switch</span> (flags.lock) {
            .none =&gt; {},
            .shared =&gt; {
                os_flags.SHLOCK = <span class="tok-null">true</span>;
                os_flags.NONBLOCK = flags.lock_nonblocking;
            },
            .exclusive =&gt; {
                os_flags.EXLOCK = <span class="tok-null">true</span>;
                os_flags.NONBLOCK = flags.lock_nonblocking;
            },
        }
    }
    <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.openatZ">openatZ</a>(self.fd, sub_path, os_flags, <span class="tok-number">0</span>);
    <span class="tok-kw">errdefer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(fd);

    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.have_flock">have_flock</a> <span class="tok-kw">and</span> !has_flock_open_flags <span class="tok-kw">and</span> flags.lock != .none) {<span class="tok-comment">
        // TODO: integrate async I/O
        </span><span class="tok-kw">const</span> lock_nonblocking: <span class="tok-type">i32</span> = <span class="tok-kw">if</span> (flags.lock_nonblocking) <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.NB">NB</a> <span class="tok-kw">else</span> <span class="tok-number">0</span>;
        <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.flock">flock</a>(fd, <span class="tok-kw">switch</span> (flags.lock) {
            .none =&gt; <span class="tok-kw">unreachable</span>,
            .shared =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.SH">SH</a> | lock_nonblocking,
            .exclusive =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.EX">EX</a> | lock_nonblocking,
        });
    }

    <span class="tok-kw">if</span> (has_flock_open_flags <span class="tok-kw">and</span> flags.lock_nonblocking) {
        <span class="tok-kw">var</span> fl_flags = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fcntl">fcntl</a>(fd, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.F">F</a>.<a href="#">GETFL</a>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        fl_flags &amp;= ~<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span> &lt;&lt; <span class="tok-builtin">@bitOffsetOf</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;NONBLOCK&quot;</span>));
        _ = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fcntl">fcntl</a>(fd, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.F">F</a>.<a href="#">SETFL</a>, fl_flags) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    }

    <span class="tok-kw">return</span> .{ .handle = fd };
}

<span class="tok-comment">/// Same as `openFile` but Windows-only and the path parameter is</span>
<span class="tok-comment">/// [WTF-16](https://simonsapin.github.io/wtf-8/#potentially-ill-formed-utf-16) encoded.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <span class="tok-kw">const</span> w = <a href="std.os.windows.html">windows</a>;
    <span class="tok-kw">const</span> file: <a href="std.fs.File.html">File</a> = .{
        .handle = <span class="tok-kw">try</span> w.OpenFile(sub_path_w, .{
            .dir = self.fd,
            .access_mask = w.SYNCHRONIZE |
                (<span class="tok-kw">if</span> (flags.isRead()) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.GENERIC_READ) <span class="tok-kw">else</span> <span class="tok-number">0</span>) |
                (<span class="tok-kw">if</span> (flags.isWrite()) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.GENERIC_WRITE) <span class="tok-kw">else</span> <span class="tok-number">0</span>),
            .creation = w.FILE_OPEN,
        }),
    };
    <span class="tok-kw">errdefer</span> file.close();
    <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> range_off: w.LARGE_INTEGER = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> range_len: w.LARGE_INTEGER = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> exclusive = <span class="tok-kw">switch</span> (flags.lock) {
        .none =&gt; <span class="tok-kw">return</span> file,
        .shared =&gt; <span class="tok-null">false</span>,
        .exclusive =&gt; <span class="tok-null">true</span>,
    };
    <span class="tok-kw">try</span> w.LockFile(
        file.handle,
        <span class="tok-null">null</span>,
        <span class="tok-null">null</span>,
        <span class="tok-null">null</span>,
        &amp;io,
        &amp;range_off,
        &amp;range_len,
        <span class="tok-null">null</span>,
        <span class="tok-builtin">@intFromBool</span>(flags.lock_nonblocking),
        <span class="tok-builtin">@intFromBool</span>(exclusive),
    );
    <span class="tok-kw">return</span> file;
}

<span class="tok-comment">/// Creates, opens, or overwrites a file with write access.</span>
<span class="tok-comment">/// Call `File.close` on the result when done.</span>
<span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span>
<span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(self.fd, sub_path);
        <span class="tok-kw">return</span> self.createFileW(path_w.span(), flags);
    }
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .wasi) {
        <span class="tok-kw">return</span> .{
            .handle = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.openatWasi">openatWasi</a>(self.fd, sub_path, .{}, .{
                .CREAT = <span class="tok-null">true</span>,
                .TRUNC = flags.truncate,
                .EXCL = flags.exclusive,
            }, .{}, .{
                .FD_READ = flags.read,
                .FD_WRITE = <span class="tok-null">true</span>,
                .FD_DATASYNC = <span class="tok-null">true</span>,
                .FD_SEEK = <span class="tok-null">true</span>,
                .FD_TELL = <span class="tok-null">true</span>,
                .FD_FDSTAT_SET_FLAGS = <span class="tok-null">true</span>,
                .FD_SYNC = <span class="tok-null">true</span>,
                .FD_ALLOCATE = <span class="tok-null">true</span>,
                .FD_ADVISE = <span class="tok-null">true</span>,
                .FD_FILESTAT_SET_TIMES = <span class="tok-null">true</span>,
                .FD_FILESTAT_SET_SIZE = <span class="tok-null">true</span>,
                .FD_FILESTAT_GET = <span class="tok-null">true</span>,<span class="tok-comment">
                // POLL_FD_READWRITE only grants extra rights if the corresponding FD_READ and/or
                // FD_WRITE is also set.
                </span>.POLL_FD_READWRITE = <span class="tok-null">true</span>,
            }, .{}),
        };
    }
    <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sub_path);
    <span class="tok-kw">return</span> self.createFileZ(&amp;path_c, flags);
}

<span class="tok-comment">/// Same as `createFile` but the path parameter is null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {
        .windows =&gt; {
            <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(self.fd, sub_path_c);
            <span class="tok-kw">return</span> self.createFileW(path_w.span(), flags);
        },
        .wasi =&gt; {
            <span class="tok-kw">return</span> <a href="std.fs.Dir.html#std.fs.Dir.createFile">createFile</a>(self, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sub_path_c, <span class="tok-number">0</span>), flags);
        },
        <span class="tok-kw">else</span> =&gt; {},
    }

    <span class="tok-kw">var</span> os_flags: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a> = .{
        .ACCMODE = <span class="tok-kw">if</span> (flags.read) .RDWR <span class="tok-kw">else</span> .WRONLY,
        .CREAT = <span class="tok-null">true</span>,
        .TRUNC = flags.truncate,
        .EXCL = flags.exclusive,
    };
    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;LARGEFILE&quot;</span>)) os_flags.LARGEFILE = <span class="tok-null">true</span>;
    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;CLOEXEC&quot;</span>)) os_flags.CLOEXEC = <span class="tok-null">true</span>;<span class="tok-comment">

    // Use the O locking flags if the os supports them to acquire the lock
    // atomically. Note that the NONBLOCK flag is removed after the openat()
    // call is successful.
    </span><span class="tok-kw">const</span> has_flock_open_flags = <span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;EXLOCK&quot;</span>);
    <span class="tok-kw">if</span> (has_flock_open_flags) <span class="tok-kw">switch</span> (flags.lock) {
        .none =&gt; {},
        .shared =&gt; {
            os_flags.SHLOCK = <span class="tok-null">true</span>;
            os_flags.NONBLOCK = flags.lock_nonblocking;
        },
        .exclusive =&gt; {
            os_flags.EXLOCK = <span class="tok-null">true</span>;
            os_flags.NONBLOCK = flags.lock_nonblocking;
        },
    };

    <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.openatZ">openatZ</a>(self.fd, sub_path_c, os_flags, flags.mode);
    <span class="tok-kw">errdefer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(fd);

    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.have_flock">have_flock</a> <span class="tok-kw">and</span> !has_flock_open_flags <span class="tok-kw">and</span> flags.lock != .none) {<span class="tok-comment">
        // TODO: integrate async I/O
        </span><span class="tok-kw">const</span> lock_nonblocking: <span class="tok-type">i32</span> = <span class="tok-kw">if</span> (flags.lock_nonblocking) <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.NB">NB</a> <span class="tok-kw">else</span> <span class="tok-number">0</span>;
        <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.flock">flock</a>(fd, <span class="tok-kw">switch</span> (flags.lock) {
            .none =&gt; <span class="tok-kw">unreachable</span>,
            .shared =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.SH">SH</a> | lock_nonblocking,
            .exclusive =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.EX">EX</a> | lock_nonblocking,
        });
    }

    <span class="tok-kw">if</span> (has_flock_open_flags <span class="tok-kw">and</span> flags.lock_nonblocking) {
        <span class="tok-kw">var</span> fl_flags = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fcntl">fcntl</a>(fd, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.F">F</a>.<a href="#">GETFL</a>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        fl_flags &amp;= ~<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span> &lt;&lt; <span class="tok-builtin">@bitOffsetOf</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;NONBLOCK&quot;</span>));
        _ = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fcntl">fcntl</a>(fd, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.F">F</a>.<a href="#">SETFL</a>, fl_flags) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    }

    <span class="tok-kw">return</span> .{ .handle = fd };
}

<span class="tok-comment">/// Same as `createFile` but Windows-only and the path parameter is</span>
<span class="tok-comment">/// [WTF-16](https://simonsapin.github.io/wtf-8/#potentially-ill-formed-utf-16) encoded.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <span class="tok-kw">const</span> w = <a href="std.os.windows.html">windows</a>;
    <span class="tok-kw">const</span> read_flag = <span class="tok-kw">if</span> (flags.read) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.GENERIC_READ) <span class="tok-kw">else</span> <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> file: <a href="std.fs.File.html">File</a> = .{
        .handle = <span class="tok-kw">try</span> w.OpenFile(sub_path_w, .{
            .dir = self.fd,
            .access_mask = w.SYNCHRONIZE | w.GENERIC_WRITE | read_flag,
            .creation = <span class="tok-kw">if</span> (flags.exclusive)
                <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.FILE_CREATE)
            <span class="tok-kw">else</span> <span class="tok-kw">if</span> (flags.truncate)
                <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.FILE_OVERWRITE_IF)
            <span class="tok-kw">else</span>
                <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.FILE_OPEN_IF),
        }),
    };
    <span class="tok-kw">errdefer</span> file.close();
    <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> range_off: w.LARGE_INTEGER = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> range_len: w.LARGE_INTEGER = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> exclusive = <span class="tok-kw">switch</span> (flags.lock) {
        .none =&gt; <span class="tok-kw">return</span> file,
        .shared =&gt; <span class="tok-null">false</span>,
        .exclusive =&gt; <span class="tok-null">true</span>,
    };
    <span class="tok-kw">try</span> w.LockFile(
        file.handle,
        <span class="tok-null">null</span>,
        <span class="tok-null">null</span>,
        <span class="tok-null">null</span>,
        &amp;io,
        &amp;range_off,
        &amp;range_len,
        <span class="tok-null">null</span>,
        <span class="tok-builtin">@intFromBool</span>(flags.lock_nonblocking),
        <span class="tok-builtin">@intFromBool</span>(exclusive),
    );
    <span class="tok-kw">return</span> file;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MakeError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>;

<span class="tok-comment">/// Creates a single directory with a relative or absolute path.</span>
<span class="tok-comment">/// To create multiple directories to make an entire path, see `makePath`.</span>
<span class="tok-comment">/// To operate on only absolute paths, see `makeDirAbsolute`.</span>
<span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDir</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.MakeDirError">MakeError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mkdirat">mkdirat</a>(self.fd, sub_path, <a href="std.fs.Dir.html#std.fs.Dir.default_mode">default_mode</a>);
}

<span class="tok-comment">/// Same as `makeDir`, but `sub_path` is null-terminated.</span>
<span class="tok-comment">/// To create multiple directories to make an entire path, see `makePath`.</span>
<span class="tok-comment">/// To operate on only absolute paths, see `makeDirAbsoluteZ`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.MakeDirError">MakeError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mkdiratZ">mkdiratZ</a>(self.fd, sub_path, <a href="std.fs.Dir.html#std.fs.Dir.default_mode">default_mode</a>);
}

<span class="tok-comment">/// Creates a single directory with a relative or absolute null-terminated WTF-16 LE-encoded path.</span>
<span class="tok-comment">/// To create multiple directories to make an entire path, see `makePath`.</span>
<span class="tok-comment">/// To operate on only absolute paths, see `makeDirAbsoluteW`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.MakeDirError">MakeError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mkdiratW">mkdiratW</a>(self.fd, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(sub_path), <a href="std.fs.Dir.html#std.fs.Dir.default_mode">default_mode</a>);
}

<span class="tok-comment">/// Calls makeDir iteratively to make an entire path</span>
<span class="tok-comment">/// (i.e. creating any parent directories that do not exist).</span>
<span class="tok-comment">/// Returns success if the path already exists and is a directory.</span>
<span class="tok-comment">/// This function is not atomic, and if it returns an error, the file system may</span>
<span class="tok-comment">/// have been modified regardless.</span>
<span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Paths containing `..` components are handled differently depending on the platform:</span>
<span class="tok-comment">/// - On Windows, `..` are resolved before the path is passed to NtCreateFile, meaning</span>
<span class="tok-comment">///   a `sub_path` like &quot;first/../second&quot; will resolve to &quot;second&quot; and only a</span>
<span class="tok-comment">///   `./second` directory will be created.</span>
<span class="tok-comment">/// - On other platforms, `..` are not resolved before the path is passed to `mkdirat`,</span>
<span class="tok-comment">///   meaning a `sub_path` like &quot;first/../second&quot; will create both a `./first`</span>
<span class="tok-comment">///   and a `./second` directory.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makePath</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) (<a href="std.posix.html#std.posix.MakeDirError">MakeError</a> || <a href="std.fs.Dir.html#std.fs.Dir.StatFileError">StatFileError</a>)!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> it = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.componentIterator">componentIterator</a>(sub_path);
    <span class="tok-kw">var</span> component = it.last() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        self.makeDir(component.path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.PathAlreadyExists =&gt; {<span class="tok-comment">
                // stat the file and return an error if it's not a directory
                // this is important because otherwise a dangling symlink
                // could cause an infinite loop
                </span>check_dir: {<span class="tok-comment">
                    // workaround for windows, see https://github.com/ziglang/zig/issues/16738
                    </span><span class="tok-kw">const</span> fstat = self.statFile(component.path) <span class="tok-kw">catch</span> |stat_err| <span class="tok-kw">switch</span> (stat_err) {
                        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">break</span> :check_dir,
                        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
                    };
                    <span class="tok-kw">if</span> (fstat.kind != .directory) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir;
                }
            },
            <span class="tok-kw">error</span>.FileNotFound =&gt; |e| {
                component = it.previous() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> e;
                <span class="tok-kw">continue</span>;
            },
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        component = it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
    }
}

<span class="tok-comment">/// Windows only. Calls makeOpenDirAccessMaskW iteratively to make an entire path</span>
<span class="tok-comment">/// (i.e. creating any parent directories that do not exist).</span>
<span class="tok-comment">/// Opens the dir if the path already exists and is a directory.</span>
<span class="tok-comment">/// This function is not atomic, and if it returns an error, the file system may</span>
<span class="tok-comment">/// have been modified regardless.</span>
<span class="tok-comment">/// `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-kw">fn</span> <span class="tok-fn">makeOpenPathAccessMaskW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, access_mask: <span class="tok-type">u32</span>, no_follow: <span class="tok-type">bool</span>) (<a href="std.posix.html#std.posix.MakeDirError">MakeError</a> || <a href="std.fs.Dir.html#std.fs.Dir.OpenError">OpenError</a> || <a href="std.fs.Dir.html#std.fs.Dir.StatFileError">StatFileError</a>)!<a href="std.fs.Dir.html">Dir</a> {
    <span class="tok-kw">const</span> w = <a href="std.os.windows.html">windows</a>;
    <span class="tok-kw">var</span> it = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.componentIterator">componentIterator</a>(sub_path);<span class="tok-comment">
    // If there are no components in the path, then create a dummy component with the full path.
    </span><span class="tok-kw">var</span> component = it.last() <span class="tok-kw">orelse</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.NativeComponentIterator">NativeComponentIterator</a>.<a href="#">Component</a>{
        .name = <span class="tok-str">&quot;&quot;</span>,
        .path = sub_path,
    };

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> w.sliceToPrefixedFileW(self.fd, component.path);
        <span class="tok-kw">const</span> is_last = it.peekNext() == <span class="tok-null">null</span>;
        <span class="tok-kw">var</span> result = self.makeOpenDirAccessMaskW(sub_path_w.span().ptr, access_mask, .{
            .no_follow = no_follow,
            .create_disposition = <span class="tok-kw">if</span> (is_last) w.FILE_OPEN_IF <span class="tok-kw">else</span> w.FILE_CREATE,
        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileNotFound =&gt; |e| {
                component = it.previous() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> e;
                <span class="tok-kw">continue</span>;
            },
            <span class="tok-kw">error</span>.PathAlreadyExists =&gt; result: {
                <a href="std.debug.html#std.debug.assert">assert</a>(!is_last);<span class="tok-comment">
                // stat the file and return an error if it's not a directory
                // this is important because otherwise a dangling symlink
                // could cause an infinite loop
                </span>check_dir: {<span class="tok-comment">
                    // workaround for windows, see https://github.com/ziglang/zig/issues/16738
                    </span><span class="tok-kw">const</span> fstat = self.statFile(component.path) <span class="tok-kw">catch</span> |stat_err| <span class="tok-kw">switch</span> (stat_err) {
                        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">break</span> :check_dir,
                        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
                    };
                    <span class="tok-kw">if</span> (fstat.kind != .directory) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir;
                }
                <span class="tok-kw">break</span> :result <span class="tok-null">null</span>;
            },
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };

        component = it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> result.?;<span class="tok-comment">

        // Don't leak the intermediate file handles
        </span><span class="tok-kw">if</span> (result) |*dir| {
            dir.close();
        }
    }
}

<span class="tok-comment">/// This function performs `makePath`, followed by `openDir`.</span>
<span class="tok-comment">/// If supported by the OS, this operation is atomic. It is not atomic on</span>
<span class="tok-comment">/// all operating systems.</span>
<span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeOpenPath</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, open_dir_options: <a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) (<a href="std.posix.html#std.posix.MakeDirError">MakeError</a> || <a href="std.fs.Dir.html#std.fs.Dir.OpenError">OpenError</a> || <a href="std.fs.Dir.html#std.fs.Dir.StatFileError">StatFileError</a>)!<a href="std.fs.Dir.html">Dir</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {
        .windows =&gt; {
            <span class="tok-kw">const</span> w = <a href="std.os.windows.html">windows</a>;
            <span class="tok-kw">const</span> base_flags = w.STANDARD_RIGHTS_READ | w.FILE_READ_ATTRIBUTES | w.FILE_READ_EA |
                w.SYNCHRONIZE | w.FILE_TRAVERSE |
                (<span class="tok-kw">if</span> (open_dir_options.iterate) w.FILE_LIST_DIRECTORY <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>));

            <span class="tok-kw">return</span> self.makeOpenPathAccessMaskW(sub_path, base_flags, open_dir_options.no_follow);
        },
        <span class="tok-kw">else</span> =&gt; {
            <span class="tok-kw">return</span> self.openDir(sub_path, open_dir_options) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.FileNotFound =&gt; {
                    <span class="tok-kw">try</span> self.makePath(sub_path);
                    <span class="tok-kw">return</span> self.openDir(sub_path, open_dir_options);
                },
                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };
        },
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RealPathError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.RealPathError">RealPathError</a>;

<span class="tok-comment">///  This function returns the canonicalized absolute pathname of</span>
<span class="tok-comment">/// `pathname` relative to this `Dir`. If `pathname` is absolute, ignores this</span>
<span class="tok-comment">/// `Dir` handle and returns the canonicalized absolute pathname of `pathname`</span>
<span class="tok-comment">/// argument.</span>
<span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">/// On Windows, the result is encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On other platforms, the result is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">/// This function is not universally supported by all platforms.</span>
<span class="tok-comment">/// Currently supported hosts are: Linux, macOS, and Windows.</span>
<span class="tok-comment">/// See also `Dir.realpathZ`, `Dir.realpathW`, and `Dir.realpathAlloc`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpath</span>(self: <a href="std.fs.Dir.html">Dir</a>, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .wasi) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;realpath is not available on WASI&quot;</span>);
    }
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> pathname_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(self.fd, pathname);
        <span class="tok-kw">return</span> self.realpathW(pathname_w.span(), out_buffer);
    }
    <span class="tok-kw">const</span> pathname_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(pathname);
    <span class="tok-kw">return</span> self.realpathZ(&amp;pathname_c, out_buffer);
}

<span class="tok-comment">/// Same as `Dir.realpath` except `pathname` is null-terminated.</span>
<span class="tok-comment">/// See also `Dir.realpath`, `realpathZ`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> pathname_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(self.fd, pathname);
        <span class="tok-kw">return</span> self.realpathW(pathname_w.span(), out_buffer);
    }

    <span class="tok-kw">var</span> flags: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a> = .{};
    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;NONBLOCK&quot;</span>)) flags.NONBLOCK = <span class="tok-null">true</span>;
    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;CLOEXEC&quot;</span>)) flags.CLOEXEC = <span class="tok-null">true</span>;
    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;PATH&quot;</span>)) flags.PATH = <span class="tok-null">true</span>;

    <span class="tok-kw">const</span> fd = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.openatZ">openatZ</a>(self.fd, pathname, flags, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // WASI-only
        </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
    <span class="tok-kw">defer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(fd);

    <span class="tok-kw">var</span> buffer: [<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> out_path = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.getFdPath">getFdPath</a>(fd, &amp;buffer);

    <span class="tok-kw">if</span> (out_path.len &gt; out_buffer.len) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
    }

    <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..out_path.len];
    <span class="tok-builtin">@memcpy</span>(result, out_path);
    <span class="tok-kw">return</span> result;
}

<span class="tok-comment">/// Windows-only. Same as `Dir.realpath` except `pathname` is WTF16 LE encoded.</span>
<span class="tok-comment">/// The result is encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// See also `Dir.realpath`, `realpathW`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathW</span>(self: <a href="std.fs.Dir.html">Dir</a>, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> w = <a href="std.os.windows.html">windows</a>;

    <span class="tok-kw">const</span> access_mask = w.GENERIC_READ | w.SYNCHRONIZE;
    <span class="tok-kw">const</span> share_access = w.FILE_SHARE_READ | w.FILE_SHARE_WRITE | w.FILE_SHARE_DELETE;
    <span class="tok-kw">const</span> creation = w.FILE_OPEN;
    <span class="tok-kw">const</span> h_file = blk: {
        <span class="tok-kw">const</span> res = w.OpenFile(pathname, .{
            .dir = self.fd,
            .access_mask = access_mask,
            .share_access = share_access,
            .creation = creation,
            .filter = .any,
        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        <span class="tok-kw">break</span> :blk res;
    };
    <span class="tok-kw">defer</span> w.CloseHandle(h_file);

    <span class="tok-kw">var</span> wide_buf: [w.PATH_MAX_WIDE]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> wide_slice = <span class="tok-kw">try</span> w.GetFinalPathNameByHandle(h_file, .{}, &amp;wide_buf);
    <span class="tok-kw">const</span> len = <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.calcWtf8Len">calcWtf8Len</a>(wide_slice);
    <span class="tok-kw">if</span> (len &gt; out_buffer.len)
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
    <span class="tok-kw">const</span> end_index = <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf16LeToWtf8">wtf16LeToWtf8</a>(out_buffer, wide_slice);
    <span class="tok-kw">return</span> out_buffer[<span class="tok-number">0</span>..end_index];
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RealPathAllocError = <a href="std.posix.html#std.posix.RealPathError">RealPathError</a> || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>;

<span class="tok-comment">/// Same as `Dir.realpath` except caller must free the returned memory.</span>
<span class="tok-comment">/// See also `Dir.realpath`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathAlloc</span>(self: <a href="std.fs.Dir.html">Dir</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html#std.fs.Dir.RealPathAllocError">RealPathAllocError</a>![]<span class="tok-type">u8</span> {<span class="tok-comment">
    // Use of max_path_bytes here is valid as the realpath function does not
    // have a variant that takes an arbitrary-size buffer.
    // TODO(#4812): Consider reimplementing realpath or using the POSIX.1-2008
    // NULL out parameter (GNU's canonicalize_file_name) to handle overelong
    // paths. musl supports passing NULL but restricts the output to PATH_MAX
    // anyway.
    </span><span class="tok-kw">var</span> buf: [<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> self.realpath(pathname, buf[<span class="tok-number">0</span>..]));
}

<span class="tok-comment">/// Changes the current working directory to the open directory handle.</span>
<span class="tok-comment">/// This modifies global state and can have surprising effects in multi-</span>
<span class="tok-comment">/// threaded applications. Most applications and especially libraries should</span>
<span class="tok-comment">/// not call this function as a general rule, however it can have use cases</span>
<span class="tok-comment">/// in, for example, implementing a shell, or child process execution.</span>
<span class="tok-comment">/// Not all targets support this. For example, WASI does not have the concept</span>
<span class="tok-comment">/// of a current working directory.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setAsCwd</span>(self: <a href="std.fs.Dir.html">Dir</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .wasi) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;changing cwd is not currently possible in WASI&quot;</span>);
    }
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">var</span> dir_path_buffer: [<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PATH_MAX_WIDE">PATH_MAX_WIDE</a>]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> dir_path = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetFinalPathNameByHandle">GetFinalPathNameByHandle</a>(self.fd, .{}, &amp;dir_path_buffer);
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
            <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.chdirW">chdirW</a>(dir_path);
        }
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SetCurrentDirectory">SetCurrentDirectory</a>(dir_path);
    }
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fchdir">fchdir</a>(self.fd);
}

<span class="tok-comment">/// Deprecated: use `OpenOptions`</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenDirOptions = <a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenOptions = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// `true` means the opened directory can be used as the `Dir` parameter</span>
    <span class="tok-comment">/// for functions which operate based on an open directory handle. When `false`,</span>
    <span class="tok-comment">/// such operations are Illegal Behavior.</span>
    access_sub_paths: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,

    <span class="tok-comment">/// `true` means the opened directory can be scanned for the files and sub-directories</span>
    <span class="tok-comment">/// of the result. It means the `iterate` function can be called.</span>
    iterate: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

    <span class="tok-comment">/// `true` means it won't dereference the symlinks.</span>
    no_follow: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
};

<span class="tok-comment">/// Opens a directory at the given path. The directory is a system resource that remains</span>
<span class="tok-comment">/// open until `close` is called on the result.</span>
<span class="tok-comment">/// The directory cannot be iterated unless the `iterate` option is set to `true`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDir</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) <a href="std.fs.Dir.html#std.fs.Dir.OpenError">OpenError</a>!<a href="std.fs.Dir.html">Dir</a> {
    <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {
        .windows =&gt; {
            <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(self.fd, sub_path);
            <span class="tok-kw">return</span> self.openDirW(sub_path_w.span().ptr, args);
        },
        .wasi =&gt; <span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
            <span class="tok-kw">var</span> base: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.rights_t.html">rights_t</a> = .{
                .FD_FILESTAT_GET = <span class="tok-null">true</span>,
                .FD_FDSTAT_SET_FLAGS = <span class="tok-null">true</span>,
                .FD_FILESTAT_SET_TIMES = <span class="tok-null">true</span>,
            };
            <span class="tok-kw">if</span> (args.access_sub_paths) {
                base.FD_READDIR = <span class="tok-null">true</span>;
                base.PATH_CREATE_DIRECTORY = <span class="tok-null">true</span>;
                base.PATH_CREATE_FILE = <span class="tok-null">true</span>;
                base.PATH_LINK_SOURCE = <span class="tok-null">true</span>;
                base.PATH_LINK_TARGET = <span class="tok-null">true</span>;
                base.PATH_OPEN = <span class="tok-null">true</span>;
                base.PATH_READLINK = <span class="tok-null">true</span>;
                base.PATH_RENAME_SOURCE = <span class="tok-null">true</span>;
                base.PATH_RENAME_TARGET = <span class="tok-null">true</span>;
                base.PATH_FILESTAT_GET = <span class="tok-null">true</span>;
                base.PATH_FILESTAT_SET_SIZE = <span class="tok-null">true</span>;
                base.PATH_FILESTAT_SET_TIMES = <span class="tok-null">true</span>;
                base.PATH_SYMLINK = <span class="tok-null">true</span>;
                base.PATH_REMOVE_DIRECTORY = <span class="tok-null">true</span>;
                base.PATH_UNLINK_FILE = <span class="tok-null">true</span>;
            }

            <span class="tok-kw">const</span> result = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.openatWasi">openatWasi</a>(
                self.fd,
                sub_path,
                .{ .SYMLINK_FOLLOW = !args.no_follow },
                .{ .DIRECTORY = <span class="tok-null">true</span> },
                .{},
                base,
                base,
            );
            <span class="tok-kw">const</span> fd = result <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.FileTooBig =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // can't happen for directories
                </span><span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // we're setting DIRECTORY
                </span><span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not setting CREAT
                </span><span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not setting CREAT
                </span><span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // locking folders is not supported
                </span><span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // can't happen for directories
                </span><span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // can't happen for directories
                </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };
            <span class="tok-kw">return</span> .{ .fd = fd };
        },
        <span class="tok-kw">else</span> =&gt; {},
    }
    <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sub_path);
    <span class="tok-kw">return</span> self.openDirZ(&amp;sub_path_c, args);
}

<span class="tok-comment">/// Same as `openDir` except the parameter is null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) <a href="std.fs.Dir.html#std.fs.Dir.OpenError">OpenError</a>!<a href="std.fs.Dir.html">Dir</a> {
    <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {
        .windows =&gt; {
            <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(self.fd, sub_path_c);
            <span class="tok-kw">return</span> self.openDirW(sub_path_w.span().ptr, args);
        },<span class="tok-comment">
        // Use the libc API when libc is linked because it implements things
        // such as opening absolute directory paths.
        </span>.wasi =&gt; <span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
            <span class="tok-kw">return</span> <a href="std.fs.Dir.html#std.fs.Dir.openDir">openDir</a>(self, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sub_path_c, <span class="tok-number">0</span>), args);
        },
        .haiku =&gt; {
            <span class="tok-kw">const</span> rc = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">_kern_open_dir</a>(self.fd, sub_path_c);
            <span class="tok-kw">if</span> (rc &gt;= <span class="tok-number">0</span>) <span class="tok-kw">return</span> .{ .fd = rc };
            <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>, <span class="tok-builtin">@enumFromInt</span>(rc))) {
                .FAULT =&gt; <span class="tok-kw">unreachable</span>,
                .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                .BADF =&gt; <span class="tok-kw">unreachable</span>,
                .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
                .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
                .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
                .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
                .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoDevice,
                .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
                .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
                .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeviceBusy,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
        },
        <span class="tok-kw">else</span> =&gt; {},
    }

    <span class="tok-kw">var</span> symlink_flags: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a> = <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {
        .wasi =&gt; .{
            .read = <span class="tok-null">true</span>,
            .NOFOLLOW = args.no_follow,
            .DIRECTORY = <span class="tok-null">true</span>,
        },
        <span class="tok-kw">else</span> =&gt; .{
            .ACCMODE = .RDONLY,
            .NOFOLLOW = args.no_follow,
            .DIRECTORY = <span class="tok-null">true</span>,
            .CLOEXEC = <span class="tok-null">true</span>,
        },
    };

    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;PATH&quot;</span>) <span class="tok-kw">and</span> !args.iterate)
        symlink_flags.PATH = <span class="tok-null">true</span>;

    <span class="tok-kw">return</span> self.openDirFlagsZ(sub_path_c, symlink_flags);
}

<span class="tok-comment">/// Same as `openDir` except the path parameter is WTF-16 LE encoded, NT-prefixed.</span>
<span class="tok-comment">/// This function asserts the target OS is Windows.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, args: <a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) <a href="std.fs.Dir.html#std.fs.Dir.OpenError">OpenError</a>!<a href="std.fs.Dir.html">Dir</a> {
    <span class="tok-kw">const</span> w = <a href="std.os.windows.html">windows</a>;<span class="tok-comment">
    // TODO remove some of these flags if args.access_sub_paths is false
    </span><span class="tok-kw">const</span> base_flags = w.STANDARD_RIGHTS_READ | w.FILE_READ_ATTRIBUTES | w.FILE_READ_EA |
        w.SYNCHRONIZE | w.FILE_TRAVERSE;
    <span class="tok-kw">const</span> flags: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (args.iterate) base_flags | w.FILE_LIST_DIRECTORY <span class="tok-kw">else</span> base_flags;
    <span class="tok-kw">const</span> dir = self.makeOpenDirAccessMaskW(sub_path_w, flags, .{
        .no_follow = args.no_follow,
        .create_disposition = w.FILE_OPEN,
    }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.ReadOnlyFileSystem =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.DiskQuota =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.LinkQuotaExceeded =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
    <span class="tok-kw">return</span> dir;
}

<span class="tok-comment">/// Asserts `flags` has `DIRECTORY` set.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">openDirFlagsZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a>) <a href="std.fs.Dir.html#std.fs.Dir.OpenError">OpenError</a>!<a href="std.fs.Dir.html">Dir</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(flags.DIRECTORY);
    <span class="tok-kw">const</span> fd = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.openatZ">openatZ</a>(self.fd, sub_path_c, flags, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.FileTooBig =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // can't happen for directories
        </span><span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // we're setting DIRECTORY
        </span><span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not setting CREAT
        </span><span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not setting CREAT
        </span><span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // locking folders is not supported
        </span><span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // can't happen for directories
        </span><span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // can't happen for directories
        </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
    <span class="tok-kw">return</span> <a href="std.fs.Dir.html">Dir</a>{ .fd = fd };
}

<span class="tok-kw">const</span> MakeOpenDirAccessMaskWOptions = <span class="tok-kw">struct</span> {
    no_follow: <span class="tok-type">bool</span>,
    create_disposition: <span class="tok-type">u32</span>,
};

<span class="tok-kw">fn</span> <span class="tok-fn">makeOpenDirAccessMaskW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, access_mask: <span class="tok-type">u32</span>, flags: <a href="std.fs.Dir.MakeOpenDirAccessMaskWOptions.html">MakeOpenDirAccessMaskWOptions</a>) (<a href="std.posix.html#std.posix.MakeDirError">MakeError</a> || <a href="std.fs.Dir.html#std.fs.Dir.OpenError">OpenError</a>)!<a href="std.fs.Dir.html">Dir</a> {
    <span class="tok-kw">const</span> w = <a href="std.os.windows.html">windows</a>;

    <span class="tok-kw">var</span> result = <a href="std.fs.Dir.html">Dir</a>{
        .fd = <span class="tok-null">undefined</span>,
    };

    <span class="tok-kw">const</span> path_len_bytes = <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intCast</span>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sub_path_w, <span class="tok-number">0</span>).len * <span class="tok-number">2</span>));
    <span class="tok-kw">var</span> nt_name = w.UNICODE_STRING{
        .Length = path_len_bytes,
        .MaximumLength = path_len_bytes,
        .Buffer = <span class="tok-builtin">@constCast</span>(sub_path_w),
    };
    <span class="tok-kw">var</span> attr = w.OBJECT_ATTRIBUTES{
        .Length = <span class="tok-builtin">@sizeOf</span>(w.OBJECT_ATTRIBUTES),
        .RootDirectory = <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(sub_path_w)) <span class="tok-null">null</span> <span class="tok-kw">else</span> self.fd,
        .Attributes = <span class="tok-number">0</span>,<span class="tok-comment"> // Note we do not use OBJ_CASE_INSENSITIVE here.
        </span>.ObjectName = &amp;nt_name,
        .SecurityDescriptor = <span class="tok-null">null</span>,
        .SecurityQualityOfService = <span class="tok-null">null</span>,
    };
    <span class="tok-kw">const</span> open_reparse_point: w.DWORD = <span class="tok-kw">if</span> (flags.no_follow) w.FILE_OPEN_REPARSE_POINT <span class="tok-kw">else</span> <span class="tok-number">0x0</span>;
    <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> rc = w.ntdll.NtCreateFile(
        &amp;result.fd,
        access_mask,
        &amp;attr,
        &amp;io,
        <span class="tok-null">null</span>,
        w.FILE_ATTRIBUTE_NORMAL,
        w.FILE_SHARE_READ | w.FILE_SHARE_WRITE | w.FILE_SHARE_DELETE,
        flags.create_disposition,
        w.FILE_DIRECTORY_FILE | w.FILE_SYNCHRONOUS_IO_NONALERT | w.FILE_OPEN_FOR_BACKUP_INTENT | open_reparse_point,
        <span class="tok-null">null</span>,
        <span class="tok-number">0</span>,
    );

    <span class="tok-kw">switch</span> (rc) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> result,
        .OBJECT_NAME_INVALID =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadPathName,
        .OBJECT_NAME_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .OBJECT_NAME_COLLISION =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .OBJECT_PATH_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOT_A_DIRECTORY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,<span class="tok-comment">
        // This can happen if the directory has 'List folder contents' permission set to 'Deny'
        // and the directory is trying to be opened for iteration.
        </span>.ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .INVALID_PARAMETER =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> w.unexpectedStatus(rc),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeleteFileError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a>;

<span class="tok-comment">/// Delete a file name and possibly the file it refers to, based on an open directory handle.</span>
<span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.UnlinkError">DeleteFileError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(self.fd, sub_path);
        <span class="tok-kw">return</span> self.deleteFileW(sub_path_w.span());
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unlinkat">unlinkat</a>(self.fd, sub_path, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not passing AT.REMOVEDIR
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sub_path);
        <span class="tok-kw">return</span> self.deleteFileZ(&amp;sub_path_c);
    }
}

<span class="tok-comment">/// Same as `deleteFile` except the parameter is null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.UnlinkError">DeleteFileError</a>!<span class="tok-type">void</span> {
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unlinkatZ">unlinkatZ</a>(self.fd, sub_path_c, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not passing AT.REMOVEDIR
        </span><span class="tok-kw">error</span>.AccessDenied =&gt; |e| <span class="tok-kw">switch</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a>) {<span class="tok-comment">
            // non-Linux POSIX systems return EPERM when trying to delete a directory, so
            // we need to handle that case specifically and translate the error
            </span>.macos, .ios, .freebsd, .netbsd, .dragonfly, .openbsd, .solaris, .illumos =&gt; {<span class="tok-comment">
                // Don't follow symlinks to match unlinkat (which acts on symlinks rather than follows them)
                </span><span class="tok-kw">const</span> fstat = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fstatatZ">fstatatZ</a>(self.fd, sub_path_c, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">SYMLINK_NOFOLLOW</a>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> e;
                <span class="tok-kw">const</span> is_dir = fstat.mode &amp; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFMT</a> == <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFDIR</a>;
                <span class="tok-kw">return</span> <span class="tok-kw">if</span> (is_dir) <span class="tok-kw">error</span>.IsDir <span class="tok-kw">else</span> e;
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> e,
        },
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
}

<span class="tok-comment">/// Same as `deleteFile` except the parameter is WTF-16 LE encoded.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.UnlinkError">DeleteFileError</a>!<span class="tok-type">void</span> {
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unlinkatW">unlinkatW</a>(self.fd, sub_path_w, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not passing AT.REMOVEDIR
        </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeleteDirError = <span class="tok-kw">error</span>{
    DirNotEmpty,
    FileNotFound,
    AccessDenied,
    FileBusy,
    FileSystem,
    SymLinkLoop,
    NameTooLong,
    NotDir,
    SystemResources,
    ReadOnlyFileSystem,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
    BadPathName,
    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
    Unexpected,
};

<span class="tok-comment">/// Returns `error.DirNotEmpty` if the directory is not empty.</span>
<span class="tok-comment">/// To delete a directory recursively, see `deleteTree`.</span>
<span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDir</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html#std.fs.Dir.DeleteDirError">DeleteDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(self.fd, sub_path);
        <span class="tok-kw">return</span> self.deleteDirW(sub_path_w.span());
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unlinkat">unlinkat</a>(self.fd, sub_path, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">REMOVEDIR</a>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not possible since we pass AT.REMOVEDIR
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sub_path);
        <span class="tok-kw">return</span> self.deleteDirZ(&amp;sub_path_c);
    }
}

<span class="tok-comment">/// Same as `deleteDir` except the parameter is null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html#std.fs.Dir.DeleteDirError">DeleteDirError</a>!<span class="tok-type">void</span> {
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unlinkatZ">unlinkatZ</a>(self.fd, sub_path_c, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">REMOVEDIR</a>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not possible since we pass AT.REMOVEDIR
        </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
}

<span class="tok-comment">/// Same as `deleteDir` except the parameter is WTF16LE, NT prefixed.</span>
<span class="tok-comment">/// This function is Windows-only.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.fs.Dir.html#std.fs.Dir.DeleteDirError">DeleteDirError</a>!<span class="tok-type">void</span> {
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unlinkatW">unlinkatW</a>(self.fd, sub_path_w, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">REMOVEDIR</a>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not possible since we pass AT.REMOVEDIR
        </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RenameError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.RenameError">RenameError</a>;

<span class="tok-comment">/// Change the name or location of a file or directory.</span>
<span class="tok-comment">/// If new_sub_path already exists, it will be replaced.</span>
<span class="tok-comment">/// Renaming a file over an existing directory or a directory</span>
<span class="tok-comment">/// over an existing file will fail with `error.IsDir` or `error.NotDir`</span>
<span class="tok-comment">/// On Windows, both paths should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rename</span>(self: <a href="std.fs.Dir.html">Dir</a>, old_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.renameat">renameat</a>(self.fd, old_sub_path, self.fd, new_sub_path);
}

<span class="tok-comment">/// Same as `rename` except the parameters are null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, old_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.renameatZ">renameatZ</a>(self.fd, old_sub_path_z, self.fd, new_sub_path_z);
}

<span class="tok-comment">/// Same as `rename` except the parameters are WTF16LE, NT prefixed.</span>
<span class="tok-comment">/// This function is Windows-only.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameW</span>(self: <a href="std.fs.Dir.html">Dir</a>, old_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, new_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.renameatW">renameatW</a>(self.fd, old_sub_path_w, self.fd, new_sub_path_w, <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TRUE">TRUE</a>);
}

<span class="tok-comment">/// Use with `Dir.symLink`, `Dir.atomicSymLink`, and `symLinkAbsolute` to</span>
<span class="tok-comment">/// specify whether the symlink will point to a file or a directory. This value</span>
<span class="tok-comment">/// is ignored on all hosts except Windows where creating symlinks to different</span>
<span class="tok-comment">/// resource types, requires different flags. By default, `symLinkAbsolute` is</span>
<span class="tok-comment">/// assumed to point to a file.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SymLinkFlags = <span class="tok-kw">struct</span> {
    is_directory: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
};

<span class="tok-comment">/// Creates a symbolic link named `sym_link_path` which contains the string `target_path`.</span>
<span class="tok-comment">/// A symbolic link (also known as a soft link) may point to an existing file or to a nonexistent</span>
<span class="tok-comment">/// one; the latter case is known as a dangling link.</span>
<span class="tok-comment">/// If `sym_link_path` exists, it will not be overwritten.</span>
<span class="tok-comment">/// On Windows, both paths should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLink</span>(
    self: <a href="std.fs.Dir.html">Dir</a>,
    target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> self.symLinkWasi(target_path, sym_link_path, flags);
    }
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {<span class="tok-comment">
        // Target path does not use sliceToPrefixedFileW because certain paths
        // are handled differently when creating a symlink than they would be
        // when converting to an NT namespaced path. CreateSymbolicLink in
        // symLinkW will handle the necessary conversion.
        </span><span class="tok-kw">var</span> target_path_w: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.PathSpace.html">PathSpace</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.checkWtf8ToWtf16LeOverflow">checkWtf8ToWtf16LeOverflow</a>(target_path, &amp;target_path_w.data)) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
        }
        target_path_w.len = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16Le">wtf8ToWtf16Le</a>(&amp;target_path_w.data, target_path);
        target_path_w.data[target_path_w.len] = <span class="tok-number">0</span>;<span class="tok-comment">
        // However, we need to canonicalize any path separators to `\`, since if
        // the target path is relative, then it must use `\` as the path separator.
        </span><a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.replaceScalar">replaceScalar</a>(
            <span class="tok-type">u16</span>,
            target_path_w.data[<span class="tok-number">0</span>..target_path_w.len],
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.nativeToLittle">nativeToLittle</a>(<span class="tok-type">u16</span>, <span class="tok-str">'/'</span>),
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.nativeToLittle">nativeToLittle</a>(<span class="tok-type">u16</span>, <span class="tok-str">'\\'</span>),
        );

        <span class="tok-kw">const</span> sym_link_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(self.fd, sym_link_path);
        <span class="tok-kw">return</span> self.symLinkW(target_path_w.span(), sym_link_path_w.span(), flags);
    }
    <span class="tok-kw">const</span> target_path_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(target_path);
    <span class="tok-kw">const</span> sym_link_path_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sym_link_path);
    <span class="tok-kw">return</span> self.symLinkZ(&amp;target_path_c, &amp;sym_link_path_c, flags);
}

<span class="tok-comment">/// WASI-only. Same as `symLink` except targeting WASI.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkWasi</span>(
    self: <a href="std.fs.Dir.html">Dir</a>,
    target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    _: <a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.symlinkat">symlinkat</a>(target_path, self.fd, sym_link_path);
}

<span class="tok-comment">/// Same as `symLink`, except the pathname parameters are null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkZ</span>(
    self: <a href="std.fs.Dir.html">Dir</a>,
    target_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    sym_link_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> target_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(self.fd, target_path_c);
        <span class="tok-kw">const</span> sym_link_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(self.fd, sym_link_path_c);
        <span class="tok-kw">return</span> self.symLinkW(target_path_w.span(), sym_link_path_w.span(), flags);
    }
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.symlinkatZ">symlinkatZ</a>(target_path_c, self.fd, sym_link_path_c);
}

<span class="tok-comment">/// Windows-only. Same as `symLink` except the pathname parameters</span>
<span class="tok-comment">/// are WTF16 LE encoded.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkW</span>(
    self: <a href="std.fs.Dir.html">Dir</a>,
    <span class="tok-comment">/// WTF-16, does not need to be NT-prefixed. The NT-prefixing</span>
    <span class="tok-comment">/// of this path is handled by CreateSymbolicLink.</span>
    <span class="tok-comment">/// Any path separators must be `\`, not `/`.</span>
    target_path_w: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>,
    <span class="tok-comment">/// WTF-16, must be NT-prefixed or relative</span>
    sym_link_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>,
    flags: <a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CreateSymbolicLink">CreateSymbolicLink</a>(self.fd, sym_link_path_w, target_path_w, flags.is_directory);
}

<span class="tok-comment">/// Same as `symLink`, except tries to create the symbolic link until it</span>
<span class="tok-comment">/// succeeds or encounters an error other than `error.PathAlreadyExists`.</span>
<span class="tok-comment">/// On Windows, both paths should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">atomicSymLink</span>(
    dir: <a href="std.fs.Dir.html">Dir</a>,
    target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (dir.symLink(target_path, sym_link_path, flags)) {
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.PathAlreadyExists =&gt; {},
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    }

    <span class="tok-kw">const</span> dirname = <a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(sym_link_path) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;.&quot;</span>;

    <span class="tok-kw">var</span> rand_buf: [<a href="std.fs.AtomicFile.html">AtomicFile</a>.<a href="std.fs.AtomicFile.html#std.fs.AtomicFile.random_bytes_len">random_bytes_len</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">const</span> temp_path_len = dirname.len + <span class="tok-number">1</span> + <a href="std.fs.html#std.fs.base64_encoder">base64_encoder</a>.<a href="#">calcSize</a>(rand_buf.len);
    <span class="tok-kw">var</span> temp_path_buf: [<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">if</span> (temp_path_len &gt; temp_path_buf.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
    <span class="tok-builtin">@memcpy</span>(temp_path_buf[<span class="tok-number">0</span>..dirname.len], dirname);
    temp_path_buf[dirname.len] = <a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep">sep</a>;

    <span class="tok-kw">const</span> temp_path = temp_path_buf[<span class="tok-number">0</span>..temp_path_len];

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <a href="std.crypto.html">crypto</a>.<a href="std.crypto.tlcsprng.html#std.crypto.tlcsprng.interface">random</a>.<a href="#">bytes</a>(rand_buf[<span class="tok-number">0</span>..]);
        _ = <a href="std.fs.html#std.fs.base64_encoder">base64_encoder</a>.<a href="#">encode</a>(temp_path[dirname.len + <span class="tok-number">1</span> ..], rand_buf[<span class="tok-number">0</span>..]);

        <span class="tok-kw">if</span> (dir.symLink(target_path, temp_path, flags)) {
            <span class="tok-kw">return</span> dir.rename(temp_path, sym_link_path);
        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">continue</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadLinkError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>;

<span class="tok-comment">/// Read value of a symbolic link.</span>
<span class="tok-comment">/// The return value is a slice of `buffer`, from index `0`.</span>
<span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span>
<span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLink</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> self.readLinkWasi(sub_path, buffer);
    }
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(self.fd, sub_path);
        <span class="tok-kw">return</span> self.readLinkW(sub_path_w.span(), buffer);
    }
    <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sub_path);
    <span class="tok-kw">return</span> self.readLinkZ(&amp;sub_path_c, buffer);
}

<span class="tok-comment">/// WASI-only. Same as `readLink` except targeting WASI.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkWasi</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.readlinkat">readlinkat</a>(self.fd, sub_path, buffer);
}

<span class="tok-comment">/// Same as `readLink`, except the `sub_path_c` parameter is null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(self.fd, sub_path_c);
        <span class="tok-kw">return</span> self.readLinkW(sub_path_w.span(), buffer);
    }
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.readlinkatZ">readlinkatZ</a>(self.fd, sub_path_c, buffer);
}

<span class="tok-comment">/// Windows-only. Same as `readLink` except the pathname parameter</span>
<span class="tok-comment">/// is WTF16 LE encoded.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ReadLink">ReadLink</a>(self.fd, sub_path_w, buffer);
}

<span class="tok-comment">/// Read all of file contents using a preallocated buffer.</span>
<span class="tok-comment">/// The returned slice has the same pointer as `buffer`. If the length matches `buffer.len`</span>
<span class="tok-comment">/// the situation is ambiguous. It could either mean that the entire file was read, and</span>
<span class="tok-comment">/// it exactly fits the buffer, or it could mean the buffer was not big enough for the</span>
<span class="tok-comment">/// entire file.</span>
<span class="tok-comment">/// On Windows, `file_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `file_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `file_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> self.openFile(file_path, .{});
    <span class="tok-kw">defer</span> file.close();

    <span class="tok-kw">const</span> end_index = <span class="tok-kw">try</span> file.readAll(buffer);
    <span class="tok-kw">return</span> buffer[<span class="tok-number">0</span>..end_index];
}

<span class="tok-comment">/// On success, caller owns returned buffer.</span>
<span class="tok-comment">/// If the file is larger than `max_bytes`, returns `error.FileTooBig`.</span>
<span class="tok-comment">/// On Windows, `file_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `file_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `file_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFileAlloc</span>(self: <a href="std.fs.Dir.html">Dir</a>, allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_bytes: <span class="tok-type">usize</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> self.readFileAllocOptions(allocator, file_path, max_bytes, <span class="tok-null">null</span>, <span class="tok-builtin">@alignOf</span>(<span class="tok-type">u8</span>), <span class="tok-null">null</span>);
}

<span class="tok-comment">/// On success, caller owns returned buffer.</span>
<span class="tok-comment">/// If the file is larger than `max_bytes`, returns `error.FileTooBig`.</span>
<span class="tok-comment">/// If `size_hint` is specified the initial buffer size is calculated using</span>
<span class="tok-comment">/// that value, otherwise the effective file size is used instead.</span>
<span class="tok-comment">/// Allows specifying alignment and a sentinel value.</span>
<span class="tok-comment">/// On Windows, `file_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `file_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `file_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFileAllocOptions</span>(
    self: <a href="std.fs.Dir.html">Dir</a>,
    allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>,
    file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    max_bytes: <span class="tok-type">usize</span>,
    size_hint: ?<span class="tok-type">usize</span>,
    <span class="tok-kw">comptime</span> alignment: <span class="tok-type">u29</span>,
    <span class="tok-kw">comptime</span> optional_sentinel: ?<span class="tok-type">u8</span>,
) !(<span class="tok-kw">if</span> (optional_sentinel) |s| [:s]<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span> <span class="tok-kw">else</span> []<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span>) {
    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> self.openFile(file_path, .{});
    <span class="tok-kw">defer</span> file.close();<span class="tok-comment">

    // If the file size doesn't fit a usize it'll be certainly greater than
    // `max_bytes`
    </span><span class="tok-kw">const</span> stat_size = size_hint <span class="tok-kw">orelse</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> file.getEndPos()) <span class="tok-kw">orelse</span>
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig;

    <span class="tok-kw">return</span> file.readToEndAllocOptions(allocator, max_bytes, stat_size, alignment, optional_sentinel);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeleteTreeError = <span class="tok-kw">error</span>{
    AccessDenied,
    FileTooBig,
    SymLinkLoop,
    ProcessFdQuotaExceeded,
    NameTooLong,
    SystemFdQuotaExceeded,
    NoDevice,
    SystemResources,
    ReadOnlyFileSystem,
    FileSystem,
    FileBusy,
    DeviceBusy,

    <span class="tok-comment">/// One of the path components was not a directory.</span>
    <span class="tok-comment">/// This error is unreachable if `sub_path` does not contain a path separator.</span>
    NotDir,

    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,

    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,

    <span class="tok-comment">/// On Windows, file paths cannot contain these characters:</span>
    <span class="tok-comment">/// '/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</span>
    BadPathName,

    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
} || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Whether `sub_path` describes a symlink, file, or directory, this function</span>
<span class="tok-comment">/// removes it. If it cannot be removed because it is a non-empty directory,</span>
<span class="tok-comment">/// this function recursively removes its entries and then tries again.</span>
<span class="tok-comment">/// This operation is not atomic on most file systems.</span>
<span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteTree</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html#std.fs.Dir.DeleteTreeError">DeleteTreeError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> initial_iterable_dir = (<span class="tok-kw">try</span> self.deleteTreeOpenInitialSubpath(sub_path, .file)) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;

    <span class="tok-kw">const</span> StackItem = <span class="tok-kw">struct</span> {
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        parent_dir: <a href="std.fs.Dir.html">Dir</a>,
        iter: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.html#std.fs.Dir.Iterator">Iterator</a>,

        <span class="tok-kw">fn</span> <span class="tok-fn">closeAll</span>(items: []<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
            <span class="tok-kw">for</span> (items) |*item| item.iter.dir.close();
        }
    };

    <span class="tok-kw">var</span> stack_buffer: [<span class="tok-number">16</span>]StackItem = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> stack = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(StackItem).initBuffer(&amp;stack_buffer);
    <span class="tok-kw">defer</span> StackItem.closeAll(stack.items);

    stack.appendAssumeCapacity(.{
        .name = sub_path,
        .parent_dir = self,
        .iter = initial_iterable_dir.iterateAssumeFirstIteration(),
    });

    process_stack: <span class="tok-kw">while</span> (stack.items.len != <span class="tok-number">0</span>) {
        <span class="tok-kw">var</span> top = &amp;stack.items[stack.items.len - <span class="tok-number">1</span>];
        <span class="tok-kw">while</span> (<span class="tok-kw">try</span> top.iter.next()) |entry| {
            <span class="tok-kw">var</span> treat_as_dir = entry.kind == .directory;
            handle_entry: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">if</span> (treat_as_dir) {
                    <span class="tok-kw">if</span> (stack.unusedCapacitySlice().len &gt;= <span class="tok-number">1</span>) {
                        <span class="tok-kw">var</span> iterable_dir = top.iter.dir.openDir(entry.name, .{
                            .no_follow = <span class="tok-null">true</span>,
                            .iterate = <span class="tok-null">true</span>,
                        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                            <span class="tok-kw">error</span>.NotDir =&gt; {
                                treat_as_dir = <span class="tok-null">false</span>;
                                <span class="tok-kw">continue</span> :handle_entry;
                            },
                            <span class="tok-kw">error</span>.FileNotFound =&gt; {<span class="tok-comment">
                                // That's fine, we were trying to remove this directory anyway.
                                </span><span class="tok-kw">break</span> :handle_entry;
                            },

                            <span class="tok-kw">error</span>.AccessDenied,
                            <span class="tok-kw">error</span>.SymLinkLoop,
                            <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
                            <span class="tok-kw">error</span>.NameTooLong,
                            <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
                            <span class="tok-kw">error</span>.NoDevice,
                            <span class="tok-kw">error</span>.SystemResources,
                            <span class="tok-kw">error</span>.Unexpected,
                            <span class="tok-kw">error</span>.InvalidUtf8,
                            <span class="tok-kw">error</span>.InvalidWtf8,
                            <span class="tok-kw">error</span>.BadPathName,
                            <span class="tok-kw">error</span>.NetworkNotFound,
                            <span class="tok-kw">error</span>.DeviceBusy,
                            =&gt; |e| <span class="tok-kw">return</span> e,
                        };
                        stack.appendAssumeCapacity(.{
                            .name = entry.name,
                            .parent_dir = top.iter.dir,
                            .iter = iterable_dir.iterateAssumeFirstIteration(),
                        });
                        <span class="tok-kw">continue</span> :process_stack;
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">try</span> top.iter.dir.deleteTreeMinStackSizeWithKindHint(entry.name, entry.kind);
                        <span class="tok-kw">break</span> :handle_entry;
                    }
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">if</span> (top.iter.dir.deleteFile(entry.name)) {
                        <span class="tok-kw">break</span> :handle_entry;
                    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                        <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">break</span> :handle_entry,<span class="tok-comment">

                        // Impossible because we do not pass any path separators.
                        </span><span class="tok-kw">error</span>.NotDir =&gt; <span class="tok-kw">unreachable</span>,

                        <span class="tok-kw">error</span>.IsDir =&gt; {
                            treat_as_dir = <span class="tok-null">true</span>;
                            <span class="tok-kw">continue</span> :handle_entry;
                        },

                        <span class="tok-kw">error</span>.AccessDenied,
                        <span class="tok-kw">error</span>.InvalidUtf8,
                        <span class="tok-kw">error</span>.InvalidWtf8,
                        <span class="tok-kw">error</span>.SymLinkLoop,
                        <span class="tok-kw">error</span>.NameTooLong,
                        <span class="tok-kw">error</span>.SystemResources,
                        <span class="tok-kw">error</span>.ReadOnlyFileSystem,
                        <span class="tok-kw">error</span>.FileSystem,
                        <span class="tok-kw">error</span>.FileBusy,
                        <span class="tok-kw">error</span>.BadPathName,
                        <span class="tok-kw">error</span>.NetworkNotFound,
                        <span class="tok-kw">error</span>.Unexpected,
                        =&gt; |e| <span class="tok-kw">return</span> e,
                    }
                }
            }
        }<span class="tok-comment">

        // On Windows, we can't delete until the dir's handle has been closed, so
        // close it before we try to delete.
        </span>top.iter.dir.close();<span class="tok-comment">

        // In order to avoid double-closing the directory when cleaning up
        // the stack in the case of an error, we save the relevant portions and
        // pop the value from the stack.
        </span><span class="tok-kw">const</span> parent_dir = top.parent_dir;
        <span class="tok-kw">const</span> name = top.name;
        stack.items.len -= <span class="tok-number">1</span>;

        <span class="tok-kw">var</span> need_to_retry: <span class="tok-type">bool</span> = <span class="tok-null">false</span>;
        parent_dir.deleteDir(name) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileNotFound =&gt; {},
            <span class="tok-kw">error</span>.DirNotEmpty =&gt; need_to_retry = <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };

        <span class="tok-kw">if</span> (need_to_retry) {<span class="tok-comment">
            // Since we closed the handle that the previous iterator used, we
            // need to re-open the dir and re-create the iterator.
            </span><span class="tok-kw">var</span> iterable_dir = iterable_dir: {
                <span class="tok-kw">var</span> treat_as_dir = <span class="tok-null">true</span>;
                handle_entry: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                    <span class="tok-kw">if</span> (treat_as_dir) {
                        <span class="tok-kw">break</span> :iterable_dir parent_dir.openDir(name, .{
                            .no_follow = <span class="tok-null">true</span>,
                            .iterate = <span class="tok-null">true</span>,
                        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                            <span class="tok-kw">error</span>.NotDir =&gt; {
                                treat_as_dir = <span class="tok-null">false</span>;
                                <span class="tok-kw">continue</span> :handle_entry;
                            },
                            <span class="tok-kw">error</span>.FileNotFound =&gt; {<span class="tok-comment">
                                // That's fine, we were trying to remove this directory anyway.
                                </span><span class="tok-kw">continue</span> :process_stack;
                            },

                            <span class="tok-kw">error</span>.AccessDenied,
                            <span class="tok-kw">error</span>.SymLinkLoop,
                            <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
                            <span class="tok-kw">error</span>.NameTooLong,
                            <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
                            <span class="tok-kw">error</span>.NoDevice,
                            <span class="tok-kw">error</span>.SystemResources,
                            <span class="tok-kw">error</span>.Unexpected,
                            <span class="tok-kw">error</span>.InvalidUtf8,
                            <span class="tok-kw">error</span>.InvalidWtf8,
                            <span class="tok-kw">error</span>.BadPathName,
                            <span class="tok-kw">error</span>.NetworkNotFound,
                            <span class="tok-kw">error</span>.DeviceBusy,
                            =&gt; |e| <span class="tok-kw">return</span> e,
                        };
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">if</span> (parent_dir.deleteFile(name)) {
                            <span class="tok-kw">continue</span> :process_stack;
                        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                            <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">continue</span> :process_stack,<span class="tok-comment">

                            // Impossible because we do not pass any path separators.
                            </span><span class="tok-kw">error</span>.NotDir =&gt; <span class="tok-kw">unreachable</span>,

                            <span class="tok-kw">error</span>.IsDir =&gt; {
                                treat_as_dir = <span class="tok-null">true</span>;
                                <span class="tok-kw">continue</span> :handle_entry;
                            },

                            <span class="tok-kw">error</span>.AccessDenied,
                            <span class="tok-kw">error</span>.InvalidUtf8,
                            <span class="tok-kw">error</span>.InvalidWtf8,
                            <span class="tok-kw">error</span>.SymLinkLoop,
                            <span class="tok-kw">error</span>.NameTooLong,
                            <span class="tok-kw">error</span>.SystemResources,
                            <span class="tok-kw">error</span>.ReadOnlyFileSystem,
                            <span class="tok-kw">error</span>.FileSystem,
                            <span class="tok-kw">error</span>.FileBusy,
                            <span class="tok-kw">error</span>.BadPathName,
                            <span class="tok-kw">error</span>.NetworkNotFound,
                            <span class="tok-kw">error</span>.Unexpected,
                            =&gt; |e| <span class="tok-kw">return</span> e,
                        }
                    }
                }
            };<span class="tok-comment">
            // We know there is room on the stack since we are just re-adding
            // the StackItem that we previously popped.
            </span>stack.appendAssumeCapacity(.{
                .name = name,
                .parent_dir = parent_dir,
                .iter = iterable_dir.iterateAssumeFirstIteration(),
            });
            <span class="tok-kw">continue</span> :process_stack;
        }
    }
}

<span class="tok-comment">/// Like `deleteTree`, but only keeps one `Iterator` active at a time to minimize the function's stack size.</span>
<span class="tok-comment">/// This is slower than `deleteTree` but uses less stack space.</span>
<span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteTreeMinStackSize</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html#std.fs.Dir.DeleteTreeError">DeleteTreeError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.deleteTreeMinStackSizeWithKindHint(sub_path, .file);
}

<span class="tok-kw">fn</span> <span class="tok-fn">deleteTreeMinStackSizeWithKindHint</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, kind_hint: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.Kind.html">Kind</a>) <a href="std.fs.Dir.html#std.fs.Dir.DeleteTreeError">DeleteTreeError</a>!<span class="tok-type">void</span> {
    start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">var</span> dir = (<span class="tok-kw">try</span> self.deleteTreeOpenInitialSubpath(sub_path, kind_hint)) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
        <span class="tok-kw">var</span> cleanup_dir_parent: ?<a href="std.fs.Dir.html">Dir</a> = <span class="tok-null">null</span>;
        <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (cleanup_dir_parent) |*d| d.close();

        <span class="tok-kw">var</span> cleanup_dir = <span class="tok-null">true</span>;
        <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (cleanup_dir) dir.close();<span class="tok-comment">

        // Valid use of max_path_bytes because dir_name_buf will only
        // ever store a single path component that was returned from the
        // filesystem.
        </span><span class="tok-kw">var</span> dir_name_buf: [<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> dir_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = sub_path;<span class="tok-comment">

        // Here we must avoid recursion, in order to provide O(1) memory guarantee of this function.
        // Go through each entry and if it is not a directory, delete it. If it is a directory,
        // open it, and close the original directory. Repeat. Then start the entire operation over.

        </span>scan_dir: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">var</span> dir_it = dir.iterateAssumeFirstIteration();
            dir_it: <span class="tok-kw">while</span> (<span class="tok-kw">try</span> dir_it.next()) |entry| {
                <span class="tok-kw">var</span> treat_as_dir = entry.kind == .directory;
                handle_entry: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                    <span class="tok-kw">if</span> (treat_as_dir) {
                        <span class="tok-kw">const</span> new_dir = dir.openDir(entry.name, .{
                            .no_follow = <span class="tok-null">true</span>,
                            .iterate = <span class="tok-null">true</span>,
                        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                            <span class="tok-kw">error</span>.NotDir =&gt; {
                                treat_as_dir = <span class="tok-null">false</span>;
                                <span class="tok-kw">continue</span> :handle_entry;
                            },
                            <span class="tok-kw">error</span>.FileNotFound =&gt; {<span class="tok-comment">
                                // That's fine, we were trying to remove this directory anyway.
                                </span><span class="tok-kw">continue</span> :dir_it;
                            },

                            <span class="tok-kw">error</span>.AccessDenied,
                            <span class="tok-kw">error</span>.SymLinkLoop,
                            <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
                            <span class="tok-kw">error</span>.NameTooLong,
                            <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
                            <span class="tok-kw">error</span>.NoDevice,
                            <span class="tok-kw">error</span>.SystemResources,
                            <span class="tok-kw">error</span>.Unexpected,
                            <span class="tok-kw">error</span>.InvalidUtf8,
                            <span class="tok-kw">error</span>.InvalidWtf8,
                            <span class="tok-kw">error</span>.BadPathName,
                            <span class="tok-kw">error</span>.NetworkNotFound,
                            <span class="tok-kw">error</span>.DeviceBusy,
                            =&gt; |e| <span class="tok-kw">return</span> e,
                        };
                        <span class="tok-kw">if</span> (cleanup_dir_parent) |*d| d.close();
                        cleanup_dir_parent = dir;
                        dir = new_dir;
                        <span class="tok-kw">const</span> result = dir_name_buf[<span class="tok-number">0</span>..entry.name.len];
                        <span class="tok-builtin">@memcpy</span>(result, entry.name);
                        dir_name = result;
                        <span class="tok-kw">continue</span> :scan_dir;
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">if</span> (dir.deleteFile(entry.name)) {
                            <span class="tok-kw">continue</span> :dir_it;
                        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                            <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">continue</span> :dir_it,<span class="tok-comment">

                            // Impossible because we do not pass any path separators.
                            </span><span class="tok-kw">error</span>.NotDir =&gt; <span class="tok-kw">unreachable</span>,

                            <span class="tok-kw">error</span>.IsDir =&gt; {
                                treat_as_dir = <span class="tok-null">true</span>;
                                <span class="tok-kw">continue</span> :handle_entry;
                            },

                            <span class="tok-kw">error</span>.AccessDenied,
                            <span class="tok-kw">error</span>.InvalidUtf8,
                            <span class="tok-kw">error</span>.InvalidWtf8,
                            <span class="tok-kw">error</span>.SymLinkLoop,
                            <span class="tok-kw">error</span>.NameTooLong,
                            <span class="tok-kw">error</span>.SystemResources,
                            <span class="tok-kw">error</span>.ReadOnlyFileSystem,
                            <span class="tok-kw">error</span>.FileSystem,
                            <span class="tok-kw">error</span>.FileBusy,
                            <span class="tok-kw">error</span>.BadPathName,
                            <span class="tok-kw">error</span>.NetworkNotFound,
                            <span class="tok-kw">error</span>.Unexpected,
                            =&gt; |e| <span class="tok-kw">return</span> e,
                        }
                    }
                }
            }<span class="tok-comment">
            // Reached the end of the directory entries, which means we successfully deleted all of them.
            // Now to remove the directory itself.
            </span>dir.close();
            cleanup_dir = <span class="tok-null">false</span>;

            <span class="tok-kw">if</span> (cleanup_dir_parent) |d| {
                d.deleteDir(dir_name) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {<span class="tok-comment">
                    // These two things can happen due to file system race conditions.
                    </span><span class="tok-kw">error</span>.FileNotFound, <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">continue</span> :start_over,
                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
                };
                <span class="tok-kw">continue</span> :start_over;
            } <span class="tok-kw">else</span> {
                self.deleteDir(sub_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span>,
                    <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">continue</span> :start_over,
                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
                };
                <span class="tok-kw">return</span>;
            }
        }
    }
}

<span class="tok-comment">/// On successful delete, returns null.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">deleteTreeOpenInitialSubpath</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, kind_hint: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.Kind.html">Kind</a>) !?<a href="std.fs.Dir.html">Dir</a> {
    <span class="tok-kw">return</span> iterable_dir: {<span class="tok-comment">
        // Treat as a file by default
        </span><span class="tok-kw">var</span> treat_as_dir = kind_hint == .directory;

        handle_entry: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">if</span> (treat_as_dir) {
                <span class="tok-kw">break</span> :iterable_dir self.openDir(sub_path, .{
                    .no_follow = <span class="tok-null">true</span>,
                    .iterate = <span class="tok-null">true</span>,
                }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.NotDir =&gt; {
                        treat_as_dir = <span class="tok-null">false</span>;
                        <span class="tok-kw">continue</span> :handle_entry;
                    },
                    <span class="tok-kw">error</span>.FileNotFound =&gt; {<span class="tok-comment">
                        // That's fine, we were trying to remove this directory anyway.
                        </span><span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    },

                    <span class="tok-kw">error</span>.AccessDenied,
                    <span class="tok-kw">error</span>.SymLinkLoop,
                    <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
                    <span class="tok-kw">error</span>.NameTooLong,
                    <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
                    <span class="tok-kw">error</span>.NoDevice,
                    <span class="tok-kw">error</span>.SystemResources,
                    <span class="tok-kw">error</span>.Unexpected,
                    <span class="tok-kw">error</span>.InvalidUtf8,
                    <span class="tok-kw">error</span>.InvalidWtf8,
                    <span class="tok-kw">error</span>.BadPathName,
                    <span class="tok-kw">error</span>.DeviceBusy,
                    <span class="tok-kw">error</span>.NetworkNotFound,
                    =&gt; |e| <span class="tok-kw">return</span> e,
                };
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">if</span> (self.deleteFile(sub_path)) {
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,

                    <span class="tok-kw">error</span>.IsDir =&gt; {
                        treat_as_dir = <span class="tok-null">true</span>;
                        <span class="tok-kw">continue</span> :handle_entry;
                    },

                    <span class="tok-kw">error</span>.AccessDenied,
                    <span class="tok-kw">error</span>.InvalidUtf8,
                    <span class="tok-kw">error</span>.InvalidWtf8,
                    <span class="tok-kw">error</span>.SymLinkLoop,
                    <span class="tok-kw">error</span>.NameTooLong,
                    <span class="tok-kw">error</span>.SystemResources,
                    <span class="tok-kw">error</span>.ReadOnlyFileSystem,
                    <span class="tok-kw">error</span>.NotDir,
                    <span class="tok-kw">error</span>.FileSystem,
                    <span class="tok-kw">error</span>.FileBusy,
                    <span class="tok-kw">error</span>.BadPathName,
                    <span class="tok-kw">error</span>.NetworkNotFound,
                    <span class="tok-kw">error</span>.Unexpected,
                    =&gt; |e| <span class="tok-kw">return</span> e,
                }
            }
        }
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteFileError = <a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.WriteError">WriteError</a> || <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteFileOptions = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
    <span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span>
    <span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span>
    sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a> = .{},
};

<span class="tok-comment">/// Writes content to the file system, using the file creation flags provided.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, options: <a href="std.fs.Dir.WriteFileOptions.html">WriteFileOptions</a>) <a href="std.fs.Dir.html#std.fs.Dir.WriteFileError">WriteFileError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> self.createFile(options.sub_path, options.flags);
    <span class="tok-kw">defer</span> file.close();
    <span class="tok-kw">try</span> file.writeAll(options.data);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> writeFile2 = <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;deprecated; renamed to writeFile&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AccessError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AccessError">AccessError</a>;

<span class="tok-comment">/// Test accessing `sub_path`.</span>
<span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">/// Be careful of Time-Of-Check-Time-Of-Use race conditions when using this function.</span>
<span class="tok-comment">/// For example, instead of testing if a file exists and then opening it, just</span>
<span class="tok-comment">/// open it and handle the error for file not found.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">access</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> sub_path_w = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(self.fd, sub_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        <span class="tok-kw">return</span> self.accessW(sub_path_w.span().ptr, flags);
    }
    <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sub_path);
    <span class="tok-kw">return</span> self.accessZ(&amp;path_c, flags);
}

<span class="tok-comment">/// Same as `access` except the path parameter is null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessZ</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> sub_path_w = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(self.fd, sub_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        <span class="tok-kw">return</span> self.accessW(sub_path_w.span().ptr, flags);
    }
    <span class="tok-kw">const</span> os_mode = <span class="tok-kw">switch</span> (flags.mode) {
        .read_only =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.F_OK">F_OK</a>),
        .write_only =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.W_OK">W_OK</a>),
        .read_write =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.R_OK">R_OK</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.W_OK">W_OK</a>),
    };
    <span class="tok-kw">const</span> result = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.faccessatZ">faccessatZ</a>(self.fd, sub_path, os_mode, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> result;
}

<span class="tok-comment">/// Same as `access` except asserts the target OS is Windows and the path parameter is</span>
<span class="tok-comment">/// * WTF-16 LE encoded</span>
<span class="tok-comment">/// * null-terminated</span>
<span class="tok-comment">/// * relative or has the NT namespace prefix</span>
<span class="tok-comment">/// TODO currently this ignores `flags`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessW</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    _ = flags;
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.faccessatW">faccessatW</a>(self.fd, sub_path_w);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> CopyFileOptions = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// When this is `null` the mode is copied from the source file.</span>
    override_mode: ?<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.mode_t">Mode</a> = <span class="tok-null">null</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PrevStatus = <span class="tok-kw">enum</span> {
    stale,
    fresh,
};

<span class="tok-comment">/// Check the file size, mtime, and mode of `source_path` and `dest_path`. If they are equal, does nothing.</span>
<span class="tok-comment">/// Otherwise, atomically copies `source_path` to `dest_path`. The destination file gains the mtime,</span>
<span class="tok-comment">/// atime, and mode of the source file so that the next call to `updateFile` will not need a copy.</span>
<span class="tok-comment">/// Returns the previous status of the file before updating.</span>
<span class="tok-comment">/// If any of the directories do not exist for dest_path, they are created.</span>
<span class="tok-comment">/// On Windows, both paths should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateFile</span>(
    source_dir: <a href="std.fs.Dir.html">Dir</a>,
    source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    dest_dir: <a href="std.fs.Dir.html">Dir</a>,
    dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    options: <a href="std.fs.Dir.CopyFileOptions.html">CopyFileOptions</a>,
) !<a href="std.fs.Dir.PrevStatus.html">PrevStatus</a> {
    <span class="tok-kw">var</span> src_file = <span class="tok-kw">try</span> source_dir.openFile(source_path, .{});
    <span class="tok-kw">defer</span> src_file.close();

    <span class="tok-kw">const</span> src_stat = <span class="tok-kw">try</span> src_file.stat();
    <span class="tok-kw">const</span> actual_mode = options.override_mode <span class="tok-kw">orelse</span> src_stat.mode;
    check_dest_stat: {
        <span class="tok-kw">const</span> dest_stat = blk: {
            <span class="tok-kw">var</span> dest_file = dest_dir.openFile(dest_path, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">break</span> :check_dest_stat,
                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };
            <span class="tok-kw">defer</span> dest_file.close();

            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> dest_file.stat();
        };

        <span class="tok-kw">if</span> (src_stat.size == dest_stat.size <span class="tok-kw">and</span>
            src_stat.mtime == dest_stat.mtime <span class="tok-kw">and</span>
            actual_mode == dest_stat.mode)
        {
            <span class="tok-kw">return</span> <a href="std.fs.Dir.PrevStatus.html">PrevStatus</a>.<a href="#">fresh</a>;
        }
    }

    <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(dest_path)) |dirname| {
        <span class="tok-kw">try</span> dest_dir.makePath(dirname);
    }

    <span class="tok-kw">var</span> atomic_file = <span class="tok-kw">try</span> dest_dir.atomicFile(dest_path, .{ .mode = actual_mode });
    <span class="tok-kw">defer</span> atomic_file.deinit();

    <span class="tok-kw">try</span> atomic_file.file.writeFileAll(src_file, .{ .in_len = src_stat.size });
    <span class="tok-kw">try</span> atomic_file.file.updateTimes(src_stat.atime, src_stat.mtime);
    <span class="tok-kw">try</span> atomic_file.finish();
    <span class="tok-kw">return</span> <a href="std.fs.Dir.PrevStatus.html">PrevStatus</a>.<a href="#">stale</a>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> CopyFileError = <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a> || <a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.FStatError">StatError</a> ||
    <a href="std.fs.AtomicFile.html">AtomicFile</a>.<a href="std.fs.File.html#std.fs.File.OpenError">InitError</a> || <a href="std.fs.Dir.html#std.fs.Dir.CopyFileRawError">CopyFileRawError</a> || <a href="std.fs.AtomicFile.html">AtomicFile</a>.<a href="std.posix.html#std.posix.RenameError">FinishError</a>;

<span class="tok-comment">/// Guaranteed to be atomic.</span>
<span class="tok-comment">/// On Linux, until https://patchwork.kernel.org/patch/9636735/ is merged and readily available,</span>
<span class="tok-comment">/// there is a possibility of power loss or application termination leaving temporary files present</span>
<span class="tok-comment">/// in the same directory as dest_path.</span>
<span class="tok-comment">/// On Windows, both paths should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyFile</span>(
    source_dir: <a href="std.fs.Dir.html">Dir</a>,
    source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    dest_dir: <a href="std.fs.Dir.html">Dir</a>,
    dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    options: <a href="std.fs.Dir.CopyFileOptions.html">CopyFileOptions</a>,
) <a href="std.fs.Dir.html#std.fs.Dir.CopyFileError">CopyFileError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> in_file = <span class="tok-kw">try</span> source_dir.openFile(source_path, .{});
    <span class="tok-kw">defer</span> in_file.close();

    <span class="tok-kw">var</span> size: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> mode = options.override_mode <span class="tok-kw">orelse</span> blk: {
        <span class="tok-kw">const</span> st = <span class="tok-kw">try</span> in_file.stat();
        size = st.size;
        <span class="tok-kw">break</span> :blk st.mode;
    };

    <span class="tok-kw">var</span> atomic_file = <span class="tok-kw">try</span> dest_dir.atomicFile(dest_path, .{ .mode = mode });
    <span class="tok-kw">defer</span> atomic_file.deinit();

    <span class="tok-kw">try</span> <a href="std.fs.Dir.html#std.fs.Dir.copy_file">copy_file</a>(in_file.handle, atomic_file.file.handle, size);
    <span class="tok-kw">try</span> atomic_file.finish();
}

<span class="tok-kw">const</span> CopyFileRawError = <span class="tok-kw">error</span>{SystemResources} || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.CopyFileRangeError">CopyFileRangeError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SendFileError">SendFileError</a>;<span class="tok-comment">

// Transfer all the data between two file descriptors in the most efficient way.
// The copy starts at offset 0, the initial offsets are preserved.
// No metadata is transferred over.
</span><span class="tok-kw">fn</span> <span class="tok-fn">copy_file</span>(fd_in: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, fd_out: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, maybe_size: ?<span class="tok-type">u64</span>) <a href="std.fs.Dir.html#std.fs.Dir.CopyFileRawError">CopyFileRawError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a>.<a href="#">isDarwin</a>()) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">fcopyfile</a>(fd_in, fd_out, <span class="tok-null">null</span>, .{ .DATA = <span class="tok-null">true</span> });
        <span class="tok-kw">switch</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,<span class="tok-comment">
            // The source file is not a directory, symbolic link, or regular file.
            // Try with the fallback path before giving up.
            </span>.OPNOTSUPP =&gt; {},
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .linux) {<span class="tok-comment">
        // Try copy_file_range first as that works at the FS level and is the
        // most efficient method (if available).
        </span><span class="tok-kw">var</span> offset: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;
        cfr_loop: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment">
            // The kernel checks the u64 value `offset+count` for overflow, use
            // a 32 bit value so that the syscall won't return EINVAL except for
            // impossibly large files (&gt; 2^64-1 - 2^32-1).
            </span><span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.copy_file_range">copy_file_range</a>(fd_in, offset, fd_out, offset, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>), <span class="tok-number">0</span>);<span class="tok-comment">
            // Terminate as soon as we have copied size bytes or no bytes
            </span><span class="tok-kw">if</span> (maybe_size) |s| {
                <span class="tok-kw">if</span> (s == amt) <span class="tok-kw">break</span> :cfr_loop;
            }
            <span class="tok-kw">if</span> (amt == <span class="tok-number">0</span>) <span class="tok-kw">break</span> :cfr_loop;
            offset += amt;
        }
        <span class="tok-kw">return</span>;
    }<span class="tok-comment">

    // Sendfile is a zero-copy mechanism iff the OS supports it, otherwise the
    // fallback code will copy the contents chunk by chunk.
    </span><span class="tok-kw">const</span> empty_iovec = [<span class="tok-number">0</span>]<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>{};
    <span class="tok-kw">var</span> offset: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;
    sendfile_loop: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sendfile">sendfile</a>(fd_out, fd_in, offset, <span class="tok-number">0</span>, &amp;empty_iovec, &amp;empty_iovec, <span class="tok-number">0</span>);<span class="tok-comment">
        // Terminate as soon as we have copied size bytes or no bytes
        </span><span class="tok-kw">if</span> (maybe_size) |s| {
            <span class="tok-kw">if</span> (s == amt) <span class="tok-kw">break</span> :sendfile_loop;
        }
        <span class="tok-kw">if</span> (amt == <span class="tok-number">0</span>) <span class="tok-kw">break</span> :sendfile_loop;
        offset += amt;
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AtomicFileOptions = <span class="tok-kw">struct</span> {
    mode: <a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.mode_t">Mode</a> = <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.default_mode">default_mode</a>,
    make_path: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
};

<span class="tok-comment">/// Directly access the `.file` field, and then call `AtomicFile.finish` to</span>
<span class="tok-comment">/// atomically replace `dest_path` with contents.</span>
<span class="tok-comment">/// Always call `AtomicFile.deinit` to clean up, regardless of whether</span>
<span class="tok-comment">/// `AtomicFile.finish` succeeded. `dest_path` must remain valid until</span>
<span class="tok-comment">/// `AtomicFile.deinit` is called.</span>
<span class="tok-comment">/// On Windows, `dest_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `dest_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `dest_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">atomicFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.fs.Dir.AtomicFileOptions.html">AtomicFileOptions</a>) !<a href="std.fs.AtomicFile.html">AtomicFile</a> {
    <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(dest_path)) |dirname| {
        <span class="tok-kw">const</span> dir = <span class="tok-kw">if</span> (options.make_path)
            <span class="tok-kw">try</span> self.makeOpenPath(dirname, .{})
        <span class="tok-kw">else</span>
            <span class="tok-kw">try</span> self.openDir(dirname, .{});

        <span class="tok-kw">return</span> <a href="std.fs.AtomicFile.html">AtomicFile</a>.<a href="std.fs.AtomicFile.html#std.fs.AtomicFile.init">init</a>(<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.basename">basename</a>(dest_path), options.mode, dir, <span class="tok-null">true</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <a href="std.fs.AtomicFile.html">AtomicFile</a>.<a href="std.fs.AtomicFile.html#std.fs.AtomicFile.init">init</a>(dest_path, options.mode, self, <span class="tok-null">false</span>);
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Stat = <a href="std.fs.File.html">File</a>.<a href="std.fs.File.Stat.html">Stat</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StatError = <a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.FStatError">StatError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stat</span>(self: <a href="std.fs.Dir.html">Dir</a>) <a href="std.posix.html#std.posix.FStatError">StatError</a>!<a href="std.fs.File.Stat.html">Stat</a> {
    <span class="tok-kw">const</span> file: <a href="std.fs.File.html">File</a> = .{ .handle = self.fd };
    <span class="tok-kw">return</span> file.stat();
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StatFileError = <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a> || <a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.FStatError">StatError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.FStatAtError">FStatAtError</a>;

<span class="tok-comment">/// Returns metadata for a file inside the directory.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// On Windows, this requires three syscalls. On other operating systems, it</span>
<span class="tok-comment">/// only takes one.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Symlinks are followed.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `sub_path` may be absolute, in which case `self` is ignored.</span>
<span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">statFile</span>(self: <a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html#std.fs.Dir.StatFileError">StatFileError</a>!<a href="std.fs.File.Stat.html">Stat</a> {
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .windows) {
        <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> self.openFile(sub_path, .{});
        <span class="tok-kw">defer</span> file.close();
        <span class="tok-kw">return</span> file.stat();
    }
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> st = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.fstatat_wasi">fstatat_wasi</a>(self.fd, sub_path, .{ .SYMLINK_FOLLOW = <span class="tok-null">true</span> });
        <span class="tok-kw">return</span> <a href="std.fs.File.Stat.html">Stat</a>.<a href="std.fs.File.Stat.html#std.fs.File.Stat.fromWasi">fromWasi</a>(st);
    }
    <span class="tok-kw">if</span> (<a href="std.fs.Dir.html#std.fs.Dir.native_os">native_os</a> == .linux) {
        <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sub_path);
        <span class="tok-kw">var</span> stx = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroes">zeroes</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.Statx.html">Statx</a>);

        <span class="tok-kw">const</span> rc = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.statx">statx</a>(
            self.fd,
            &amp;sub_path_c,
            <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.AT.html">AT</a>.<a href="std.os.linux.AT.html#std.os.linux.AT.NO_AUTOMOUNT">NO_AUTOMOUNT</a>,
            <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_TYPE">STATX_TYPE</a> | <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_MODE">STATX_MODE</a> | <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_ATIME">STATX_ATIME</a> | <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_MTIME">STATX_MTIME</a> | <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_CTIME">STATX_CTIME</a>,
            &amp;stx,
        );

        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(rc)) {
            .SUCCESS =&gt; <a href="std.fs.File.Stat.html">Stat</a>.<a href="std.fs.File.Stat.html#std.fs.File.Stat.fromLinux">fromLinux</a>(stx),
            .ACCES =&gt; <span class="tok-kw">error</span>.AccessDenied,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .LOOP =&gt; <span class="tok-kw">error</span>.SymLinkLoop,
            .NAMETOOLONG =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handled by posix.toPosixPath() above.
            </span>.NOENT, .NOTDIR =&gt; <span class="tok-kw">error</span>.FileNotFound,
            .NOMEM =&gt; <span class="tok-kw">error</span>.SystemResources,
            <span class="tok-kw">else</span> =&gt; |err| <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        };
    }
    <span class="tok-kw">const</span> st = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fstatat">fstatat</a>(self.fd, sub_path, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> <a href="std.fs.File.Stat.html">Stat</a>.<a href="std.fs.File.Stat.html#std.fs.File.Stat.fromPosix">fromPosix</a>(st);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ChmodError = <a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.FChmodError">ChmodError</a>;

<span class="tok-comment">/// Changes the mode of the directory.</span>
<span class="tok-comment">/// The process must have the correct privileges in order to do this</span>
<span class="tok-comment">/// successfully, or must have the effective user ID matching the owner</span>
<span class="tok-comment">/// of the directory. Additionally, the directory must have been opened</span>
<span class="tok-comment">/// with `OpenOptions{ .iterate = true }`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chmod</span>(self: <a href="std.fs.Dir.html">Dir</a>, new_mode: <a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.mode_t">Mode</a>) <a href="std.posix.html#std.posix.FChmodError">ChmodError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> file: <a href="std.fs.File.html">File</a> = .{ .handle = self.fd };
    <span class="tok-kw">try</span> file.chmod(new_mode);
}

<span class="tok-comment">/// Changes the owner and group of the directory.</span>
<span class="tok-comment">/// The process must have the correct privileges in order to do this</span>
<span class="tok-comment">/// successfully. The group may be changed by the owner of the directory to</span>
<span class="tok-comment">/// any group of which the owner is a member. Additionally, the directory</span>
<span class="tok-comment">/// must have been opened with `OpenOptions{ .iterate = true }`. If the</span>
<span class="tok-comment">/// owner or group is specified as `null`, the ID is not changed.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chown</span>(self: <a href="std.fs.Dir.html">Dir</a>, owner: ?<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.uid_t">Uid</a>, group: ?<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.gid_t">Gid</a>) <a href="std.posix.html#std.posix.FChownError">ChownError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> file: <a href="std.fs.File.html">File</a> = .{ .handle = self.fd };
    <span class="tok-kw">try</span> file.chown(owner, group);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ChownError = <a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.FChownError">ChownError</a>;

<span class="tok-kw">const</span> Permissions = <a href="std.fs.File.html">File</a>.<a href="std.fs.File.Permissions.html">Permissions</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SetPermissionsError = <a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.FChmodError">SetPermissionsError</a>;

<span class="tok-comment">/// Sets permissions according to the provided `Permissions` struct.</span>
<span class="tok-comment">/// This method is *NOT* available on WASI</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setPermissions</span>(self: <a href="std.fs.Dir.html">Dir</a>, permissions: <a href="std.fs.File.Permissions.html">Permissions</a>) <a href="std.posix.html#std.posix.FChmodError">SetPermissionsError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> file: <a href="std.fs.File.html">File</a> = .{ .handle = self.fd };
    <span class="tok-kw">try</span> file.setPermissions(permissions);
}

<span class="tok-kw">const</span> Metadata = <a href="std.fs.File.html">File</a>.<a href="std.fs.File.Metadata.html">Metadata</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MetadataError = <a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.FStatError">MetadataError</a>;

<span class="tok-comment">/// Returns a `Metadata` struct, representing the permissions on the directory</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadata</span>(self: <a href="std.fs.Dir.html">Dir</a>) <a href="std.posix.html#std.posix.FStatError">MetadataError</a>!<a href="std.fs.File.Metadata.html">Metadata</a> {
    <span class="tok-kw">const</span> file: <a href="std.fs.File.html">File</a> = .{ .handle = self.fd };
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> file.metadata();
}

<span class="tok-kw">const</span> Dir = <span class="tok-builtin">@This</span>();
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../std.zig&quot;</span>);
<span class="tok-kw">const</span> File = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>;
<span class="tok-kw">const</span> AtomicFile = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.AtomicFile.html">AtomicFile</a>;
<span class="tok-kw">const</span> base64_encoder = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.base64_encoder">base64_encoder</a>;
<span class="tok-kw">const</span> crypto = <a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>;
<span class="tok-kw">const</span> posix = <a href="std.html">std</a>.<a href="std.posix.html">posix</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> path = <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>;
<span class="tok-kw">const</span> fs = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>;
<span class="tok-kw">const</span> Allocator = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> linux = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>;
<span class="tok-kw">const</span> windows = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>;
<span class="tok-kw">const</span> native_os = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>;
<span class="tok-kw">const</span> have_flock = <span class="tok-builtin">@TypeOf</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">flock</a>) != <span class="tok-type">void</span>;</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
