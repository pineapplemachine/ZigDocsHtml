<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">Thread</a></li><li><a href="std.Thread.Condition.html" class="active">Condition</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.Thread.Condition" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.Thread.Condition</span><a href="#src.zig-std.Thread.Condition">[src]</a></h1><div class="tldDocs"><p>Condition variables are used with a Mutex to efficiently wait for an arbitrary condition to occur.
It does this by atomically unlocking the mutex, blocking the thread until notified, and finally re-locking the mutex.
Condition can be statically initialized and is at most <code>@sizeOf(u64)</code> large.</p>
<p>Example:</p>
<pre><code>var m = Mutex{};
var c = Condition{};
var predicate = false;

fn consumer() void {
    m.lock();
    defer m.unlock();

    while (!predicate) {
        c.wait(&amp;m);
    }
}

fn producer() void {
    {
        m.lock();
        defer m.unlock();
        predicate = true;
    }
    c.signal();
}

const thread = try std.Thread.spawn(.{}, producer, .{});
consumer();
thread.join();
</code></pre>
<p>Note that condition variables can only reliably unblock threads that are sequenced before them using the same Mutex.
This means that the following is allowed to deadlock:</p>
<pre><code>thread-1: mutex.lock()
thread-1: condition.wait(&amp;mutex)

thread-2: // mutex.lock() (without this, the following signal may not see the waiting thread-1)
thread-2: // mutex.unlock() (this is optional for correctness once locked above, as signal can be called while holding the mutex)
thread-2: condition.signal()
</code></pre>
</div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>impl: <a href="std.Thread.Condition.html#std.Thread.Condition.Impl">Impl</a> = .{}</code></pre></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.Thread.Condition.wait" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">wait</span><a href="#src.zig-std.Thread.Condition.wait">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">wait</span>(self: *<a href="std.Thread.Condition.html">Condition</a>, mutex: *<a href="std.Thread.Mutex.html">Mutex</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Atomically releases the Mutex, blocks the caller thread, then re-acquires the Mutex on return.
&quot;Atomically&quot; here refers to accesses done on the Condition after acquiring the Mutex.</p>
<p>The Mutex must be locked by the caller's thread when this function is called.
A Mutex can have multiple Conditions waiting with it concurrently, but not the opposite.
It is undefined behavior for multiple threads to wait ith different mutexes using the same Condition concurrently.
Once threads have finished waiting with one Mutex, the Condition can be used to wait with another Mutex.</p>
<p>A blocking call to wait() is unblocked from one of the following conditions:</p>
<ul>
<li>a spurious (&quot;at random&quot;) wake up occurs</li>
<li>a future call to <code>signal()</code> or <code>broadcast()</code> which has acquired the Mutex and is sequenced after this <code>wait()</code>.</li>
</ul>
<p>Given wait() can be interrupted spuriously, the blocking condition should be checked continuously
irrespective of any notifications from <code>signal()</code> or <code>broadcast()</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.Thread.Condition.html">Condition</a></code></pre></div><div><pre><code>mutex: *<a href="std.Thread.Mutex.html">Mutex</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Thread.Condition.wait">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">wait</span>(self: *<a href="std.Thread.Condition.html">Condition</a>, mutex: *<a href="std.Thread.Mutex.html">Mutex</a>) <span class="tok-type">void</span> {
    self.impl.wait(mutex, <span class="tok-null">null</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.Timeout =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // no timeout provided so we shouldn't have timed-out
    </span>};
}</code></pre></details></div></div><div class="decl"><h2 id="std.Thread.Condition.timedWait" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">timedWait</span><a href="#src.zig-std.Thread.Condition.timedWait">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">timedWait</span>(self: *<a href="std.Thread.Condition.html">Condition</a>, mutex: *<a href="std.Thread.Mutex.html">Mutex</a>, timeout_ns: <span class="tok-type">u64</span>) <span class="tok-kw">error</span>{Timeout}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Atomically releases the Mutex, blocks the caller thread, then re-acquires the Mutex on return.
&quot;Atomically&quot; here refers to accesses done on the Condition after acquiring the Mutex.</p>
<p>The Mutex must be locked by the caller's thread when this function is called.
A Mutex can have multiple Conditions waiting with it concurrently, but not the opposite.
It is undefined behavior for multiple threads to wait ith different mutexes using the same Condition concurrently.
Once threads have finished waiting with one Mutex, the Condition can be used to wait with another Mutex.</p>
<p>A blocking call to <code>timedWait()</code> is unblocked from one of the following conditions:</p>
<ul>
<li>a spurious (&quot;at random&quot;) wake occurs</li>
<li>the caller was blocked for around <code>timeout_ns</code> nanoseconds, in which <code>error.Timeout</code> is returned.</li>
<li>a future call to <code>signal()</code> or <code>broadcast()</code> which has acquired the Mutex and is sequenced after this <code>timedWait()</code>.</li>
</ul>
<p>Given <code>timedWait()</code> can be interrupted spuriously, the blocking condition should be checked continuously
irrespective of any notifications from <code>signal()</code> or <code>broadcast()</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.Thread.Condition.html">Condition</a></code></pre></div><div><pre><code>mutex: *<a href="std.Thread.Mutex.html">Mutex</a></code></pre></div><div><pre><code>timeout_ns: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Thread.Condition.timedWait">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">timedWait</span>(self: *<a href="std.Thread.Condition.html">Condition</a>, mutex: *<a href="std.Thread.Mutex.html">Mutex</a>, timeout_ns: <span class="tok-type">u64</span>) <span class="tok-kw">error</span>{Timeout}!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.impl.wait(mutex, timeout_ns);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Thread.Condition.signal" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">signal</span><a href="#src.zig-std.Thread.Condition.signal">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">signal</span>(self: *<a href="std.Thread.Condition.html">Condition</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Unblocks at least one thread blocked in a call to <code>wait()</code> or <code>timedWait()</code> with a given Mutex.
The blocked thread must be sequenced before this call with respect to acquiring the same Mutex in order to be observable for unblocking.
<code>signal()</code> can be called with or without the relevant Mutex being acquired and have no &quot;effect&quot; if there's no observable blocked threads.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.Thread.Condition.html">Condition</a></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> signal {<span class="tok-comment">
    // This test requires spawning threads
    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    }

    <span class="tok-kw">const</span> num_threads = <span class="tok-number">4</span>;

    <span class="tok-kw">const</span> SignalTest = <span class="tok-kw">struct</span> {
        mutex: <a href="std.Thread.Mutex.html">Mutex</a> = .{},
        cond: <a href="std.Thread.Condition.html">Condition</a> = .{},
        notified: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        threads: [num_threads]<a href="std.html">std</a>.<a href="std.Thread.html">Thread</a> = <span class="tok-null">undefined</span>,
        spawn_count: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.IntFittingRange">IntFittingRange</a>(<span class="tok-number">0</span>, num_threads) = <span class="tok-number">0</span>,

        <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
            self.mutex.lock();
            <span class="tok-kw">defer</span> self.mutex.unlock();
            self.spawn_count += <span class="tok-number">1</span>;<span class="tok-comment">

            // Use timedWait() a few times before using wait()
            // to test multiple threads timing out frequently.
            </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (!self.notified) : (i +%= <span class="tok-number">1</span>) {
                <span class="tok-kw">if</span> (i &lt; <span class="tok-number">5</span>) {
                    self.cond.timedWait(&amp;self.mutex, <span class="tok-number">1</span>) <span class="tok-kw">catch</span> {};
                } <span class="tok-kw">else</span> {
                    self.cond.wait(&amp;self.mutex);
                }
            }<span class="tok-comment">

            // Once we received the signal, notify another thread (inside the lock).
            </span><a href="std.debug.html#std.debug.assert">assert</a>(self.notified);
            self.cond.signal();
        }
    };

    <span class="tok-kw">var</span> signal_test = SignalTest{};
    <span class="tok-kw">for</span> (&amp;signal_test.threads) |*t| {
        t.* = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.html#std.Thread.spawn">spawn</a>(.{}, SignalTest.run, .{&amp;signal_test});
    }

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.Thread.html#std.Thread.sleep">sleep</a>(<span class="tok-number">10</span> * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_ms">ns_per_ms</a>);

        signal_test.mutex.lock();
        <span class="tok-kw">defer</span> signal_test.mutex.unlock();<span class="tok-comment">
        // Make sure at least one thread has finished spawning to avoid testing nothing.
        </span><span class="tok-kw">if</span> (signal_test.spawn_count &gt; <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
    }

    {<span class="tok-comment">
        // Wake up one of them (outside the lock) after setting notified=true.
        </span><span class="tok-kw">defer</span> signal_test.cond.signal();

        signal_test.mutex.lock();
        <span class="tok-kw">defer</span> signal_test.mutex.unlock();

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!signal_test.notified);
        signal_test.notified = <span class="tok-null">true</span>;
    }

    <span class="tok-kw">for</span> (signal_test.threads) |t| {
        t.join();
    }
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Thread.Condition.signal">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">signal</span>(self: *<a href="std.Thread.Condition.html">Condition</a>) <span class="tok-type">void</span> {
    self.impl.wake(.one);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Thread.Condition.broadcast" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">broadcast</span><a href="#src.zig-std.Thread.Condition.broadcast">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">broadcast</span>(self: *<a href="std.Thread.Condition.html">Condition</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Unblocks all threads currently blocked in a call to <code>wait()</code> or <code>timedWait()</code> with a given Mutex.
The blocked threads must be sequenced before this call with respect to acquiring the same Mutex in order to be observable for unblocking.
<code>broadcast()</code> can be called with or without the relevant Mutex being acquired and have no &quot;effect&quot; if there's no observable blocked threads.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.Thread.Condition.html">Condition</a></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> broadcast {<span class="tok-comment">
    // This test requires spawning threads
    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    }

    <span class="tok-kw">const</span> num_threads = <span class="tok-number">10</span>;

    <span class="tok-kw">const</span> BroadcastTest = <span class="tok-kw">struct</span> {
        mutex: <a href="std.Thread.Mutex.html">Mutex</a> = .{},
        cond: <a href="std.Thread.Condition.html">Condition</a> = .{},
        completed: <a href="std.Thread.Condition.html">Condition</a> = .{},
        count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
        threads: [num_threads]<a href="std.html">std</a>.<a href="std.Thread.html">Thread</a> = <span class="tok-null">undefined</span>,

        <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
            self.mutex.lock();
            <span class="tok-kw">defer</span> self.mutex.unlock();<span class="tok-comment">

            // The last broadcast thread to start tells the main test thread it's completed.
            </span>self.count += <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (self.count == num_threads) {
                self.completed.signal();
            }<span class="tok-comment">

            // Waits for the count to reach zero after the main test thread observes it at num_threads.
            // Tries to use timedWait() a bit before falling back to wait() to test multiple threads timing out.
            </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (self.count != <span class="tok-number">0</span>) : (i +%= <span class="tok-number">1</span>) {
                <span class="tok-kw">if</span> (i &lt; <span class="tok-number">10</span>) {
                    self.cond.timedWait(&amp;self.mutex, <span class="tok-number">1</span>) <span class="tok-kw">catch</span> {};
                } <span class="tok-kw">else</span> {
                    self.cond.wait(&amp;self.mutex);
                }
            }
        }
    };

    <span class="tok-kw">var</span> broadcast_test = BroadcastTest{};
    <span class="tok-kw">for</span> (&amp;broadcast_test.threads) |*t| {
        t.* = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.html#std.Thread.spawn">spawn</a>(.{}, BroadcastTest.run, .{&amp;broadcast_test});
    }

    {
        broadcast_test.mutex.lock();
        <span class="tok-kw">defer</span> broadcast_test.mutex.unlock();<span class="tok-comment">

        // Wait for all the broadcast threads to spawn.
        // timedWait() to detect any potential deadlocks.
        </span><span class="tok-kw">while</span> (broadcast_test.count != num_threads) {
            broadcast_test.completed.timedWait(
                &amp;broadcast_test.mutex,
                <span class="tok-number">1</span> * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a>,
            ) <span class="tok-kw">catch</span> {};
        }<span class="tok-comment">

        // Reset the counter and wake all the threads to exit.
        </span>broadcast_test.count = <span class="tok-number">0</span>;
        broadcast_test.cond.broadcast();
    }

    <span class="tok-kw">for</span> (broadcast_test.threads) |t| {
        t.join();
    }
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Thread.Condition.broadcast">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">broadcast</span>(self: *<a href="std.Thread.Condition.html">Condition</a>) <span class="tok-type">void</span> {
    self.impl.wake(.all);
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.Thread.Condition">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! Condition variables are used with a Mutex to efficiently wait for an arbitrary condition to occur.</span>
<span class="tok-comment">//! It does this by atomically unlocking the mutex, blocking the thread until notified, and finally re-locking the mutex.</span>
<span class="tok-comment">//! Condition can be statically initialized and is at most `@sizeOf(u64)` large.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! Example:</span>
<span class="tok-comment">//! ```</span>
<span class="tok-comment">//! var m = Mutex{};</span>
<span class="tok-comment">//! var c = Condition{};</span>
<span class="tok-comment">//! var predicate = false;</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! fn consumer() void {</span>
<span class="tok-comment">//!     m.lock();</span>
<span class="tok-comment">//!     defer m.unlock();</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//!     while (!predicate) {</span>
<span class="tok-comment">//!         c.wait(&amp;m);</span>
<span class="tok-comment">//!     }</span>
<span class="tok-comment">//! }</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! fn producer() void {</span>
<span class="tok-comment">//!     {</span>
<span class="tok-comment">//!         m.lock();</span>
<span class="tok-comment">//!         defer m.unlock();</span>
<span class="tok-comment">//!         predicate = true;</span>
<span class="tok-comment">//!     }</span>
<span class="tok-comment">//!     c.signal();</span>
<span class="tok-comment">//! }</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! const thread = try std.Thread.spawn(.{}, producer, .{});</span>
<span class="tok-comment">//! consumer();</span>
<span class="tok-comment">//! thread.join();</span>
<span class="tok-comment">//! ```</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! Note that condition variables can only reliably unblock threads that are sequenced before them using the same Mutex.</span>
<span class="tok-comment">//! This means that the following is allowed to deadlock:</span>
<span class="tok-comment">//! ```</span>
<span class="tok-comment">//! thread-1: mutex.lock()</span>
<span class="tok-comment">//! thread-1: condition.wait(&amp;mutex)</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! thread-2: // mutex.lock() (without this, the following signal may not see the waiting thread-1)</span>
<span class="tok-comment">//! thread-2: // mutex.unlock() (this is optional for correctness once locked above, as signal can be called while holding the mutex)</span>
<span class="tok-comment">//! thread-2: condition.signal()</span>
<span class="tok-comment">//! ```</span>

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../std.zig&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> Condition = <span class="tok-builtin">@This</span>();
<span class="tok-kw">const</span> Mutex = <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.Mutex.html">Mutex</a>;

<span class="tok-kw">const</span> os = <a href="std.html">std</a>.<a href="std.os.html">os</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;
<span class="tok-kw">const</span> Futex = <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.Futex.html">Futex</a>;

impl: <a href="std.Thread.Condition.html#std.Thread.Condition.Impl">Impl</a> = .{},

<span class="tok-comment">/// Atomically releases the Mutex, blocks the caller thread, then re-acquires the Mutex on return.</span>
<span class="tok-comment">/// &quot;Atomically&quot; here refers to accesses done on the Condition after acquiring the Mutex.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The Mutex must be locked by the caller's thread when this function is called.</span>
<span class="tok-comment">/// A Mutex can have multiple Conditions waiting with it concurrently, but not the opposite.</span>
<span class="tok-comment">/// It is undefined behavior for multiple threads to wait ith different mutexes using the same Condition concurrently.</span>
<span class="tok-comment">/// Once threads have finished waiting with one Mutex, the Condition can be used to wait with another Mutex.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// A blocking call to wait() is unblocked from one of the following conditions:</span>
<span class="tok-comment">/// - a spurious (&quot;at random&quot;) wake up occurs</span>
<span class="tok-comment">/// - a future call to `signal()` or `broadcast()` which has acquired the Mutex and is sequenced after this `wait()`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Given wait() can be interrupted spuriously, the blocking condition should be checked continuously</span>
<span class="tok-comment">/// irrespective of any notifications from `signal()` or `broadcast()`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">wait</span>(self: *<a href="std.Thread.Condition.html">Condition</a>, mutex: *<a href="std.Thread.Mutex.html">Mutex</a>) <span class="tok-type">void</span> {
    self.impl.wait(mutex, <span class="tok-null">null</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.Timeout =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // no timeout provided so we shouldn't have timed-out
    </span>};
}

<span class="tok-comment">/// Atomically releases the Mutex, blocks the caller thread, then re-acquires the Mutex on return.</span>
<span class="tok-comment">/// &quot;Atomically&quot; here refers to accesses done on the Condition after acquiring the Mutex.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The Mutex must be locked by the caller's thread when this function is called.</span>
<span class="tok-comment">/// A Mutex can have multiple Conditions waiting with it concurrently, but not the opposite.</span>
<span class="tok-comment">/// It is undefined behavior for multiple threads to wait ith different mutexes using the same Condition concurrently.</span>
<span class="tok-comment">/// Once threads have finished waiting with one Mutex, the Condition can be used to wait with another Mutex.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// A blocking call to `timedWait()` is unblocked from one of the following conditions:</span>
<span class="tok-comment">/// - a spurious (&quot;at random&quot;) wake occurs</span>
<span class="tok-comment">/// - the caller was blocked for around `timeout_ns` nanoseconds, in which `error.Timeout` is returned.</span>
<span class="tok-comment">/// - a future call to `signal()` or `broadcast()` which has acquired the Mutex and is sequenced after this `timedWait()`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Given `timedWait()` can be interrupted spuriously, the blocking condition should be checked continuously</span>
<span class="tok-comment">/// irrespective of any notifications from `signal()` or `broadcast()`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">timedWait</span>(self: *<a href="std.Thread.Condition.html">Condition</a>, mutex: *<a href="std.Thread.Mutex.html">Mutex</a>, timeout_ns: <span class="tok-type">u64</span>) <span class="tok-kw">error</span>{Timeout}!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.impl.wait(mutex, timeout_ns);
}

<span class="tok-comment">/// Unblocks at least one thread blocked in a call to `wait()` or `timedWait()` with a given Mutex.</span>
<span class="tok-comment">/// The blocked thread must be sequenced before this call with respect to acquiring the same Mutex in order to be observable for unblocking.</span>
<span class="tok-comment">/// `signal()` can be called with or without the relevant Mutex being acquired and have no &quot;effect&quot; if there's no observable blocked threads.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">signal</span>(self: *<a href="std.Thread.Condition.html">Condition</a>) <span class="tok-type">void</span> {
    self.impl.wake(.one);
}

<span class="tok-comment">/// Unblocks all threads currently blocked in a call to `wait()` or `timedWait()` with a given Mutex.</span>
<span class="tok-comment">/// The blocked threads must be sequenced before this call with respect to acquiring the same Mutex in order to be observable for unblocking.</span>
<span class="tok-comment">/// `broadcast()` can be called with or without the relevant Mutex being acquired and have no &quot;effect&quot; if there's no observable blocked threads.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">broadcast</span>(self: *<a href="std.Thread.Condition.html">Condition</a>) <span class="tok-type">void</span> {
    self.impl.wake(.all);
}

<span class="tok-kw">const</span> Impl = <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>)
    <a href="std.Thread.Condition.SingleThreadedImpl.html">SingleThreadedImpl</a>
<span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows)
    <a href="std.Thread.Condition.WindowsImpl.html">WindowsImpl</a>
<span class="tok-kw">else</span>
    <a href="std.Thread.Condition.FutexImpl.html">FutexImpl</a>;

<span class="tok-kw">const</span> Notify = <span class="tok-kw">enum</span> {
    one,<span class="tok-comment"> // wake up only one thread
    </span>all,<span class="tok-comment"> // wake up all threads
</span>};

<span class="tok-kw">const</span> SingleThreadedImpl = <span class="tok-kw">struct</span> {
    <span class="tok-kw">fn</span> <span class="tok-fn">wait</span>(self: *<a href="std.Thread.Condition.html#std.Thread.Condition.Impl">Impl</a>, mutex: *<a href="std.Thread.Mutex.html">Mutex</a>, timeout: ?<span class="tok-type">u64</span>) <span class="tok-kw">error</span>{Timeout}!<span class="tok-type">void</span> {
        _ = self;
        _ = mutex;<span class="tok-comment">

        // There are no other threads to wake us up.
        // So if we wait without a timeout we would never wake up.
        </span><span class="tok-kw">const</span> timeout_ns = timeout <span class="tok-kw">orelse</span> {
            <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // deadlock detected
        </span>};

        <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.Thread.html#std.Thread.sleep">sleep</a>(timeout_ns);
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Timeout;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">wake</span>(self: *<a href="std.Thread.Condition.html#std.Thread.Condition.Impl">Impl</a>, <span class="tok-kw">comptime</span> notify: <a href="std.Thread.Condition.Notify.html">Notify</a>) <span class="tok-type">void</span> {<span class="tok-comment">
        // There are no other threads to wake up.
        </span>_ = self;
        _ = notify;
    }
};

<span class="tok-kw">const</span> WindowsImpl = <span class="tok-kw">struct</span> {
    condition: <a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.CONDITION_VARIABLE.html">CONDITION_VARIABLE</a> = .{},

    <span class="tok-kw">fn</span> <span class="tok-fn">wait</span>(self: *<a href="std.Thread.Condition.html#std.Thread.Condition.Impl">Impl</a>, mutex: *<a href="std.Thread.Mutex.html">Mutex</a>, timeout: ?<span class="tok-type">u64</span>) <span class="tok-kw">error</span>{Timeout}!<span class="tok-type">void</span> {
        <span class="tok-kw">var</span> timeout_overflowed = <span class="tok-null">false</span>;
        <span class="tok-kw">var</span> timeout_ms: <a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a> = <a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.INFINITE">INFINITE</a>;

        <span class="tok-kw">if</span> (timeout) |timeout_ns| {<span class="tok-comment">
            // Round the nanoseconds to the nearest millisecond,
            // then saturating cast it to windows DWORD for use in kernel32 call.
            </span><span class="tok-kw">const</span> ms = (timeout_ns +| (<a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_ms">ns_per_ms</a> / <span class="tok-number">2</span>)) / <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_ms">ns_per_ms</a>;
            timeout_ms = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a>, ms) <span class="tok-kw">orelse</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a>);<span class="tok-comment">

            // Track if the timeout overflowed into INFINITE and make sure not to wait forever.
            </span><span class="tok-kw">if</span> (timeout_ms == <a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.INFINITE">INFINITE</a>) {
                timeout_overflowed = <span class="tok-null">true</span>;
                timeout_ms -= <span class="tok-number">1</span>;
            }
        }

        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.mode">mode</a> == .Debug) {<span class="tok-comment">
            // The internal state of the DebugMutex needs to be handled here as well.
            </span>mutex.impl.locking_thread.store(<span class="tok-number">0</span>, .unordered);
        }
        <span class="tok-kw">const</span> rc = <a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.SleepConditionVariableSRW">SleepConditionVariableSRW</a>(
            &amp;self.condition,
            <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.mode">mode</a> == .Debug) &amp;mutex.impl.impl.srwlock <span class="tok-kw">else</span> &amp;mutex.impl.srwlock,
            timeout_ms,
            <span class="tok-number">0</span>,<span class="tok-comment"> // the srwlock was assumed to acquired in exclusive mode not shared
        </span>);
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.mode">mode</a> == .Debug) {<span class="tok-comment">
            // The internal state of the DebugMutex needs to be handled here as well.
            </span>mutex.impl.locking_thread.store(<a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.html#std.Thread.getCurrentId">getCurrentId</a>(), .unordered);
        }<span class="tok-comment">

        // Return error.Timeout if we know the timeout elapsed correctly.
        </span><span class="tok-kw">if</span> (rc == <a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FALSE">FALSE</a>) {
            <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetLastError">GetLastError</a>() == .TIMEOUT);
            <span class="tok-kw">if</span> (!timeout_overflowed) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Timeout;
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">wake</span>(self: *<a href="std.Thread.Condition.html#std.Thread.Condition.Impl">Impl</a>, <span class="tok-kw">comptime</span> notify: <a href="std.Thread.Condition.Notify.html">Notify</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">switch</span> (notify) {
            .one =&gt; <a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.WakeConditionVariable">WakeConditionVariable</a>(&amp;self.condition),
            .all =&gt; <a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.WakeAllConditionVariable">WakeAllConditionVariable</a>(&amp;self.condition),
        }
    }
};

<span class="tok-kw">const</span> FutexImpl = <span class="tok-kw">struct</span> {
    state: <a href="std.html">std</a>.<a href="std.atomic.html">atomic</a>.<a href="std.atomic.html#std.atomic.Value">Value</a>(<span class="tok-type">u32</span>) = <a href="std.html">std</a>.<a href="std.atomic.html">atomic</a>.<a href="std.atomic.html#std.atomic.Value">Value</a>(<span class="tok-type">u32</span>).init(<span class="tok-number">0</span>),
    epoch: <a href="std.html">std</a>.<a href="std.atomic.html">atomic</a>.<a href="std.atomic.html#std.atomic.Value">Value</a>(<span class="tok-type">u32</span>) = <a href="std.html">std</a>.<a href="std.atomic.html">atomic</a>.<a href="std.atomic.html#std.atomic.Value">Value</a>(<span class="tok-type">u32</span>).init(<span class="tok-number">0</span>),

    <span class="tok-kw">const</span> one_waiter = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> waiter_mask = <span class="tok-number">0xffff</span>;

    <span class="tok-kw">const</span> one_signal = <span class="tok-number">1</span> &lt;&lt; <span class="tok-number">16</span>;
    <span class="tok-kw">const</span> signal_mask = <span class="tok-number">0xffff</span> &lt;&lt; <span class="tok-number">16</span>;

    <span class="tok-kw">fn</span> <span class="tok-fn">wait</span>(self: *<a href="std.Thread.Condition.html#std.Thread.Condition.Impl">Impl</a>, mutex: *<a href="std.Thread.Mutex.html">Mutex</a>, timeout: ?<span class="tok-type">u64</span>) <span class="tok-kw">error</span>{Timeout}!<span class="tok-type">void</span> {<span class="tok-comment">
        // Observe the epoch, then check the state again to see if we should wake up.
        // The epoch must be observed before we check the state or we could potentially miss a wake() and deadlock:
        //
        // - T1: s = LOAD(&amp;state)
        // - T2: UPDATE(&amp;s, signal)
        // - T2: UPDATE(&amp;epoch, 1) + FUTEX_WAKE(&amp;epoch)
        // - T1: e = LOAD(&amp;epoch) (was reordered after the state load)
        // - T1: s &amp; signals == 0 -&gt; FUTEX_WAIT(&amp;epoch, e) (missed the state update + the epoch change)
        //
        // Acquire barrier to ensure the epoch load happens before the state load.
        </span><span class="tok-kw">var</span> epoch = self.epoch.load(.acquire);
        <span class="tok-kw">var</span> state = self.state.fetchAdd(<a href="std.Thread.Condition.FutexImpl.html#std.Thread.Condition.FutexImpl.one_waiter">one_waiter</a>, .monotonic);
        <a href="std.debug.html#std.debug.assert">assert</a>(state &amp; <a href="std.Thread.Condition.FutexImpl.html#std.Thread.Condition.FutexImpl.waiter_mask">waiter_mask</a> != <a href="std.Thread.Condition.FutexImpl.html#std.Thread.Condition.FutexImpl.waiter_mask">waiter_mask</a>);
        state += <a href="std.Thread.Condition.FutexImpl.html#std.Thread.Condition.FutexImpl.one_waiter">one_waiter</a>;

        mutex.unlock();
        <span class="tok-kw">defer</span> mutex.lock();

        <span class="tok-kw">var</span> futex_deadline = <a href="std.Thread.Futex.html">Futex</a>.<a href="std.Thread.Futex.Deadline.html">Deadline</a>.<a href="std.Thread.Futex.Deadline.html#std.Thread.Futex.Deadline.init">init</a>(timeout);

        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            futex_deadline.wait(&amp;self.epoch, epoch) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {<span class="tok-comment">
                // On timeout, we must decrement the waiter we added above.
                </span><span class="tok-kw">error</span>.Timeout =&gt; {
                    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment">
                        // If there's a signal when we're timing out, consume it and report being woken up instead.
                        // Acquire barrier ensures code before the wake() which added the signal happens before we decrement it and return.
                        </span><span class="tok-kw">while</span> (state &amp; <a href="std.Thread.Condition.FutexImpl.html#std.Thread.Condition.FutexImpl.signal_mask">signal_mask</a> != <span class="tok-number">0</span>) {
                            <span class="tok-kw">const</span> new_state = state - <a href="std.Thread.Condition.FutexImpl.html#std.Thread.Condition.FutexImpl.one_waiter">one_waiter</a> - <a href="std.Thread.Condition.FutexImpl.html#std.Thread.Condition.FutexImpl.one_signal">one_signal</a>;
                            state = self.state.cmpxchgWeak(state, new_state, .acquire, .monotonic) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
                        }<span class="tok-comment">

                        // Remove the waiter we added and officially return timed out.
                        </span><span class="tok-kw">const</span> new_state = state - <a href="std.Thread.Condition.FutexImpl.html#std.Thread.Condition.FutexImpl.one_waiter">one_waiter</a>;
                        state = self.state.cmpxchgWeak(state, new_state, .monotonic, .monotonic) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
                    }
                },
            };

            epoch = self.epoch.load(.acquire);
            state = self.state.load(.monotonic);<span class="tok-comment">

            // Try to wake up by consuming a signal and decremented the waiter we added previously.
            // Acquire barrier ensures code before the wake() which added the signal happens before we decrement it and return.
            </span><span class="tok-kw">while</span> (state &amp; <a href="std.Thread.Condition.FutexImpl.html#std.Thread.Condition.FutexImpl.signal_mask">signal_mask</a> != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> new_state = state - <a href="std.Thread.Condition.FutexImpl.html#std.Thread.Condition.FutexImpl.one_waiter">one_waiter</a> - <a href="std.Thread.Condition.FutexImpl.html#std.Thread.Condition.FutexImpl.one_signal">one_signal</a>;
                state = self.state.cmpxchgWeak(state, new_state, .acquire, .monotonic) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
            }
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">wake</span>(self: *<a href="std.Thread.Condition.html#std.Thread.Condition.Impl">Impl</a>, <span class="tok-kw">comptime</span> notify: <a href="std.Thread.Condition.Notify.html">Notify</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">var</span> state = self.state.load(.monotonic);
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">const</span> waiters = (state &amp; <a href="std.Thread.Condition.FutexImpl.html#std.Thread.Condition.FutexImpl.waiter_mask">waiter_mask</a>) / <a href="std.Thread.Condition.FutexImpl.html#std.Thread.Condition.FutexImpl.one_waiter">one_waiter</a>;
            <span class="tok-kw">const</span> signals = (state &amp; <a href="std.Thread.Condition.FutexImpl.html#std.Thread.Condition.FutexImpl.signal_mask">signal_mask</a>) / <a href="std.Thread.Condition.FutexImpl.html#std.Thread.Condition.FutexImpl.one_signal">one_signal</a>;<span class="tok-comment">

            // Reserves which waiters to wake up by incrementing the signals count.
            // Therefore, the signals count is always less than or equal to the waiters count.
            // We don't need to Futex.wake if there's nothing to wake up or if other wake() threads have reserved to wake up the current waiters.
            </span><span class="tok-kw">const</span> wakeable = waiters - signals;
            <span class="tok-kw">if</span> (wakeable == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span>;
            }

            <span class="tok-kw">const</span> to_wake = <span class="tok-kw">switch</span> (notify) {
                .one =&gt; <span class="tok-number">1</span>,
                .all =&gt; wakeable,
            };<span class="tok-comment">

            // Reserve the amount of waiters to wake by incrementing the signals count.
            // Release barrier ensures code before the wake() happens before the signal it posted and consumed by the wait() threads.
            </span><span class="tok-kw">const</span> new_state = state + (<a href="std.Thread.Condition.FutexImpl.html#std.Thread.Condition.FutexImpl.one_signal">one_signal</a> * to_wake);
            state = self.state.cmpxchgWeak(state, new_state, .release, .monotonic) <span class="tok-kw">orelse</span> {<span class="tok-comment">
                // Wake up the waiting threads we reserved above by changing the epoch value.
                // NOTE: a waiting thread could miss a wake up if *exactly* ((1&lt;&lt;32)-1) wake()s happen between it observing the epoch and sleeping on it.
                // This is very unlikely due to how many precise amount of Futex.wake() calls that would be between the waiting thread's potential preemption.
                //
                // Release barrier ensures the signal being added to the state happens before the epoch is changed.
                // If not, the waiting thread could potentially deadlock from missing both the state and epoch change:
                //
                // - T2: UPDATE(&amp;epoch, 1) (reordered before the state change)
                // - T1: e = LOAD(&amp;epoch)
                // - T1: s = LOAD(&amp;state)
                // - T2: UPDATE(&amp;state, signal) + FUTEX_WAKE(&amp;epoch)
                // - T1: s &amp; signals == 0 -&gt; FUTEX_WAIT(&amp;epoch, e) (missed both epoch change and state change)
                </span>_ = self.epoch.fetchAdd(<span class="tok-number">1</span>, .release);
                <a href="std.Thread.Futex.html">Futex</a>.<a href="std.Thread.Futex.html#std.Thread.Futex.wake">wake</a>(&amp;self.epoch, to_wake);
                <span class="tok-kw">return</span>;
            };
        }
    }
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;smoke test&quot;</span> {
    <span class="tok-kw">var</span> mutex = <a href="std.Thread.Mutex.html">Mutex</a>{};
    <span class="tok-kw">var</span> cond = <a href="std.Thread.Condition.html">Condition</a>{};<span class="tok-comment">

    // Try to wake outside the mutex
    </span><span class="tok-kw">defer</span> cond.signal();
    <span class="tok-kw">defer</span> cond.broadcast();

    mutex.lock();
    <span class="tok-kw">defer</span> mutex.unlock();<span class="tok-comment">

    // Try to wait with a timeout (should not deadlock)
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.Timeout, cond.timedWait(&amp;mutex, <span class="tok-number">0</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.Timeout, cond.timedWait(&amp;mutex, <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_ms">ns_per_ms</a>));<span class="tok-comment">

    // Try to wake inside the mutex.
    </span>cond.signal();
    cond.broadcast();
}<span class="tok-comment">

// Inspired from: https://github.com/Amanieu/parking_lot/pull/129
</span><span class="tok-kw">test</span> <span class="tok-str">&quot;wait and signal&quot;</span> {<span class="tok-comment">
    // This test requires spawning threads
    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    }

    <span class="tok-kw">const</span> num_threads = <span class="tok-number">4</span>;

    <span class="tok-kw">const</span> MultiWait = <span class="tok-kw">struct</span> {
        mutex: <a href="std.Thread.Mutex.html">Mutex</a> = .{},
        cond: <a href="std.Thread.Condition.html">Condition</a> = .{},
        threads: [num_threads]<a href="std.html">std</a>.<a href="std.Thread.html">Thread</a> = <span class="tok-null">undefined</span>,
        spawn_count: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.IntFittingRange">IntFittingRange</a>(<span class="tok-number">0</span>, num_threads) = <span class="tok-number">0</span>,

        <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
            self.mutex.lock();
            <span class="tok-kw">defer</span> self.mutex.unlock();
            self.spawn_count += <span class="tok-number">1</span>;

            self.cond.wait(&amp;self.mutex);
            self.cond.timedWait(&amp;self.mutex, <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_ms">ns_per_ms</a>) <span class="tok-kw">catch</span> {};
            self.cond.signal();
        }
    };

    <span class="tok-kw">var</span> multi_wait = MultiWait{};
    <span class="tok-kw">for</span> (&amp;multi_wait.threads) |*t| {
        t.* = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.html#std.Thread.spawn">spawn</a>(.{}, MultiWait.run, .{&amp;multi_wait});
    }

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.Thread.html#std.Thread.sleep">sleep</a>(<span class="tok-number">100</span> * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_ms">ns_per_ms</a>);

        multi_wait.mutex.lock();
        <span class="tok-kw">defer</span> multi_wait.mutex.unlock();<span class="tok-comment">
        // Make sure all of the threads have finished spawning to avoid a deadlock.
        </span><span class="tok-kw">if</span> (multi_wait.spawn_count == num_threads) <span class="tok-kw">break</span>;
    }

    multi_wait.cond.signal();
    <span class="tok-kw">for</span> (multi_wait.threads) |t| {
        t.join();
    }
}

<span class="tok-kw">test</span> signal {<span class="tok-comment">
    // This test requires spawning threads
    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    }

    <span class="tok-kw">const</span> num_threads = <span class="tok-number">4</span>;

    <span class="tok-kw">const</span> SignalTest = <span class="tok-kw">struct</span> {
        mutex: <a href="std.Thread.Mutex.html">Mutex</a> = .{},
        cond: <a href="std.Thread.Condition.html">Condition</a> = .{},
        notified: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        threads: [num_threads]<a href="std.html">std</a>.<a href="std.Thread.html">Thread</a> = <span class="tok-null">undefined</span>,
        spawn_count: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.IntFittingRange">IntFittingRange</a>(<span class="tok-number">0</span>, num_threads) = <span class="tok-number">0</span>,

        <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
            self.mutex.lock();
            <span class="tok-kw">defer</span> self.mutex.unlock();
            self.spawn_count += <span class="tok-number">1</span>;<span class="tok-comment">

            // Use timedWait() a few times before using wait()
            // to test multiple threads timing out frequently.
            </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (!self.notified) : (i +%= <span class="tok-number">1</span>) {
                <span class="tok-kw">if</span> (i &lt; <span class="tok-number">5</span>) {
                    self.cond.timedWait(&amp;self.mutex, <span class="tok-number">1</span>) <span class="tok-kw">catch</span> {};
                } <span class="tok-kw">else</span> {
                    self.cond.wait(&amp;self.mutex);
                }
            }<span class="tok-comment">

            // Once we received the signal, notify another thread (inside the lock).
            </span><a href="std.debug.html#std.debug.assert">assert</a>(self.notified);
            self.cond.signal();
        }
    };

    <span class="tok-kw">var</span> signal_test = SignalTest{};
    <span class="tok-kw">for</span> (&amp;signal_test.threads) |*t| {
        t.* = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.html#std.Thread.spawn">spawn</a>(.{}, SignalTest.run, .{&amp;signal_test});
    }

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.Thread.html#std.Thread.sleep">sleep</a>(<span class="tok-number">10</span> * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_ms">ns_per_ms</a>);

        signal_test.mutex.lock();
        <span class="tok-kw">defer</span> signal_test.mutex.unlock();<span class="tok-comment">
        // Make sure at least one thread has finished spawning to avoid testing nothing.
        </span><span class="tok-kw">if</span> (signal_test.spawn_count &gt; <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
    }

    {<span class="tok-comment">
        // Wake up one of them (outside the lock) after setting notified=true.
        </span><span class="tok-kw">defer</span> signal_test.cond.signal();

        signal_test.mutex.lock();
        <span class="tok-kw">defer</span> signal_test.mutex.unlock();

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!signal_test.notified);
        signal_test.notified = <span class="tok-null">true</span>;
    }

    <span class="tok-kw">for</span> (signal_test.threads) |t| {
        t.join();
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;multi signal&quot;</span> {<span class="tok-comment">
    // This test requires spawning threads
    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    }

    <span class="tok-kw">const</span> num_threads = <span class="tok-number">4</span>;
    <span class="tok-kw">const</span> num_iterations = <span class="tok-number">4</span>;

    <span class="tok-kw">const</span> Paddle = <span class="tok-kw">struct</span> {
        mutex: <a href="std.Thread.Mutex.html">Mutex</a> = .{},
        cond: <a href="std.Thread.Condition.html">Condition</a> = .{},
        value: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,

        <span class="tok-kw">fn</span> <span class="tok-fn">hit</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
            <span class="tok-kw">defer</span> self.cond.signal();

            self.mutex.lock();
            <span class="tok-kw">defer</span> self.mutex.unlock();

            self.value += <span class="tok-number">1</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(self: *<span class="tok-builtin">@This</span>(), hit_to: *<span class="tok-builtin">@This</span>()) !<span class="tok-type">void</span> {
            self.mutex.lock();
            <span class="tok-kw">defer</span> self.mutex.unlock();

            <span class="tok-kw">var</span> current: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (current &lt; num_iterations) : (current += <span class="tok-number">1</span>) {<span class="tok-comment">
                // Wait for the value to change from hit()
                </span><span class="tok-kw">while</span> (self.value == current) {
                    self.cond.wait(&amp;self.mutex);
                }<span class="tok-comment">

                // hit the next paddle
                </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(self.value, current + <span class="tok-number">1</span>);
                hit_to.hit();
            }
        }
    };

    <span class="tok-kw">var</span> paddles = [_]Paddle{.{}} ** num_threads;
    <span class="tok-kw">var</span> threads = [_]<a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>{<span class="tok-null">undefined</span>} ** num_threads;<span class="tok-comment">

    // Create a circle of paddles which hit each other
    </span><span class="tok-kw">for</span> (&amp;threads, <span class="tok-number">0</span>..) |*t, i| {
        <span class="tok-kw">const</span> paddle = &amp;paddles[i];
        <span class="tok-kw">const</span> hit_to = &amp;paddles[(i + <span class="tok-number">1</span>) % paddles.len];
        t.* = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.html#std.Thread.spawn">spawn</a>(.{}, Paddle.run, .{ paddle, hit_to });
    }<span class="tok-comment">

    // Hit the first paddle and wait for them all to complete by hitting each other for num_iterations.
    </span>paddles[<span class="tok-number">0</span>].hit();
    <span class="tok-kw">for</span> (threads) |t| t.join();<span class="tok-comment">

    // The first paddle will be hit one last time by the last paddle.
    </span><span class="tok-kw">for</span> (paddles, <span class="tok-number">0</span>..) |p, i| {
        <span class="tok-kw">const</span> expected = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, num_iterations) + <span class="tok-builtin">@intFromBool</span>(i == <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(p.value, expected);
    }
}

<span class="tok-kw">test</span> broadcast {<span class="tok-comment">
    // This test requires spawning threads
    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    }

    <span class="tok-kw">const</span> num_threads = <span class="tok-number">10</span>;

    <span class="tok-kw">const</span> BroadcastTest = <span class="tok-kw">struct</span> {
        mutex: <a href="std.Thread.Mutex.html">Mutex</a> = .{},
        cond: <a href="std.Thread.Condition.html">Condition</a> = .{},
        completed: <a href="std.Thread.Condition.html">Condition</a> = .{},
        count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
        threads: [num_threads]<a href="std.html">std</a>.<a href="std.Thread.html">Thread</a> = <span class="tok-null">undefined</span>,

        <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
            self.mutex.lock();
            <span class="tok-kw">defer</span> self.mutex.unlock();<span class="tok-comment">

            // The last broadcast thread to start tells the main test thread it's completed.
            </span>self.count += <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (self.count == num_threads) {
                self.completed.signal();
            }<span class="tok-comment">

            // Waits for the count to reach zero after the main test thread observes it at num_threads.
            // Tries to use timedWait() a bit before falling back to wait() to test multiple threads timing out.
            </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (self.count != <span class="tok-number">0</span>) : (i +%= <span class="tok-number">1</span>) {
                <span class="tok-kw">if</span> (i &lt; <span class="tok-number">10</span>) {
                    self.cond.timedWait(&amp;self.mutex, <span class="tok-number">1</span>) <span class="tok-kw">catch</span> {};
                } <span class="tok-kw">else</span> {
                    self.cond.wait(&amp;self.mutex);
                }
            }
        }
    };

    <span class="tok-kw">var</span> broadcast_test = BroadcastTest{};
    <span class="tok-kw">for</span> (&amp;broadcast_test.threads) |*t| {
        t.* = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.html#std.Thread.spawn">spawn</a>(.{}, BroadcastTest.run, .{&amp;broadcast_test});
    }

    {
        broadcast_test.mutex.lock();
        <span class="tok-kw">defer</span> broadcast_test.mutex.unlock();<span class="tok-comment">

        // Wait for all the broadcast threads to spawn.
        // timedWait() to detect any potential deadlocks.
        </span><span class="tok-kw">while</span> (broadcast_test.count != num_threads) {
            broadcast_test.completed.timedWait(
                &amp;broadcast_test.mutex,
                <span class="tok-number">1</span> * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a>,
            ) <span class="tok-kw">catch</span> {};
        }<span class="tok-comment">

        // Reset the counter and wake all the threads to exit.
        </span>broadcast_test.count = <span class="tok-number">0</span>;
        broadcast_test.cond.broadcast();
    }

    <span class="tok-kw">for</span> (broadcast_test.threads) |t| {
        t.join();
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;broadcasting - wake all threads&quot;</span> {<span class="tok-comment">
    // Tests issue #12877
    // This test requires spawning threads
    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    }

    <span class="tok-kw">var</span> num_runs: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> num_threads = <span class="tok-number">10</span>;

    <span class="tok-kw">while</span> (num_runs &gt; <span class="tok-number">0</span>) : (num_runs -= <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> BroadcastTest = <span class="tok-kw">struct</span> {
            mutex: <a href="std.Thread.Mutex.html">Mutex</a> = .{},
            cond: <a href="std.Thread.Condition.html">Condition</a> = .{},
            completed: <a href="std.Thread.Condition.html">Condition</a> = .{},
            count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
            thread_id_to_wake: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
            threads: [num_threads]<a href="std.html">std</a>.<a href="std.Thread.html">Thread</a> = <span class="tok-null">undefined</span>,
            wakeups: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,

            <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(self: *<span class="tok-builtin">@This</span>(), thread_id: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
                self.mutex.lock();
                <span class="tok-kw">defer</span> self.mutex.unlock();<span class="tok-comment">

                // The last broadcast thread to start tells the main test thread it's completed.
                </span>self.count += <span class="tok-number">1</span>;
                <span class="tok-kw">if</span> (self.count == num_threads) {
                    self.completed.signal();
                }

                <span class="tok-kw">while</span> (self.thread_id_to_wake != thread_id) {
                    self.cond.timedWait(&amp;self.mutex, <span class="tok-number">1</span> * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a>) <span class="tok-kw">catch</span> {};
                    self.wakeups += <span class="tok-number">1</span>;
                }
                <span class="tok-kw">if</span> (self.thread_id_to_wake &lt;= num_threads) {<span class="tok-comment">
                    // Signal next thread to wake up.
                    </span>self.thread_id_to_wake += <span class="tok-number">1</span>;
                    self.cond.broadcast();
                }
            }
        };

        <span class="tok-kw">var</span> broadcast_test = BroadcastTest{};
        <span class="tok-kw">var</span> thread_id: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
        <span class="tok-kw">for</span> (&amp;broadcast_test.threads) |*t| {
            t.* = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.html#std.Thread.spawn">spawn</a>(.{}, BroadcastTest.run, .{ &amp;broadcast_test, thread_id });
            thread_id += <span class="tok-number">1</span>;
        }

        {
            broadcast_test.mutex.lock();
            <span class="tok-kw">defer</span> broadcast_test.mutex.unlock();<span class="tok-comment">

            // Wait for all the broadcast threads to spawn.
            // timedWait() to detect any potential deadlocks.
            </span><span class="tok-kw">while</span> (broadcast_test.count != num_threads) {
                broadcast_test.completed.timedWait(
                    &amp;broadcast_test.mutex,
                    <span class="tok-number">1</span> * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a>,
                ) <span class="tok-kw">catch</span> {};
            }<span class="tok-comment">

            // Signal thread 1 to wake up
            </span>broadcast_test.thread_id_to_wake = <span class="tok-number">1</span>;
            broadcast_test.cond.broadcast();
        }

        <span class="tok-kw">for</span> (broadcast_test.threads) |t| {
            t.join();
        }
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
