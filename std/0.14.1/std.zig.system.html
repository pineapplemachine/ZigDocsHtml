<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">zig</a></li><li><a href="std.zig.system.html" class="active">system</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.zig.system" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.zig.system</span><a href="#src.zig-std.zig.system">[src]</a></h1><div class="sectNamespaces"><h2 class="sectionHeader">Namespaces</h2><ul class="listNamespaces columns"><li><a href="std.zig.system.windows.html">std.zig.system.windows</a></li><li><a href="std.zig.system.darwin.html">std.zig.system.darwin</a></li><li><a href="std.zig.system.linux.html">std.zig.system.linux</a></li></ul></div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.zig.system.NativePaths.html">std.zig.system.NativePaths</a></li><li><a href="std.zig.system.Executor.html">std.zig.system.Executor</a></li><li><a href="std.zig.system.GetExternalExecutorOptions.html">std.zig.system.GetExternalExecutorOptions</a></li></ul></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.zig.system.DetectError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">DetectError</span><a href="#src.zig-std.zig.system.DetectError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>DeviceBusy</dt></div><div><dt>FileSystem</dt></div><div><dt>OSVersionDetectionFail</dt></div><div><dt>ProcessFdQuotaExceeded</dt></div><div><dt>ProcessNotFound</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemFdQuotaExceeded</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.system.DetectError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DetectError = <span class="tok-kw">error</span>{
    FileSystem,
    SystemResources,
    SymLinkLoop,
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    DeviceBusy,
    OSVersionDetectionFail,
    Unexpected,
    ProcessNotFound,
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.system.AbiAndDynamicLinkerFromFileError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">AbiAndDynamicLinkerFromFileError</span><a href="#src.zig-std.zig.system.AbiAndDynamicLinkerFromFileError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>FileSystem</dt></div><div><dt>InvalidElfClass</dt></div><div><dt>InvalidElfEndian</dt></div><div><dt>InvalidElfFile</dt></div><div><dt>InvalidElfMagic</dt></div><div><dt>InvalidElfVersion</dt></div><div><dt>NameTooLong</dt></div><div><dt>ProcessFdQuotaExceeded</dt></div><div><dt>ProcessNotFound</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemFdQuotaExceeded</dt></div><div><dt>SystemResources</dt></div><div><dt>UnableToReadElfFile</dt></div><div><dt>Unexpected</dt></div><div><dt>UnexpectedEndOfFile</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.system.AbiAndDynamicLinkerFromFileError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AbiAndDynamicLinkerFromFileError = <span class="tok-kw">error</span>{
    FileSystem,
    SystemResources,
    SymLinkLoop,
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    UnableToReadElfFile,
    InvalidElfClass,
    InvalidElfVersion,
    InvalidElfEndian,
    InvalidElfFile,
    InvalidElfMagic,
    Unexpected,
    UnexpectedEndOfFile,
    NameTooLong,
    ProcessNotFound,
}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.zig.system.getExternalExecutor" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getExternalExecutor</span><a href="#src.zig-std.zig.system.getExternalExecutor">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getExternalExecutor</span>( host: <a href="std.html">std</a>.<a href="std.Target.html">Target</a>, candidate: *<span class="tok-kw">const</span> <a href="std.html">std</a>.<a href="std.Target.html">Target</a>, options: <a href="std.zig.system.GetExternalExecutorOptions.html">GetExternalExecutorOptions</a>, ) <a href="std.zig.system.Executor.html">Executor</a></code></pre></div><div class="tldDocs"><p>Return whether or not the given host is capable of running executables of
the other target.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>host: <a href="std.html">std</a>.<a href="std.Target.html">Target</a></code></pre></div><div><pre><code>candidate: *<span class="tok-kw">const</span> <a href="std.html">std</a>.<a href="std.Target.html">Target</a></code></pre></div><div><pre><code>options: <a href="std.zig.system.GetExternalExecutorOptions.html">GetExternalExecutorOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.system.getExternalExecutor">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getExternalExecutor</span>(
    host: <a href="std.html">std</a>.<a href="std.Target.html">Target</a>,
    candidate: *<span class="tok-kw">const</span> <a href="std.html">std</a>.<a href="std.Target.html">Target</a>,
    options: <a href="std.zig.system.GetExternalExecutorOptions.html">GetExternalExecutorOptions</a>,
) <a href="std.zig.system.Executor.html">Executor</a> {
    <span class="tok-kw">const</span> os_match = host.os.tag == candidate.os.tag;
    <span class="tok-kw">const</span> cpu_ok = cpu_ok: {
        <span class="tok-kw">if</span> (host.cpu.arch == candidate.cpu.arch)
            <span class="tok-kw">break</span> :cpu_ok <span class="tok-null">true</span>;

        <span class="tok-kw">if</span> (host.cpu.arch == .x86_64 <span class="tok-kw">and</span> candidate.cpu.arch == .x86)
            <span class="tok-kw">break</span> :cpu_ok <span class="tok-null">true</span>;

        <span class="tok-kw">if</span> (host.cpu.arch == .aarch64 <span class="tok-kw">and</span> candidate.cpu.arch == .arm)
            <span class="tok-kw">break</span> :cpu_ok <span class="tok-null">true</span>;

        <span class="tok-kw">if</span> (host.cpu.arch == .aarch64_be <span class="tok-kw">and</span> candidate.cpu.arch == .armeb)
            <span class="tok-kw">break</span> :cpu_ok <span class="tok-null">true</span>;<span class="tok-comment">

        // TODO additionally detect incompatible CPU features.
        // Note that in some cases the OS kernel will emulate missing CPU features
        // when an illegal instruction is encountered.

        </span><span class="tok-kw">break</span> :cpu_ok <span class="tok-null">false</span>;
    };

    <span class="tok-kw">var</span> bad_result: <a href="std.zig.system.Executor.html">Executor</a> = .bad_os_or_cpu;

    <span class="tok-kw">if</span> (os_match <span class="tok-kw">and</span> cpu_ok) native: {
        <span class="tok-kw">if</span> (options.link_libc) {
            <span class="tok-kw">if</span> (candidate.dynamic_linker.get()) |candidate_dl| {
                <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().access(candidate_dl, .{}) <span class="tok-kw">catch</span> {
                    bad_result = .{ .bad_dl = candidate_dl };
                    <span class="tok-kw">break</span> :native;
                };
            }
        }
        <span class="tok-kw">return</span> .native;
    }<span class="tok-comment">

    // If the OS match and OS is macOS and CPU is arm64, we can use Rosetta 2
    // to emulate the foreign architecture.
    </span><span class="tok-kw">if</span> (options.allow_rosetta <span class="tok-kw">and</span> os_match <span class="tok-kw">and</span>
        host.os.tag == .macos <span class="tok-kw">and</span> host.cpu.arch == .aarch64)
    {
        <span class="tok-kw">switch</span> (candidate.cpu.arch) {
            .x86_64 =&gt; <span class="tok-kw">return</span> .rosetta,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> bad_result,
        }
    }<span class="tok-comment">

    // If the OS matches, we can use QEMU to emulate a foreign architecture.
    </span><span class="tok-kw">if</span> (options.allow_qemu <span class="tok-kw">and</span> os_match <span class="tok-kw">and</span> (!cpu_ok <span class="tok-kw">or</span> options.qemu_fixes_dl)) {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (candidate.cpu.arch) {
            .aarch64 =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-aarch64&quot;</span> },
            .aarch64_be =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-aarch64_be&quot;</span> },
            .arm, .thumb =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-arm&quot;</span> },
            .armeb, .thumbeb =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-armeb&quot;</span> },
            .hexagon =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-hexagon&quot;</span> },
            .loongarch64 =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-loongarch64&quot;</span> },
            .m68k =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-m68k&quot;</span> },
            .mips =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-mips&quot;</span> },
            .mipsel =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-mipsel&quot;</span> },
            .mips64 =&gt; <a href="std.zig.system.Executor.html">Executor</a>{
                .qemu = <span class="tok-kw">switch</span> (candidate.abi) {
                    .gnuabin32, .muslabin32 =&gt; <span class="tok-str">&quot;qemu-mipsn32&quot;</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-str">&quot;qemu-mips64&quot;</span>,
                },
            },
            .mips64el =&gt; <a href="std.zig.system.Executor.html">Executor</a>{
                .qemu = <span class="tok-kw">switch</span> (candidate.abi) {
                    .gnuabin32, .muslabin32 =&gt; <span class="tok-str">&quot;qemu-mipsn32el&quot;</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-str">&quot;qemu-mips64el&quot;</span>,
                },
            },
            .powerpc =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-ppc&quot;</span> },
            .powerpc64 =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-ppc64&quot;</span> },
            .powerpc64le =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-ppc64le&quot;</span> },
            .riscv32 =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-riscv32&quot;</span> },
            .riscv64 =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-riscv64&quot;</span> },
            .s390x =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-s390x&quot;</span> },
            .sparc =&gt; <a href="std.zig.system.Executor.html">Executor</a>{
                .qemu = <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.sparc.html">sparc</a>.<a href="std.Target.sparc.html#std.Target.sparc.featureSetHas">featureSetHas</a>(candidate.cpu.features, .v9))
                    <span class="tok-str">&quot;qemu-sparc32plus&quot;</span>
                <span class="tok-kw">else</span>
                    <span class="tok-str">&quot;qemu-sparc&quot;</span>,
            },
            .sparc64 =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-sparc64&quot;</span> },
            .x86 =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-i386&quot;</span> },
            .x86_64 =&gt; <span class="tok-kw">switch</span> (candidate.abi) {
                .gnux32, .muslx32 =&gt; <span class="tok-kw">return</span> bad_result,
                <span class="tok-kw">else</span> =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-x86_64&quot;</span> },
            },
            .xtensa =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-xtensa&quot;</span> },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> bad_result,
        };
    }

    <span class="tok-kw">if</span> (options.allow_wasmtime <span class="tok-kw">and</span> candidate.cpu.arch.isWasm()) {
        <span class="tok-kw">return</span> <a href="std.zig.system.Executor.html">Executor</a>{ .wasmtime = <span class="tok-str">&quot;wasmtime&quot;</span> };
    }

    <span class="tok-kw">switch</span> (candidate.os.tag) {
        .windows =&gt; {
            <span class="tok-kw">if</span> (options.allow_wine) {
                <span class="tok-kw">const</span> wine_supported = <span class="tok-kw">switch</span> (candidate.cpu.arch) {
                    .thumb =&gt; <span class="tok-kw">switch</span> (host.cpu.arch) {
                        .arm, .thumb, .aarch64 =&gt; <span class="tok-null">true</span>,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
                    },
                    .aarch64 =&gt; host.cpu.arch == .aarch64,
                    .x86 =&gt; host.cpu.arch.isX86(),
                    .x86_64 =&gt; host.cpu.arch == .x86_64,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
                };
                <span class="tok-kw">return</span> <span class="tok-kw">if</span> (wine_supported) <a href="std.zig.system.Executor.html">Executor</a>{ .wine = <span class="tok-str">&quot;wine&quot;</span> } <span class="tok-kw">else</span> bad_result;
            }
            <span class="tok-kw">return</span> bad_result;
        },
        .driverkit, .macos =&gt; {
            <span class="tok-kw">if</span> (options.allow_darling) {<span class="tok-comment">
                // This check can be loosened once darling adds a QEMU-based emulation
                // layer for non-host architectures:
                // https://github.com/darlinghq/darling/issues/863
                </span><span class="tok-kw">if</span> (candidate.cpu.arch != host.cpu.arch) {
                    <span class="tok-kw">return</span> bad_result;
                }
                <span class="tok-kw">return</span> <a href="std.zig.system.Executor.html">Executor</a>{ .darling = <span class="tok-str">&quot;darling&quot;</span> };
            }
            <span class="tok-kw">return</span> bad_result;
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> bad_result,
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.system.resolveTargetQuery" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">resolveTargetQuery</span><a href="#src.zig-std.zig.system.resolveTargetQuery">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resolveTargetQuery</span>(query: <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>) <a href="std.zig.system.html#std.zig.system.DetectError">DetectError</a>!<a href="std.Target.html">Target</a></code></pre></div><div class="tldDocs"><p>Given a <code><a href="std.Target.Query.html">Target.Query</a></code>, which specifies in detail which parts of the
target should be detected natively, which should be standard or default,
and which are provided explicitly, this function resolves the native
components by detecting the native system, and then resolves
standard/default parts relative to that.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>query: <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.system.resolveTargetQuery">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resolveTargetQuery</span>(query: <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>) <a href="std.zig.system.html#std.zig.system.DetectError">DetectError</a>!<a href="std.Target.html">Target</a> {<span class="tok-comment">
    // Until https://github.com/ziglang/zig/issues/4592 is implemented (support detecting the
    // native CPU architecture as being different than the current target), we use this:
    </span><span class="tok-kw">const</span> query_cpu_arch = query.cpu_arch <span class="tok-kw">orelse</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>;
    <span class="tok-kw">const</span> query_os_tag = query.os_tag <span class="tok-kw">orelse</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>;
    <span class="tok-kw">const</span> query_abi = query.abi <span class="tok-kw">orelse</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.abi">abi</a>;
    <span class="tok-kw">var</span> os = query_os_tag.defaultVersionRange(query_cpu_arch, query_abi);
    <span class="tok-kw">if</span> (query.os_tag == <span class="tok-null">null</span>) {
        <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a>) {
            .linux =&gt; {
                <span class="tok-kw">const</span> uts = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.uname">uname</a>();
                <span class="tok-kw">const</span> release = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;uts.release, <span class="tok-number">0</span>);<span class="tok-comment">
                // The release field sometimes has a weird format,
                // `Version.parse` will attempt to find some meaningful interpretation.
                </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a>.<a href="std.SemanticVersion.html#std.SemanticVersion.parse">parse</a>(release)) |ver| {
                    os.version_range.linux.range.min = ver;
                    os.version_range.linux.range.max = ver;
                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.Overflow =&gt; {},
                    <span class="tok-kw">error</span>.InvalidVersion =&gt; {},
                }
            },
            .solaris, .illumos =&gt; {
                <span class="tok-kw">const</span> uts = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.uname">uname</a>();
                <span class="tok-kw">const</span> release = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;uts.release, <span class="tok-number">0</span>);
                <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a>.<a href="std.SemanticVersion.html#std.SemanticVersion.parse">parse</a>(release)) |ver| {
                    os.version_range.semver.min = ver;
                    os.version_range.semver.max = ver;
                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.Overflow =&gt; {},
                    <span class="tok-kw">error</span>.InvalidVersion =&gt; {},
                }
            },
            .windows =&gt; {
                <span class="tok-kw">const</span> detected_version = <a href="std.zig.system.windows.html">windows</a>.<a href="std.zig.system.windows.html#std.zig.system.windows.detectRuntimeVersion">detectRuntimeVersion</a>();
                os.version_range.windows.min = detected_version;
                os.version_range.windows.max = detected_version;
            },
            .macos =&gt; <span class="tok-kw">try</span> <a href="std.zig.system.darwin.html">darwin</a>.<a href="std.zig.system.darwin.macos.html">macos</a>.<a href="std.zig.system.darwin.macos.html#std.zig.system.darwin.macos.detect">detect</a>(&amp;os),
            .freebsd, .netbsd, .dragonfly =&gt; {
                <span class="tok-kw">const</span> key = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a>) {
                    .freebsd =&gt; <span class="tok-str">&quot;kern.osreldate&quot;</span>,
                    .netbsd, .dragonfly =&gt; <span class="tok-str">&quot;kern.osrevision&quot;</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                };
                <span class="tok-kw">var</span> value: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(value));

                <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sysctlbynameZ">sysctlbynameZ</a>(key, &amp;value, &amp;len, <span class="tok-null">null</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // constant, known good value
                    </span><span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // only when setting values,
                    </span><span class="tok-kw">error</span>.SystemResources =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // memory already on the stack
                    </span><span class="tok-kw">error</span>.UnknownName =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // constant, known good value
                    </span><span class="tok-kw">error</span>.Unexpected =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OSVersionDetectionFail,
                };

                <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a>) {
                    .freebsd =&gt; {<span class="tok-comment">
                        // https://www.freebsd.org/doc/en_US.ISO8859-1/books/porters-handbook/versions.html
                        // Major * 100,000 has been convention since FreeBSD 2.2 (1997)
                        // Minor * 1(0),000 summed has been convention since FreeBSD 2.2 (1997)
                        // e.g. 492101 = 4.11-STABLE = 4.(9+2)
                        </span><span class="tok-kw">const</span> major = value / <span class="tok-number">100_000</span>;
                        <span class="tok-kw">const</span> minor1 = value % <span class="tok-number">100_000</span> / <span class="tok-number">10_000</span>;<span class="tok-comment"> // usually 0 since 5.1
                        </span><span class="tok-kw">const</span> minor2 = value % <span class="tok-number">10_000</span> / <span class="tok-number">1_000</span>;<span class="tok-comment"> // 0 before 5.1, minor version since
                        </span><span class="tok-kw">const</span> patch = value % <span class="tok-number">1_000</span>;
                        os.version_range.semver.min = .{ .major = major, .minor = minor1 + minor2, .patch = patch };
                        os.version_range.semver.max = os.version_range.semver.min;
                    },
                    .netbsd =&gt; {<span class="tok-comment">
                        // #define __NetBSD_Version__ MMmmrrpp00
                        //
                        // M = major version
                        // m = minor version; a minor number of 99 indicates current.
                        // r = 0 (*)
                        // p = patchlevel
                        </span><span class="tok-kw">const</span> major = value / <span class="tok-number">100_000_000</span>;
                        <span class="tok-kw">const</span> minor = value % <span class="tok-number">100_000_000</span> / <span class="tok-number">1_000_000</span>;
                        <span class="tok-kw">const</span> patch = value % <span class="tok-number">10_000</span> / <span class="tok-number">100</span>;
                        os.version_range.semver.min = .{ .major = major, .minor = minor, .patch = patch };
                        os.version_range.semver.max = os.version_range.semver.min;
                    },
                    .dragonfly =&gt; {<span class="tok-comment">
                        // https://github.com/DragonFlyBSD/DragonFlyBSD/blob/cb2cde83771754aeef9bb3251ee48959138dec87/Makefile.inc1#L15-L17
                        // flat base10 format: Mmmmpp
                        //   M = major
                        //   m = minor; odd-numbers indicate current dev branch
                        //   p = patch
                        </span><span class="tok-kw">const</span> major = value / <span class="tok-number">100_000</span>;
                        <span class="tok-kw">const</span> minor = value % <span class="tok-number">100_000</span> / <span class="tok-number">100</span>;
                        <span class="tok-kw">const</span> patch = value % <span class="tok-number">100</span>;
                        os.version_range.semver.min = .{ .major = major, .minor = minor, .patch = patch };
                        os.version_range.semver.max = os.version_range.semver.min;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                }
            },
            .openbsd =&gt; {
                <span class="tok-kw">const</span> mib: [<span class="tok-number">2</span>]<span class="tok-type">c_int</span> = [_]<span class="tok-type">c_int</span>{
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.CTL">CTL</a>.<a href="#">KERN</a>,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.KERN">KERN</a>.<a href="#">OSRELEASE</a>,
                };
                <span class="tok-kw">var</span> buf: [<span class="tok-number">64</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">
                // consider that sysctl result includes null-termination
                // reserve 1 byte to ensure we never overflow when appending &quot;.0&quot;
                </span><span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = buf.len - <span class="tok-number">1</span>;

                <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sysctl">sysctl</a>(&amp;mib, &amp;buf, &amp;len, <span class="tok-null">null</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // constant, known good value
                    </span><span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // only when setting values,
                    </span><span class="tok-kw">error</span>.SystemResources =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // memory already on the stack
                    </span><span class="tok-kw">error</span>.UnknownName =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // constant, known good value
                    </span><span class="tok-kw">error</span>.Unexpected =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OSVersionDetectionFail,
                };<span class="tok-comment">

                // append &quot;.0&quot; to satisfy semver
                </span>buf[len - <span class="tok-number">1</span>] = <span class="tok-str">'.'</span>;
                buf[len] = <span class="tok-str">'0'</span>;
                len += <span class="tok-number">1</span>;

                <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a>.<a href="std.SemanticVersion.html#std.SemanticVersion.parse">parse</a>(buf[<span class="tok-number">0</span>..len])) |ver| {
                    os.version_range.semver.min = ver;
                    os.version_range.semver.max = ver;
                } <span class="tok-kw">else</span> |_| {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OSVersionDetectionFail;
                }
            },
            <span class="tok-kw">else</span> =&gt; {<span class="tok-comment">
                // Unimplemented, fall back to default version range.
            </span>},
        }
    }

    <span class="tok-kw">if</span> (query.os_version_min) |min| <span class="tok-kw">switch</span> (min) {
        .none =&gt; {},
        .semver =&gt; |semver| <span class="tok-kw">switch</span> (os.tag.versionRangeTag()) {
            <span class="tok-kw">inline</span> .hurd, .linux =&gt; |t| <span class="tok-builtin">@field</span>(os.version_range, <span class="tok-builtin">@tagName</span>(t)).range.min = semver,
            <span class="tok-kw">else</span> =&gt; os.version_range.semver.min = semver,
        },
        .windows =&gt; |win_ver| os.version_range.windows.min = win_ver,
    };

    <span class="tok-kw">if</span> (query.os_version_max) |max| <span class="tok-kw">switch</span> (max) {
        .none =&gt; {},
        .semver =&gt; |semver| <span class="tok-kw">switch</span> (os.tag.versionRangeTag()) {
            <span class="tok-kw">inline</span> .hurd, .linux =&gt; |t| <span class="tok-builtin">@field</span>(os.version_range, <span class="tok-builtin">@tagName</span>(t)).range.max = semver,
            <span class="tok-kw">else</span> =&gt; os.version_range.semver.max = semver,
        },
        .windows =&gt; |win_ver| os.version_range.windows.max = win_ver,
    };

    <span class="tok-kw">if</span> (query.glibc_version) |glibc| {
        <span class="tok-kw">switch</span> (os.tag.versionRangeTag()) {
            <span class="tok-kw">inline</span> .hurd, .linux =&gt; |t| <span class="tok-builtin">@field</span>(os.version_range, <span class="tok-builtin">@tagName</span>(t)).glibc = glibc,
            <span class="tok-kw">else</span> =&gt; {},
        }
    }

    <span class="tok-kw">if</span> (query.android_api_level) |android| {
        os.version_range.linux.android = android;
    }

    <span class="tok-kw">var</span> cpu = <span class="tok-kw">switch</span> (query.cpu_model) {
        .native =&gt; <a href="std.zig.system.html#std.zig.system.detectNativeCpuAndFeatures">detectNativeCpuAndFeatures</a>(query_cpu_arch, os, query),
        .baseline =&gt; <a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>.<a href="std.Target.Cpu.html#std.Target.Cpu.baseline">baseline</a>(query_cpu_arch, os),
        .determined_by_arch_os =&gt; <span class="tok-kw">if</span> (query.cpu_arch == <span class="tok-null">null</span>)
            <a href="std.zig.system.html#std.zig.system.detectNativeCpuAndFeatures">detectNativeCpuAndFeatures</a>(query_cpu_arch, os, query)
        <span class="tok-kw">else</span>
            <a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>.<a href="std.Target.Cpu.html#std.Target.Cpu.baseline">baseline</a>(query_cpu_arch, os),
        .explicit =&gt; |model| model.toCpu(query_cpu_arch),
    } <span class="tok-kw">orelse</span> backup_cpu_detection: {
        <span class="tok-kw">break</span> :backup_cpu_detection <a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>.<a href="std.Target.Cpu.html#std.Target.Cpu.baseline">baseline</a>(query_cpu_arch, os);
    };<span class="tok-comment">

    // For x86, we need to populate some CPU feature flags depending on architecture
    // and mode:
    //  * 16bit_mode =&gt; if the abi is code16
    //  * 32bit_mode =&gt; if the arch is x86
    // However, the &quot;mode&quot; flags can be used as overrides, so if the user explicitly
    // sets one of them, that takes precedence.
    </span><span class="tok-kw">switch</span> (query_cpu_arch) {
        .x86 =&gt; {
            <span class="tok-kw">if</span> (!<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.html#std.Target.x86.featureSetHasAny">featureSetHasAny</a>(query.cpu_features_add, .{
                .@&quot;16bit_mode&quot;, .@&quot;32bit_mode&quot;,
            })) {
                <span class="tok-kw">switch</span> (query_abi) {
                    .code16 =&gt; cpu.features.addFeature(
                        <span class="tok-builtin">@intFromEnum</span>(<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.Feature.html">Feature</a>.<a href="#"16bit_mode"">@&quot;16bit_mode&quot;</a>),
                    ),
                    <span class="tok-kw">else</span> =&gt; cpu.features.addFeature(
                        <span class="tok-builtin">@intFromEnum</span>(<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.Feature.html">Feature</a>.<a href="#"32bit_mode"">@&quot;32bit_mode&quot;</a>),
                    ),
                }
            }
        },
        .arm, .armeb =&gt; {<span class="tok-comment">
            // XXX What do we do if the target has the noarm feature?
            //     What do we do if the user specifies +thumb_mode?
        </span>},
        .thumb, .thumbeb =&gt; {
            cpu.features.addFeature(
                <span class="tok-builtin">@intFromEnum</span>(<a href="std.Target.html">Target</a>.<a href="std.Target.arm.html">arm</a>.<a href="std.Target.arm.Feature.html">Feature</a>.<a href="#">thumb_mode</a>),
            );
        },
        <span class="tok-kw">else</span> =&gt; {},
    }
    <a href="std.zig.system.html#std.zig.system.updateCpuFeatures">updateCpuFeatures</a>(
        &amp;cpu.features,
        cpu.arch.allFeaturesList(),
        query.cpu_features_add,
        query.cpu_features_sub,
    );

    <span class="tok-kw">var</span> result = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.detectAbiAndDynamicLinker">detectAbiAndDynamicLinker</a>(cpu, os, query);<span class="tok-comment">

    // These CPU feature hacks have to come after ABI detection.
    </span>{
        <span class="tok-kw">if</span> (result.cpu.arch == .hexagon) {<span class="tok-comment">
            // Both LLVM and LLD have broken support for the small data area. Yet LLVM has the
            // feature on by default for all Hexagon CPUs. Clang sort of solves this by defaulting
            // the `-gpsize` command line parameter for the Hexagon backend to 0, so that no
            // constants get placed in the SDA. (This of course breaks down if the user passes
            // `-G &lt;n&gt;` to Clang...) We can't do the `-gpsize` hack because we can have multiple
            // concurrent LLVM emit jobs, and command line options in LLVM are shared globally. So
            // just force this feature off. Lovely stuff.
            </span>result.cpu.features.removeFeature(<span class="tok-builtin">@intFromEnum</span>(<a href="std.Target.html">Target</a>.<a href="std.Target.hexagon.html">hexagon</a>.<a href="std.Target.hexagon.Feature.html">Feature</a>.<a href="#">small_data</a>));
        }<span class="tok-comment">

        // https://github.com/llvm/llvm-project/issues/105978
        </span><span class="tok-kw">if</span> (result.cpu.arch.isArm() <span class="tok-kw">and</span> result.abi.float() == .soft) {
            result.cpu.features.removeFeature(<span class="tok-builtin">@intFromEnum</span>(<a href="std.Target.html">Target</a>.<a href="std.Target.arm.html">arm</a>.<a href="std.Target.arm.Feature.html">Feature</a>.<a href="#">vfp2</a>));
        }
    }<span class="tok-comment">

    // It's possible that we detect the native ABI, but fail to detect the OS version or were told
    // to use the default OS version range. In that case, while we can't determine the exact native
    // OS version, we do at least know that some ABIs require a particular OS version (by way of
    // `std.zig.target.available_libcs`). So in this case, adjust the OS version to the minimum that
    // we know is required.
    </span><span class="tok-kw">if</span> (result.abi != query_abi <span class="tok-kw">and</span> query.os_version_min == <span class="tok-null">null</span>) {
        <span class="tok-kw">const</span> result_ver_range = &amp;result.os.version_range;
        <span class="tok-kw">const</span> abi_ver_range = result.os.tag.defaultVersionRange(result.cpu.arch, result.abi).version_range;

        <span class="tok-kw">switch</span> (result.os.tag.versionRangeTag()) {
            .none =&gt; {},
            .semver =&gt; <span class="tok-kw">if</span> (result_ver_range.semver.min.order(abi_ver_range.semver.min) == .lt) {
                result_ver_range.semver.min = abi_ver_range.semver.min;
            },
            <span class="tok-kw">inline</span> .hurd, .linux =&gt; |t| {
                <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(result_ver_range, <span class="tok-builtin">@tagName</span>(t)).range.min.order(<span class="tok-builtin">@field</span>(abi_ver_range, <span class="tok-builtin">@tagName</span>(t)).range.min) == .lt) {
                    <span class="tok-builtin">@field</span>(result_ver_range, <span class="tok-builtin">@tagName</span>(t)).range.min = <span class="tok-builtin">@field</span>(abi_ver_range, <span class="tok-builtin">@tagName</span>(t)).range.min;
                }

                <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(result_ver_range, <span class="tok-builtin">@tagName</span>(t)).glibc.order(<span class="tok-builtin">@field</span>(abi_ver_range, <span class="tok-builtin">@tagName</span>(t)).glibc) == .lt <span class="tok-kw">and</span>
                    query.glibc_version == <span class="tok-null">null</span>)
                {
                    <span class="tok-builtin">@field</span>(result_ver_range, <span class="tok-builtin">@tagName</span>(t)).glibc = <span class="tok-builtin">@field</span>(abi_ver_range, <span class="tok-builtin">@tagName</span>(t)).glibc;
                }
            },
            .windows =&gt; <span class="tok-kw">if</span> (!result_ver_range.windows.min.isAtLeast(abi_ver_range.windows.min)) {
                result_ver_range.windows.min = abi_ver_range.windows.min;
            },
        }
    }

    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.system.abiAndDynamicLinkerFromFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">abiAndDynamicLinkerFromFile</span><a href="#src.zig-std.zig.system.abiAndDynamicLinkerFromFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">abiAndDynamicLinkerFromFile</span>( file: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>, cpu: <a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>, os: <a href="std.Target.html">Target</a>.<a href="std.Target.Os.html">Os</a>, ld_info_list: []<span class="tok-kw">const</span> <a href="std.zig.system.LdInfo.html">LdInfo</a>, query: <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>, ) <a href="std.zig.system.html#std.zig.system.AbiAndDynamicLinkerFromFileError">AbiAndDynamicLinkerFromFileError</a>!<a href="std.Target.html">Target</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>file: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>cpu: <a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a></code></pre></div><div><pre><code>os: <a href="std.Target.html">Target</a>.<a href="std.Target.Os.html">Os</a></code></pre></div><div><pre><code>ld_info_list: []<span class="tok-kw">const</span> <a href="std.zig.system.LdInfo.html">LdInfo</a></code></pre></div><div><pre><code>query: <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.system.abiAndDynamicLinkerFromFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">abiAndDynamicLinkerFromFile</span>(
    file: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>,
    cpu: <a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>,
    os: <a href="std.Target.html">Target</a>.<a href="std.Target.Os.html">Os</a>,
    ld_info_list: []<span class="tok-kw">const</span> <a href="std.zig.system.LdInfo.html">LdInfo</a>,
    query: <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>,
) <a href="std.zig.system.html#std.zig.system.AbiAndDynamicLinkerFromFileError">AbiAndDynamicLinkerFromFileError</a>!<a href="std.Target.html">Target</a> {
    <span class="tok-kw">var</span> hdr_buf: [<span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Ehdr.html">Elf64_Ehdr</a>)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Ehdr.html">Elf64_Ehdr</a>)) = <span class="tok-null">undefined</span>;
    _ = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(file, &amp;hdr_buf, <span class="tok-number">0</span>, hdr_buf.len);
    <span class="tok-kw">const</span> hdr32: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Ehdr.html">Elf32_Ehdr</a> = <span class="tok-builtin">@ptrCast</span>(&amp;hdr_buf);
    <span class="tok-kw">const</span> hdr64: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Ehdr.html">Elf64_Ehdr</a> = <span class="tok-builtin">@ptrCast</span>(&amp;hdr_buf);
    <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, hdr32.e_ident[<span class="tok-number">0</span>..<span class="tok-number">4</span>], <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.MAGIC">MAGIC</a>)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfMagic;
    <span class="tok-kw">const</span> elf_endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a> = <span class="tok-kw">switch</span> (hdr32.e_ident[<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.EI_DATA">EI_DATA</a>]) {
        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.ELFDATA2LSB">ELFDATA2LSB</a> =&gt; .little,
        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.ELFDATA2MSB">ELFDATA2MSB</a> =&gt; .big,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfEndian,
    };
    <span class="tok-kw">const</span> need_bswap = elf_endian != <a href="std.zig.system.html#std.zig.system.native_endian">native_endian</a>;
    <span class="tok-kw">if</span> (hdr32.e_ident[<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.EI_VERSION">EI_VERSION</a>] != <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfVersion;

    <span class="tok-kw">const</span> is_64 = <span class="tok-kw">switch</span> (hdr32.e_ident[<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.EI_CLASS">EI_CLASS</a>]) {
        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.ELFCLASS32">ELFCLASS32</a> =&gt; <span class="tok-null">false</span>,
        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.ELFCLASS64">ELFCLASS64</a> =&gt; <span class="tok-null">true</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfClass,
    };
    <span class="tok-kw">var</span> phoff = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, hdr32.e_phoff, hdr64.e_phoff);
    <span class="tok-kw">const</span> phentsize = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, hdr32.e_phentsize, hdr64.e_phentsize);
    <span class="tok-kw">const</span> phnum = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, hdr32.e_phnum, hdr64.e_phnum);

    <span class="tok-kw">var</span> result: <a href="std.Target.html">Target</a> = .{
        .cpu = cpu,
        .os = os,
        .abi = query.abi <span class="tok-kw">orelse</span> <a href="std.Target.html">Target</a>.<a href="std.Target.Abi.html">Abi</a>.<a href="std.Target.Abi.html#std.Target.Abi.default">default</a>(cpu.arch, os),
        .ofmt = query.ofmt <span class="tok-kw">orelse</span> <a href="std.Target.html">Target</a>.<a href="std.Target.ObjectFormat.html">ObjectFormat</a>.<a href="std.Target.ObjectFormat.html#std.Target.ObjectFormat.default">default</a>(os.tag, cpu.arch),
        .dynamic_linker = query.dynamic_linker,
    };
    <span class="tok-kw">var</span> rpath_offset: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>;<span class="tok-comment"> // Found inside PT_DYNAMIC
    </span><span class="tok-kw">const</span> look_for_ld = query.dynamic_linker.get() == <span class="tok-null">null</span>;

    <span class="tok-kw">var</span> ph_buf: [<span class="tok-number">16</span> * <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Phdr.html">Elf64_Phdr</a>)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Phdr.html">Elf64_Phdr</a>)) = <span class="tok-null">undefined</span>;
    <span class="tok-kw">if</span> (phentsize &gt; <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Phdr.html">Elf64_Phdr</a>)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfFile;

    <span class="tok-kw">var</span> ph_i: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (ph_i &lt; phnum) {<span class="tok-comment">
        // Reserve some bytes so that we can deref the 64-bit struct fields
        // even when the ELF file is 32-bits.
        </span><span class="tok-kw">const</span> ph_reserve: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Phdr.html">Elf64_Phdr</a>) - <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Phdr.html">Elf32_Phdr</a>);
        <span class="tok-kw">const</span> ph_read_byte_len = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(file, ph_buf[<span class="tok-number">0</span> .. ph_buf.len - ph_reserve], phoff, phentsize);
        <span class="tok-kw">var</span> ph_buf_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (ph_buf_i &lt; ph_read_byte_len <span class="tok-kw">and</span> ph_i &lt; phnum) : ({
            ph_i += <span class="tok-number">1</span>;
            phoff += phentsize;
            ph_buf_i += phentsize;
        }) {
            <span class="tok-kw">const</span> ph32: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Phdr.html">Elf32_Phdr</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;ph_buf[ph_buf_i]));
            <span class="tok-kw">const</span> ph64: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Phdr.html">Elf64_Phdr</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;ph_buf[ph_buf_i]));
            <span class="tok-kw">const</span> p_type = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, ph32.p_type, ph64.p_type);
            <span class="tok-kw">switch</span> (p_type) {
                <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_INTERP">PT_INTERP</a> =&gt; <span class="tok-kw">if</span> (look_for_ld) {
                    <span class="tok-kw">const</span> p_offset = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, ph32.p_offset, ph64.p_offset);
                    <span class="tok-kw">const</span> p_filesz = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, ph32.p_filesz, ph64.p_filesz);
                    <span class="tok-kw">if</span> (p_filesz &gt; result.dynamic_linker.buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
                    <span class="tok-kw">const</span> filesz: <span class="tok-type">usize</span> = <span class="tok-builtin">@intCast</span>(p_filesz);
                    _ = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(file, result.dynamic_linker.buffer[<span class="tok-number">0</span>..filesz], p_offset, filesz);<span class="tok-comment">
                    // PT_INTERP includes a null byte in filesz.
                    </span><span class="tok-kw">const</span> len = filesz - <span class="tok-number">1</span>;<span class="tok-comment">
                    // dynamic_linker.max_byte is &quot;max&quot;, not &quot;len&quot;.
                    // We know it will fit in u8 because we check against dynamic_linker.buffer.len above.
                    </span>result.dynamic_linker.len = <span class="tok-builtin">@intCast</span>(len);<span class="tok-comment">

                    // Use it to determine ABI.
                    </span><span class="tok-kw">const</span> full_ld_path = result.dynamic_linker.buffer[<span class="tok-number">0</span>..len];
                    <span class="tok-kw">for</span> (ld_info_list) |ld_info| {
                        <span class="tok-kw">const</span> standard_ld_basename = <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.basename">basename</a>(ld_info.ld.get().?);
                        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.endsWith">endsWith</a>(<span class="tok-type">u8</span>, full_ld_path, standard_ld_basename)) {
                            result.abi = ld_info.abi;
                            <span class="tok-kw">break</span>;
                        }
                    }
                },<span class="tok-comment">
                // We only need this for detecting glibc version.
                </span><a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_DYNAMIC">PT_DYNAMIC</a> =&gt; <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a> == .linux <span class="tok-kw">and</span> result.isGnuLibC() <span class="tok-kw">and</span>
                    query.glibc_version == <span class="tok-null">null</span>)
                {
                    <span class="tok-kw">var</span> dyn_off = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, ph32.p_offset, ph64.p_offset);
                    <span class="tok-kw">const</span> p_filesz = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, ph32.p_filesz, ph64.p_filesz);
                    <span class="tok-kw">const</span> dyn_size: <span class="tok-type">usize</span> = <span class="tok-kw">if</span> (is_64) <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Dyn.html">Elf64_Dyn</a>) <span class="tok-kw">else</span> <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Dyn.html">Elf32_Dyn</a>);
                    <span class="tok-kw">const</span> dyn_num = p_filesz / dyn_size;
                    <span class="tok-kw">var</span> dyn_buf: [<span class="tok-number">16</span> * <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Dyn.html">Elf64_Dyn</a>)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Dyn.html">Elf64_Dyn</a>)) = <span class="tok-null">undefined</span>;
                    <span class="tok-kw">var</span> dyn_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                    dyn: <span class="tok-kw">while</span> (dyn_i &lt; dyn_num) {<span class="tok-comment">
                        // Reserve some bytes so that we can deref the 64-bit struct fields
                        // even when the ELF file is 32-bits.
                        </span><span class="tok-kw">const</span> dyn_reserve: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Dyn.html">Elf64_Dyn</a>) - <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Dyn.html">Elf32_Dyn</a>);
                        <span class="tok-kw">const</span> dyn_read_byte_len = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(
                            file,
                            dyn_buf[<span class="tok-number">0</span> .. dyn_buf.len - dyn_reserve],
                            dyn_off,
                            dyn_size,
                        );
                        <span class="tok-kw">var</span> dyn_buf_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                        <span class="tok-kw">while</span> (dyn_buf_i &lt; dyn_read_byte_len <span class="tok-kw">and</span> dyn_i &lt; dyn_num) : ({
                            dyn_i += <span class="tok-number">1</span>;
                            dyn_off += dyn_size;
                            dyn_buf_i += dyn_size;
                        }) {
                            <span class="tok-kw">const</span> dyn32: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Dyn.html">Elf32_Dyn</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;dyn_buf[dyn_buf_i]));
                            <span class="tok-kw">const</span> dyn64: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Dyn.html">Elf64_Dyn</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;dyn_buf[dyn_buf_i]));
                            <span class="tok-kw">const</span> tag = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, dyn32.d_tag, dyn64.d_tag);
                            <span class="tok-kw">const</span> val = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, dyn32.d_val, dyn64.d_val);
                            <span class="tok-kw">if</span> (tag == <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_RUNPATH">DT_RUNPATH</a>) {
                                rpath_offset = val;
                                <span class="tok-kw">break</span> :dyn;
                            }
                        }
                    }
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,
            }
        }
    }

    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a> == .linux <span class="tok-kw">and</span> result.isGnuLibC() <span class="tok-kw">and</span>
        query.glibc_version == <span class="tok-null">null</span>)
    {
        <span class="tok-kw">const</span> shstrndx = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, hdr32.e_shstrndx, hdr64.e_shstrndx);

        <span class="tok-kw">var</span> shoff = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, hdr32.e_shoff, hdr64.e_shoff);
        <span class="tok-kw">const</span> shentsize = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, hdr32.e_shentsize, hdr64.e_shentsize);
        <span class="tok-kw">const</span> str_section_off = shoff + <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, shentsize) * <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, shstrndx);

        <span class="tok-kw">var</span> sh_buf: [<span class="tok-number">16</span> * <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Shdr.html">Elf64_Shdr</a>)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Shdr.html">Elf64_Shdr</a>)) = <span class="tok-null">undefined</span>;
        <span class="tok-kw">if</span> (sh_buf.len &lt; shentsize) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfFile;

        _ = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(file, &amp;sh_buf, str_section_off, shentsize);
        <span class="tok-kw">const</span> shstr32: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Shdr.html">Elf32_Shdr</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;sh_buf));
        <span class="tok-kw">const</span> shstr64: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Shdr.html">Elf64_Shdr</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;sh_buf));
        <span class="tok-kw">const</span> shstrtab_off = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, shstr32.sh_offset, shstr64.sh_offset);
        <span class="tok-kw">const</span> shstrtab_size = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, shstr32.sh_size, shstr64.sh_size);
        <span class="tok-kw">var</span> strtab_buf: [<span class="tok-number">4096</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> shstrtab_len = <span class="tok-builtin">@min</span>(shstrtab_size, strtab_buf.len);
        <span class="tok-kw">const</span> shstrtab_read_len = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(file, &amp;strtab_buf, shstrtab_off, shstrtab_len);
        <span class="tok-kw">const</span> shstrtab = strtab_buf[<span class="tok-number">0</span>..shstrtab_read_len];

        <span class="tok-kw">const</span> shnum = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, hdr32.e_shnum, hdr64.e_shnum);
        <span class="tok-kw">var</span> sh_i: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> dynstr: ?<span class="tok-kw">struct</span> { offset: <span class="tok-type">u64</span>, size: <span class="tok-type">u64</span> } = find_dyn_str: <span class="tok-kw">while</span> (sh_i &lt; shnum) {<span class="tok-comment">
            // Reserve some bytes so that we can deref the 64-bit struct fields
            // even when the ELF file is 32-bits.
            </span><span class="tok-kw">const</span> sh_reserve: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Shdr.html">Elf64_Shdr</a>) - <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Shdr.html">Elf32_Shdr</a>);
            <span class="tok-kw">const</span> sh_read_byte_len = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(
                file,
                sh_buf[<span class="tok-number">0</span> .. sh_buf.len - sh_reserve],
                shoff,
                shentsize,
            );
            <span class="tok-kw">var</span> sh_buf_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (sh_buf_i &lt; sh_read_byte_len <span class="tok-kw">and</span> sh_i &lt; shnum) : ({
                sh_i += <span class="tok-number">1</span>;
                shoff += shentsize;
                sh_buf_i += shentsize;
            }) {
                <span class="tok-kw">const</span> sh32: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Shdr.html">Elf32_Shdr</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;sh_buf[sh_buf_i]));
                <span class="tok-kw">const</span> sh64: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Shdr.html">Elf64_Shdr</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;sh_buf[sh_buf_i]));
                <span class="tok-kw">const</span> sh_name_off = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, sh32.sh_name, sh64.sh_name);
                <span class="tok-kw">const</span> sh_name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(shstrtab[sh_name_off..], <span class="tok-number">0</span>);
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, sh_name, <span class="tok-str">&quot;.dynstr&quot;</span>)) {
                    <span class="tok-kw">break</span> :find_dyn_str .{
                        .offset = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, sh32.sh_offset, sh64.sh_offset),
                        .size = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, sh32.sh_size, sh64.sh_size),
                    };
                }
            }
        } <span class="tok-kw">else</span> <span class="tok-null">null</span>;

        <span class="tok-kw">if</span> (dynstr) |ds| {
            <span class="tok-kw">if</span> (rpath_offset) |rpoff| {
                <span class="tok-kw">if</span> (rpoff &gt; ds.size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfFile;
                <span class="tok-kw">const</span> rpoff_file = ds.offset + rpoff;
                <span class="tok-kw">const</span> rp_max_size = ds.size - rpoff;

                <span class="tok-kw">const</span> strtab_len = <span class="tok-builtin">@min</span>(rp_max_size, strtab_buf.len);
                <span class="tok-kw">const</span> strtab_read_len = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(file, &amp;strtab_buf, rpoff_file, strtab_len);
                <span class="tok-kw">const</span> strtab = strtab_buf[<span class="tok-number">0</span>..strtab_read_len];

                <span class="tok-kw">const</span> rpath_list = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(strtab, <span class="tok-number">0</span>);
                <span class="tok-kw">var</span> it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, rpath_list, <span class="tok-str">':'</span>);
                <span class="tok-kw">while</span> (it.next()) |rpath| {
                    <span class="tok-kw">if</span> (<a href="std.zig.system.html#std.zig.system.glibcVerFromRPath">glibcVerFromRPath</a>(rpath)) |ver| {
                        result.os.version_range.linux.glibc = ver;
                        <span class="tok-kw">return</span> result;
                    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                        <span class="tok-kw">error</span>.GLibCNotFound =&gt; <span class="tok-kw">continue</span>,
                        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
                    }
                }
            }
        }

        <span class="tok-kw">if</span> (result.dynamic_linker.get()) |dl_path| glibc_ver: {<span class="tok-comment">
            // There is no DT_RUNPATH so we try to find libc.so.6 inside the same
            // directory as the dynamic linker.
            </span><span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(dl_path)) |rpath| {
                <span class="tok-kw">if</span> (<a href="std.zig.system.html#std.zig.system.glibcVerFromRPath">glibcVerFromRPath</a>(rpath)) |ver| {
                    result.os.version_range.linux.glibc = ver;
                    <span class="tok-kw">return</span> result;
                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.GLibCNotFound =&gt; {},
                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
                }
            }<span class="tok-comment">

            // So far, no luck. Next we try to see if the information is
            // present in the symlink data for the dynamic linker path.
            </span><span class="tok-kw">var</span> link_buf: [<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PATH_MAX">PATH_MAX</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> link_name = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.readlink">readlink</a>(dl_path, &amp;link_buf) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // WASI only
                </span><span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows only
                </span><span class="tok-kw">error</span>.BadPathName =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows only
                </span><span class="tok-kw">error</span>.UnsupportedReparsePointType =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows only
                </span><span class="tok-kw">error</span>.NetworkNotFound =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows only

                </span><span class="tok-kw">error</span>.AccessDenied,
                <span class="tok-kw">error</span>.FileNotFound,
                <span class="tok-kw">error</span>.NotLink,
                <span class="tok-kw">error</span>.NotDir,
                =&gt; <span class="tok-kw">break</span> :glibc_ver,

                <span class="tok-kw">error</span>.SystemResources,
                <span class="tok-kw">error</span>.FileSystem,
                <span class="tok-kw">error</span>.SymLinkLoop,
                <span class="tok-kw">error</span>.Unexpected,
                =&gt; |e| <span class="tok-kw">return</span> e,
            };
            result.os.version_range.linux.glibc = <a href="std.zig.system.html#std.zig.system.glibcVerFromLinkName">glibcVerFromLinkName</a>(
                <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.basename">basename</a>(link_name),
                <span class="tok-str">&quot;ld-&quot;</span>,
            ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.UnrecognizedGnuLibCFileName,
                <span class="tok-kw">error</span>.InvalidGnuLibCVersion,
                =&gt; <span class="tok-kw">break</span> :glibc_ver,
            };
            <span class="tok-kw">return</span> result;
        }<span class="tok-comment">

        // Nothing worked so far. Finally we fall back to hard-coded search paths.
        // Some distros such as Debian keep their libc.so.6 in `/lib/$triple/`.
        </span><span class="tok-kw">var</span> path_buf: [<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PATH_MAX">PATH_MAX</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> prefix = <span class="tok-str">&quot;/lib/&quot;</span>;
        <span class="tok-kw">const</span> cpu_arch = <span class="tok-builtin">@tagName</span>(result.cpu.arch);
        <span class="tok-kw">const</span> os_tag = <span class="tok-builtin">@tagName</span>(result.os.tag);
        <span class="tok-kw">const</span> abi = <span class="tok-builtin">@tagName</span>(result.abi);
        <span class="tok-builtin">@memcpy</span>(path_buf[index..][<span class="tok-number">0</span>..prefix.len], prefix);
        index += prefix.len;
        <span class="tok-builtin">@memcpy</span>(path_buf[index..][<span class="tok-number">0</span>..cpu_arch.len], cpu_arch);
        index += cpu_arch.len;
        path_buf[index] = <span class="tok-str">'-'</span>;
        index += <span class="tok-number">1</span>;
        <span class="tok-builtin">@memcpy</span>(path_buf[index..][<span class="tok-number">0</span>..os_tag.len], os_tag);
        index += os_tag.len;
        path_buf[index] = <span class="tok-str">'-'</span>;
        index += <span class="tok-number">1</span>;
        <span class="tok-builtin">@memcpy</span>(path_buf[index..][<span class="tok-number">0</span>..abi.len], abi);
        index += abi.len;
        <span class="tok-kw">const</span> rpath = path_buf[<span class="tok-number">0</span>..index];
        <span class="tok-kw">if</span> (<a href="std.zig.system.html#std.zig.system.glibcVerFromRPath">glibcVerFromRPath</a>(rpath)) |ver| {
            result.os.version_range.linux.glibc = ver;
            <span class="tok-kw">return</span> result;
        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.GLibCNotFound =&gt; {},
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        }
    }

    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.zig.system">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> NativePaths = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;system/NativePaths.zig&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> windows = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;system/windows.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> darwin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;system/darwin.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> linux = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;system/linux.zig&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Executor = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    native,
    rosetta,
    qemu: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    wine: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    wasmtime: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    darling: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    bad_dl: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    bad_os_or_cpu,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetExternalExecutorOptions = <span class="tok-kw">struct</span> {
    allow_darling: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,
    allow_qemu: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,
    allow_rosetta: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,
    allow_wasmtime: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,
    allow_wine: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,
    qemu_fixes_dl: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    link_libc: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
};

<span class="tok-comment">/// Return whether or not the given host is capable of running executables of</span>
<span class="tok-comment">/// the other target.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getExternalExecutor</span>(
    host: <a href="std.html">std</a>.<a href="std.Target.html">Target</a>,
    candidate: *<span class="tok-kw">const</span> <a href="std.html">std</a>.<a href="std.Target.html">Target</a>,
    options: <a href="std.zig.system.GetExternalExecutorOptions.html">GetExternalExecutorOptions</a>,
) <a href="std.zig.system.Executor.html">Executor</a> {
    <span class="tok-kw">const</span> os_match = host.os.tag == candidate.os.tag;
    <span class="tok-kw">const</span> cpu_ok = cpu_ok: {
        <span class="tok-kw">if</span> (host.cpu.arch == candidate.cpu.arch)
            <span class="tok-kw">break</span> :cpu_ok <span class="tok-null">true</span>;

        <span class="tok-kw">if</span> (host.cpu.arch == .x86_64 <span class="tok-kw">and</span> candidate.cpu.arch == .x86)
            <span class="tok-kw">break</span> :cpu_ok <span class="tok-null">true</span>;

        <span class="tok-kw">if</span> (host.cpu.arch == .aarch64 <span class="tok-kw">and</span> candidate.cpu.arch == .arm)
            <span class="tok-kw">break</span> :cpu_ok <span class="tok-null">true</span>;

        <span class="tok-kw">if</span> (host.cpu.arch == .aarch64_be <span class="tok-kw">and</span> candidate.cpu.arch == .armeb)
            <span class="tok-kw">break</span> :cpu_ok <span class="tok-null">true</span>;<span class="tok-comment">

        // TODO additionally detect incompatible CPU features.
        // Note that in some cases the OS kernel will emulate missing CPU features
        // when an illegal instruction is encountered.

        </span><span class="tok-kw">break</span> :cpu_ok <span class="tok-null">false</span>;
    };

    <span class="tok-kw">var</span> bad_result: <a href="std.zig.system.Executor.html">Executor</a> = .bad_os_or_cpu;

    <span class="tok-kw">if</span> (os_match <span class="tok-kw">and</span> cpu_ok) native: {
        <span class="tok-kw">if</span> (options.link_libc) {
            <span class="tok-kw">if</span> (candidate.dynamic_linker.get()) |candidate_dl| {
                <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().access(candidate_dl, .{}) <span class="tok-kw">catch</span> {
                    bad_result = .{ .bad_dl = candidate_dl };
                    <span class="tok-kw">break</span> :native;
                };
            }
        }
        <span class="tok-kw">return</span> .native;
    }<span class="tok-comment">

    // If the OS match and OS is macOS and CPU is arm64, we can use Rosetta 2
    // to emulate the foreign architecture.
    </span><span class="tok-kw">if</span> (options.allow_rosetta <span class="tok-kw">and</span> os_match <span class="tok-kw">and</span>
        host.os.tag == .macos <span class="tok-kw">and</span> host.cpu.arch == .aarch64)
    {
        <span class="tok-kw">switch</span> (candidate.cpu.arch) {
            .x86_64 =&gt; <span class="tok-kw">return</span> .rosetta,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> bad_result,
        }
    }<span class="tok-comment">

    // If the OS matches, we can use QEMU to emulate a foreign architecture.
    </span><span class="tok-kw">if</span> (options.allow_qemu <span class="tok-kw">and</span> os_match <span class="tok-kw">and</span> (!cpu_ok <span class="tok-kw">or</span> options.qemu_fixes_dl)) {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (candidate.cpu.arch) {
            .aarch64 =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-aarch64&quot;</span> },
            .aarch64_be =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-aarch64_be&quot;</span> },
            .arm, .thumb =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-arm&quot;</span> },
            .armeb, .thumbeb =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-armeb&quot;</span> },
            .hexagon =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-hexagon&quot;</span> },
            .loongarch64 =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-loongarch64&quot;</span> },
            .m68k =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-m68k&quot;</span> },
            .mips =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-mips&quot;</span> },
            .mipsel =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-mipsel&quot;</span> },
            .mips64 =&gt; <a href="std.zig.system.Executor.html">Executor</a>{
                .qemu = <span class="tok-kw">switch</span> (candidate.abi) {
                    .gnuabin32, .muslabin32 =&gt; <span class="tok-str">&quot;qemu-mipsn32&quot;</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-str">&quot;qemu-mips64&quot;</span>,
                },
            },
            .mips64el =&gt; <a href="std.zig.system.Executor.html">Executor</a>{
                .qemu = <span class="tok-kw">switch</span> (candidate.abi) {
                    .gnuabin32, .muslabin32 =&gt; <span class="tok-str">&quot;qemu-mipsn32el&quot;</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-str">&quot;qemu-mips64el&quot;</span>,
                },
            },
            .powerpc =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-ppc&quot;</span> },
            .powerpc64 =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-ppc64&quot;</span> },
            .powerpc64le =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-ppc64le&quot;</span> },
            .riscv32 =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-riscv32&quot;</span> },
            .riscv64 =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-riscv64&quot;</span> },
            .s390x =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-s390x&quot;</span> },
            .sparc =&gt; <a href="std.zig.system.Executor.html">Executor</a>{
                .qemu = <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.sparc.html">sparc</a>.<a href="std.Target.sparc.html#std.Target.sparc.featureSetHas">featureSetHas</a>(candidate.cpu.features, .v9))
                    <span class="tok-str">&quot;qemu-sparc32plus&quot;</span>
                <span class="tok-kw">else</span>
                    <span class="tok-str">&quot;qemu-sparc&quot;</span>,
            },
            .sparc64 =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-sparc64&quot;</span> },
            .x86 =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-i386&quot;</span> },
            .x86_64 =&gt; <span class="tok-kw">switch</span> (candidate.abi) {
                .gnux32, .muslx32 =&gt; <span class="tok-kw">return</span> bad_result,
                <span class="tok-kw">else</span> =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-x86_64&quot;</span> },
            },
            .xtensa =&gt; <a href="std.zig.system.Executor.html">Executor</a>{ .qemu = <span class="tok-str">&quot;qemu-xtensa&quot;</span> },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> bad_result,
        };
    }

    <span class="tok-kw">if</span> (options.allow_wasmtime <span class="tok-kw">and</span> candidate.cpu.arch.isWasm()) {
        <span class="tok-kw">return</span> <a href="std.zig.system.Executor.html">Executor</a>{ .wasmtime = <span class="tok-str">&quot;wasmtime&quot;</span> };
    }

    <span class="tok-kw">switch</span> (candidate.os.tag) {
        .windows =&gt; {
            <span class="tok-kw">if</span> (options.allow_wine) {
                <span class="tok-kw">const</span> wine_supported = <span class="tok-kw">switch</span> (candidate.cpu.arch) {
                    .thumb =&gt; <span class="tok-kw">switch</span> (host.cpu.arch) {
                        .arm, .thumb, .aarch64 =&gt; <span class="tok-null">true</span>,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
                    },
                    .aarch64 =&gt; host.cpu.arch == .aarch64,
                    .x86 =&gt; host.cpu.arch.isX86(),
                    .x86_64 =&gt; host.cpu.arch == .x86_64,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
                };
                <span class="tok-kw">return</span> <span class="tok-kw">if</span> (wine_supported) <a href="std.zig.system.Executor.html">Executor</a>{ .wine = <span class="tok-str">&quot;wine&quot;</span> } <span class="tok-kw">else</span> bad_result;
            }
            <span class="tok-kw">return</span> bad_result;
        },
        .driverkit, .macos =&gt; {
            <span class="tok-kw">if</span> (options.allow_darling) {<span class="tok-comment">
                // This check can be loosened once darling adds a QEMU-based emulation
                // layer for non-host architectures:
                // https://github.com/darlinghq/darling/issues/863
                </span><span class="tok-kw">if</span> (candidate.cpu.arch != host.cpu.arch) {
                    <span class="tok-kw">return</span> bad_result;
                }
                <span class="tok-kw">return</span> <a href="std.zig.system.Executor.html">Executor</a>{ .darling = <span class="tok-str">&quot;darling&quot;</span> };
            }
            <span class="tok-kw">return</span> bad_result;
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> bad_result,
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> DetectError = <span class="tok-kw">error</span>{
    FileSystem,
    SystemResources,
    SymLinkLoop,
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    DeviceBusy,
    OSVersionDetectionFail,
    Unexpected,
    ProcessNotFound,
};

<span class="tok-comment">/// Given a `Target.Query`, which specifies in detail which parts of the</span>
<span class="tok-comment">/// target should be detected natively, which should be standard or default,</span>
<span class="tok-comment">/// and which are provided explicitly, this function resolves the native</span>
<span class="tok-comment">/// components by detecting the native system, and then resolves</span>
<span class="tok-comment">/// standard/default parts relative to that.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resolveTargetQuery</span>(query: <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>) <a href="std.zig.system.html#std.zig.system.DetectError">DetectError</a>!<a href="std.Target.html">Target</a> {<span class="tok-comment">
    // Until https://github.com/ziglang/zig/issues/4592 is implemented (support detecting the
    // native CPU architecture as being different than the current target), we use this:
    </span><span class="tok-kw">const</span> query_cpu_arch = query.cpu_arch <span class="tok-kw">orelse</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>;
    <span class="tok-kw">const</span> query_os_tag = query.os_tag <span class="tok-kw">orelse</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>;
    <span class="tok-kw">const</span> query_abi = query.abi <span class="tok-kw">orelse</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.abi">abi</a>;
    <span class="tok-kw">var</span> os = query_os_tag.defaultVersionRange(query_cpu_arch, query_abi);
    <span class="tok-kw">if</span> (query.os_tag == <span class="tok-null">null</span>) {
        <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a>) {
            .linux =&gt; {
                <span class="tok-kw">const</span> uts = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.uname">uname</a>();
                <span class="tok-kw">const</span> release = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;uts.release, <span class="tok-number">0</span>);<span class="tok-comment">
                // The release field sometimes has a weird format,
                // `Version.parse` will attempt to find some meaningful interpretation.
                </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a>.<a href="std.SemanticVersion.html#std.SemanticVersion.parse">parse</a>(release)) |ver| {
                    os.version_range.linux.range.min = ver;
                    os.version_range.linux.range.max = ver;
                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.Overflow =&gt; {},
                    <span class="tok-kw">error</span>.InvalidVersion =&gt; {},
                }
            },
            .solaris, .illumos =&gt; {
                <span class="tok-kw">const</span> uts = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.uname">uname</a>();
                <span class="tok-kw">const</span> release = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;uts.release, <span class="tok-number">0</span>);
                <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a>.<a href="std.SemanticVersion.html#std.SemanticVersion.parse">parse</a>(release)) |ver| {
                    os.version_range.semver.min = ver;
                    os.version_range.semver.max = ver;
                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.Overflow =&gt; {},
                    <span class="tok-kw">error</span>.InvalidVersion =&gt; {},
                }
            },
            .windows =&gt; {
                <span class="tok-kw">const</span> detected_version = <a href="std.zig.system.windows.html">windows</a>.<a href="std.zig.system.windows.html#std.zig.system.windows.detectRuntimeVersion">detectRuntimeVersion</a>();
                os.version_range.windows.min = detected_version;
                os.version_range.windows.max = detected_version;
            },
            .macos =&gt; <span class="tok-kw">try</span> <a href="std.zig.system.darwin.html">darwin</a>.<a href="std.zig.system.darwin.macos.html">macos</a>.<a href="std.zig.system.darwin.macos.html#std.zig.system.darwin.macos.detect">detect</a>(&amp;os),
            .freebsd, .netbsd, .dragonfly =&gt; {
                <span class="tok-kw">const</span> key = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a>) {
                    .freebsd =&gt; <span class="tok-str">&quot;kern.osreldate&quot;</span>,
                    .netbsd, .dragonfly =&gt; <span class="tok-str">&quot;kern.osrevision&quot;</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                };
                <span class="tok-kw">var</span> value: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(value));

                <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sysctlbynameZ">sysctlbynameZ</a>(key, &amp;value, &amp;len, <span class="tok-null">null</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // constant, known good value
                    </span><span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // only when setting values,
                    </span><span class="tok-kw">error</span>.SystemResources =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // memory already on the stack
                    </span><span class="tok-kw">error</span>.UnknownName =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // constant, known good value
                    </span><span class="tok-kw">error</span>.Unexpected =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OSVersionDetectionFail,
                };

                <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a>) {
                    .freebsd =&gt; {<span class="tok-comment">
                        // https://www.freebsd.org/doc/en_US.ISO8859-1/books/porters-handbook/versions.html
                        // Major * 100,000 has been convention since FreeBSD 2.2 (1997)
                        // Minor * 1(0),000 summed has been convention since FreeBSD 2.2 (1997)
                        // e.g. 492101 = 4.11-STABLE = 4.(9+2)
                        </span><span class="tok-kw">const</span> major = value / <span class="tok-number">100_000</span>;
                        <span class="tok-kw">const</span> minor1 = value % <span class="tok-number">100_000</span> / <span class="tok-number">10_000</span>;<span class="tok-comment"> // usually 0 since 5.1
                        </span><span class="tok-kw">const</span> minor2 = value % <span class="tok-number">10_000</span> / <span class="tok-number">1_000</span>;<span class="tok-comment"> // 0 before 5.1, minor version since
                        </span><span class="tok-kw">const</span> patch = value % <span class="tok-number">1_000</span>;
                        os.version_range.semver.min = .{ .major = major, .minor = minor1 + minor2, .patch = patch };
                        os.version_range.semver.max = os.version_range.semver.min;
                    },
                    .netbsd =&gt; {<span class="tok-comment">
                        // #define __NetBSD_Version__ MMmmrrpp00
                        //
                        // M = major version
                        // m = minor version; a minor number of 99 indicates current.
                        // r = 0 (*)
                        // p = patchlevel
                        </span><span class="tok-kw">const</span> major = value / <span class="tok-number">100_000_000</span>;
                        <span class="tok-kw">const</span> minor = value % <span class="tok-number">100_000_000</span> / <span class="tok-number">1_000_000</span>;
                        <span class="tok-kw">const</span> patch = value % <span class="tok-number">10_000</span> / <span class="tok-number">100</span>;
                        os.version_range.semver.min = .{ .major = major, .minor = minor, .patch = patch };
                        os.version_range.semver.max = os.version_range.semver.min;
                    },
                    .dragonfly =&gt; {<span class="tok-comment">
                        // https://github.com/DragonFlyBSD/DragonFlyBSD/blob/cb2cde83771754aeef9bb3251ee48959138dec87/Makefile.inc1#L15-L17
                        // flat base10 format: Mmmmpp
                        //   M = major
                        //   m = minor; odd-numbers indicate current dev branch
                        //   p = patch
                        </span><span class="tok-kw">const</span> major = value / <span class="tok-number">100_000</span>;
                        <span class="tok-kw">const</span> minor = value % <span class="tok-number">100_000</span> / <span class="tok-number">100</span>;
                        <span class="tok-kw">const</span> patch = value % <span class="tok-number">100</span>;
                        os.version_range.semver.min = .{ .major = major, .minor = minor, .patch = patch };
                        os.version_range.semver.max = os.version_range.semver.min;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                }
            },
            .openbsd =&gt; {
                <span class="tok-kw">const</span> mib: [<span class="tok-number">2</span>]<span class="tok-type">c_int</span> = [_]<span class="tok-type">c_int</span>{
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.CTL">CTL</a>.<a href="#">KERN</a>,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.KERN">KERN</a>.<a href="#">OSRELEASE</a>,
                };
                <span class="tok-kw">var</span> buf: [<span class="tok-number">64</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">
                // consider that sysctl result includes null-termination
                // reserve 1 byte to ensure we never overflow when appending &quot;.0&quot;
                </span><span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = buf.len - <span class="tok-number">1</span>;

                <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sysctl">sysctl</a>(&amp;mib, &amp;buf, &amp;len, <span class="tok-null">null</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // constant, known good value
                    </span><span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // only when setting values,
                    </span><span class="tok-kw">error</span>.SystemResources =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // memory already on the stack
                    </span><span class="tok-kw">error</span>.UnknownName =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // constant, known good value
                    </span><span class="tok-kw">error</span>.Unexpected =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OSVersionDetectionFail,
                };<span class="tok-comment">

                // append &quot;.0&quot; to satisfy semver
                </span>buf[len - <span class="tok-number">1</span>] = <span class="tok-str">'.'</span>;
                buf[len] = <span class="tok-str">'0'</span>;
                len += <span class="tok-number">1</span>;

                <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a>.<a href="std.SemanticVersion.html#std.SemanticVersion.parse">parse</a>(buf[<span class="tok-number">0</span>..len])) |ver| {
                    os.version_range.semver.min = ver;
                    os.version_range.semver.max = ver;
                } <span class="tok-kw">else</span> |_| {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OSVersionDetectionFail;
                }
            },
            <span class="tok-kw">else</span> =&gt; {<span class="tok-comment">
                // Unimplemented, fall back to default version range.
            </span>},
        }
    }

    <span class="tok-kw">if</span> (query.os_version_min) |min| <span class="tok-kw">switch</span> (min) {
        .none =&gt; {},
        .semver =&gt; |semver| <span class="tok-kw">switch</span> (os.tag.versionRangeTag()) {
            <span class="tok-kw">inline</span> .hurd, .linux =&gt; |t| <span class="tok-builtin">@field</span>(os.version_range, <span class="tok-builtin">@tagName</span>(t)).range.min = semver,
            <span class="tok-kw">else</span> =&gt; os.version_range.semver.min = semver,
        },
        .windows =&gt; |win_ver| os.version_range.windows.min = win_ver,
    };

    <span class="tok-kw">if</span> (query.os_version_max) |max| <span class="tok-kw">switch</span> (max) {
        .none =&gt; {},
        .semver =&gt; |semver| <span class="tok-kw">switch</span> (os.tag.versionRangeTag()) {
            <span class="tok-kw">inline</span> .hurd, .linux =&gt; |t| <span class="tok-builtin">@field</span>(os.version_range, <span class="tok-builtin">@tagName</span>(t)).range.max = semver,
            <span class="tok-kw">else</span> =&gt; os.version_range.semver.max = semver,
        },
        .windows =&gt; |win_ver| os.version_range.windows.max = win_ver,
    };

    <span class="tok-kw">if</span> (query.glibc_version) |glibc| {
        <span class="tok-kw">switch</span> (os.tag.versionRangeTag()) {
            <span class="tok-kw">inline</span> .hurd, .linux =&gt; |t| <span class="tok-builtin">@field</span>(os.version_range, <span class="tok-builtin">@tagName</span>(t)).glibc = glibc,
            <span class="tok-kw">else</span> =&gt; {},
        }
    }

    <span class="tok-kw">if</span> (query.android_api_level) |android| {
        os.version_range.linux.android = android;
    }

    <span class="tok-kw">var</span> cpu = <span class="tok-kw">switch</span> (query.cpu_model) {
        .native =&gt; <a href="std.zig.system.html#std.zig.system.detectNativeCpuAndFeatures">detectNativeCpuAndFeatures</a>(query_cpu_arch, os, query),
        .baseline =&gt; <a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>.<a href="std.Target.Cpu.html#std.Target.Cpu.baseline">baseline</a>(query_cpu_arch, os),
        .determined_by_arch_os =&gt; <span class="tok-kw">if</span> (query.cpu_arch == <span class="tok-null">null</span>)
            <a href="std.zig.system.html#std.zig.system.detectNativeCpuAndFeatures">detectNativeCpuAndFeatures</a>(query_cpu_arch, os, query)
        <span class="tok-kw">else</span>
            <a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>.<a href="std.Target.Cpu.html#std.Target.Cpu.baseline">baseline</a>(query_cpu_arch, os),
        .explicit =&gt; |model| model.toCpu(query_cpu_arch),
    } <span class="tok-kw">orelse</span> backup_cpu_detection: {
        <span class="tok-kw">break</span> :backup_cpu_detection <a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>.<a href="std.Target.Cpu.html#std.Target.Cpu.baseline">baseline</a>(query_cpu_arch, os);
    };<span class="tok-comment">

    // For x86, we need to populate some CPU feature flags depending on architecture
    // and mode:
    //  * 16bit_mode =&gt; if the abi is code16
    //  * 32bit_mode =&gt; if the arch is x86
    // However, the &quot;mode&quot; flags can be used as overrides, so if the user explicitly
    // sets one of them, that takes precedence.
    </span><span class="tok-kw">switch</span> (query_cpu_arch) {
        .x86 =&gt; {
            <span class="tok-kw">if</span> (!<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.html#std.Target.x86.featureSetHasAny">featureSetHasAny</a>(query.cpu_features_add, .{
                .@&quot;16bit_mode&quot;, .@&quot;32bit_mode&quot;,
            })) {
                <span class="tok-kw">switch</span> (query_abi) {
                    .code16 =&gt; cpu.features.addFeature(
                        <span class="tok-builtin">@intFromEnum</span>(<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.Feature.html">Feature</a>.<a href="#"16bit_mode"">@&quot;16bit_mode&quot;</a>),
                    ),
                    <span class="tok-kw">else</span> =&gt; cpu.features.addFeature(
                        <span class="tok-builtin">@intFromEnum</span>(<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.Feature.html">Feature</a>.<a href="#"32bit_mode"">@&quot;32bit_mode&quot;</a>),
                    ),
                }
            }
        },
        .arm, .armeb =&gt; {<span class="tok-comment">
            // XXX What do we do if the target has the noarm feature?
            //     What do we do if the user specifies +thumb_mode?
        </span>},
        .thumb, .thumbeb =&gt; {
            cpu.features.addFeature(
                <span class="tok-builtin">@intFromEnum</span>(<a href="std.Target.html">Target</a>.<a href="std.Target.arm.html">arm</a>.<a href="std.Target.arm.Feature.html">Feature</a>.<a href="#">thumb_mode</a>),
            );
        },
        <span class="tok-kw">else</span> =&gt; {},
    }
    <a href="std.zig.system.html#std.zig.system.updateCpuFeatures">updateCpuFeatures</a>(
        &amp;cpu.features,
        cpu.arch.allFeaturesList(),
        query.cpu_features_add,
        query.cpu_features_sub,
    );

    <span class="tok-kw">var</span> result = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.detectAbiAndDynamicLinker">detectAbiAndDynamicLinker</a>(cpu, os, query);<span class="tok-comment">

    // These CPU feature hacks have to come after ABI detection.
    </span>{
        <span class="tok-kw">if</span> (result.cpu.arch == .hexagon) {<span class="tok-comment">
            // Both LLVM and LLD have broken support for the small data area. Yet LLVM has the
            // feature on by default for all Hexagon CPUs. Clang sort of solves this by defaulting
            // the `-gpsize` command line parameter for the Hexagon backend to 0, so that no
            // constants get placed in the SDA. (This of course breaks down if the user passes
            // `-G &lt;n&gt;` to Clang...) We can't do the `-gpsize` hack because we can have multiple
            // concurrent LLVM emit jobs, and command line options in LLVM are shared globally. So
            // just force this feature off. Lovely stuff.
            </span>result.cpu.features.removeFeature(<span class="tok-builtin">@intFromEnum</span>(<a href="std.Target.html">Target</a>.<a href="std.Target.hexagon.html">hexagon</a>.<a href="std.Target.hexagon.Feature.html">Feature</a>.<a href="#">small_data</a>));
        }<span class="tok-comment">

        // https://github.com/llvm/llvm-project/issues/105978
        </span><span class="tok-kw">if</span> (result.cpu.arch.isArm() <span class="tok-kw">and</span> result.abi.float() == .soft) {
            result.cpu.features.removeFeature(<span class="tok-builtin">@intFromEnum</span>(<a href="std.Target.html">Target</a>.<a href="std.Target.arm.html">arm</a>.<a href="std.Target.arm.Feature.html">Feature</a>.<a href="#">vfp2</a>));
        }
    }<span class="tok-comment">

    // It's possible that we detect the native ABI, but fail to detect the OS version or were told
    // to use the default OS version range. In that case, while we can't determine the exact native
    // OS version, we do at least know that some ABIs require a particular OS version (by way of
    // `std.zig.target.available_libcs`). So in this case, adjust the OS version to the minimum that
    // we know is required.
    </span><span class="tok-kw">if</span> (result.abi != query_abi <span class="tok-kw">and</span> query.os_version_min == <span class="tok-null">null</span>) {
        <span class="tok-kw">const</span> result_ver_range = &amp;result.os.version_range;
        <span class="tok-kw">const</span> abi_ver_range = result.os.tag.defaultVersionRange(result.cpu.arch, result.abi).version_range;

        <span class="tok-kw">switch</span> (result.os.tag.versionRangeTag()) {
            .none =&gt; {},
            .semver =&gt; <span class="tok-kw">if</span> (result_ver_range.semver.min.order(abi_ver_range.semver.min) == .lt) {
                result_ver_range.semver.min = abi_ver_range.semver.min;
            },
            <span class="tok-kw">inline</span> .hurd, .linux =&gt; |t| {
                <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(result_ver_range, <span class="tok-builtin">@tagName</span>(t)).range.min.order(<span class="tok-builtin">@field</span>(abi_ver_range, <span class="tok-builtin">@tagName</span>(t)).range.min) == .lt) {
                    <span class="tok-builtin">@field</span>(result_ver_range, <span class="tok-builtin">@tagName</span>(t)).range.min = <span class="tok-builtin">@field</span>(abi_ver_range, <span class="tok-builtin">@tagName</span>(t)).range.min;
                }

                <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(result_ver_range, <span class="tok-builtin">@tagName</span>(t)).glibc.order(<span class="tok-builtin">@field</span>(abi_ver_range, <span class="tok-builtin">@tagName</span>(t)).glibc) == .lt <span class="tok-kw">and</span>
                    query.glibc_version == <span class="tok-null">null</span>)
                {
                    <span class="tok-builtin">@field</span>(result_ver_range, <span class="tok-builtin">@tagName</span>(t)).glibc = <span class="tok-builtin">@field</span>(abi_ver_range, <span class="tok-builtin">@tagName</span>(t)).glibc;
                }
            },
            .windows =&gt; <span class="tok-kw">if</span> (!result_ver_range.windows.min.isAtLeast(abi_ver_range.windows.min)) {
                result_ver_range.windows.min = abi_ver_range.windows.min;
            },
        }
    }

    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">fn</span> <span class="tok-fn">updateCpuFeatures</span>(
    set: *<a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>.<a href="std.Target.Cpu.Feature.html">Feature</a>.<a href="std.Target.Cpu.Feature.Set.html">Set</a>,
    all_features_list: []<span class="tok-kw">const</span> <a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>.<a href="std.Target.Cpu.Feature.html">Feature</a>,
    add_set: <a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>.<a href="std.Target.Cpu.Feature.html">Feature</a>.<a href="std.Target.Cpu.Feature.Set.html">Set</a>,
    sub_set: <a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>.<a href="std.Target.Cpu.Feature.html">Feature</a>.<a href="std.Target.Cpu.Feature.Set.html">Set</a>,
) <span class="tok-type">void</span> {
    set.removeFeatureSet(sub_set);
    set.addFeatureSet(add_set);
    set.populateDependencies(all_features_list);
    set.removeFeatureSet(sub_set);
}

<span class="tok-kw">fn</span> <span class="tok-fn">detectNativeCpuAndFeatures</span>(cpu_arch: <a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>.<a href="std.Target.Cpu.Arch.html">Arch</a>, os: <a href="std.Target.html">Target</a>.<a href="std.Target.Os.html">Os</a>, query: <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>) ?<a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a> {<span class="tok-comment">
    // Here we switch on a comptime value rather than `cpu_arch`. This is valid because `cpu_arch`,
    // although it is a runtime value, is guaranteed to be one of the architectures in the set
    // of the respective switch prong.
    </span><span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>) {
        .x86_64, .x86 =&gt; {
            <span class="tok-kw">return</span> <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;system/x86.zig&quot;</span>).detectNativeCpuAndFeatures(cpu_arch, os, query);
        },
        <span class="tok-kw">else</span> =&gt; {},
    }

    <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
        .linux =&gt; <span class="tok-kw">return</span> <a href="std.zig.system.linux.html">linux</a>.<a href="std.zig.system.linux.html#std.zig.system.linux.detectNativeCpuAndFeatures">detectNativeCpuAndFeatures</a>(),
        .macos =&gt; <span class="tok-kw">return</span> <a href="std.zig.system.darwin.html">darwin</a>.<a href="std.zig.system.darwin.macos.html">macos</a>.<a href="std.zig.system.darwin.macos.html#std.zig.system.darwin.macos.detectNativeCpuAndFeatures">detectNativeCpuAndFeatures</a>(),
        .windows =&gt; <span class="tok-kw">return</span> <a href="std.zig.system.windows.html">windows</a>.<a href="std.zig.system.windows.html#std.zig.system.windows.detectNativeCpuAndFeatures">detectNativeCpuAndFeatures</a>(),
        <span class="tok-kw">else</span> =&gt; {},
    }<span class="tok-comment">

    // This architecture does not have CPU model &amp; feature detection yet.
    // See https://github.com/ziglang/zig/issues/4591
    </span><span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AbiAndDynamicLinkerFromFileError = <span class="tok-kw">error</span>{
    FileSystem,
    SystemResources,
    SymLinkLoop,
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    UnableToReadElfFile,
    InvalidElfClass,
    InvalidElfVersion,
    InvalidElfEndian,
    InvalidElfFile,
    InvalidElfMagic,
    Unexpected,
    UnexpectedEndOfFile,
    NameTooLong,
    ProcessNotFound,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">abiAndDynamicLinkerFromFile</span>(
    file: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>,
    cpu: <a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>,
    os: <a href="std.Target.html">Target</a>.<a href="std.Target.Os.html">Os</a>,
    ld_info_list: []<span class="tok-kw">const</span> <a href="std.zig.system.LdInfo.html">LdInfo</a>,
    query: <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>,
) <a href="std.zig.system.html#std.zig.system.AbiAndDynamicLinkerFromFileError">AbiAndDynamicLinkerFromFileError</a>!<a href="std.Target.html">Target</a> {
    <span class="tok-kw">var</span> hdr_buf: [<span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Ehdr.html">Elf64_Ehdr</a>)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Ehdr.html">Elf64_Ehdr</a>)) = <span class="tok-null">undefined</span>;
    _ = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(file, &amp;hdr_buf, <span class="tok-number">0</span>, hdr_buf.len);
    <span class="tok-kw">const</span> hdr32: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Ehdr.html">Elf32_Ehdr</a> = <span class="tok-builtin">@ptrCast</span>(&amp;hdr_buf);
    <span class="tok-kw">const</span> hdr64: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Ehdr.html">Elf64_Ehdr</a> = <span class="tok-builtin">@ptrCast</span>(&amp;hdr_buf);
    <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, hdr32.e_ident[<span class="tok-number">0</span>..<span class="tok-number">4</span>], <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.MAGIC">MAGIC</a>)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfMagic;
    <span class="tok-kw">const</span> elf_endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a> = <span class="tok-kw">switch</span> (hdr32.e_ident[<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.EI_DATA">EI_DATA</a>]) {
        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.ELFDATA2LSB">ELFDATA2LSB</a> =&gt; .little,
        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.ELFDATA2MSB">ELFDATA2MSB</a> =&gt; .big,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfEndian,
    };
    <span class="tok-kw">const</span> need_bswap = elf_endian != <a href="std.zig.system.html#std.zig.system.native_endian">native_endian</a>;
    <span class="tok-kw">if</span> (hdr32.e_ident[<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.EI_VERSION">EI_VERSION</a>] != <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfVersion;

    <span class="tok-kw">const</span> is_64 = <span class="tok-kw">switch</span> (hdr32.e_ident[<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.EI_CLASS">EI_CLASS</a>]) {
        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.ELFCLASS32">ELFCLASS32</a> =&gt; <span class="tok-null">false</span>,
        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.ELFCLASS64">ELFCLASS64</a> =&gt; <span class="tok-null">true</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfClass,
    };
    <span class="tok-kw">var</span> phoff = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, hdr32.e_phoff, hdr64.e_phoff);
    <span class="tok-kw">const</span> phentsize = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, hdr32.e_phentsize, hdr64.e_phentsize);
    <span class="tok-kw">const</span> phnum = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, hdr32.e_phnum, hdr64.e_phnum);

    <span class="tok-kw">var</span> result: <a href="std.Target.html">Target</a> = .{
        .cpu = cpu,
        .os = os,
        .abi = query.abi <span class="tok-kw">orelse</span> <a href="std.Target.html">Target</a>.<a href="std.Target.Abi.html">Abi</a>.<a href="std.Target.Abi.html#std.Target.Abi.default">default</a>(cpu.arch, os),
        .ofmt = query.ofmt <span class="tok-kw">orelse</span> <a href="std.Target.html">Target</a>.<a href="std.Target.ObjectFormat.html">ObjectFormat</a>.<a href="std.Target.ObjectFormat.html#std.Target.ObjectFormat.default">default</a>(os.tag, cpu.arch),
        .dynamic_linker = query.dynamic_linker,
    };
    <span class="tok-kw">var</span> rpath_offset: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>;<span class="tok-comment"> // Found inside PT_DYNAMIC
    </span><span class="tok-kw">const</span> look_for_ld = query.dynamic_linker.get() == <span class="tok-null">null</span>;

    <span class="tok-kw">var</span> ph_buf: [<span class="tok-number">16</span> * <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Phdr.html">Elf64_Phdr</a>)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Phdr.html">Elf64_Phdr</a>)) = <span class="tok-null">undefined</span>;
    <span class="tok-kw">if</span> (phentsize &gt; <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Phdr.html">Elf64_Phdr</a>)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfFile;

    <span class="tok-kw">var</span> ph_i: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (ph_i &lt; phnum) {<span class="tok-comment">
        // Reserve some bytes so that we can deref the 64-bit struct fields
        // even when the ELF file is 32-bits.
        </span><span class="tok-kw">const</span> ph_reserve: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Phdr.html">Elf64_Phdr</a>) - <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Phdr.html">Elf32_Phdr</a>);
        <span class="tok-kw">const</span> ph_read_byte_len = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(file, ph_buf[<span class="tok-number">0</span> .. ph_buf.len - ph_reserve], phoff, phentsize);
        <span class="tok-kw">var</span> ph_buf_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (ph_buf_i &lt; ph_read_byte_len <span class="tok-kw">and</span> ph_i &lt; phnum) : ({
            ph_i += <span class="tok-number">1</span>;
            phoff += phentsize;
            ph_buf_i += phentsize;
        }) {
            <span class="tok-kw">const</span> ph32: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Phdr.html">Elf32_Phdr</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;ph_buf[ph_buf_i]));
            <span class="tok-kw">const</span> ph64: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Phdr.html">Elf64_Phdr</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;ph_buf[ph_buf_i]));
            <span class="tok-kw">const</span> p_type = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, ph32.p_type, ph64.p_type);
            <span class="tok-kw">switch</span> (p_type) {
                <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_INTERP">PT_INTERP</a> =&gt; <span class="tok-kw">if</span> (look_for_ld) {
                    <span class="tok-kw">const</span> p_offset = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, ph32.p_offset, ph64.p_offset);
                    <span class="tok-kw">const</span> p_filesz = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, ph32.p_filesz, ph64.p_filesz);
                    <span class="tok-kw">if</span> (p_filesz &gt; result.dynamic_linker.buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
                    <span class="tok-kw">const</span> filesz: <span class="tok-type">usize</span> = <span class="tok-builtin">@intCast</span>(p_filesz);
                    _ = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(file, result.dynamic_linker.buffer[<span class="tok-number">0</span>..filesz], p_offset, filesz);<span class="tok-comment">
                    // PT_INTERP includes a null byte in filesz.
                    </span><span class="tok-kw">const</span> len = filesz - <span class="tok-number">1</span>;<span class="tok-comment">
                    // dynamic_linker.max_byte is &quot;max&quot;, not &quot;len&quot;.
                    // We know it will fit in u8 because we check against dynamic_linker.buffer.len above.
                    </span>result.dynamic_linker.len = <span class="tok-builtin">@intCast</span>(len);<span class="tok-comment">

                    // Use it to determine ABI.
                    </span><span class="tok-kw">const</span> full_ld_path = result.dynamic_linker.buffer[<span class="tok-number">0</span>..len];
                    <span class="tok-kw">for</span> (ld_info_list) |ld_info| {
                        <span class="tok-kw">const</span> standard_ld_basename = <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.basename">basename</a>(ld_info.ld.get().?);
                        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.endsWith">endsWith</a>(<span class="tok-type">u8</span>, full_ld_path, standard_ld_basename)) {
                            result.abi = ld_info.abi;
                            <span class="tok-kw">break</span>;
                        }
                    }
                },<span class="tok-comment">
                // We only need this for detecting glibc version.
                </span><a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_DYNAMIC">PT_DYNAMIC</a> =&gt; <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a> == .linux <span class="tok-kw">and</span> result.isGnuLibC() <span class="tok-kw">and</span>
                    query.glibc_version == <span class="tok-null">null</span>)
                {
                    <span class="tok-kw">var</span> dyn_off = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, ph32.p_offset, ph64.p_offset);
                    <span class="tok-kw">const</span> p_filesz = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, ph32.p_filesz, ph64.p_filesz);
                    <span class="tok-kw">const</span> dyn_size: <span class="tok-type">usize</span> = <span class="tok-kw">if</span> (is_64) <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Dyn.html">Elf64_Dyn</a>) <span class="tok-kw">else</span> <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Dyn.html">Elf32_Dyn</a>);
                    <span class="tok-kw">const</span> dyn_num = p_filesz / dyn_size;
                    <span class="tok-kw">var</span> dyn_buf: [<span class="tok-number">16</span> * <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Dyn.html">Elf64_Dyn</a>)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Dyn.html">Elf64_Dyn</a>)) = <span class="tok-null">undefined</span>;
                    <span class="tok-kw">var</span> dyn_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                    dyn: <span class="tok-kw">while</span> (dyn_i &lt; dyn_num) {<span class="tok-comment">
                        // Reserve some bytes so that we can deref the 64-bit struct fields
                        // even when the ELF file is 32-bits.
                        </span><span class="tok-kw">const</span> dyn_reserve: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Dyn.html">Elf64_Dyn</a>) - <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Dyn.html">Elf32_Dyn</a>);
                        <span class="tok-kw">const</span> dyn_read_byte_len = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(
                            file,
                            dyn_buf[<span class="tok-number">0</span> .. dyn_buf.len - dyn_reserve],
                            dyn_off,
                            dyn_size,
                        );
                        <span class="tok-kw">var</span> dyn_buf_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                        <span class="tok-kw">while</span> (dyn_buf_i &lt; dyn_read_byte_len <span class="tok-kw">and</span> dyn_i &lt; dyn_num) : ({
                            dyn_i += <span class="tok-number">1</span>;
                            dyn_off += dyn_size;
                            dyn_buf_i += dyn_size;
                        }) {
                            <span class="tok-kw">const</span> dyn32: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Dyn.html">Elf32_Dyn</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;dyn_buf[dyn_buf_i]));
                            <span class="tok-kw">const</span> dyn64: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Dyn.html">Elf64_Dyn</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;dyn_buf[dyn_buf_i]));
                            <span class="tok-kw">const</span> tag = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, dyn32.d_tag, dyn64.d_tag);
                            <span class="tok-kw">const</span> val = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, dyn32.d_val, dyn64.d_val);
                            <span class="tok-kw">if</span> (tag == <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_RUNPATH">DT_RUNPATH</a>) {
                                rpath_offset = val;
                                <span class="tok-kw">break</span> :dyn;
                            }
                        }
                    }
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,
            }
        }
    }

    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a> == .linux <span class="tok-kw">and</span> result.isGnuLibC() <span class="tok-kw">and</span>
        query.glibc_version == <span class="tok-null">null</span>)
    {
        <span class="tok-kw">const</span> shstrndx = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, hdr32.e_shstrndx, hdr64.e_shstrndx);

        <span class="tok-kw">var</span> shoff = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, hdr32.e_shoff, hdr64.e_shoff);
        <span class="tok-kw">const</span> shentsize = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, hdr32.e_shentsize, hdr64.e_shentsize);
        <span class="tok-kw">const</span> str_section_off = shoff + <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, shentsize) * <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, shstrndx);

        <span class="tok-kw">var</span> sh_buf: [<span class="tok-number">16</span> * <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Shdr.html">Elf64_Shdr</a>)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Shdr.html">Elf64_Shdr</a>)) = <span class="tok-null">undefined</span>;
        <span class="tok-kw">if</span> (sh_buf.len &lt; shentsize) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfFile;

        _ = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(file, &amp;sh_buf, str_section_off, shentsize);
        <span class="tok-kw">const</span> shstr32: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Shdr.html">Elf32_Shdr</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;sh_buf));
        <span class="tok-kw">const</span> shstr64: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Shdr.html">Elf64_Shdr</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;sh_buf));
        <span class="tok-kw">const</span> shstrtab_off = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, shstr32.sh_offset, shstr64.sh_offset);
        <span class="tok-kw">const</span> shstrtab_size = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, shstr32.sh_size, shstr64.sh_size);
        <span class="tok-kw">var</span> strtab_buf: [<span class="tok-number">4096</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> shstrtab_len = <span class="tok-builtin">@min</span>(shstrtab_size, strtab_buf.len);
        <span class="tok-kw">const</span> shstrtab_read_len = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(file, &amp;strtab_buf, shstrtab_off, shstrtab_len);
        <span class="tok-kw">const</span> shstrtab = strtab_buf[<span class="tok-number">0</span>..shstrtab_read_len];

        <span class="tok-kw">const</span> shnum = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, hdr32.e_shnum, hdr64.e_shnum);
        <span class="tok-kw">var</span> sh_i: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> dynstr: ?<span class="tok-kw">struct</span> { offset: <span class="tok-type">u64</span>, size: <span class="tok-type">u64</span> } = find_dyn_str: <span class="tok-kw">while</span> (sh_i &lt; shnum) {<span class="tok-comment">
            // Reserve some bytes so that we can deref the 64-bit struct fields
            // even when the ELF file is 32-bits.
            </span><span class="tok-kw">const</span> sh_reserve: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Shdr.html">Elf64_Shdr</a>) - <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Shdr.html">Elf32_Shdr</a>);
            <span class="tok-kw">const</span> sh_read_byte_len = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(
                file,
                sh_buf[<span class="tok-number">0</span> .. sh_buf.len - sh_reserve],
                shoff,
                shentsize,
            );
            <span class="tok-kw">var</span> sh_buf_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (sh_buf_i &lt; sh_read_byte_len <span class="tok-kw">and</span> sh_i &lt; shnum) : ({
                sh_i += <span class="tok-number">1</span>;
                shoff += shentsize;
                sh_buf_i += shentsize;
            }) {
                <span class="tok-kw">const</span> sh32: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Shdr.html">Elf32_Shdr</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;sh_buf[sh_buf_i]));
                <span class="tok-kw">const</span> sh64: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Shdr.html">Elf64_Shdr</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;sh_buf[sh_buf_i]));
                <span class="tok-kw">const</span> sh_name_off = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, sh32.sh_name, sh64.sh_name);
                <span class="tok-kw">const</span> sh_name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(shstrtab[sh_name_off..], <span class="tok-number">0</span>);
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, sh_name, <span class="tok-str">&quot;.dynstr&quot;</span>)) {
                    <span class="tok-kw">break</span> :find_dyn_str .{
                        .offset = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, sh32.sh_offset, sh64.sh_offset),
                        .size = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, sh32.sh_size, sh64.sh_size),
                    };
                }
            }
        } <span class="tok-kw">else</span> <span class="tok-null">null</span>;

        <span class="tok-kw">if</span> (dynstr) |ds| {
            <span class="tok-kw">if</span> (rpath_offset) |rpoff| {
                <span class="tok-kw">if</span> (rpoff &gt; ds.size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfFile;
                <span class="tok-kw">const</span> rpoff_file = ds.offset + rpoff;
                <span class="tok-kw">const</span> rp_max_size = ds.size - rpoff;

                <span class="tok-kw">const</span> strtab_len = <span class="tok-builtin">@min</span>(rp_max_size, strtab_buf.len);
                <span class="tok-kw">const</span> strtab_read_len = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(file, &amp;strtab_buf, rpoff_file, strtab_len);
                <span class="tok-kw">const</span> strtab = strtab_buf[<span class="tok-number">0</span>..strtab_read_len];

                <span class="tok-kw">const</span> rpath_list = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(strtab, <span class="tok-number">0</span>);
                <span class="tok-kw">var</span> it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, rpath_list, <span class="tok-str">':'</span>);
                <span class="tok-kw">while</span> (it.next()) |rpath| {
                    <span class="tok-kw">if</span> (<a href="std.zig.system.html#std.zig.system.glibcVerFromRPath">glibcVerFromRPath</a>(rpath)) |ver| {
                        result.os.version_range.linux.glibc = ver;
                        <span class="tok-kw">return</span> result;
                    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                        <span class="tok-kw">error</span>.GLibCNotFound =&gt; <span class="tok-kw">continue</span>,
                        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
                    }
                }
            }
        }

        <span class="tok-kw">if</span> (result.dynamic_linker.get()) |dl_path| glibc_ver: {<span class="tok-comment">
            // There is no DT_RUNPATH so we try to find libc.so.6 inside the same
            // directory as the dynamic linker.
            </span><span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(dl_path)) |rpath| {
                <span class="tok-kw">if</span> (<a href="std.zig.system.html#std.zig.system.glibcVerFromRPath">glibcVerFromRPath</a>(rpath)) |ver| {
                    result.os.version_range.linux.glibc = ver;
                    <span class="tok-kw">return</span> result;
                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.GLibCNotFound =&gt; {},
                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
                }
            }<span class="tok-comment">

            // So far, no luck. Next we try to see if the information is
            // present in the symlink data for the dynamic linker path.
            </span><span class="tok-kw">var</span> link_buf: [<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PATH_MAX">PATH_MAX</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> link_name = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.readlink">readlink</a>(dl_path, &amp;link_buf) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // WASI only
                </span><span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows only
                </span><span class="tok-kw">error</span>.BadPathName =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows only
                </span><span class="tok-kw">error</span>.UnsupportedReparsePointType =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows only
                </span><span class="tok-kw">error</span>.NetworkNotFound =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows only

                </span><span class="tok-kw">error</span>.AccessDenied,
                <span class="tok-kw">error</span>.FileNotFound,
                <span class="tok-kw">error</span>.NotLink,
                <span class="tok-kw">error</span>.NotDir,
                =&gt; <span class="tok-kw">break</span> :glibc_ver,

                <span class="tok-kw">error</span>.SystemResources,
                <span class="tok-kw">error</span>.FileSystem,
                <span class="tok-kw">error</span>.SymLinkLoop,
                <span class="tok-kw">error</span>.Unexpected,
                =&gt; |e| <span class="tok-kw">return</span> e,
            };
            result.os.version_range.linux.glibc = <a href="std.zig.system.html#std.zig.system.glibcVerFromLinkName">glibcVerFromLinkName</a>(
                <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.basename">basename</a>(link_name),
                <span class="tok-str">&quot;ld-&quot;</span>,
            ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.UnrecognizedGnuLibCFileName,
                <span class="tok-kw">error</span>.InvalidGnuLibCVersion,
                =&gt; <span class="tok-kw">break</span> :glibc_ver,
            };
            <span class="tok-kw">return</span> result;
        }<span class="tok-comment">

        // Nothing worked so far. Finally we fall back to hard-coded search paths.
        // Some distros such as Debian keep their libc.so.6 in `/lib/$triple/`.
        </span><span class="tok-kw">var</span> path_buf: [<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PATH_MAX">PATH_MAX</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> prefix = <span class="tok-str">&quot;/lib/&quot;</span>;
        <span class="tok-kw">const</span> cpu_arch = <span class="tok-builtin">@tagName</span>(result.cpu.arch);
        <span class="tok-kw">const</span> os_tag = <span class="tok-builtin">@tagName</span>(result.os.tag);
        <span class="tok-kw">const</span> abi = <span class="tok-builtin">@tagName</span>(result.abi);
        <span class="tok-builtin">@memcpy</span>(path_buf[index..][<span class="tok-number">0</span>..prefix.len], prefix);
        index += prefix.len;
        <span class="tok-builtin">@memcpy</span>(path_buf[index..][<span class="tok-number">0</span>..cpu_arch.len], cpu_arch);
        index += cpu_arch.len;
        path_buf[index] = <span class="tok-str">'-'</span>;
        index += <span class="tok-number">1</span>;
        <span class="tok-builtin">@memcpy</span>(path_buf[index..][<span class="tok-number">0</span>..os_tag.len], os_tag);
        index += os_tag.len;
        path_buf[index] = <span class="tok-str">'-'</span>;
        index += <span class="tok-number">1</span>;
        <span class="tok-builtin">@memcpy</span>(path_buf[index..][<span class="tok-number">0</span>..abi.len], abi);
        index += abi.len;
        <span class="tok-kw">const</span> rpath = path_buf[<span class="tok-number">0</span>..index];
        <span class="tok-kw">if</span> (<a href="std.zig.system.html#std.zig.system.glibcVerFromRPath">glibcVerFromRPath</a>(rpath)) |ver| {
            result.os.version_range.linux.glibc = ver;
            <span class="tok-kw">return</span> result;
        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.GLibCNotFound =&gt; {},
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        }
    }

    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">fn</span> <span class="tok-fn">glibcVerFromLinkName</span>(link_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{ UnrecognizedGnuLibCFileName, InvalidGnuLibCVersion }!<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a> {<span class="tok-comment">
    // example: &quot;libc-2.3.4.so&quot;
    // example: &quot;libc-2.27.so&quot;
    // example: &quot;ld-2.33.so&quot;
    </span><span class="tok-kw">const</span> suffix = <span class="tok-str">&quot;.so&quot;</span>;
    <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u8</span>, link_name, prefix) <span class="tok-kw">or</span> !<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.endsWith">endsWith</a>(<span class="tok-type">u8</span>, link_name, suffix)) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnrecognizedGnuLibCFileName;
    }<span class="tok-comment">
    // chop off &quot;libc-&quot; and &quot;.so&quot;
    </span><span class="tok-kw">const</span> link_name_chopped = link_name[prefix.len .. link_name.len - suffix.len];
    <span class="tok-kw">return</span> <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>.<a href="std.Target.Query.html#std.Target.Query.parseVersion">parseVersion</a>(link_name_chopped) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.Overflow =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidGnuLibCVersion,
        <span class="tok-kw">error</span>.InvalidVersion =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidGnuLibCVersion,
    };
}

<span class="tok-kw">test</span> glibcVerFromLinkName {
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.UnrecognizedGnuLibCFileName, <a href="std.zig.system.html#std.zig.system.glibcVerFromLinkName">glibcVerFromLinkName</a>(<span class="tok-str">&quot;ld-2.37.so&quot;</span>, <span class="tok-str">&quot;this-prefix-does-not-exist&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.UnrecognizedGnuLibCFileName, <a href="std.zig.system.html#std.zig.system.glibcVerFromLinkName">glibcVerFromLinkName</a>(<span class="tok-str">&quot;libc-2.37.so-is-not-end&quot;</span>, <span class="tok-str">&quot;libc-&quot;</span>));

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.InvalidGnuLibCVersion, <a href="std.zig.system.html#std.zig.system.glibcVerFromLinkName">glibcVerFromLinkName</a>(<span class="tok-str">&quot;ld-2.so&quot;</span>, <span class="tok-str">&quot;ld-&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a>{ .major = <span class="tok-number">2</span>, .minor = <span class="tok-number">37</span>, .patch = <span class="tok-number">0</span> }, <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.glibcVerFromLinkName">glibcVerFromLinkName</a>(<span class="tok-str">&quot;ld-2.37.so&quot;</span>, <span class="tok-str">&quot;ld-&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a>{ .major = <span class="tok-number">2</span>, .minor = <span class="tok-number">37</span>, .patch = <span class="tok-number">0</span> }, <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.glibcVerFromLinkName">glibcVerFromLinkName</a>(<span class="tok-str">&quot;ld-2.37.0.so&quot;</span>, <span class="tok-str">&quot;ld-&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a>{ .major = <span class="tok-number">2</span>, .minor = <span class="tok-number">37</span>, .patch = <span class="tok-number">1</span> }, <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.glibcVerFromLinkName">glibcVerFromLinkName</a>(<span class="tok-str">&quot;ld-2.37.1.so&quot;</span>, <span class="tok-str">&quot;ld-&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.InvalidGnuLibCVersion, <a href="std.zig.system.html#std.zig.system.glibcVerFromLinkName">glibcVerFromLinkName</a>(<span class="tok-str">&quot;ld-2.37.4.5.so&quot;</span>, <span class="tok-str">&quot;ld-&quot;</span>));
}

<span class="tok-kw">fn</span> <span class="tok-fn">glibcVerFromRPath</span>(rpath: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a> {
    <span class="tok-kw">var</span> dir = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().openDir(rpath, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // WASI only
        </span><span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
        </span><span class="tok-kw">error</span>.BadPathName =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.DeviceBusy =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.NetworkNotFound =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only

        </span><span class="tok-kw">error</span>.FileNotFound,
        <span class="tok-kw">error</span>.NotDir,
        <span class="tok-kw">error</span>.AccessDenied,
        <span class="tok-kw">error</span>.NoDevice,
        =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.GLibCNotFound,

        <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        <span class="tok-kw">error</span>.SystemResources,
        <span class="tok-kw">error</span>.SymLinkLoop,
        <span class="tok-kw">error</span>.Unexpected,
        =&gt; |e| <span class="tok-kw">return</span> e,
    };
    <span class="tok-kw">defer</span> dir.close();<span class="tok-comment">

    // Now we have a candidate for the path to libc shared object. In
    // the past, we used readlink() here because the link name would
    // reveal the glibc version. However, in more recent GNU/Linux
    // installations, there is no symlink. Thus we instead use a more
    // robust check of opening the libc shared object and looking at the
    // .dynstr section, and finding the max version number of symbols
    // that start with &quot;GLIBC_2.&quot;.
    </span><span class="tok-kw">const</span> glibc_so_basename = <span class="tok-str">&quot;libc.so.6&quot;</span>;
    <span class="tok-kw">var</span> f = dir.openFile(glibc_so_basename, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // WASI only
        </span><span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows only
        </span><span class="tok-kw">error</span>.BadPathName =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows only
        </span><span class="tok-kw">error</span>.PipeBusy =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
        </span><span class="tok-kw">error</span>.SharingViolation =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
        </span><span class="tok-kw">error</span>.NetworkNotFound =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
        </span><span class="tok-kw">error</span>.AntivirusInterference =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
        </span><span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // No lock requested.
        </span><span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // read-only
        </span><span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // read-only
        </span><span class="tok-kw">error</span>.DeviceBusy =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // read-only
        </span><span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // read-only
        </span><span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not using O_NONBLOCK
        </span><span class="tok-kw">error</span>.NoDevice =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not asking for a special device

        </span><span class="tok-kw">error</span>.AccessDenied,
        <span class="tok-kw">error</span>.FileNotFound,
        <span class="tok-kw">error</span>.NotDir,
        <span class="tok-kw">error</span>.IsDir,
        =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.GLibCNotFound,

        <span class="tok-kw">error</span>.FileTooBig =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,

        <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        <span class="tok-kw">error</span>.SystemResources,
        <span class="tok-kw">error</span>.SymLinkLoop,
        <span class="tok-kw">error</span>.Unexpected,
        =&gt; |e| <span class="tok-kw">return</span> e,
    };
    <span class="tok-kw">defer</span> f.close();

    <span class="tok-kw">return</span> <a href="std.zig.system.html#std.zig.system.glibcVerFromSoFile">glibcVerFromSoFile</a>(f) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.InvalidElfMagic,
        <span class="tok-kw">error</span>.InvalidElfEndian,
        <span class="tok-kw">error</span>.InvalidElfClass,
        <span class="tok-kw">error</span>.InvalidElfFile,
        <span class="tok-kw">error</span>.InvalidElfVersion,
        <span class="tok-kw">error</span>.InvalidGnuLibCVersion,
        <span class="tok-kw">error</span>.UnexpectedEndOfFile,
        =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.GLibCNotFound,

        <span class="tok-kw">error</span>.SystemResources,
        <span class="tok-kw">error</span>.UnableToReadElfFile,
        <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.FileSystem,
        <span class="tok-kw">error</span>.ProcessNotFound,
        =&gt; |e| <span class="tok-kw">return</span> e,
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">glibcVerFromSoFile</span>(file: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>) !<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a> {
    <span class="tok-kw">var</span> hdr_buf: [<span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Ehdr.html">Elf64_Ehdr</a>)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Ehdr.html">Elf64_Ehdr</a>)) = <span class="tok-null">undefined</span>;
    _ = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(file, &amp;hdr_buf, <span class="tok-number">0</span>, hdr_buf.len);
    <span class="tok-kw">const</span> hdr32: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Ehdr.html">Elf32_Ehdr</a> = <span class="tok-builtin">@ptrCast</span>(&amp;hdr_buf);
    <span class="tok-kw">const</span> hdr64: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Ehdr.html">Elf64_Ehdr</a> = <span class="tok-builtin">@ptrCast</span>(&amp;hdr_buf);
    <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, hdr32.e_ident[<span class="tok-number">0</span>..<span class="tok-number">4</span>], <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.MAGIC">MAGIC</a>)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfMagic;
    <span class="tok-kw">const</span> elf_endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a> = <span class="tok-kw">switch</span> (hdr32.e_ident[<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.EI_DATA">EI_DATA</a>]) {
        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.ELFDATA2LSB">ELFDATA2LSB</a> =&gt; .little,
        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.ELFDATA2MSB">ELFDATA2MSB</a> =&gt; .big,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfEndian,
    };
    <span class="tok-kw">const</span> need_bswap = elf_endian != <a href="std.zig.system.html#std.zig.system.native_endian">native_endian</a>;
    <span class="tok-kw">if</span> (hdr32.e_ident[<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.EI_VERSION">EI_VERSION</a>] != <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfVersion;

    <span class="tok-kw">const</span> is_64 = <span class="tok-kw">switch</span> (hdr32.e_ident[<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.EI_CLASS">EI_CLASS</a>]) {
        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.ELFCLASS32">ELFCLASS32</a> =&gt; <span class="tok-null">false</span>,
        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.ELFCLASS64">ELFCLASS64</a> =&gt; <span class="tok-null">true</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfClass,
    };
    <span class="tok-kw">const</span> shstrndx = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, hdr32.e_shstrndx, hdr64.e_shstrndx);
    <span class="tok-kw">var</span> shoff = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, hdr32.e_shoff, hdr64.e_shoff);
    <span class="tok-kw">const</span> shentsize = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, hdr32.e_shentsize, hdr64.e_shentsize);
    <span class="tok-kw">const</span> str_section_off = shoff + <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, shentsize) * <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, shstrndx);
    <span class="tok-kw">var</span> sh_buf: [<span class="tok-number">16</span> * <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Shdr.html">Elf64_Shdr</a>)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Shdr.html">Elf64_Shdr</a>)) = <span class="tok-null">undefined</span>;
    <span class="tok-kw">if</span> (sh_buf.len &lt; shentsize) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfFile;

    _ = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(file, &amp;sh_buf, str_section_off, shentsize);
    <span class="tok-kw">const</span> shstr32: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Shdr.html">Elf32_Shdr</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;sh_buf));
    <span class="tok-kw">const</span> shstr64: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Shdr.html">Elf64_Shdr</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;sh_buf));
    <span class="tok-kw">const</span> shstrtab_off = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, shstr32.sh_offset, shstr64.sh_offset);
    <span class="tok-kw">const</span> shstrtab_size = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, shstr32.sh_size, shstr64.sh_size);
    <span class="tok-kw">var</span> strtab_buf: [<span class="tok-number">4096</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> shstrtab_len = <span class="tok-builtin">@min</span>(shstrtab_size, strtab_buf.len);
    <span class="tok-kw">const</span> shstrtab_read_len = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(file, &amp;strtab_buf, shstrtab_off, shstrtab_len);
    <span class="tok-kw">const</span> shstrtab = strtab_buf[<span class="tok-number">0</span>..shstrtab_read_len];
    <span class="tok-kw">const</span> shnum = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, hdr32.e_shnum, hdr64.e_shnum);
    <span class="tok-kw">var</span> sh_i: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> dynstr: <span class="tok-kw">struct</span> { offset: <span class="tok-type">u64</span>, size: <span class="tok-type">u64</span> } = find_dyn_str: <span class="tok-kw">while</span> (sh_i &lt; shnum) {<span class="tok-comment">
        // Reserve some bytes so that we can deref the 64-bit struct fields
        // even when the ELF file is 32-bits.
        </span><span class="tok-kw">const</span> sh_reserve: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Shdr.html">Elf64_Shdr</a>) - <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Shdr.html">Elf32_Shdr</a>);
        <span class="tok-kw">const</span> sh_read_byte_len = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(
            file,
            sh_buf[<span class="tok-number">0</span> .. sh_buf.len - sh_reserve],
            shoff,
            shentsize,
        );
        <span class="tok-kw">var</span> sh_buf_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (sh_buf_i &lt; sh_read_byte_len <span class="tok-kw">and</span> sh_i &lt; shnum) : ({
            sh_i += <span class="tok-number">1</span>;
            shoff += shentsize;
            sh_buf_i += shentsize;
        }) {
            <span class="tok-kw">const</span> sh32: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf32_Shdr.html">Elf32_Shdr</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;sh_buf[sh_buf_i]));
            <span class="tok-kw">const</span> sh64: *<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Shdr.html">Elf64_Shdr</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;sh_buf[sh_buf_i]));
            <span class="tok-kw">const</span> sh_name_off = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, sh32.sh_name, sh64.sh_name);
            <span class="tok-kw">const</span> sh_name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(shstrtab[sh_name_off..], <span class="tok-number">0</span>);
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, sh_name, <span class="tok-str">&quot;.dynstr&quot;</span>)) {
                <span class="tok-kw">break</span> :find_dyn_str .{
                    .offset = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, sh32.sh_offset, sh64.sh_offset),
                    .size = <a href="std.zig.system.html#std.zig.system.elfInt">elfInt</a>(is_64, need_bswap, sh32.sh_size, sh64.sh_size),
                };
            }
        }
    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidGnuLibCVersion;<span class="tok-comment">

    // Here we loop over all the strings in the dynstr string table, assuming that any
    // strings that start with &quot;GLIBC_2.&quot; indicate the existence of such a glibc version,
    // and furthermore, that the system-installed glibc is at minimum that version.

    // Empirically, glibc 2.34 libc.so .dynstr section is 32441 bytes on my system.
    // Here I use double this value plus some headroom. This makes it only need
    // a single read syscall here.
    </span><span class="tok-kw">var</span> buf: [<span class="tok-number">80000</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">if</span> (buf.len &lt; dynstr.size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidGnuLibCVersion;

    <span class="tok-kw">const</span> dynstr_size: <span class="tok-type">usize</span> = <span class="tok-builtin">@intCast</span>(dynstr.size);
    <span class="tok-kw">const</span> dynstr_bytes = buf[<span class="tok-number">0</span>..dynstr_size];
    _ = <span class="tok-kw">try</span> <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(file, dynstr_bytes, dynstr.offset, dynstr_bytes.len);
    <span class="tok-kw">var</span> it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(<span class="tok-type">u8</span>, dynstr_bytes, <span class="tok-number">0</span>);
    <span class="tok-kw">var</span> max_ver: <a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a> = .{ .major = <span class="tok-number">2</span>, .minor = <span class="tok-number">2</span>, .patch = <span class="tok-number">5</span> };
    <span class="tok-kw">while</span> (it.next()) |s| {
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u8</span>, s, <span class="tok-str">&quot;GLIBC_2.&quot;</span>)) {
            <span class="tok-kw">const</span> chopped = s[<span class="tok-str">&quot;GLIBC_&quot;</span>.len..];
            <span class="tok-kw">const</span> ver = <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>.<a href="std.Target.Query.html#std.Target.Query.parseVersion">parseVersion</a>(chopped) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.Overflow =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidGnuLibCVersion,
                <span class="tok-kw">error</span>.InvalidVersion =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidGnuLibCVersion,
            };
            <span class="tok-kw">switch</span> (ver.order(max_ver)) {
                .gt =&gt; max_ver = ver,
                .lt, .eq =&gt; <span class="tok-kw">continue</span>,
            }
        }
    }
    <span class="tok-kw">return</span> max_ver;
}

<span class="tok-comment">/// In the past, this function attempted to use the executable's own binary if it was dynamically</span>
<span class="tok-comment">/// linked to answer both the C ABI question and the dynamic linker question. However, this</span>
<span class="tok-comment">/// could be problematic on a system that uses a RUNPATH for the compiler binary, locking</span>
<span class="tok-comment">/// it to an older glibc version, while system binaries such as /usr/bin/env use a newer glibc</span>
<span class="tok-comment">/// version. The problem is that libc.so.6 glibc version will match that of the system while</span>
<span class="tok-comment">/// the dynamic linker will match that of the compiler binary. Executables with these versions</span>
<span class="tok-comment">/// mismatching will fail to run.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Therefore, this function works the same regardless of whether the compiler binary is</span>
<span class="tok-comment">/// dynamically or statically linked. It inspects `/usr/bin/env` as an ELF file to find the</span>
<span class="tok-comment">/// answer to these questions, or if there is a shebang line, then it chases the referenced</span>
<span class="tok-comment">/// file recursively. If that does not provide the answer, then the function falls back to</span>
<span class="tok-comment">/// defaults.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">detectAbiAndDynamicLinker</span>(
    cpu: <a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>,
    os: <a href="std.Target.html">Target</a>.<a href="std.Target.Os.html">Os</a>,
    query: <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>,
) <a href="std.zig.system.html#std.zig.system.DetectError">DetectError</a>!<a href="std.Target.html">Target</a> {
    <span class="tok-kw">const</span> native_target_has_ld = <span class="tok-kw">comptime</span> <a href="std.Target.html">Target</a>.<a href="std.Target.DynamicLinker.html">DynamicLinker</a>.<a href="std.Target.DynamicLinker.html#std.Target.DynamicLinker.kind">kind</a>(<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) != .none;
    <span class="tok-kw">const</span> is_linux = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a> == .linux;
    <span class="tok-kw">const</span> is_solarish = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a>.<a href="#">isSolarish</a>();
    <span class="tok-kw">const</span> is_darwin = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a>.<a href="#">isDarwin</a>();
    <span class="tok-kw">const</span> have_all_info = query.dynamic_linker.get() != <span class="tok-null">null</span> <span class="tok-kw">and</span>
        query.abi != <span class="tok-null">null</span> <span class="tok-kw">and</span> (!is_linux <span class="tok-kw">or</span> query.abi.?.isGnu());
    <span class="tok-kw">const</span> os_is_non_native = query.os_tag != <span class="tok-null">null</span>;<span class="tok-comment">
    // The Solaris/illumos environment is always the same.
    </span><span class="tok-kw">if</span> (!native_target_has_ld <span class="tok-kw">or</span> have_all_info <span class="tok-kw">or</span> os_is_non_native <span class="tok-kw">or</span> is_solarish <span class="tok-kw">or</span> is_darwin) {
        <span class="tok-kw">return</span> <a href="std.zig.system.html#std.zig.system.defaultAbiAndDynamicLinker">defaultAbiAndDynamicLinker</a>(cpu, os, query);
    }
    <span class="tok-kw">if</span> (query.abi) |abi| {
        <span class="tok-kw">if</span> (abi.isMusl()) {<span class="tok-comment">
            // musl implies static linking.
            </span><span class="tok-kw">return</span> <a href="std.zig.system.html#std.zig.system.defaultAbiAndDynamicLinker">defaultAbiAndDynamicLinker</a>(cpu, os, query);
        }
    }<span class="tok-comment">
    // The current target's ABI cannot be relied on for this. For example, we may build the zig
    // compiler for target riscv64-linux-musl and provide a tarball for users to download.
    // A user could then run that zig compiler on riscv64-linux-gnu. This use case is well-defined
    // and supported by Zig. But that means that we must detect the system ABI here rather than
    // relying on `builtin.target`.
    </span><span class="tok-kw">const</span> all_abis = <span class="tok-kw">comptime</span> blk: {
        <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@intFromEnum</span>(<a href="std.Target.html">Target</a>.<a href="std.Target.Abi.html">Abi</a>.<a href="#">none</a>) == <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> fields = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(<a href="std.Target.html">Target</a>.<a href="std.Target.Abi.html">Abi</a>)[<span class="tok-number">1</span>..];
        <span class="tok-kw">var</span> array: [fields.len]<a href="std.Target.html">Target</a>.<a href="std.Target.Abi.html">Abi</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">for</span> (fields, <span class="tok-number">0</span>..) |field, i| {
            array[i] = <span class="tok-builtin">@field</span>(<a href="std.Target.html">Target</a>.<a href="std.Target.Abi.html">Abi</a>, field.name);
        }
        <span class="tok-kw">break</span> :blk array;
    };
    <span class="tok-kw">var</span> ld_info_list_buffer: [all_abis.len]<a href="std.zig.system.LdInfo.html">LdInfo</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> ld_info_list_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">switch</span> (<a href="std.Target.html">Target</a>.<a href="std.Target.DynamicLinker.html">DynamicLinker</a>.<a href="std.Target.DynamicLinker.html#std.Target.DynamicLinker.kind">kind</a>(os.tag)) {<span class="tok-comment">
        // The OS has no dynamic linker. Leave the list empty and rely on `Abi.default()` to pick
        // something sensible in `abiAndDynamicLinkerFromFile()`.
        </span>.none =&gt; {},<span class="tok-comment">
        // The OS has a system-wide dynamic linker. Unfortunately, this implies that there's no
        // useful ABI information that we can glean from it merely being present. That means the
        // best we can do for this case (for now) is also `Abi.default()`.
        </span>.arch_os =&gt; {},<span class="tok-comment">
        // The OS can have different dynamic linker paths depending on libc/ABI. In this case, we
        // need to gather all the valid arch/OS/ABI combinations. `abiAndDynamicLinkerFromFile()`
        // will then look for a dynamic linker with a matching path on the system and pick the ABI
        // we associated it with here.
        </span>.arch_os_abi =&gt; <span class="tok-kw">for</span> (all_abis) |abi| {
            <span class="tok-kw">const</span> ld = <a href="std.Target.html">Target</a>.<a href="std.Target.DynamicLinker.html">DynamicLinker</a>.<a href="std.Target.DynamicLinker.html#std.Target.DynamicLinker.standard">standard</a>(cpu, os, abi);<span class="tok-comment">

            // Does the generated target triple actually have a standard dynamic linker path?
            </span><span class="tok-kw">if</span> (ld.get() == <span class="tok-null">null</span>) <span class="tok-kw">continue</span>;

            ld_info_list_buffer[ld_info_list_len] = .{
                .ld = ld,
                .abi = abi,
            };
            ld_info_list_len += <span class="tok-number">1</span>;
        },
    }

    <span class="tok-kw">const</span> ld_info_list = ld_info_list_buffer[<span class="tok-number">0</span>..ld_info_list_len];<span class="tok-comment">

    // Best case scenario: the executable is dynamically linked, and we can iterate
    // over our own shared objects and find a dynamic linker.
    </span><span class="tok-kw">const</span> elf_file = elf_file: {<span class="tok-comment">
        // This block looks for a shebang line in /usr/bin/env,
        // if it finds one, then instead of using /usr/bin/env as the ELF file to examine, it uses the file it references instead,
        // doing the same logic recursively in case it finds another shebang line.

        </span><span class="tok-kw">var</span> file_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-kw">switch</span> (os.tag) {<span class="tok-comment">
            // Since /usr/bin/env is hard-coded into the shebang line of many portable scripts, it's a
            // reasonably reliable path to start with.
            </span><span class="tok-kw">else</span> =&gt; <span class="tok-str">&quot;/usr/bin/env&quot;</span>,<span class="tok-comment">
            // Haiku does not have a /usr root directory.
            </span>.haiku =&gt; <span class="tok-str">&quot;/bin/env&quot;</span>,
        };<span class="tok-comment">

        // According to `man 2 execve`:
        //
        // The kernel imposes a maximum length on the text
        // that follows the &quot;#!&quot; characters at the start of a script;
        // characters beyond the limit are ignored.
        // Before Linux 5.1, the limit is 127 characters.
        // Since Linux 5.1, the limit is 255 characters.
        //
        // Tests show that bash and zsh consider 255 as total limit,
        // *including* &quot;#!&quot; characters and ignoring newline.
        // For safety, we set max length as 255 + \n (1).
        </span><span class="tok-kw">var</span> buffer: [<span class="tok-number">255</span> + <span class="tok-number">1</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment">
            // Interpreter path can be relative on Linux, but
            // for simplicity we are asserting it is an absolute path.
            </span><span class="tok-kw">const</span> file = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.openFileAbsolute">openFileAbsolute</a>(file_name, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.SharingViolation =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // WASI only
                </span><span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows only
                </span><span class="tok-kw">error</span>.BadPathName =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.PipeBusy =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // opened without write permissions
                </span><span class="tok-kw">error</span>.AntivirusInterference =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only error

                </span><span class="tok-kw">error</span>.IsDir,
                <span class="tok-kw">error</span>.NotDir,
                <span class="tok-kw">error</span>.AccessDenied,
                <span class="tok-kw">error</span>.NoDevice,
                <span class="tok-kw">error</span>.FileNotFound,
                <span class="tok-kw">error</span>.NetworkNotFound,
                <span class="tok-kw">error</span>.FileTooBig,
                <span class="tok-kw">error</span>.Unexpected,
                =&gt; |e| {
                    <a href="std.html">std</a>.<a href="std.log.html">log</a>.<a href="std.log.html#std.log.warn">warn</a>(<span class="tok-str">&quot;Encountered error: {s}, falling back to default ABI and dynamic linker.&quot;</span>, .{<span class="tok-builtin">@errorName</span>(e)});
                    <span class="tok-kw">return</span> <a href="std.zig.system.html#std.zig.system.defaultAbiAndDynamicLinker">defaultAbiAndDynamicLinker</a>(cpu, os, query);
                },

                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };
            <span class="tok-kw">var</span> is_elf_file = <span class="tok-null">false</span>;
            <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (is_elf_file == <span class="tok-null">false</span>) file.close();<span class="tok-comment">

            // Shortest working interpreter path is &quot;#!/i&quot; (4)
            // (interpreter is &quot;/i&quot;, assuming all paths are absolute, like in above comment).
            // ELF magic number length is also 4.
            //
            // If file is shorter than that, it is definitely not ELF file
            // nor file with &quot;shebang&quot; line.
            </span><span class="tok-kw">const</span> min_len: <span class="tok-type">usize</span> = <span class="tok-number">4</span>;

            <span class="tok-kw">const</span> len = <a href="std.zig.system.html#std.zig.system.preadAtLeast">preadAtLeast</a>(file, &amp;buffer, <span class="tok-number">0</span>, min_len) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.UnexpectedEndOfFile,
                <span class="tok-kw">error</span>.UnableToReadElfFile,
                <span class="tok-kw">error</span>.ProcessNotFound,
                =&gt; <span class="tok-kw">return</span> <a href="std.zig.system.html#std.zig.system.defaultAbiAndDynamicLinker">defaultAbiAndDynamicLinker</a>(cpu, os, query),

                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };
            <span class="tok-kw">const</span> content = buffer[<span class="tok-number">0</span>..len];

            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, content[<span class="tok-number">0</span>..<span class="tok-number">4</span>], <a href="std.html">std</a>.<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.MAGIC">MAGIC</a>)) {<span class="tok-comment">
                // It is very likely ELF file!
                </span>is_elf_file = <span class="tok-null">true</span>;
                <span class="tok-kw">break</span> :elf_file file;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, content[<span class="tok-number">0</span>..<span class="tok-number">2</span>], <span class="tok-str">&quot;#!&quot;</span>)) {<span class="tok-comment">
                // We detected shebang, now parse entire line.

                // Trim leading &quot;#!&quot;, spaces and tabs.
                </span><span class="tok-kw">const</span> trimmed_line = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trimLeft">trimLeft</a>(<span class="tok-type">u8</span>, content[<span class="tok-number">2</span>..], &amp;.{ <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span> });<span class="tok-comment">

                // This line can have:
                // * Interpreter path only,
                // * Interpreter path and arguments, all separated by space, tab or NUL character.
                // And optionally newline at the end.
                </span><span class="tok-kw">const</span> path_maybe_args = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trimRight">trimRight</a>(<span class="tok-type">u8</span>, trimmed_line, <span class="tok-str">&quot;\n&quot;</span>);<span class="tok-comment">

                // Separate path and args.
                </span><span class="tok-kw">const</span> path_end = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfAny">indexOfAny</a>(<span class="tok-type">u8</span>, path_maybe_args, &amp;.{ <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span>, <span class="tok-number">0</span> }) <span class="tok-kw">orelse</span> path_maybe_args.len;

                file_name = path_maybe_args[<span class="tok-number">0</span>..path_end];
                <span class="tok-kw">continue</span>;
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // Not a ELF file, not a shell script with &quot;shebang line&quot;, invalid duck.
                </span><span class="tok-kw">return</span> <a href="std.zig.system.html#std.zig.system.defaultAbiAndDynamicLinker">defaultAbiAndDynamicLinker</a>(cpu, os, query);
            }
        }
    };
    <span class="tok-kw">defer</span> elf_file.close();<span class="tok-comment">

    // TODO: inline this function and combine the buffer we already read above to find
    // the possible shebang line with the buffer we use for the ELF header.
    </span><span class="tok-kw">return</span> <a href="std.zig.system.html#std.zig.system.abiAndDynamicLinkerFromFile">abiAndDynamicLinkerFromFile</a>(elf_file, cpu, os, ld_info_list, query) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.FileSystem,
        <span class="tok-kw">error</span>.SystemResources,
        <span class="tok-kw">error</span>.SymLinkLoop,
        <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        <span class="tok-kw">error</span>.ProcessNotFound,
        =&gt; |e| <span class="tok-kw">return</span> e,

        <span class="tok-kw">error</span>.UnableToReadElfFile,
        <span class="tok-kw">error</span>.InvalidElfClass,
        <span class="tok-kw">error</span>.InvalidElfVersion,
        <span class="tok-kw">error</span>.InvalidElfEndian,
        <span class="tok-kw">error</span>.InvalidElfFile,
        <span class="tok-kw">error</span>.InvalidElfMagic,
        <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.UnexpectedEndOfFile,
        <span class="tok-kw">error</span>.NameTooLong,<span class="tok-comment">
        // Finally, we fall back on the standard path.
        </span>=&gt; |e| {
            <a href="std.html">std</a>.<a href="std.log.html">log</a>.<a href="std.log.html#std.log.warn">warn</a>(<span class="tok-str">&quot;Encountered error: {s}, falling back to default ABI and dynamic linker.&quot;</span>, .{<span class="tok-builtin">@errorName</span>(e)});
            <span class="tok-kw">return</span> <a href="std.zig.system.html#std.zig.system.defaultAbiAndDynamicLinker">defaultAbiAndDynamicLinker</a>(cpu, os, query);
        },
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">defaultAbiAndDynamicLinker</span>(cpu: <a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>, os: <a href="std.Target.html">Target</a>.<a href="std.Target.Os.html">Os</a>, query: <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>) <a href="std.Target.html">Target</a> {
    <span class="tok-kw">const</span> abi = query.abi <span class="tok-kw">orelse</span> <a href="std.Target.html">Target</a>.<a href="std.Target.Abi.html">Abi</a>.<a href="std.Target.Abi.html#std.Target.Abi.default">default</a>(cpu.arch, os);
    <span class="tok-kw">return</span> .{
        .cpu = cpu,
        .os = os,
        .abi = abi,
        .ofmt = query.ofmt <span class="tok-kw">orelse</span> <a href="std.Target.html">Target</a>.<a href="std.Target.ObjectFormat.html">ObjectFormat</a>.<a href="std.Target.ObjectFormat.html#std.Target.ObjectFormat.default">default</a>(os.tag, cpu.arch),
        .dynamic_linker = <span class="tok-kw">if</span> (query.dynamic_linker.get() == <span class="tok-null">null</span>)
            <a href="std.Target.html">Target</a>.<a href="std.Target.DynamicLinker.html">DynamicLinker</a>.<a href="std.Target.DynamicLinker.html#std.Target.DynamicLinker.standard">standard</a>(cpu, os, abi)
        <span class="tok-kw">else</span>
            query.dynamic_linker,
    };
}

<span class="tok-kw">const</span> LdInfo = <span class="tok-kw">struct</span> {
    ld: <a href="std.Target.html">Target</a>.<a href="std.Target.DynamicLinker.html">DynamicLinker</a>,
    abi: <a href="std.Target.html">Target</a>.<a href="std.Target.Abi.html">Abi</a>,
};

<span class="tok-kw">fn</span> <span class="tok-fn">preadAtLeast</span>(file: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>, buf: []<span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>, min_read_len: <span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; min_read_len) {
        <span class="tok-kw">const</span> len = file.pread(buf[i..], offset + i) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.OperationAborted =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
            </span><span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Did not request blocking mode
            </span><span class="tok-kw">error</span>.Canceled =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // timerfd is unseekable
            </span><span class="tok-kw">error</span>.NotOpenForReading =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.SystemResources =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReadElfFile,
            <span class="tok-kw">error</span>.BrokenPipe =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReadElfFile,
            <span class="tok-kw">error</span>.Unseekable =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReadElfFile,
            <span class="tok-kw">error</span>.ConnectionResetByPeer =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReadElfFile,
            <span class="tok-kw">error</span>.ConnectionTimedOut =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReadElfFile,
            <span class="tok-kw">error</span>.SocketNotConnected =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReadElfFile,
            <span class="tok-kw">error</span>.Unexpected =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
            <span class="tok-kw">error</span>.InputOutput =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
            <span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
            <span class="tok-kw">error</span>.ProcessNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            <span class="tok-kw">error</span>.LockViolation =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReadElfFile,
        };
        <span class="tok-kw">if</span> (len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfFile;
        i += len;
    }
    <span class="tok-kw">return</span> i;
}

<span class="tok-kw">fn</span> <span class="tok-fn">elfInt</span>(is_64: <span class="tok-type">bool</span>, need_bswap: <span class="tok-type">bool</span>, int_32: <span class="tok-kw">anytype</span>, int_64: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(int_64) {
    <span class="tok-kw">if</span> (is_64) {
        <span class="tok-kw">if</span> (need_bswap) {
            <span class="tok-kw">return</span> <span class="tok-builtin">@byteSwap</span>(int_64);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> int_64;
        }
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">if</span> (need_bswap) {
            <span class="tok-kw">return</span> <span class="tok-builtin">@byteSwap</span>(int_32);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> int_32;
        }
    }
}

<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../std.zig&quot;</span>);
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> elf = <a href="std.html">std</a>.<a href="std.elf.html">elf</a>;
<span class="tok-kw">const</span> fs = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> Target = <a href="std.html">std</a>.<a href="std.Target.html">Target</a>;
<span class="tok-kw">const</span> native_endian = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>.<a href="#">endian</a>();
<span class="tok-kw">const</span> posix = <a href="std.html">std</a>.<a href="std.posix.html">posix</a>;

<span class="tok-kw">test</span> {
    _ = <a href="std.zig.system.NativePaths.html">NativePaths</a>;

    _ = <a href="std.zig.system.darwin.html">darwin</a>;
    _ = <a href="std.zig.system.linux.html">linux</a>;
    _ = <a href="std.zig.system.windows.html">windows</a>;
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
