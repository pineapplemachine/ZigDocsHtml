<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">Build</a></li><li><a href="std.Build.html" class="">Step</a></li><li><a href="std.Build.Step.Compile.html" class="active">Compile</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.Build.Step.Compile" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.Build.Step.Compile</span><a href="#src.zig-std.Build.Step.Compile">[src]</a></h1><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.Build.Step.Compile.ExpectedCompileErrors.html">std.Build.Step.Compile.ExpectedCompileErrors</a></li><li><a href="std.Build.Step.Compile.Entry.html">std.Build.Step.Compile.Entry</a></li><li><a href="std.Build.Step.Compile.Options.html">std.Build.Step.Compile.Options</a></li><li><a href="std.Build.Step.Compile.Kind.html">std.Build.Step.Compile.Kind</a></li><li><a href="std.Build.Step.Compile.HeaderInstallation.html">std.Build.Step.Compile.HeaderInstallation</a></li><li><a href="std.Build.Step.Compile.TestRunner.html">std.Build.Step.Compile.TestRunner</a></li></ul></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>step: <a href="std.Build.Step.html">Step</a></code></pre></div><div><pre><code>root_module: *<a href="std.Build.Module.html">Module</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>linker_script: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span></code></pre></div><div><pre><code>version_script: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span></code></pre></div><div><pre><code>out_filename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>out_lib_filename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>linkage: ?<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.LinkMode.html">LinkMode</a> = <span class="tok-null">null</span></code></pre></div><div><pre><code>version: ?<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a></code></pre></div><div><pre><code>kind: <a href="std.Build.Step.Compile.Kind.html">Kind</a></code></pre></div><div><pre><code>major_only_filename: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>name_only_filename: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>formatted_panics: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span></code></pre></div><div><pre><code>compress_debug_sections: <span class="tok-kw">enum</span> { none, zlib, zstd } = .none</code></pre></div><div><pre><code>verbose_link: <span class="tok-type">bool</span></code></pre></div><div><pre><code>verbose_cc: <span class="tok-type">bool</span></code></pre></div><div><pre><code>bundle_compiler_rt: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span></code></pre></div><div><pre><code>bundle_ubsan_rt: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span></code></pre></div><div><pre><code>rdynamic: <span class="tok-type">bool</span></code></pre></div><div><pre><code>import_memory: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre></div><div><pre><code>export_memory: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre></div><div><pre><code>import_symbols: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>For WebAssembly targets, this will allow for undefined symbols to
be imported from the host environment.</p>
</div></div><div><pre><code>import_table: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre></div><div><pre><code>export_table: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre></div><div><pre><code>initial_memory: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span></code></pre></div><div><pre><code>max_memory: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span></code></pre></div><div><pre><code>shared_memory: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre></div><div><pre><code>global_base: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span></code></pre></div><div><pre><code>zig_lib_dir: ?<a href="std.Build.LazyPath.html">LazyPath</a></code></pre><div class="fieldDocs"><p>Set via options; intended to be read-only after that.</p>
</div></div><div><pre><code>exec_cmd_args: ?[]<span class="tok-kw">const</span> ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>filters: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>test_runner: ?<a href="std.Build.Step.Compile.TestRunner.html">TestRunner</a></code></pre></div><div><pre><code>wasi_exec_model: ?<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.WasiExecModel.html">WasiExecModel</a> = <span class="tok-null">null</span></code></pre></div><div><pre><code>installed_headers: <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.Step.Compile.HeaderInstallation.html">HeaderInstallation</a>)</code></pre></div><div><pre><code>installed_headers_include_tree: ?*<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.WriteFile.html">WriteFile</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>This step is used to create an include tree that dependent modules can add to their include
search paths. Installed headers are copied to this step.
This step is created the first time a module links with this artifact and is not
created otherwise.</p>
</div></div><div><pre><code>rc_includes: <span class="tok-kw">enum</span> { any, msvc, gnu, none } = .any</code></pre><div class="fieldDocs"><p>Behavior of automatic detection of include directories when compiling .rc files.
any: Use MSVC if available, fall back to MinGW.
msvc: Use MSVC include paths (must be present on the system).
gnu: Use MinGW include paths (distributed with Zig).
none: Do not use any autodetected include paths.</p>
</div></div><div><pre><code>win32_manifest: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>(Windows) .manifest file to embed in the compilation
Set via options; intended to be read-only after that.</p>
</div></div><div><pre><code>installed_path: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>image_base: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>Base address for an executable image.</p>
</div></div><div><pre><code>libc_file: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span></code></pre></div><div><pre><code>each_lib_rpath: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span></code></pre></div><div><pre><code>build_id: ?<a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.BuildId.html">BuildId</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>On ELF targets, this will emit a link section called &quot;.note.gnu.build-id&quot;
which can be used to coordinate a stripped binary with its debug symbols.
As an example, the bloaty project refuses to work unless its inputs have
build ids, in order to prevent accidental mismatches.
The default is to not include this section because it slows down linking.</p>
</div></div><div><pre><code>link_eh_frame_hdr: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>Create a .eh_frame_hdr section and a PT_GNU_EH_FRAME segment in the ELF
file.</p>
</div></div><div><pre><code>link_emit_relocs: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre></div><div><pre><code>link_function_sections: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>Place every function in its own section so that unused ones may be
safely garbage-collected during the linking phase.</p>
</div></div><div><pre><code>link_data_sections: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>Place every data in its own section so that unused ones may be
safely garbage-collected during the linking phase.</p>
</div></div><div><pre><code>link_gc_sections: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>Remove functions and data that are unreachable by the entry point or
exported symbols.</p>
</div></div><div><pre><code>linker_dynamicbase: <span class="tok-type">bool</span> = <span class="tok-null">true</span></code></pre><div class="fieldDocs"><p>(Windows) Whether or not to enable ASLR. Maps to the /DYNAMICBASE[:NO] linker argument.</p>
</div></div><div><pre><code>linker_allow_shlib_undefined: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span></code></pre></div><div><pre><code>linker_allow_undefined_version: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>Allow version scripts to refer to undefined symbols.</p>
</div></div><div><pre><code>linker_enable_new_dtags: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span></code></pre></div><div><pre><code>link_z_notext: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>Permit read-only relocations in read-only segments. Disallowed by default.</p>
</div></div><div><pre><code>link_z_relro: <span class="tok-type">bool</span> = <span class="tok-null">true</span></code></pre><div class="fieldDocs"><p>Force all relocations to be read-only after processing.</p>
</div></div><div><pre><code>link_z_lazy: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>Allow relocations to be lazily processed after load.</p>
</div></div><div><pre><code>link_z_common_page_size: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>Common page size</p>
</div></div><div><pre><code>link_z_max_page_size: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>Maximum page size</p>
</div></div><div><pre><code>install_name: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>(Darwin) Install name for the dylib</p>
</div></div><div><pre><code>entitlements: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>(Darwin) Path to entitlements file</p>
</div></div><div><pre><code>pagezero_size: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>(Darwin) Size of the pagezero segment.</p>
</div></div><div><pre><code>headerpad_size: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>(Darwin) Set size of the padding between the end of load commands
and start of <code>__TEXT,__text</code> section.</p>
</div></div><div><pre><code>headerpad_max_install_names: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>(Darwin) Automatically Set size of the padding between the end of load commands
and start of <code>__TEXT,__text</code> section to a value fitting all paths expanded to MAXPATHLEN.</p>
</div></div><div><pre><code>dead_strip_dylibs: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>(Darwin) Remove dylibs that are unreachable by the entry point or exported symbols.</p>
</div></div><div><pre><code>force_load_objc: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>(Darwin) Force load all members of static archives that implement an Objective-C class or category</p>
</div></div><div><pre><code>discard_local_symbols: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>Whether local symbols should be discarded from the symbol table.</p>
</div></div><div><pre><code>pie: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>Position Independent Executable</p>
</div></div><div><pre><code>dll_export_fns: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span></code></pre></div><div><pre><code>subsystem: ?<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.SubSystem.html">SubSystem</a> = <span class="tok-null">null</span></code></pre></div><div><pre><code>mingw_unicode_entry_point: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>(Windows) When targeting the MinGW ABI, use the unicode entry point (wmain/wWinMain)</p>
</div></div><div><pre><code>entry: <a href="std.Build.Step.Compile.Entry.html">Entry</a> = .default</code></pre><div class="fieldDocs"><p>How the linker must handle the entry point of the executable.</p>
</div></div><div><pre><code>force_undefined_symbols: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.StringHashMap">StringHashMap</a>(<span class="tok-type">void</span>)</code></pre><div class="fieldDocs"><p>List of symbols forced as undefined in the symbol table
thus forcing their resolution by the linker.
Corresponds to <code>-u &lt;symbol&gt;</code> for ELF/MachO and <code>/include:&lt;symbol&gt;</code> for COFF/PE.</p>
</div></div><div><pre><code>stack_size: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>Overrides the default stack size</p>
</div></div><div><pre><code>want_lto: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span></code></pre></div><div><pre><code>use_llvm: ?<span class="tok-type">bool</span></code></pre></div><div><pre><code>use_lld: ?<span class="tok-type">bool</span></code></pre></div><div><pre><code>allow_so_scripts: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>Corresponds to the <code>-fallow-so-scripts</code> / <code>-fno-allow-so-scripts</code> CLI
flags, overriding the global user setting provided to the <code>zig build</code>
command.</p>
<p>The compiler defaults this value to off so that users whose system shared
libraries are all ELF files don't have to pay the cost of checking every
file to find out if it is a text file instead.</p>
</div></div><div><pre><code>expect_errors: ?<a href="std.Build.Step.Compile.ExpectedCompileErrors.html">ExpectedCompileErrors</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>This is an advanced setting that can change the intent of this Compile step.
If this value is non-null, it means that this Compile step exists to
check for compile errors and return <em>success</em> if they match, and failure
otherwise.</p>
</div></div><div><pre><code>emit_directory: ?*<a href="std.Build.GeneratedFile.html">GeneratedFile</a></code></pre></div><div><pre><code>generated_docs: ?*<a href="std.Build.GeneratedFile.html">GeneratedFile</a></code></pre></div><div><pre><code>generated_asm: ?*<a href="std.Build.GeneratedFile.html">GeneratedFile</a></code></pre></div><div><pre><code>generated_bin: ?*<a href="std.Build.GeneratedFile.html">GeneratedFile</a></code></pre></div><div><pre><code>generated_pdb: ?*<a href="std.Build.GeneratedFile.html">GeneratedFile</a></code></pre></div><div><pre><code>generated_implib: ?*<a href="std.Build.GeneratedFile.html">GeneratedFile</a></code></pre></div><div><pre><code>generated_llvm_bc: ?*<a href="std.Build.GeneratedFile.html">GeneratedFile</a></code></pre></div><div><pre><code>generated_llvm_ir: ?*<a href="std.Build.GeneratedFile.html">GeneratedFile</a></code></pre></div><div><pre><code>generated_h: ?*<a href="std.Build.GeneratedFile.html">GeneratedFile</a></code></pre></div><div><pre><code>error_limit: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>The maximum number of distinct errors within a compilation step
Defaults to <code>std.math.maxInt(u16)</code></p>
</div></div><div><pre><code>is_linking_libc: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>Computed during make().</p>
</div></div><div><pre><code>is_linking_libcpp: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>Computed during make().</p>
</div></div><div><pre><code>no_builtin: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre></div><div><pre><code>zig_process: ?*<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ZigProcess.html">ZigProcess</a></code></pre><div class="fieldDocs"><p>Populated during the make phase when there is a long-lived compiler process.
Managed by the build runner, not user build script.</p>
</div></div><div><pre><code>sanitize_coverage_trace_pc_guard: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>Enables coverage instrumentation that is only useful if you are using third
party fuzzers that depend on it. Otherwise, slows down the instrumented
binary with unnecessary function calls.</p>
<p>This kind of coverage instrumentation is used by AFLplusplus v4.21c,
however, modern fuzzers - including Zig - have switched to using &quot;inline
8-bit counters&quot; or &quot;inline bool flag&quot; which incurs only a single
instruction for coverage, along with &quot;trace cmp&quot; which instruments
comparisons and reports the operands.</p>
<p>To instead enable fuzz testing instrumentation on a compilation using Zig's
builtin fuzzer, see the <code>fuzz</code> flag in <code><a href="std.Build.Module.html">Module</a></code>.</p>
</div></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.Build.Step.Compile.base_id" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">base_id</span><a href="#src.zig-std.Build.Step.Compile.base_id">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.base_id">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> base_id: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Id.html">Id</a> = .compile</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.Build.Step.Compile.create" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">create</span><a href="#src.zig-std.Build.Step.Compile.create">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(owner: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>, options: <a href="std.Build.Step.Compile.Options.html">Options</a>) *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>owner: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>options: <a href="std.Build.Step.Compile.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.create">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(owner: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>, options: <a href="std.Build.Step.Compile.Options.html">Options</a>) *<a href="std.Build.Step.Compile.html">Compile</a> {
    <span class="tok-kw">const</span> name = owner.dupe(options.name);
    <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;/&quot;</span>) != <span class="tok-null">null</span> <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;\\&quot;</span>) != <span class="tok-null">null</span>) {
        <a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;invalid name: '{s}'. It looks like a file path, but it is supposed to be the library or application name.&quot;</span>, .{name});
    }<span class="tok-comment">

    // Avoid the common case of the step name looking like &quot;zig test test&quot;.
    </span><span class="tok-kw">const</span> name_adjusted = <span class="tok-kw">if</span> (options.kind == .@&quot;test&quot; <span class="tok-kw">and</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;test&quot;</span>))
        <span class="tok-str">&quot;&quot;</span>
    <span class="tok-kw">else</span>
        owner.fmt(<span class="tok-str">&quot;{s} &quot;</span>, .{name});

    <span class="tok-kw">const</span> resolved_target = options.root_module.resolved_target <span class="tok-kw">orelse</span>
        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;the root Module of a Compile step must be created with a known 'target' field&quot;</span>);
    <span class="tok-kw">const</span> target = resolved_target.result;

    <span class="tok-kw">const</span> step_name = owner.fmt(<span class="tok-str">&quot;{s} {s}{s} {s}&quot;</span>, .{
        <span class="tok-kw">switch</span> (options.kind) {
            .exe =&gt; <span class="tok-str">&quot;zig build-exe&quot;</span>,
            .lib =&gt; <span class="tok-str">&quot;zig build-lib&quot;</span>,
            .obj =&gt; <span class="tok-str">&quot;zig build-obj&quot;</span>,
            .@&quot;test&quot; =&gt; <span class="tok-str">&quot;zig test&quot;</span>,
        },
        name_adjusted,
        <span class="tok-builtin">@tagName</span>(options.root_module.optimize <span class="tok-kw">orelse</span> .Debug),
        resolved_target.query.zigTriple(owner.allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>),
    });

    <span class="tok-kw">const</span> out_filename = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.binNameAlloc">binNameAlloc</a>(owner.allocator, .{
        .root_name = name,
        .target = target,
        .output_mode = <span class="tok-kw">switch</span> (options.kind) {
            .lib =&gt; .Lib,
            .obj =&gt; .Obj,
            .exe, .@&quot;test&quot; =&gt; .Exe,
        },
        .link_mode = options.linkage,
        .version = options.version,
    }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);

    <span class="tok-kw">const</span> compile = owner.allocator.create(<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    compile.* = .{
        .root_module = options.root_module,
        .verbose_link = <span class="tok-null">false</span>,
        .verbose_cc = <span class="tok-null">false</span>,
        .linkage = options.linkage,
        .kind = options.kind,
        .name = name,
        .step = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.html#std.Build.Step.init">init</a>(.{
            .id = <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.base_id">base_id</a>,
            .name = step_name,
            .owner = owner,
            .makeFn = <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.make">make</a>,
            .max_rss = options.max_rss,
        }),
        .version = options.version,
        .out_filename = out_filename,
        .out_lib_filename = <span class="tok-null">undefined</span>,
        .major_only_filename = <span class="tok-null">null</span>,
        .name_only_filename = <span class="tok-null">null</span>,
        .installed_headers = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.Step.Compile.HeaderInstallation.html">HeaderInstallation</a>).init(owner.allocator),
        .zig_lib_dir = <span class="tok-null">null</span>,
        .exec_cmd_args = <span class="tok-null">null</span>,
        .filters = options.filters,
        .test_runner = <span class="tok-null">null</span>,<span class="tok-comment"> // set below
        </span>.rdynamic = <span class="tok-null">false</span>,
        .installed_path = <span class="tok-null">null</span>,
        .force_undefined_symbols = <a href="std.hash_map.html#std.hash_map.StringHashMap">StringHashMap</a>(<span class="tok-type">void</span>).init(owner.allocator),

        .emit_directory = <span class="tok-null">null</span>,
        .generated_docs = <span class="tok-null">null</span>,
        .generated_asm = <span class="tok-null">null</span>,
        .generated_bin = <span class="tok-null">null</span>,
        .generated_pdb = <span class="tok-null">null</span>,
        .generated_implib = <span class="tok-null">null</span>,
        .generated_llvm_bc = <span class="tok-null">null</span>,
        .generated_llvm_ir = <span class="tok-null">null</span>,
        .generated_h = <span class="tok-null">null</span>,

        .use_llvm = options.use_llvm,
        .use_lld = options.use_lld,

        .zig_process = <span class="tok-null">null</span>,
    };

    <span class="tok-kw">if</span> (options.zig_lib_dir) |lp| {
        compile.zig_lib_dir = lp.dupe(compile.step.owner);
        lp.addStepDependencies(&amp;compile.step);
    }

    <span class="tok-kw">if</span> (options.test_runner) |runner| {
        compile.test_runner = .{
            .path = runner.path.dupe(compile.step.owner),
            .mode = runner.mode,
        };
        runner.path.addStepDependencies(&amp;compile.step);
    }<span class="tok-comment">

    // Only the PE/COFF format has a Resource Table which is where the manifest
    // gets embedded, so for any other target the manifest file is just ignored.
    </span><span class="tok-kw">if</span> (target.ofmt == .coff) {
        <span class="tok-kw">if</span> (options.win32_manifest) |lp| {
            compile.win32_manifest = lp.dupe(compile.step.owner);
            lp.addStepDependencies(&amp;compile.step);
        }
    }

    <span class="tok-kw">if</span> (compile.kind == .lib) {
        <span class="tok-kw">if</span> (compile.linkage != <span class="tok-null">null</span> <span class="tok-kw">and</span> compile.linkage.? == .static) {
            compile.out_lib_filename = compile.out_filename;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (compile.version) |version| {
            <span class="tok-kw">if</span> (target.os.tag.isDarwin()) {
                compile.major_only_filename = owner.fmt(<span class="tok-str">&quot;lib{s}.{d}.dylib&quot;</span>, .{
                    compile.name,
                    version.major,
                });
                compile.name_only_filename = owner.fmt(<span class="tok-str">&quot;lib{s}.dylib&quot;</span>, .{compile.name});
                compile.out_lib_filename = compile.out_filename;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (target.os.tag == .windows) {
                compile.out_lib_filename = owner.fmt(<span class="tok-str">&quot;{s}.lib&quot;</span>, .{compile.name});
            } <span class="tok-kw">else</span> {
                compile.major_only_filename = owner.fmt(<span class="tok-str">&quot;lib{s}.so.{d}&quot;</span>, .{ compile.name, version.major });
                compile.name_only_filename = owner.fmt(<span class="tok-str">&quot;lib{s}.so&quot;</span>, .{compile.name});
                compile.out_lib_filename = compile.out_filename;
            }
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">if</span> (target.os.tag.isDarwin()) {
                compile.out_lib_filename = compile.out_filename;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (target.os.tag == .windows) {
                compile.out_lib_filename = owner.fmt(<span class="tok-str">&quot;{s}.lib&quot;</span>, .{compile.name});
            } <span class="tok-kw">else</span> {
                compile.out_lib_filename = compile.out_filename;
            }
        }
    }

    <span class="tok-kw">return</span> compile;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.installHeader" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">installHeader</span><a href="#src.zig-std.Build.Step.Compile.installHeader">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installHeader</span>(cs: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Marks the specified header for installation alongside this artifact.
When a module links with this artifact, all headers marked for installation are added to that
module's include search path.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cs: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>source: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div><pre><code>dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.installHeader">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installHeader</span>(cs: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> b = cs.step.owner;
    <span class="tok-kw">const</span> installation: <a href="std.Build.Step.Compile.HeaderInstallation.html">HeaderInstallation</a> = .{ .file = .{
        .source = source.dupe(b),
        .dest_rel_path = b.dupePath(dest_rel_path),
    } };
    cs.installed_headers.append(installation) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    cs.addHeaderInstallationToIncludeTree(installation);
    installation.getSource().addStepDependencies(&amp;cs.step);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.installHeadersDirectory" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">installHeadersDirectory</span><a href="#src.zig-std.Build.Step.Compile.installHeadersDirectory">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installHeadersDirectory</span>( cs: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.Build.Step.Compile.HeaderInstallation.html">HeaderInstallation</a>.<a href="std.Build.Step.Compile.HeaderInstallation.Directory.html">Directory</a>.<a href="std.Build.Step.Compile.HeaderInstallation.Directory.Options.html">Options</a>, ) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Marks headers from the specified directory for installation alongside this artifact.
When a module links with this artifact, all headers marked for installation are added to that
module's include search path.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cs: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>source: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div><pre><code>dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.Build.Step.Compile.HeaderInstallation.html">HeaderInstallation</a>.<a href="std.Build.Step.Compile.HeaderInstallation.Directory.html">Directory</a>.<a href="std.Build.Step.Compile.HeaderInstallation.Directory.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.installHeadersDirectory">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installHeadersDirectory</span>(
    cs: *<a href="std.Build.Step.Compile.html">Compile</a>,
    source: <a href="std.Build.LazyPath.html">LazyPath</a>,
    dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    options: <a href="std.Build.Step.Compile.HeaderInstallation.html">HeaderInstallation</a>.<a href="std.Build.Step.Compile.HeaderInstallation.Directory.html">Directory</a>.<a href="std.Build.Step.Compile.HeaderInstallation.Directory.Options.html">Options</a>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> b = cs.step.owner;
    <span class="tok-kw">const</span> installation: <a href="std.Build.Step.Compile.HeaderInstallation.html">HeaderInstallation</a> = .{ .directory = .{
        .source = source.dupe(b),
        .dest_rel_path = b.dupePath(dest_rel_path),
        .options = options.dupe(b),
    } };
    cs.installed_headers.append(installation) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    cs.addHeaderInstallationToIncludeTree(installation);
    installation.getSource().addStepDependencies(&amp;cs.step);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.installConfigHeader" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">installConfigHeader</span><a href="#src.zig-std.Build.Step.Compile.installConfigHeader">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installConfigHeader</span>(cs: *<a href="std.Build.Step.Compile.html">Compile</a>, config_header: *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ConfigHeader.html">ConfigHeader</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Marks the specified config header for installation alongside this artifact.
When a module links with this artifact, all headers marked for installation are added to that
module's include search path.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cs: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>config_header: *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ConfigHeader.html">ConfigHeader</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.installConfigHeader">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installConfigHeader</span>(cs: *<a href="std.Build.Step.Compile.html">Compile</a>, config_header: *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ConfigHeader.html">ConfigHeader</a>) <span class="tok-type">void</span> {
    cs.installHeader(config_header.getOutput(), config_header.include_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.installLibraryHeaders" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">installLibraryHeaders</span><a href="#src.zig-std.Build.Step.Compile.installLibraryHeaders">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installLibraryHeaders</span>(cs: *<a href="std.Build.Step.Compile.html">Compile</a>, lib: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Forwards all headers marked for installation from <code>lib</code> to this artifact.
When a module links with this artifact, all headers marked for installation are added to that
module's include search path.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cs: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>lib: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.installLibraryHeaders">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installLibraryHeaders</span>(cs: *<a href="std.Build.Step.Compile.html">Compile</a>, lib: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(lib.kind == .lib);
    <span class="tok-kw">for</span> (lib.installed_headers.items) |installation| {
        <span class="tok-kw">const</span> installation_copy = installation.dupe(lib.step.owner);
        cs.installed_headers.append(installation_copy) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
        cs.addHeaderInstallationToIncludeTree(installation_copy);
        installation_copy.getSource().addStepDependencies(&amp;cs.step);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.getEmittedIncludeTree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEmittedIncludeTree</span><a href="#src.zig-std.Build.Step.Compile.getEmittedIncludeTree">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedIncludeTree</span>(cs: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cs: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.getEmittedIncludeTree">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedIncludeTree</span>(cs: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">if</span> (cs.installed_headers_include_tree) |wf| <span class="tok-kw">return</span> wf.getDirectory();
    <span class="tok-kw">const</span> b = cs.step.owner;
    <span class="tok-kw">const</span> wf = b.addWriteFiles();
    cs.installed_headers_include_tree = wf;
    <span class="tok-kw">for</span> (cs.installed_headers.items) |installation| {
        cs.addHeaderInstallationToIncludeTree(installation);
    }<span class="tok-comment">
    // The compile step itself does not need to depend on the write files step,
    // only dependent modules do.
    </span><span class="tok-kw">return</span> wf.getDirectory();
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.addObjCopy" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addObjCopy</span><a href="#src.zig-std.Build.Step.Compile.addObjCopy">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addObjCopy</span>(cs: *<a href="std.Build.Step.Compile.html">Compile</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ObjCopy.html">ObjCopy</a>.<a href="std.Build.Step.ObjCopy.Options.html">Options</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ObjCopy.html">ObjCopy</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cs: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ObjCopy.html">ObjCopy</a>.<a href="std.Build.Step.ObjCopy.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.addObjCopy">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addObjCopy</span>(cs: *<a href="std.Build.Step.Compile.html">Compile</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ObjCopy.html">ObjCopy</a>.<a href="std.Build.Step.ObjCopy.Options.html">Options</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ObjCopy.html">ObjCopy</a> {
    <span class="tok-kw">const</span> b = cs.step.owner;
    <span class="tok-kw">var</span> copy = options;
    <span class="tok-kw">if</span> (copy.basename == <span class="tok-null">null</span>) {
        <span class="tok-kw">if</span> (options.format) |f| {
            copy.basename = b.fmt(<span class="tok-str">&quot;{s}.{s}&quot;</span>, .{ cs.name, <span class="tok-builtin">@tagName</span>(f) });
        } <span class="tok-kw">else</span> {
            copy.basename = cs.name;
        }
    }
    <span class="tok-kw">return</span> b.addObjCopy(cs.getEmittedBin(), copy);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.checkObject" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkObject</span><a href="#src.zig-std.Build.Step.Compile.checkObject">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkObject</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.checkObject">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkObject</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.CheckObject.html">CheckObject</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.CheckObject.html">CheckObject</a>.<a href="std.Build.Step.CheckObject.html#std.Build.Step.CheckObject.create">create</a>(compile.step.owner, compile.getEmittedBin(), compile.rootModuleTarget().ofmt);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.setLinkerScript" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setLinkerScript</span><a href="#src.zig-std.Build.Step.Compile.setLinkerScript">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setLinkerScript</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>source: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.setLinkerScript">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setLinkerScript</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> b = compile.step.owner;
    compile.linker_script = source.dupe(b);
    source.addStepDependencies(&amp;compile.step);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.setVersionScript" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setVersionScript</span><a href="#src.zig-std.Build.Step.Compile.setVersionScript">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setVersionScript</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>source: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.setVersionScript">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setVersionScript</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> b = compile.step.owner;
    compile.version_script = source.dupe(b);
    source.addStepDependencies(&amp;compile.step);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.forceUndefinedSymbol" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">forceUndefinedSymbol</span><a href="#src.zig-std.Build.Step.Compile.forceUndefinedSymbol">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">forceUndefinedSymbol</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, symbol_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>symbol_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.forceUndefinedSymbol">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">forceUndefinedSymbol</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, symbol_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> b = compile.step.owner;
    compile.force_undefined_symbols.put(b.dupe(symbol_name), {}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.dependsOnSystemLibrary" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dependsOnSystemLibrary</span><a href="#src.zig-std.Build.Step.Compile.dependsOnSystemLibrary">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dependsOnSystemLibrary</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns whether the library, executable, or object depends on a particular system library.
Includes transitive dependencies.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.dependsOnSystemLibrary">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dependsOnSystemLibrary</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">var</span> is_linking_libc = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> is_linking_libcpp = <span class="tok-null">false</span>;

    <span class="tok-kw">for</span> (compile.getCompileDependencies(<span class="tok-null">true</span>)) |some_compile| {
        <span class="tok-kw">for</span> (some_compile.root_module.getGraph().modules) |mod| {
            <span class="tok-kw">for</span> (mod.link_objects.items) |lo| {
                <span class="tok-kw">switch</span> (lo) {
                    .system_lib =&gt; |lib| <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, lib.name, name)) <span class="tok-kw">return</span> <span class="tok-null">true</span>,
                    <span class="tok-kw">else</span> =&gt; {},
                }
            }
            <span class="tok-kw">if</span> (mod.link_libc <span class="tok-kw">orelse</span> <span class="tok-null">false</span>) is_linking_libc = <span class="tok-null">true</span>;
            <span class="tok-kw">if</span> (mod.link_libcpp <span class="tok-kw">orelse</span> <span class="tok-null">false</span>) is_linking_libcpp = <span class="tok-null">true</span>;
        }
    }

    <span class="tok-kw">const</span> target = compile.rootModuleTarget();

    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.target.html">target</a>.<a href="std.zig.target.html#std.zig.target.isLibCLibName">isLibCLibName</a>(target, name)) {
        <span class="tok-kw">return</span> is_linking_libc;
    }

    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.target.html">target</a>.<a href="std.zig.target.html#std.zig.target.isLibCxxLibName">isLibCxxLibName</a>(target, name)) {
        <span class="tok-kw">return</span> is_linking_libcpp;
    }

    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.isDynamicLibrary" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isDynamicLibrary</span><a href="#src.zig-std.Build.Step.Compile.isDynamicLibrary">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isDynamicLibrary</span>(compile: *<span class="tok-kw">const</span> <a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<span class="tok-kw">const</span> <a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.isDynamicLibrary">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isDynamicLibrary</span>(compile: *<span class="tok-kw">const</span> <a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> compile.kind == .lib <span class="tok-kw">and</span> compile.linkage == .dynamic;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.isStaticLibrary" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isStaticLibrary</span><a href="#src.zig-std.Build.Step.Compile.isStaticLibrary">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isStaticLibrary</span>(compile: *<span class="tok-kw">const</span> <a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<span class="tok-kw">const</span> <a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.isStaticLibrary">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isStaticLibrary</span>(compile: *<span class="tok-kw">const</span> <a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> compile.kind == .lib <span class="tok-kw">and</span> compile.linkage != .dynamic;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.isDll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isDll</span><a href="#src.zig-std.Build.Step.Compile.isDll">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isDll</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.isDll">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isDll</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> compile.isDynamicLibrary() <span class="tok-kw">and</span> compile.rootModuleTarget().os.tag == .windows;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.producesPdbFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">producesPdbFile</span><a href="#src.zig-std.Build.Step.Compile.producesPdbFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">producesPdbFile</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.producesPdbFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">producesPdbFile</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> target = compile.rootModuleTarget();<span class="tok-comment">
    // TODO: Is this right? Isn't PDB for *any* PE/COFF file?
    // TODO: just share this logic with the compiler, silly!
    </span><span class="tok-kw">switch</span> (target.os.tag) {
        .windows, .uefi =&gt; {},
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
    }
    <span class="tok-kw">if</span> (target.ofmt == .c) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    <span class="tok-kw">if</span> (compile.root_module.strip == <span class="tok-null">true</span> <span class="tok-kw">or</span>
        (compile.root_module.strip == <span class="tok-null">null</span> <span class="tok-kw">and</span> compile.root_module.optimize == .ReleaseSmall))
    {
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }
    <span class="tok-kw">return</span> compile.isDynamicLibrary() <span class="tok-kw">or</span> compile.kind == .exe <span class="tok-kw">or</span> compile.kind == .@&quot;test&quot;;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.producesImplib" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">producesImplib</span><a href="#src.zig-std.Build.Step.Compile.producesImplib">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">producesImplib</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.producesImplib">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">producesImplib</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> compile.isDll();
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.linkLibC" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">linkLibC</span><a href="#src.zig-std.Build.Step.Compile.linkLibC">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkLibC</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.linkLibC">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkLibC</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">void</span> {
    compile.root_module.link_libc = <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.linkLibCpp" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">linkLibCpp</span><a href="#src.zig-std.Build.Step.Compile.linkLibCpp">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkLibCpp</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.linkLibCpp">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkLibCpp</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">void</span> {
    compile.root_module.link_libcpp = <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.linkSystemLibrary" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">linkSystemLibrary</span><a href="#src.zig-std.Build.Step.Compile.linkSystemLibrary">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkSystemLibrary</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.linkSystemLibrary">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkSystemLibrary</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> compile.root_module.linkSystemLibrary(name, .{});
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.linkSystemLibrary2" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">linkSystemLibrary2</span><a href="#src.zig-std.Build.Step.Compile.linkSystemLibrary2">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkSystemLibrary2</span>( compile: *<a href="std.Build.Step.Compile.html">Compile</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.LinkSystemLibraryOptions.html">LinkSystemLibraryOptions</a>, ) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.LinkSystemLibraryOptions.html">LinkSystemLibraryOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.linkSystemLibrary2">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkSystemLibrary2</span>(
    compile: *<a href="std.Build.Step.Compile.html">Compile</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    options: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.LinkSystemLibraryOptions.html">LinkSystemLibraryOptions</a>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> compile.root_module.linkSystemLibrary(name, options);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.linkFramework" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">linkFramework</span><a href="#src.zig-std.Build.Step.Compile.linkFramework">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkFramework</span>(c: *<a href="std.Build.Step.Compile.html">Compile</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>c: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.linkFramework">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkFramework</span>(c: *<a href="std.Build.Step.Compile.html">Compile</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    c.root_module.linkFramework(name, .{});
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.addCSourceFiles" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addCSourceFiles</span><a href="#src.zig-std.Build.Step.Compile.addCSourceFiles">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCSourceFiles</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, options: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.AddCSourceFilesOptions.html">AddCSourceFilesOptions</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Handy when you have many C/C++ source files and want them all to have the same flags.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>options: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.AddCSourceFilesOptions.html">AddCSourceFilesOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.addCSourceFiles">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCSourceFiles</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, options: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.AddCSourceFilesOptions.html">AddCSourceFilesOptions</a>) <span class="tok-type">void</span> {
    compile.root_module.addCSourceFiles(options);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.addCSourceFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addCSourceFile</span><a href="#src.zig-std.Build.Step.Compile.addCSourceFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCSourceFile</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.CSourceFile.html">CSourceFile</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>source: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.CSourceFile.html">CSourceFile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.addCSourceFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCSourceFile</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.CSourceFile.html">CSourceFile</a>) <span class="tok-type">void</span> {
    compile.root_module.addCSourceFile(source);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.addWin32ResourceFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addWin32ResourceFile</span><a href="#src.zig-std.Build.Step.Compile.addWin32ResourceFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWin32ResourceFile</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.RcSourceFile.html">RcSourceFile</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Resource files must have the extension <code>.rc</code>.
Can be called regardless of target. The .rc file will be ignored
if the target object format does not support embedded resources.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>source: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.RcSourceFile.html">RcSourceFile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.addWin32ResourceFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWin32ResourceFile</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.RcSourceFile.html">RcSourceFile</a>) <span class="tok-type">void</span> {
    compile.root_module.addWin32ResourceFile(source);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.setVerboseLink" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setVerboseLink</span><a href="#src.zig-std.Build.Step.Compile.setVerboseLink">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setVerboseLink</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>value: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.setVerboseLink">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setVerboseLink</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    compile.verbose_link = value;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.setVerboseCC" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setVerboseCC</span><a href="#src.zig-std.Build.Step.Compile.setVerboseCC">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setVerboseCC</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>value: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.setVerboseCC">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setVerboseCC</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    compile.verbose_cc = value;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.setLibCFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setLibCFile</span><a href="#src.zig-std.Build.Step.Compile.setLibCFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setLibCFile</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, libc_file: ?<a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>libc_file: ?<a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.setLibCFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setLibCFile</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, libc_file: ?<a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> b = compile.step.owner;
    <span class="tok-kw">if</span> (libc_file) |f| {
        compile.libc_file = f.dupe(b);
        f.addStepDependencies(&amp;compile.step);
    } <span class="tok-kw">else</span> {
        compile.libc_file = <span class="tok-null">null</span>;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.getEmittedBinDirectory" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEmittedBinDirectory</span><a href="#src.zig-std.Build.Step.Compile.getEmittedBinDirectory">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedBinDirectory</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div class="tldDocs"><p>Returns the path to the directory that contains the emitted binary file.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.getEmittedBinDirectory">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedBinDirectory</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    _ = compile.getEmittedBin();
    <span class="tok-kw">return</span> compile.getEmittedFileGeneric(&amp;compile.emit_directory);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.getEmittedBin" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEmittedBin</span><a href="#src.zig-std.Build.Step.Compile.getEmittedBin">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedBin</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div class="tldDocs"><p>Returns the path to the generated executable, library or object file.
To run an executable built with zig build, use <code>run</code>, or create an install step and invoke it.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.getEmittedBin">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedBin</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">return</span> compile.getEmittedFileGeneric(&amp;compile.generated_bin);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.getEmittedImplib" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEmittedImplib</span><a href="#src.zig-std.Build.Step.Compile.getEmittedImplib">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedImplib</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div class="tldDocs"><p>Returns the path to the generated import library.
This function can only be called for libraries.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.getEmittedImplib">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedImplib</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(compile.kind == .lib);
    <span class="tok-kw">return</span> compile.getEmittedFileGeneric(&amp;compile.generated_implib);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.getEmittedH" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEmittedH</span><a href="#src.zig-std.Build.Step.Compile.getEmittedH">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedH</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div class="tldDocs"><p>Returns the path to the generated header file.
This function can only be called for libraries or objects.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.getEmittedH">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedH</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(compile.kind != .exe <span class="tok-kw">and</span> compile.kind != .@&quot;test&quot;);
    <span class="tok-kw">return</span> compile.getEmittedFileGeneric(&amp;compile.generated_h);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.getEmittedPdb" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEmittedPdb</span><a href="#src.zig-std.Build.Step.Compile.getEmittedPdb">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedPdb</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div class="tldDocs"><p>Returns the generated PDB file.
If the compilation does not produce a PDB file, this causes a FileNotFound error
at build time.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.getEmittedPdb">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedPdb</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    _ = compile.getEmittedBin();
    <span class="tok-kw">return</span> compile.getEmittedFileGeneric(&amp;compile.generated_pdb);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.getEmittedDocs" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEmittedDocs</span><a href="#src.zig-std.Build.Step.Compile.getEmittedDocs">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedDocs</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div class="tldDocs"><p>Returns the path to the generated documentation directory.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.getEmittedDocs">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedDocs</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">return</span> compile.getEmittedFileGeneric(&amp;compile.generated_docs);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.getEmittedAsm" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEmittedAsm</span><a href="#src.zig-std.Build.Step.Compile.getEmittedAsm">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedAsm</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div class="tldDocs"><p>Returns the path to the generated assembly code.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.getEmittedAsm">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedAsm</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">return</span> compile.getEmittedFileGeneric(&amp;compile.generated_asm);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.getEmittedLlvmIr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEmittedLlvmIr</span><a href="#src.zig-std.Build.Step.Compile.getEmittedLlvmIr">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedLlvmIr</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div class="tldDocs"><p>Returns the path to the generated LLVM IR.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.getEmittedLlvmIr">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedLlvmIr</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">return</span> compile.getEmittedFileGeneric(&amp;compile.generated_llvm_ir);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.getEmittedLlvmBc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEmittedLlvmBc</span><a href="#src.zig-std.Build.Step.Compile.getEmittedLlvmBc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedLlvmBc</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div class="tldDocs"><p>Returns the path to the generated LLVM BC.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.getEmittedLlvmBc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedLlvmBc</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">return</span> compile.getEmittedFileGeneric(&amp;compile.generated_llvm_bc);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.addAssemblyFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addAssemblyFile</span><a href="#src.zig-std.Build.Step.Compile.addAssemblyFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAssemblyFile</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>source: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.addAssemblyFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAssemblyFile</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    compile.root_module.addAssemblyFile(source);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.addObjectFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addObjectFile</span><a href="#src.zig-std.Build.Step.Compile.addObjectFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addObjectFile</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>source: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.addObjectFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addObjectFile</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    compile.root_module.addObjectFile(source);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.addObject" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addObject</span><a href="#src.zig-std.Build.Step.Compile.addObject">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addObject</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, object: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>object: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.addObject">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addObject</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, object: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">void</span> {
    compile.root_module.addObject(object);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.linkLibrary" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">linkLibrary</span><a href="#src.zig-std.Build.Step.Compile.linkLibrary">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkLibrary</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, library: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>library: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.linkLibrary">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkLibrary</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, library: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">void</span> {
    compile.root_module.linkLibrary(library);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.addAfterIncludePath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addAfterIncludePath</span><a href="#src.zig-std.Build.Step.Compile.addAfterIncludePath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAfterIncludePath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.addAfterIncludePath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAfterIncludePath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    compile.root_module.addAfterIncludePath(lazy_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.addSystemIncludePath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addSystemIncludePath</span><a href="#src.zig-std.Build.Step.Compile.addSystemIncludePath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSystemIncludePath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.addSystemIncludePath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSystemIncludePath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    compile.root_module.addSystemIncludePath(lazy_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.addIncludePath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addIncludePath</span><a href="#src.zig-std.Build.Step.Compile.addIncludePath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addIncludePath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.addIncludePath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addIncludePath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    compile.root_module.addIncludePath(lazy_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.addConfigHeader" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addConfigHeader</span><a href="#src.zig-std.Build.Step.Compile.addConfigHeader">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addConfigHeader</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, config_header: *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ConfigHeader.html">ConfigHeader</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>config_header: *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ConfigHeader.html">ConfigHeader</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.addConfigHeader">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addConfigHeader</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, config_header: *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ConfigHeader.html">ConfigHeader</a>) <span class="tok-type">void</span> {
    compile.root_module.addConfigHeader(config_header);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.addLibraryPath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addLibraryPath</span><a href="#src.zig-std.Build.Step.Compile.addLibraryPath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addLibraryPath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, directory_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>directory_path: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.addLibraryPath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addLibraryPath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, directory_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    compile.root_module.addLibraryPath(directory_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.addRPath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addRPath</span><a href="#src.zig-std.Build.Step.Compile.addRPath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addRPath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, directory_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>directory_path: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.addRPath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addRPath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, directory_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    compile.root_module.addRPath(directory_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.addSystemFrameworkPath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addSystemFrameworkPath</span><a href="#src.zig-std.Build.Step.Compile.addSystemFrameworkPath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSystemFrameworkPath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, directory_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>directory_path: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.addSystemFrameworkPath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSystemFrameworkPath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, directory_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    compile.root_module.addSystemFrameworkPath(directory_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.addFrameworkPath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addFrameworkPath</span><a href="#src.zig-std.Build.Step.Compile.addFrameworkPath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFrameworkPath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, directory_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>directory_path: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.addFrameworkPath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFrameworkPath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, directory_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    compile.root_module.addFrameworkPath(directory_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.setExecCmd" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setExecCmd</span><a href="#src.zig-std.Build.Step.Compile.setExecCmd">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setExecCmd</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, args: []<span class="tok-kw">const</span> ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>compile: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>args: []<span class="tok-kw">const</span> ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.setExecCmd">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setExecCmd</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, args: []<span class="tok-kw">const</span> ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> b = compile.step.owner;
    <a href="std.debug.html#std.debug.assert">assert</a>(compile.kind == .@&quot;test&quot;);
    <span class="tok-kw">const</span> duped_args = b.allocator.alloc(?[]<span class="tok-type">u8</span>, args.len) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    <span class="tok-kw">for</span> (args, <span class="tok-number">0</span>..) |arg, i| {
        duped_args[i] = <span class="tok-kw">if</span> (arg) |a| b.dupe(a) <span class="tok-kw">else</span> <span class="tok-null">null</span>;
    }
    compile.exec_cmd_args = duped_args;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.rebuildInFuzzMode" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rebuildInFuzzMode</span><a href="#src.zig-std.Build.Step.Compile.rebuildInFuzzMode">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rebuildInFuzzMode</span>(c: *<a href="std.Build.Step.Compile.html">Compile</a>, progress_node: <a href="std.html">std</a>.<a href="std.Progress.html">Progress</a>.<a href="std.Progress.Node.html">Node</a>) !<a href="std.Build.Cache.Path.html">Path</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>c: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>progress_node: <a href="std.html">std</a>.<a href="std.Progress.html">Progress</a>.<a href="std.Progress.Node.html">Node</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.rebuildInFuzzMode">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rebuildInFuzzMode</span>(c: *<a href="std.Build.Step.Compile.html">Compile</a>, progress_node: <a href="std.html">std</a>.<a href="std.Progress.html">Progress</a>.<a href="std.Progress.Node.html">Node</a>) !<a href="std.Build.Cache.Path.html">Path</a> {
    <span class="tok-kw">const</span> gpa = c.step.owner.allocator;

    c.step.result_error_msgs.clearRetainingCapacity();
    c.step.result_stderr = <span class="tok-str">&quot;&quot;</span>;

    c.step.result_error_bundle.deinit(gpa);
    c.step.result_error_bundle = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.ErrorBundle.html">ErrorBundle</a>.<a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.empty">empty</a>;

    <span class="tok-kw">const</span> zig_args = <span class="tok-kw">try</span> <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.getZigArgs">getZigArgs</a>(c, <span class="tok-null">true</span>);
    <span class="tok-kw">const</span> maybe_output_bin_path = <span class="tok-kw">try</span> c.step.evalZigProcess(zig_args, progress_node, <span class="tok-null">false</span>);
    <span class="tok-kw">return</span> maybe_output_bin_path.?;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.doAtomicSymLinks" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">doAtomicSymLinks</span><a href="#src.zig-std.Build.Step.Compile.doAtomicSymLinks">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doAtomicSymLinks</span>( step: *<a href="std.Build.Step.html">Step</a>, output_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, filename_major_only: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, filename_name_only: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>step: *<a href="std.Build.Step.html">Step</a></code></pre></div><div><pre><code>output_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>filename_major_only: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>filename_name_only: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.doAtomicSymLinks">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doAtomicSymLinks</span>(
    step: *<a href="std.Build.Step.html">Step</a>,
    output_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    filename_major_only: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    filename_name_only: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> b = step.owner;
    <span class="tok-kw">const</span> out_dir = <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(output_path) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;.&quot;</span>;
    <span class="tok-kw">const</span> out_basename = <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.basename">basename</a>(output_path);<span class="tok-comment">
    // sym link for libfoo.so.1 to libfoo.so.1.2.3
    </span><span class="tok-kw">const</span> major_only_path = b.pathJoin(&amp;.{ out_dir, filename_major_only });
    <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().atomicSymLink(out_basename, major_only_path, .{}) <span class="tok-kw">catch</span> |err| {
        <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;unable to symlink {s} -&gt; {s}: {s}&quot;</span>, .{
            major_only_path, out_basename, <span class="tok-builtin">@errorName</span>(err),
        });
    };<span class="tok-comment">
    // sym link for libfoo.so to libfoo.so.1
    </span><span class="tok-kw">const</span> name_only_path = b.pathJoin(&amp;.{ out_dir, filename_name_only });
    <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().atomicSymLink(filename_major_only, name_only_path, .{}) <span class="tok-kw">catch</span> |err| {
        <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;Unable to symlink {s} -&gt; {s}: {s}&quot;</span>, .{
            name_only_path, filename_major_only, <span class="tok-builtin">@errorName</span>(err),
        });
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.rootModuleTarget" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rootModuleTarget</span><a href="#src.zig-std.Build.Step.Compile.rootModuleTarget">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rootModuleTarget</span>(c: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.html">std</a>.<a href="std.Target.html">Target</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>c: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.rootModuleTarget">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rootModuleTarget</span>(c: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.html">std</a>.<a href="std.Target.html">Target</a> {<span class="tok-comment">
    // The root module is always given a target, so we know this to be non-null.
    </span><span class="tok-kw">return</span> c.root_module.resolved_target.?.result;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.Compile.getCompileDependencies" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getCompileDependencies</span><a href="#src.zig-std.Build.Step.Compile.getCompileDependencies">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getCompileDependencies</span>(start: *<a href="std.Build.Step.Compile.html">Compile</a>, chase_dynamic: <span class="tok-type">bool</span>) []<span class="tok-kw">const</span> *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div class="tldDocs"><p>Return the full set of <code><a href="std.Build.Step.Compile.html">Step.Compile</a></code> which <code>start</code> depends on, recursively. <code>start</code> itself is
always returned as the first element. If <code>chase_dynamic</code> is <code>false</code>, then dynamic libraries are
not included, and their dependencies are not considered; if <code>chase_dynamic</code> is <code>true</code>, dynamic
libraries are treated the same as other linked <code><a href="std.Build.Step.Compile.html">Compile</a></code>s.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>start: *<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>chase_dynamic: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.Compile.getCompileDependencies">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getCompileDependencies</span>(start: *<a href="std.Build.Step.Compile.html">Compile</a>, chase_dynamic: <span class="tok-type">bool</span>) []<span class="tok-kw">const</span> *<a href="std.Build.Step.Compile.html">Compile</a> {
    <span class="tok-kw">const</span> arena = start.step.owner.graph.arena;

    <span class="tok-kw">var</span> compiles: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(*<a href="std.Build.Step.Compile.html">Compile</a>, <span class="tok-type">void</span>) = .empty;
    <span class="tok-kw">var</span> next_idx: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    compiles.putNoClobber(arena, start, {}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);

    <span class="tok-kw">while</span> (next_idx &lt; compiles.count()) {
        <span class="tok-kw">const</span> compile = compiles.keys()[next_idx];
        next_idx += <span class="tok-number">1</span>;

        <span class="tok-kw">for</span> (compile.root_module.getGraph().modules) |mod| {
            <span class="tok-kw">for</span> (mod.link_objects.items) |lo| {
                <span class="tok-kw">switch</span> (lo) {
                    .other_step =&gt; |other_compile| {
                        <span class="tok-kw">if</span> (!chase_dynamic <span class="tok-kw">and</span> other_compile.isDynamicLibrary()) <span class="tok-kw">continue</span>;
                        compiles.put(arena, other_compile, {}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
                    },
                    <span class="tok-kw">else</span> =&gt; {},
                }
            }
        }
    }

    <span class="tok-kw">return</span> compiles.keys();
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.Build.Step.Compile">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> fs = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> panic = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>;
<span class="tok-kw">const</span> ArrayList = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>;
<span class="tok-kw">const</span> StringHashMap = <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.StringHashMap">StringHashMap</a>;
<span class="tok-kw">const</span> Sha256 = <a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>.<a href="std.crypto.hash.html">hash</a>.<a href="std.crypto.sha2.html">sha2</a>.<a href="std.crypto.sha2.html#std.crypto.sha2.Sha256">Sha256</a>;
<span class="tok-kw">const</span> Allocator = <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> Step = <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.Step.html">Step</a>;
<span class="tok-kw">const</span> LazyPath = <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>;
<span class="tok-kw">const</span> PkgConfigPkg = <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.PkgConfigPkg.html">PkgConfigPkg</a>;
<span class="tok-kw">const</span> PkgConfigError = <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.html#std.Build.PkgConfigError">PkgConfigError</a>;
<span class="tok-kw">const</span> RunError = <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.html#std.Build.RunError">RunError</a>;
<span class="tok-kw">const</span> Module = <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.Module.html">Module</a>;
<span class="tok-kw">const</span> InstallDir = <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.InstallDir.html">InstallDir</a>;
<span class="tok-kw">const</span> GeneratedFile = <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.GeneratedFile.html">GeneratedFile</a>;
<span class="tok-kw">const</span> Compile = <span class="tok-builtin">@This</span>();
<span class="tok-kw">const</span> Path = <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Path.html">Path</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> base_id: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Id.html">Id</a> = .compile;

step: <a href="std.Build.Step.html">Step</a>,
root_module: *<a href="std.Build.Module.html">Module</a>,

name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
linker_script: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,
version_script: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,
out_filename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
out_lib_filename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
linkage: ?<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.LinkMode.html">LinkMode</a> = <span class="tok-null">null</span>,
version: ?<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a>,
kind: <a href="std.Build.Step.Compile.Kind.html">Kind</a>,
major_only_filename: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
name_only_filename: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
formatted_panics: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,<span class="tok-comment">
// keep in sync with src/link.zig:CompressDebugSections
</span>compress_debug_sections: <span class="tok-kw">enum</span> { none, zlib, zstd } = .none,
verbose_link: <span class="tok-type">bool</span>,
verbose_cc: <span class="tok-type">bool</span>,
bundle_compiler_rt: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
bundle_ubsan_rt: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
rdynamic: <span class="tok-type">bool</span>,
import_memory: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
export_memory: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
<span class="tok-comment">/// For WebAssembly targets, this will allow for undefined symbols to</span>
<span class="tok-comment">/// be imported from the host environment.</span>
import_symbols: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
import_table: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
export_table: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
initial_memory: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>,
max_memory: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>,
shared_memory: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
global_base: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>,
<span class="tok-comment">/// Set via options; intended to be read-only after that.</span>
zig_lib_dir: ?<a href="std.Build.LazyPath.html">LazyPath</a>,
exec_cmd_args: ?[]<span class="tok-kw">const</span> ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
filters: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
test_runner: ?<a href="std.Build.Step.Compile.TestRunner.html">TestRunner</a>,
wasi_exec_model: ?<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.WasiExecModel.html">WasiExecModel</a> = <span class="tok-null">null</span>,

installed_headers: <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.Step.Compile.HeaderInstallation.html">HeaderInstallation</a>),

<span class="tok-comment">/// This step is used to create an include tree that dependent modules can add to their include</span>
<span class="tok-comment">/// search paths. Installed headers are copied to this step.</span>
<span class="tok-comment">/// This step is created the first time a module links with this artifact and is not</span>
<span class="tok-comment">/// created otherwise.</span>
installed_headers_include_tree: ?*<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.WriteFile.html">WriteFile</a> = <span class="tok-null">null</span>,<span class="tok-comment">

// keep in sync with src/Compilation.zig:RcIncludes
</span><span class="tok-comment">/// Behavior of automatic detection of include directories when compiling .rc files.</span>
<span class="tok-comment">///  any: Use MSVC if available, fall back to MinGW.</span>
<span class="tok-comment">///  msvc: Use MSVC include paths (must be present on the system).</span>
<span class="tok-comment">///  gnu: Use MinGW include paths (distributed with Zig).</span>
<span class="tok-comment">///  none: Do not use any autodetected include paths.</span>
rc_includes: <span class="tok-kw">enum</span> { any, msvc, gnu, none } = .any,

<span class="tok-comment">/// (Windows) .manifest file to embed in the compilation</span>
<span class="tok-comment">/// Set via options; intended to be read-only after that.</span>
win32_manifest: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,

installed_path: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,

<span class="tok-comment">/// Base address for an executable image.</span>
image_base: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>,

libc_file: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,

each_lib_rpath: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
<span class="tok-comment">/// On ELF targets, this will emit a link section called &quot;.note.gnu.build-id&quot;</span>
<span class="tok-comment">/// which can be used to coordinate a stripped binary with its debug symbols.</span>
<span class="tok-comment">/// As an example, the bloaty project refuses to work unless its inputs have</span>
<span class="tok-comment">/// build ids, in order to prevent accidental mismatches.</span>
<span class="tok-comment">/// The default is to not include this section because it slows down linking.</span>
build_id: ?<a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.BuildId.html">BuildId</a> = <span class="tok-null">null</span>,

<span class="tok-comment">/// Create a .eh_frame_hdr section and a PT_GNU_EH_FRAME segment in the ELF</span>
<span class="tok-comment">/// file.</span>
link_eh_frame_hdr: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
link_emit_relocs: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

<span class="tok-comment">/// Place every function in its own section so that unused ones may be</span>
<span class="tok-comment">/// safely garbage-collected during the linking phase.</span>
link_function_sections: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

<span class="tok-comment">/// Place every data in its own section so that unused ones may be</span>
<span class="tok-comment">/// safely garbage-collected during the linking phase.</span>
link_data_sections: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

<span class="tok-comment">/// Remove functions and data that are unreachable by the entry point or</span>
<span class="tok-comment">/// exported symbols.</span>
link_gc_sections: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,

<span class="tok-comment">/// (Windows) Whether or not to enable ASLR. Maps to the /DYNAMICBASE[:NO] linker argument.</span>
linker_dynamicbase: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,

linker_allow_shlib_undefined: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,

<span class="tok-comment">/// Allow version scripts to refer to undefined symbols.</span>
linker_allow_undefined_version: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,<span class="tok-comment">

// Enable (or disable) the new DT_RUNPATH tag in the dynamic section.
</span>linker_enable_new_dtags: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,

<span class="tok-comment">/// Permit read-only relocations in read-only segments. Disallowed by default.</span>
link_z_notext: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

<span class="tok-comment">/// Force all relocations to be read-only after processing.</span>
link_z_relro: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,

<span class="tok-comment">/// Allow relocations to be lazily processed after load.</span>
link_z_lazy: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

<span class="tok-comment">/// Common page size</span>
link_z_common_page_size: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>,

<span class="tok-comment">/// Maximum page size</span>
link_z_max_page_size: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>,

<span class="tok-comment">/// (Darwin) Install name for the dylib</span>
install_name: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,

<span class="tok-comment">/// (Darwin) Path to entitlements file</span>
entitlements: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,

<span class="tok-comment">/// (Darwin) Size of the pagezero segment.</span>
pagezero_size: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>,

<span class="tok-comment">/// (Darwin) Set size of the padding between the end of load commands</span>
<span class="tok-comment">/// and start of `__TEXT,__text` section.</span>
headerpad_size: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>,

<span class="tok-comment">/// (Darwin) Automatically Set size of the padding between the end of load commands</span>
<span class="tok-comment">/// and start of `__TEXT,__text` section to a value fitting all paths expanded to MAXPATHLEN.</span>
headerpad_max_install_names: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

<span class="tok-comment">/// (Darwin) Remove dylibs that are unreachable by the entry point or exported symbols.</span>
dead_strip_dylibs: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

<span class="tok-comment">/// (Darwin) Force load all members of static archives that implement an Objective-C class or category</span>
force_load_objc: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

<span class="tok-comment">/// Whether local symbols should be discarded from the symbol table.</span>
discard_local_symbols: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

<span class="tok-comment">/// Position Independent Executable</span>
pie: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,

dll_export_fns: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,

subsystem: ?<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.SubSystem.html">SubSystem</a> = <span class="tok-null">null</span>,

<span class="tok-comment">/// (Windows) When targeting the MinGW ABI, use the unicode entry point (wmain/wWinMain)</span>
mingw_unicode_entry_point: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

<span class="tok-comment">/// How the linker must handle the entry point of the executable.</span>
entry: <a href="std.Build.Step.Compile.Entry.html">Entry</a> = .default,

<span class="tok-comment">/// List of symbols forced as undefined in the symbol table</span>
<span class="tok-comment">/// thus forcing their resolution by the linker.</span>
<span class="tok-comment">/// Corresponds to `-u &lt;symbol&gt;` for ELF/MachO and `/include:&lt;symbol&gt;` for COFF/PE.</span>
force_undefined_symbols: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.StringHashMap">StringHashMap</a>(<span class="tok-type">void</span>),

<span class="tok-comment">/// Overrides the default stack size</span>
stack_size: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>,

want_lto: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
use_llvm: ?<span class="tok-type">bool</span>,
use_lld: ?<span class="tok-type">bool</span>,

<span class="tok-comment">/// Corresponds to the `-fallow-so-scripts` / `-fno-allow-so-scripts` CLI</span>
<span class="tok-comment">/// flags, overriding the global user setting provided to the `zig build`</span>
<span class="tok-comment">/// command.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The compiler defaults this value to off so that users whose system shared</span>
<span class="tok-comment">/// libraries are all ELF files don't have to pay the cost of checking every</span>
<span class="tok-comment">/// file to find out if it is a text file instead.</span>
allow_so_scripts: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,

<span class="tok-comment">/// This is an advanced setting that can change the intent of this Compile step.</span>
<span class="tok-comment">/// If this value is non-null, it means that this Compile step exists to</span>
<span class="tok-comment">/// check for compile errors and return *success* if they match, and failure</span>
<span class="tok-comment">/// otherwise.</span>
expect_errors: ?<a href="std.Build.Step.Compile.ExpectedCompileErrors.html">ExpectedCompileErrors</a> = <span class="tok-null">null</span>,

emit_directory: ?*<a href="std.Build.GeneratedFile.html">GeneratedFile</a>,

generated_docs: ?*<a href="std.Build.GeneratedFile.html">GeneratedFile</a>,
generated_asm: ?*<a href="std.Build.GeneratedFile.html">GeneratedFile</a>,
generated_bin: ?*<a href="std.Build.GeneratedFile.html">GeneratedFile</a>,
generated_pdb: ?*<a href="std.Build.GeneratedFile.html">GeneratedFile</a>,
generated_implib: ?*<a href="std.Build.GeneratedFile.html">GeneratedFile</a>,
generated_llvm_bc: ?*<a href="std.Build.GeneratedFile.html">GeneratedFile</a>,
generated_llvm_ir: ?*<a href="std.Build.GeneratedFile.html">GeneratedFile</a>,
generated_h: ?*<a href="std.Build.GeneratedFile.html">GeneratedFile</a>,

<span class="tok-comment">/// The maximum number of distinct errors within a compilation step</span>
<span class="tok-comment">/// Defaults to `std.math.maxInt(u16)`</span>
error_limit: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>,

<span class="tok-comment">/// Computed during make().</span>
is_linking_libc: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
<span class="tok-comment">/// Computed during make().</span>
is_linking_libcpp: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

no_builtin: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

<span class="tok-comment">/// Populated during the make phase when there is a long-lived compiler process.</span>
<span class="tok-comment">/// Managed by the build runner, not user build script.</span>
zig_process: ?*<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ZigProcess.html">ZigProcess</a>,

<span class="tok-comment">/// Enables coverage instrumentation that is only useful if you are using third</span>
<span class="tok-comment">/// party fuzzers that depend on it. Otherwise, slows down the instrumented</span>
<span class="tok-comment">/// binary with unnecessary function calls.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This kind of coverage instrumentation is used by AFLplusplus v4.21c,</span>
<span class="tok-comment">/// however, modern fuzzers - including Zig - have switched to using &quot;inline</span>
<span class="tok-comment">/// 8-bit counters&quot; or &quot;inline bool flag&quot; which incurs only a single</span>
<span class="tok-comment">/// instruction for coverage, along with &quot;trace cmp&quot; which instruments</span>
<span class="tok-comment">/// comparisons and reports the operands.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// To instead enable fuzz testing instrumentation on a compilation using Zig's</span>
<span class="tok-comment">/// builtin fuzzer, see the `fuzz` flag in `Module`.</span>
sanitize_coverage_trace_pc_guard: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExpectedCompileErrors = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    contains: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    exact: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    starts_with: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    stderr_contains: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    <span class="tok-comment">/// Let the compiler decide whether to make an entry point and what to name</span>
    <span class="tok-comment">/// it.</span>
    default,
    <span class="tok-comment">/// The executable will have no entry point.</span>
    disabled,
    <span class="tok-comment">/// The executable will have an entry point with the default symbol name.</span>
    enabled,
    <span class="tok-comment">/// The executable will have an entry point with the specified symbol name.</span>
    symbol_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Options = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    root_module: *<a href="std.Build.Module.html">Module</a>,
    kind: <a href="std.Build.Step.Compile.Kind.html">Kind</a>,
    linkage: ?<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.LinkMode.html">LinkMode</a> = <span class="tok-null">null</span>,
    version: ?<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a> = <span class="tok-null">null</span>,
    max_rss: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
    filters: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;.{},
    test_runner: ?<a href="std.Build.Step.Compile.TestRunner.html">TestRunner</a> = <span class="tok-null">null</span>,
    use_llvm: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    use_lld: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    zig_lib_dir: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Embed a `.manifest` file in the compilation if the object format supports it.</span>
    <span class="tok-comment">/// https://learn.microsoft.com/en-us/windows/win32/sbscs/manifest-files-reference</span>
    <span class="tok-comment">/// Manifest files must have the extension `.manifest`.</span>
    <span class="tok-comment">/// Can be set regardless of target. The `.manifest` file will be ignored</span>
    <span class="tok-comment">/// if the target object format does not support embedded manifests.</span>
    win32_manifest: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Kind = <span class="tok-kw">enum</span> {
    exe,
    lib,
    obj,
    @&quot;test&quot;,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> HeaderInstallation = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    file: <a href="std.Build.Step.Compile.HeaderInstallation.File.html">File</a>,
    directory: <a href="std.Build.Step.Compile.HeaderInstallation.Directory.html">Directory</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> File = <span class="tok-kw">struct</span> {
        source: <a href="std.Build.LazyPath.html">LazyPath</a>,
        dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(file: <a href="std.Build.Step.Compile.HeaderInstallation.File.html">File</a>, b: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>) <a href="std.Build.Step.Compile.HeaderInstallation.File.html">File</a> {
            <span class="tok-kw">return</span> .{
                .source = file.source.dupe(b),
                .dest_rel_path = b.dupePath(file.dest_rel_path),
            };
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Directory = <span class="tok-kw">struct</span> {
        source: <a href="std.Build.LazyPath.html">LazyPath</a>,
        dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        options: <a href="std.Build.Step.Compile.HeaderInstallation.Directory.html">Directory</a>.<a href="std.Build.Step.Compile.HeaderInstallation.Directory.Options.html">Options</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Options = <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// File paths that end in any of these suffixes will be excluded from installation.</span>
            exclude_extensions: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;.{},
            <span class="tok-comment">/// Only file paths that end in any of these suffixes will be included in installation.</span>
            <span class="tok-comment">/// `null` means that all suffixes will be included.</span>
            <span class="tok-comment">/// `exclude_extensions` takes precedence over `include_extensions`.</span>
            include_extensions: ?[]<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;.{<span class="tok-str">&quot;.h&quot;</span>},

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(opts: <a href="std.Build.Step.Compile.HeaderInstallation.Directory.html">Directory</a>.<a href="std.Build.Step.Compile.HeaderInstallation.Directory.Options.html">Options</a>, b: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>) <a href="std.Build.Step.Compile.HeaderInstallation.Directory.html">Directory</a>.<a href="std.Build.Step.Compile.HeaderInstallation.Directory.Options.html">Options</a> {
                <span class="tok-kw">return</span> .{
                    .exclude_extensions = b.dupeStrings(opts.exclude_extensions),
                    .include_extensions = <span class="tok-kw">if</span> (opts.include_extensions) |incs| b.dupeStrings(incs) <span class="tok-kw">else</span> <span class="tok-null">null</span>,
                };
            }
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(dir: <a href="std.Build.Step.Compile.HeaderInstallation.Directory.html">Directory</a>, b: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>) <a href="std.Build.Step.Compile.HeaderInstallation.Directory.html">Directory</a> {
            <span class="tok-kw">return</span> .{
                .source = dir.source.dupe(b),
                .dest_rel_path = b.dupePath(dir.dest_rel_path),
                .options = dir.options.dupe(b),
            };
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSource</span>(installation: <a href="std.Build.Step.Compile.HeaderInstallation.html">HeaderInstallation</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (installation) {
            <span class="tok-kw">inline</span> .file, .directory =&gt; |x| x.source,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(installation: <a href="std.Build.Step.Compile.HeaderInstallation.html">HeaderInstallation</a>, b: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>) <a href="std.Build.Step.Compile.HeaderInstallation.html">HeaderInstallation</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (installation) {
            .file =&gt; |f| .{ .file = f.dupe(b) },
            .directory =&gt; |d| .{ .directory = d.dupe(b) },
        };
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TestRunner = <span class="tok-kw">struct</span> {
    path: <a href="std.Build.LazyPath.html">LazyPath</a>,
    <span class="tok-comment">/// Test runners can either be &quot;simple&quot;, running tests when spawned and terminating when the</span>
    <span class="tok-comment">/// tests are complete, or they can use `std.zig.Server` over stdio to interact more closely</span>
    <span class="tok-comment">/// with the build system.</span>
    mode: <span class="tok-kw">enum</span> { simple, server },
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(owner: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>, options: <a href="std.Build.Step.Compile.Options.html">Options</a>) *<a href="std.Build.Step.Compile.html">Compile</a> {
    <span class="tok-kw">const</span> name = owner.dupe(options.name);
    <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;/&quot;</span>) != <span class="tok-null">null</span> <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;\\&quot;</span>) != <span class="tok-null">null</span>) {
        <a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;invalid name: '{s}'. It looks like a file path, but it is supposed to be the library or application name.&quot;</span>, .{name});
    }<span class="tok-comment">

    // Avoid the common case of the step name looking like &quot;zig test test&quot;.
    </span><span class="tok-kw">const</span> name_adjusted = <span class="tok-kw">if</span> (options.kind == .@&quot;test&quot; <span class="tok-kw">and</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;test&quot;</span>))
        <span class="tok-str">&quot;&quot;</span>
    <span class="tok-kw">else</span>
        owner.fmt(<span class="tok-str">&quot;{s} &quot;</span>, .{name});

    <span class="tok-kw">const</span> resolved_target = options.root_module.resolved_target <span class="tok-kw">orelse</span>
        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;the root Module of a Compile step must be created with a known 'target' field&quot;</span>);
    <span class="tok-kw">const</span> target = resolved_target.result;

    <span class="tok-kw">const</span> step_name = owner.fmt(<span class="tok-str">&quot;{s} {s}{s} {s}&quot;</span>, .{
        <span class="tok-kw">switch</span> (options.kind) {
            .exe =&gt; <span class="tok-str">&quot;zig build-exe&quot;</span>,
            .lib =&gt; <span class="tok-str">&quot;zig build-lib&quot;</span>,
            .obj =&gt; <span class="tok-str">&quot;zig build-obj&quot;</span>,
            .@&quot;test&quot; =&gt; <span class="tok-str">&quot;zig test&quot;</span>,
        },
        name_adjusted,
        <span class="tok-builtin">@tagName</span>(options.root_module.optimize <span class="tok-kw">orelse</span> .Debug),
        resolved_target.query.zigTriple(owner.allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>),
    });

    <span class="tok-kw">const</span> out_filename = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.binNameAlloc">binNameAlloc</a>(owner.allocator, .{
        .root_name = name,
        .target = target,
        .output_mode = <span class="tok-kw">switch</span> (options.kind) {
            .lib =&gt; .Lib,
            .obj =&gt; .Obj,
            .exe, .@&quot;test&quot; =&gt; .Exe,
        },
        .link_mode = options.linkage,
        .version = options.version,
    }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);

    <span class="tok-kw">const</span> compile = owner.allocator.create(<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    compile.* = .{
        .root_module = options.root_module,
        .verbose_link = <span class="tok-null">false</span>,
        .verbose_cc = <span class="tok-null">false</span>,
        .linkage = options.linkage,
        .kind = options.kind,
        .name = name,
        .step = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.html#std.Build.Step.init">init</a>(.{
            .id = <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.base_id">base_id</a>,
            .name = step_name,
            .owner = owner,
            .makeFn = <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.make">make</a>,
            .max_rss = options.max_rss,
        }),
        .version = options.version,
        .out_filename = out_filename,
        .out_lib_filename = <span class="tok-null">undefined</span>,
        .major_only_filename = <span class="tok-null">null</span>,
        .name_only_filename = <span class="tok-null">null</span>,
        .installed_headers = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.Step.Compile.HeaderInstallation.html">HeaderInstallation</a>).init(owner.allocator),
        .zig_lib_dir = <span class="tok-null">null</span>,
        .exec_cmd_args = <span class="tok-null">null</span>,
        .filters = options.filters,
        .test_runner = <span class="tok-null">null</span>,<span class="tok-comment"> // set below
        </span>.rdynamic = <span class="tok-null">false</span>,
        .installed_path = <span class="tok-null">null</span>,
        .force_undefined_symbols = <a href="std.hash_map.html#std.hash_map.StringHashMap">StringHashMap</a>(<span class="tok-type">void</span>).init(owner.allocator),

        .emit_directory = <span class="tok-null">null</span>,
        .generated_docs = <span class="tok-null">null</span>,
        .generated_asm = <span class="tok-null">null</span>,
        .generated_bin = <span class="tok-null">null</span>,
        .generated_pdb = <span class="tok-null">null</span>,
        .generated_implib = <span class="tok-null">null</span>,
        .generated_llvm_bc = <span class="tok-null">null</span>,
        .generated_llvm_ir = <span class="tok-null">null</span>,
        .generated_h = <span class="tok-null">null</span>,

        .use_llvm = options.use_llvm,
        .use_lld = options.use_lld,

        .zig_process = <span class="tok-null">null</span>,
    };

    <span class="tok-kw">if</span> (options.zig_lib_dir) |lp| {
        compile.zig_lib_dir = lp.dupe(compile.step.owner);
        lp.addStepDependencies(&amp;compile.step);
    }

    <span class="tok-kw">if</span> (options.test_runner) |runner| {
        compile.test_runner = .{
            .path = runner.path.dupe(compile.step.owner),
            .mode = runner.mode,
        };
        runner.path.addStepDependencies(&amp;compile.step);
    }<span class="tok-comment">

    // Only the PE/COFF format has a Resource Table which is where the manifest
    // gets embedded, so for any other target the manifest file is just ignored.
    </span><span class="tok-kw">if</span> (target.ofmt == .coff) {
        <span class="tok-kw">if</span> (options.win32_manifest) |lp| {
            compile.win32_manifest = lp.dupe(compile.step.owner);
            lp.addStepDependencies(&amp;compile.step);
        }
    }

    <span class="tok-kw">if</span> (compile.kind == .lib) {
        <span class="tok-kw">if</span> (compile.linkage != <span class="tok-null">null</span> <span class="tok-kw">and</span> compile.linkage.? == .static) {
            compile.out_lib_filename = compile.out_filename;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (compile.version) |version| {
            <span class="tok-kw">if</span> (target.os.tag.isDarwin()) {
                compile.major_only_filename = owner.fmt(<span class="tok-str">&quot;lib{s}.{d}.dylib&quot;</span>, .{
                    compile.name,
                    version.major,
                });
                compile.name_only_filename = owner.fmt(<span class="tok-str">&quot;lib{s}.dylib&quot;</span>, .{compile.name});
                compile.out_lib_filename = compile.out_filename;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (target.os.tag == .windows) {
                compile.out_lib_filename = owner.fmt(<span class="tok-str">&quot;{s}.lib&quot;</span>, .{compile.name});
            } <span class="tok-kw">else</span> {
                compile.major_only_filename = owner.fmt(<span class="tok-str">&quot;lib{s}.so.{d}&quot;</span>, .{ compile.name, version.major });
                compile.name_only_filename = owner.fmt(<span class="tok-str">&quot;lib{s}.so&quot;</span>, .{compile.name});
                compile.out_lib_filename = compile.out_filename;
            }
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">if</span> (target.os.tag.isDarwin()) {
                compile.out_lib_filename = compile.out_filename;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (target.os.tag == .windows) {
                compile.out_lib_filename = owner.fmt(<span class="tok-str">&quot;{s}.lib&quot;</span>, .{compile.name});
            } <span class="tok-kw">else</span> {
                compile.out_lib_filename = compile.out_filename;
            }
        }
    }

    <span class="tok-kw">return</span> compile;
}

<span class="tok-comment">/// Marks the specified header for installation alongside this artifact.</span>
<span class="tok-comment">/// When a module links with this artifact, all headers marked for installation are added to that</span>
<span class="tok-comment">/// module's include search path.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installHeader</span>(cs: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> b = cs.step.owner;
    <span class="tok-kw">const</span> installation: <a href="std.Build.Step.Compile.HeaderInstallation.html">HeaderInstallation</a> = .{ .file = .{
        .source = source.dupe(b),
        .dest_rel_path = b.dupePath(dest_rel_path),
    } };
    cs.installed_headers.append(installation) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    cs.addHeaderInstallationToIncludeTree(installation);
    installation.getSource().addStepDependencies(&amp;cs.step);
}

<span class="tok-comment">/// Marks headers from the specified directory for installation alongside this artifact.</span>
<span class="tok-comment">/// When a module links with this artifact, all headers marked for installation are added to that</span>
<span class="tok-comment">/// module's include search path.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installHeadersDirectory</span>(
    cs: *<a href="std.Build.Step.Compile.html">Compile</a>,
    source: <a href="std.Build.LazyPath.html">LazyPath</a>,
    dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    options: <a href="std.Build.Step.Compile.HeaderInstallation.html">HeaderInstallation</a>.<a href="std.Build.Step.Compile.HeaderInstallation.Directory.html">Directory</a>.<a href="std.Build.Step.Compile.HeaderInstallation.Directory.Options.html">Options</a>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> b = cs.step.owner;
    <span class="tok-kw">const</span> installation: <a href="std.Build.Step.Compile.HeaderInstallation.html">HeaderInstallation</a> = .{ .directory = .{
        .source = source.dupe(b),
        .dest_rel_path = b.dupePath(dest_rel_path),
        .options = options.dupe(b),
    } };
    cs.installed_headers.append(installation) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    cs.addHeaderInstallationToIncludeTree(installation);
    installation.getSource().addStepDependencies(&amp;cs.step);
}

<span class="tok-comment">/// Marks the specified config header for installation alongside this artifact.</span>
<span class="tok-comment">/// When a module links with this artifact, all headers marked for installation are added to that</span>
<span class="tok-comment">/// module's include search path.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installConfigHeader</span>(cs: *<a href="std.Build.Step.Compile.html">Compile</a>, config_header: *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ConfigHeader.html">ConfigHeader</a>) <span class="tok-type">void</span> {
    cs.installHeader(config_header.getOutput(), config_header.include_path);
}

<span class="tok-comment">/// Forwards all headers marked for installation from `lib` to this artifact.</span>
<span class="tok-comment">/// When a module links with this artifact, all headers marked for installation are added to that</span>
<span class="tok-comment">/// module's include search path.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installLibraryHeaders</span>(cs: *<a href="std.Build.Step.Compile.html">Compile</a>, lib: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(lib.kind == .lib);
    <span class="tok-kw">for</span> (lib.installed_headers.items) |installation| {
        <span class="tok-kw">const</span> installation_copy = installation.dupe(lib.step.owner);
        cs.installed_headers.append(installation_copy) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
        cs.addHeaderInstallationToIncludeTree(installation_copy);
        installation_copy.getSource().addStepDependencies(&amp;cs.step);
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">addHeaderInstallationToIncludeTree</span>(cs: *<a href="std.Build.Step.Compile.html">Compile</a>, installation: <a href="std.Build.Step.Compile.HeaderInstallation.html">HeaderInstallation</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (cs.installed_headers_include_tree) |wf| <span class="tok-kw">switch</span> (installation) {
        .file =&gt; |file| {
            _ = wf.addCopyFile(file.source, file.dest_rel_path);
        },
        .directory =&gt; |dir| {
            _ = wf.addCopyDirectory(dir.source, dir.dest_rel_path, .{
                .exclude_extensions = dir.options.exclude_extensions,
                .include_extensions = dir.options.include_extensions,
            });
        },
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedIncludeTree</span>(cs: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">if</span> (cs.installed_headers_include_tree) |wf| <span class="tok-kw">return</span> wf.getDirectory();
    <span class="tok-kw">const</span> b = cs.step.owner;
    <span class="tok-kw">const</span> wf = b.addWriteFiles();
    cs.installed_headers_include_tree = wf;
    <span class="tok-kw">for</span> (cs.installed_headers.items) |installation| {
        cs.addHeaderInstallationToIncludeTree(installation);
    }<span class="tok-comment">
    // The compile step itself does not need to depend on the write files step,
    // only dependent modules do.
    </span><span class="tok-kw">return</span> wf.getDirectory();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addObjCopy</span>(cs: *<a href="std.Build.Step.Compile.html">Compile</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ObjCopy.html">ObjCopy</a>.<a href="std.Build.Step.ObjCopy.Options.html">Options</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ObjCopy.html">ObjCopy</a> {
    <span class="tok-kw">const</span> b = cs.step.owner;
    <span class="tok-kw">var</span> copy = options;
    <span class="tok-kw">if</span> (copy.basename == <span class="tok-null">null</span>) {
        <span class="tok-kw">if</span> (options.format) |f| {
            copy.basename = b.fmt(<span class="tok-str">&quot;{s}.{s}&quot;</span>, .{ cs.name, <span class="tok-builtin">@tagName</span>(f) });
        } <span class="tok-kw">else</span> {
            copy.basename = cs.name;
        }
    }
    <span class="tok-kw">return</span> b.addObjCopy(cs.getEmittedBin(), copy);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkObject</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.CheckObject.html">CheckObject</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.CheckObject.html">CheckObject</a>.<a href="std.Build.Step.CheckObject.html#std.Build.Step.CheckObject.create">create</a>(compile.step.owner, compile.getEmittedBin(), compile.rootModuleTarget().ofmt);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setLinkerScript</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> b = compile.step.owner;
    compile.linker_script = source.dupe(b);
    source.addStepDependencies(&amp;compile.step);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setVersionScript</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> b = compile.step.owner;
    compile.version_script = source.dupe(b);
    source.addStepDependencies(&amp;compile.step);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">forceUndefinedSymbol</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, symbol_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> b = compile.step.owner;
    compile.force_undefined_symbols.put(b.dupe(symbol_name), {}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
}

<span class="tok-comment">/// Returns whether the library, executable, or object depends on a particular system library.</span>
<span class="tok-comment">/// Includes transitive dependencies.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dependsOnSystemLibrary</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">var</span> is_linking_libc = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> is_linking_libcpp = <span class="tok-null">false</span>;

    <span class="tok-kw">for</span> (compile.getCompileDependencies(<span class="tok-null">true</span>)) |some_compile| {
        <span class="tok-kw">for</span> (some_compile.root_module.getGraph().modules) |mod| {
            <span class="tok-kw">for</span> (mod.link_objects.items) |lo| {
                <span class="tok-kw">switch</span> (lo) {
                    .system_lib =&gt; |lib| <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, lib.name, name)) <span class="tok-kw">return</span> <span class="tok-null">true</span>,
                    <span class="tok-kw">else</span> =&gt; {},
                }
            }
            <span class="tok-kw">if</span> (mod.link_libc <span class="tok-kw">orelse</span> <span class="tok-null">false</span>) is_linking_libc = <span class="tok-null">true</span>;
            <span class="tok-kw">if</span> (mod.link_libcpp <span class="tok-kw">orelse</span> <span class="tok-null">false</span>) is_linking_libcpp = <span class="tok-null">true</span>;
        }
    }

    <span class="tok-kw">const</span> target = compile.rootModuleTarget();

    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.target.html">target</a>.<a href="std.zig.target.html#std.zig.target.isLibCLibName">isLibCLibName</a>(target, name)) {
        <span class="tok-kw">return</span> is_linking_libc;
    }

    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.target.html">target</a>.<a href="std.zig.target.html#std.zig.target.isLibCxxLibName">isLibCxxLibName</a>(target, name)) {
        <span class="tok-kw">return</span> is_linking_libcpp;
    }

    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isDynamicLibrary</span>(compile: *<span class="tok-kw">const</span> <a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> compile.kind == .lib <span class="tok-kw">and</span> compile.linkage == .dynamic;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isStaticLibrary</span>(compile: *<span class="tok-kw">const</span> <a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> compile.kind == .lib <span class="tok-kw">and</span> compile.linkage != .dynamic;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isDll</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> compile.isDynamicLibrary() <span class="tok-kw">and</span> compile.rootModuleTarget().os.tag == .windows;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">producesPdbFile</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> target = compile.rootModuleTarget();<span class="tok-comment">
    // TODO: Is this right? Isn't PDB for *any* PE/COFF file?
    // TODO: just share this logic with the compiler, silly!
    </span><span class="tok-kw">switch</span> (target.os.tag) {
        .windows, .uefi =&gt; {},
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
    }
    <span class="tok-kw">if</span> (target.ofmt == .c) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    <span class="tok-kw">if</span> (compile.root_module.strip == <span class="tok-null">true</span> <span class="tok-kw">or</span>
        (compile.root_module.strip == <span class="tok-null">null</span> <span class="tok-kw">and</span> compile.root_module.optimize == .ReleaseSmall))
    {
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }
    <span class="tok-kw">return</span> compile.isDynamicLibrary() <span class="tok-kw">or</span> compile.kind == .exe <span class="tok-kw">or</span> compile.kind == .@&quot;test&quot;;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">producesImplib</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> compile.isDll();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkLibC</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">void</span> {
    compile.root_module.link_libc = <span class="tok-null">true</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkLibCpp</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">void</span> {
    compile.root_module.link_libcpp = <span class="tok-null">true</span>;
}

<span class="tok-kw">const</span> PkgConfigResult = <span class="tok-kw">struct</span> {
    cflags: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    libs: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
};

<span class="tok-comment">/// Run pkg-config for the given library name and parse the output, returning the arguments</span>
<span class="tok-comment">/// that should be passed to zig to link the given library.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">runPkgConfig</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, lib_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<a href="std.Build.Step.Compile.PkgConfigResult.html">PkgConfigResult</a> {
    <span class="tok-kw">const</span> wl_rpath_prefix = <span class="tok-str">&quot;-Wl,-rpath,&quot;</span>;

    <span class="tok-kw">const</span> b = compile.step.owner;
    <span class="tok-kw">const</span> pkg_name = match: {<span class="tok-comment">
        // First we have to map the library name to pkg config name. Unfortunately,
        // there are several examples where this is not straightforward:
        // -lSDL2 -&gt; pkg-config sdl2
        // -lgdk-3 -&gt; pkg-config gdk-3.0
        // -latk-1.0 -&gt; pkg-config atk
        // -lpulse -&gt; pkg-config libpulse
        </span><span class="tok-kw">const</span> pkgs = <span class="tok-kw">try</span> <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.getPkgConfigList">getPkgConfigList</a>(b);<span class="tok-comment">

        // Exact match means instant winner.
        </span><span class="tok-kw">for</span> (pkgs) |pkg| {
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, pkg.name, lib_name)) {
                <span class="tok-kw">break</span> :match pkg.name;
            }
        }<span class="tok-comment">

        // Next we'll try ignoring case.
        </span><span class="tok-kw">for</span> (pkgs) |pkg| {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(pkg.name, lib_name)) {
                <span class="tok-kw">break</span> :match pkg.name;
            }
        }<span class="tok-comment">

        // Prefixed &quot;lib&quot; or suffixed &quot;.0&quot;.
        </span><span class="tok-kw">for</span> (pkgs) |pkg| {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.indexOfIgnoreCase">indexOfIgnoreCase</a>(pkg.name, lib_name)) |pos| {
                <span class="tok-kw">const</span> prefix = pkg.name[<span class="tok-number">0</span>..pos];
                <span class="tok-kw">const</span> suffix = pkg.name[pos + lib_name.len ..];
                <span class="tok-kw">if</span> (prefix.len &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> !<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, prefix, <span class="tok-str">&quot;lib&quot;</span>)) <span class="tok-kw">continue</span>;
                <span class="tok-kw">if</span> (suffix.len &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> !<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, suffix, <span class="tok-str">&quot;.0&quot;</span>)) <span class="tok-kw">continue</span>;
                <span class="tok-kw">break</span> :match pkg.name;
            }
        }<span class="tok-comment">

        // Trimming &quot;-1.0&quot;.
        </span><span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.endsWith">endsWith</a>(<span class="tok-type">u8</span>, lib_name, <span class="tok-str">&quot;-1.0&quot;</span>)) {
            <span class="tok-kw">const</span> trimmed_lib_name = lib_name[<span class="tok-number">0</span> .. lib_name.len - <span class="tok-str">&quot;-1.0&quot;</span>.len];
            <span class="tok-kw">for</span> (pkgs) |pkg| {
                <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(pkg.name, trimmed_lib_name)) {
                    <span class="tok-kw">break</span> :match pkg.name;
                }
            }
        }

        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PackageNotFound;
    };

    <span class="tok-kw">var</span> code: <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> pkg_config_exe = b.graph.env_map.get(<span class="tok-str">&quot;PKG_CONFIG&quot;</span>) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;pkg-config&quot;</span>;
    <span class="tok-kw">const</span> stdout = <span class="tok-kw">if</span> (b.runAllowFail(&amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{
        pkg_config_exe,
        pkg_name,
        <span class="tok-str">&quot;--cflags&quot;</span>,
        <span class="tok-str">&quot;--libs&quot;</span>,
    }, &amp;code, .Ignore)) |stdout| stdout <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.ProcessTerminated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PkgConfigCrashed,
        <span class="tok-kw">error</span>.ExecNotSupported =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PkgConfigFailed,
        <span class="tok-kw">error</span>.ExitCodeFailure =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PkgConfigFailed,
        <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PkgConfigNotInstalled,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };

    <span class="tok-kw">var</span> zig_cflags = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(b.allocator);
    <span class="tok-kw">defer</span> zig_cflags.deinit();
    <span class="tok-kw">var</span> zig_libs = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(b.allocator);
    <span class="tok-kw">defer</span> zig_libs.deinit();

    <span class="tok-kw">var</span> arg_it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a>(<span class="tok-type">u8</span>, stdout, <span class="tok-str">&quot; \r\n\t&quot;</span>);
    <span class="tok-kw">while</span> (arg_it.next()) |arg| {
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, arg, <span class="tok-str">&quot;-I&quot;</span>)) {
            <span class="tok-kw">const</span> dir = arg_it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PkgConfigInvalidOutput;
            <span class="tok-kw">try</span> zig_cflags.appendSlice(&amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;-I&quot;</span>, dir });
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u8</span>, arg, <span class="tok-str">&quot;-I&quot;</span>)) {
            <span class="tok-kw">try</span> zig_cflags.append(arg);
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, arg, <span class="tok-str">&quot;-L&quot;</span>)) {
            <span class="tok-kw">const</span> dir = arg_it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PkgConfigInvalidOutput;
            <span class="tok-kw">try</span> zig_libs.appendSlice(&amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;-L&quot;</span>, dir });
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u8</span>, arg, <span class="tok-str">&quot;-L&quot;</span>)) {
            <span class="tok-kw">try</span> zig_libs.append(arg);
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, arg, <span class="tok-str">&quot;-l&quot;</span>)) {
            <span class="tok-kw">const</span> lib = arg_it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PkgConfigInvalidOutput;
            <span class="tok-kw">try</span> zig_libs.appendSlice(&amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;-l&quot;</span>, lib });
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u8</span>, arg, <span class="tok-str">&quot;-l&quot;</span>)) {
            <span class="tok-kw">try</span> zig_libs.append(arg);
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, arg, <span class="tok-str">&quot;-D&quot;</span>)) {
            <span class="tok-kw">const</span> macro = arg_it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PkgConfigInvalidOutput;
            <span class="tok-kw">try</span> zig_cflags.appendSlice(&amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;-D&quot;</span>, macro });
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u8</span>, arg, <span class="tok-str">&quot;-D&quot;</span>)) {
            <span class="tok-kw">try</span> zig_cflags.append(arg);
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u8</span>, arg, wl_rpath_prefix)) {
            <span class="tok-kw">try</span> zig_cflags.appendSlice(&amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;-rpath&quot;</span>, arg[wl_rpath_prefix.len..] });
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.debug_pkg_config) {
            <span class="tok-kw">return</span> compile.step.fail(<span class="tok-str">&quot;unknown pkg-config flag '{s}'&quot;</span>, .{arg});
        }
    }

    <span class="tok-kw">return</span> .{
        .cflags = <span class="tok-kw">try</span> zig_cflags.toOwnedSlice(),
        .libs = <span class="tok-kw">try</span> zig_libs.toOwnedSlice(),
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkSystemLibrary</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> compile.root_module.linkSystemLibrary(name, .{});
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkSystemLibrary2</span>(
    compile: *<a href="std.Build.Step.Compile.html">Compile</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    options: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.LinkSystemLibraryOptions.html">LinkSystemLibraryOptions</a>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> compile.root_module.linkSystemLibrary(name, options);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkFramework</span>(c: *<a href="std.Build.Step.Compile.html">Compile</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    c.root_module.linkFramework(name, .{});
}

<span class="tok-comment">/// Handy when you have many C/C++ source files and want them all to have the same flags.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCSourceFiles</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, options: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.AddCSourceFilesOptions.html">AddCSourceFilesOptions</a>) <span class="tok-type">void</span> {
    compile.root_module.addCSourceFiles(options);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCSourceFile</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.CSourceFile.html">CSourceFile</a>) <span class="tok-type">void</span> {
    compile.root_module.addCSourceFile(source);
}

<span class="tok-comment">/// Resource files must have the extension `.rc`.</span>
<span class="tok-comment">/// Can be called regardless of target. The .rc file will be ignored</span>
<span class="tok-comment">/// if the target object format does not support embedded resources.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWin32ResourceFile</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.RcSourceFile.html">RcSourceFile</a>) <span class="tok-type">void</span> {
    compile.root_module.addWin32ResourceFile(source);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setVerboseLink</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    compile.verbose_link = value;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setVerboseCC</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    compile.verbose_cc = value;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setLibCFile</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, libc_file: ?<a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> b = compile.step.owner;
    <span class="tok-kw">if</span> (libc_file) |f| {
        compile.libc_file = f.dupe(b);
        f.addStepDependencies(&amp;compile.step);
    } <span class="tok-kw">else</span> {
        compile.libc_file = <span class="tok-null">null</span>;
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">getEmittedFileGeneric</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, output_file: *?*<a href="std.Build.GeneratedFile.html">GeneratedFile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">if</span> (output_file.*) |file| <span class="tok-kw">return</span> .{ .generated = .{ .file = file } };
    <span class="tok-kw">const</span> arena = compile.step.owner.allocator;
    <span class="tok-kw">const</span> generated_file = arena.create(<a href="std.Build.GeneratedFile.html">GeneratedFile</a>) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    generated_file.* = .{ .step = &amp;compile.step };
    output_file.* = generated_file;
    <span class="tok-kw">return</span> .{ .generated = .{ .file = generated_file } };
}

<span class="tok-comment">/// Returns the path to the directory that contains the emitted binary file.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedBinDirectory</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    _ = compile.getEmittedBin();
    <span class="tok-kw">return</span> compile.getEmittedFileGeneric(&amp;compile.emit_directory);
}

<span class="tok-comment">/// Returns the path to the generated executable, library or object file.</span>
<span class="tok-comment">/// To run an executable built with zig build, use `run`, or create an install step and invoke it.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedBin</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">return</span> compile.getEmittedFileGeneric(&amp;compile.generated_bin);
}

<span class="tok-comment">/// Returns the path to the generated import library.</span>
<span class="tok-comment">/// This function can only be called for libraries.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedImplib</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(compile.kind == .lib);
    <span class="tok-kw">return</span> compile.getEmittedFileGeneric(&amp;compile.generated_implib);
}

<span class="tok-comment">/// Returns the path to the generated header file.</span>
<span class="tok-comment">/// This function can only be called for libraries or objects.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedH</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(compile.kind != .exe <span class="tok-kw">and</span> compile.kind != .@&quot;test&quot;);
    <span class="tok-kw">return</span> compile.getEmittedFileGeneric(&amp;compile.generated_h);
}

<span class="tok-comment">/// Returns the generated PDB file.</span>
<span class="tok-comment">/// If the compilation does not produce a PDB file, this causes a FileNotFound error</span>
<span class="tok-comment">/// at build time.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedPdb</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    _ = compile.getEmittedBin();
    <span class="tok-kw">return</span> compile.getEmittedFileGeneric(&amp;compile.generated_pdb);
}

<span class="tok-comment">/// Returns the path to the generated documentation directory.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedDocs</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">return</span> compile.getEmittedFileGeneric(&amp;compile.generated_docs);
}

<span class="tok-comment">/// Returns the path to the generated assembly code.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedAsm</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">return</span> compile.getEmittedFileGeneric(&amp;compile.generated_asm);
}

<span class="tok-comment">/// Returns the path to the generated LLVM IR.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedLlvmIr</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">return</span> compile.getEmittedFileGeneric(&amp;compile.generated_llvm_ir);
}

<span class="tok-comment">/// Returns the path to the generated LLVM BC.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEmittedLlvmBc</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">return</span> compile.getEmittedFileGeneric(&amp;compile.generated_llvm_bc);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAssemblyFile</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    compile.root_module.addAssemblyFile(source);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addObjectFile</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    compile.root_module.addObjectFile(source);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addObject</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, object: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">void</span> {
    compile.root_module.addObject(object);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkLibrary</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, library: *<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">void</span> {
    compile.root_module.linkLibrary(library);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAfterIncludePath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    compile.root_module.addAfterIncludePath(lazy_path);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSystemIncludePath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    compile.root_module.addSystemIncludePath(lazy_path);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addIncludePath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    compile.root_module.addIncludePath(lazy_path);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addConfigHeader</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, config_header: *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ConfigHeader.html">ConfigHeader</a>) <span class="tok-type">void</span> {
    compile.root_module.addConfigHeader(config_header);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addLibraryPath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, directory_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    compile.root_module.addLibraryPath(directory_path);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addRPath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, directory_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    compile.root_module.addRPath(directory_path);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSystemFrameworkPath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, directory_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    compile.root_module.addSystemFrameworkPath(directory_path);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFrameworkPath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, directory_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    compile.root_module.addFrameworkPath(directory_path);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setExecCmd</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, args: []<span class="tok-kw">const</span> ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> b = compile.step.owner;
    <a href="std.debug.html#std.debug.assert">assert</a>(compile.kind == .@&quot;test&quot;);
    <span class="tok-kw">const</span> duped_args = b.allocator.alloc(?[]<span class="tok-type">u8</span>, args.len) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    <span class="tok-kw">for</span> (args, <span class="tok-number">0</span>..) |arg, i| {
        duped_args[i] = <span class="tok-kw">if</span> (arg) |a| b.dupe(a) <span class="tok-kw">else</span> <span class="tok-null">null</span>;
    }
    compile.exec_cmd_args = duped_args;
}

<span class="tok-kw">const</span> CliNamedModules = <span class="tok-kw">struct</span> {
    modules: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(*<a href="std.Build.Module.html">Module</a>, <span class="tok-type">void</span>),
    names: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMapUnmanaged">StringArrayHashMapUnmanaged</a>(<span class="tok-type">void</span>),

    <span class="tok-comment">/// Traverse the whole dependency graph and give every module a unique</span>
    <span class="tok-comment">/// name, ideally one named after what it's called somewhere in the graph.</span>
    <span class="tok-comment">/// It will help here to have both a mapping from module to name and a set</span>
    <span class="tok-comment">/// of all the currently-used names.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(arena: <a href="std.mem.Allocator.html">Allocator</a>, root_module: *<a href="std.Build.Module.html">Module</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.Build.Step.Compile.CliNamedModules.html">CliNamedModules</a> {
        <span class="tok-kw">var</span> compile: <a href="std.Build.Step.Compile.CliNamedModules.html">CliNamedModules</a> = .{
            .modules = .{},
            .names = .{},
        };
        <span class="tok-kw">const</span> graph = root_module.getGraph();
        {
            <a href="std.debug.html#std.debug.assert">assert</a>(graph.modules[<span class="tok-number">0</span>] == root_module);
            <span class="tok-kw">try</span> compile.modules.put(arena, root_module, {});
            <span class="tok-kw">try</span> compile.names.put(arena, <span class="tok-str">&quot;root&quot;</span>, {});
        }
        <span class="tok-kw">for</span> (graph.modules[<span class="tok-number">1</span>..], graph.names[<span class="tok-number">1</span>..]) |mod, orig_name| {
            <span class="tok-kw">var</span> name = orig_name;
            <span class="tok-kw">var</span> n: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> compile.names.getOrPut(arena, name);
                <span class="tok-kw">if</span> (!gop.found_existing) {
                    <span class="tok-kw">try</span> compile.modules.putNoClobber(arena, mod, {});
                    <span class="tok-kw">break</span>;
                }
                name = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrint">allocPrint</a>(arena, <span class="tok-str">&quot;{s}{d}&quot;</span>, .{ orig_name, n });
                n += <span class="tok-number">1</span>;
            }
        }
        <span class="tok-kw">return</span> compile;
    }
};

<span class="tok-kw">fn</span> <span class="tok-fn">getGeneratedFilePath</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, <span class="tok-kw">comptime</span> tag_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, asking_step: ?*<a href="std.Build.Step.html">Step</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> maybe_path: ?*<a href="std.Build.GeneratedFile.html">GeneratedFile</a> = <span class="tok-builtin">@field</span>(compile, tag_name);

    <span class="tok-kw">const</span> generated_file = maybe_path <span class="tok-kw">orelse</span> {
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.lockStdErr">lockStdErr</a>();
        <span class="tok-kw">const</span> stderr = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>();

        <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.html#std.Build.dumpBadGetPathHelp">dumpBadGetPathHelp</a>(&amp;compile.step, stderr, compile.step.owner, asking_step) <span class="tok-kw">catch</span> {};

        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;missing emit option for &quot;</span> ++ tag_name);
    };

    <span class="tok-kw">const</span> path = generated_file.path <span class="tok-kw">orelse</span> {
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.lockStdErr">lockStdErr</a>();
        <span class="tok-kw">const</span> stderr = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>();

        <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.html#std.Build.dumpBadGetPathHelp">dumpBadGetPathHelp</a>(&amp;compile.step, stderr, compile.step.owner, asking_step) <span class="tok-kw">catch</span> {};

        <span class="tok-builtin">@panic</span>(tag_name ++ <span class="tok-str">&quot; is null. Is there a missing step dependency?&quot;</span>);
    };

    <span class="tok-kw">return</span> path;
}

<span class="tok-kw">fn</span> <span class="tok-fn">getZigArgs</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>, fuzz: <span class="tok-type">bool</span>) ![][]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> step = &amp;compile.step;
    <span class="tok-kw">const</span> b = step.owner;
    <span class="tok-kw">const</span> arena = b.allocator;

    <span class="tok-kw">var</span> zig_args = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(arena);
    <span class="tok-kw">defer</span> zig_args.deinit();

    <span class="tok-kw">try</span> zig_args.append(b.graph.zig_exe);

    <span class="tok-kw">const</span> cmd = <span class="tok-kw">switch</span> (compile.kind) {
        .lib =&gt; <span class="tok-str">&quot;build-lib&quot;</span>,
        .exe =&gt; <span class="tok-str">&quot;build-exe&quot;</span>,
        .obj =&gt; <span class="tok-str">&quot;build-obj&quot;</span>,
        .@&quot;test&quot; =&gt; <span class="tok-str">&quot;test&quot;</span>,
    };
    <span class="tok-kw">try</span> zig_args.append(cmd);

    <span class="tok-kw">if</span> (b.reference_trace) |some| {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrint">allocPrint</a>(arena, <span class="tok-str">&quot;-freference-trace={d}&quot;</span>, .{some}));
    }
    <span class="tok-kw">try</span> <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.addFlag">addFlag</a>(&amp;zig_args, <span class="tok-str">&quot;allow-so-scripts&quot;</span>, compile.allow_so_scripts <span class="tok-kw">orelse</span> b.graph.allow_so_scripts);

    <span class="tok-kw">try</span> <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.addFlag">addFlag</a>(&amp;zig_args, <span class="tok-str">&quot;llvm&quot;</span>, compile.use_llvm);
    <span class="tok-kw">try</span> <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.addFlag">addFlag</a>(&amp;zig_args, <span class="tok-str">&quot;lld&quot;</span>, compile.use_lld);

    <span class="tok-kw">if</span> (compile.root_module.resolved_target.?.query.ofmt) |ofmt| {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrint">allocPrint</a>(arena, <span class="tok-str">&quot;-ofmt={s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(ofmt)}));
    }

    <span class="tok-kw">switch</span> (compile.entry) {
        .default =&gt; {},
        .disabled =&gt; <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-fno-entry&quot;</span>),
        .enabled =&gt; <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-fentry&quot;</span>),
        .symbol_name =&gt; |entry_name| {
            <span class="tok-kw">try</span> zig_args.append(<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrint">allocPrint</a>(arena, <span class="tok-str">&quot;-fentry={s}&quot;</span>, .{entry_name}));
        },
    }

    {
        <span class="tok-kw">var</span> symbol_it = compile.force_undefined_symbols.keyIterator();
        <span class="tok-kw">while</span> (symbol_it.next()) |symbol_name| {
            <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--force_undefined&quot;</span>);
            <span class="tok-kw">try</span> zig_args.append(symbol_name.*);
        }
    }

    <span class="tok-kw">if</span> (compile.stack_size) |stack_size| {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--stack&quot;</span>);
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrint">allocPrint</a>(arena, <span class="tok-str">&quot;{}&quot;</span>, .{stack_size}));
    }

    <span class="tok-kw">if</span> (fuzz) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-ffuzz&quot;</span>);
    }

    {<span class="tok-comment">
        // Stores system libraries that have already been seen for at least one
        // module, along with any arguments that need to be passed to the
        // compiler for each module individually.
        </span><span class="tok-kw">var</span> seen_system_libs: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.StringHashMapUnmanaged">StringHashMapUnmanaged</a>([]<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) = .empty;
        <span class="tok-kw">var</span> frameworks: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMapUnmanaged">StringArrayHashMapUnmanaged</a>(<a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.LinkFrameworkOptions.html">LinkFrameworkOptions</a>) = .empty;

        <span class="tok-kw">var</span> prev_has_cflags = <span class="tok-null">false</span>;
        <span class="tok-kw">var</span> prev_has_rcflags = <span class="tok-null">false</span>;
        <span class="tok-kw">var</span> prev_search_strategy: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.SystemLib.html">SystemLib</a>.<a href="std.Build.Module.SystemLib.SearchStrategy.html">SearchStrategy</a> = .paths_first;
        <span class="tok-kw">var</span> prev_preferred_link_mode: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.LinkMode.html">LinkMode</a> = .dynamic;<span class="tok-comment">
        // Track the number of positional arguments so that a nice error can be
        // emitted if there is nothing to link.
        </span><span class="tok-kw">var</span> total_linker_objects: <span class="tok-type">usize</span> = <span class="tok-builtin">@intFromBool</span>(compile.root_module.root_source_file != <span class="tok-null">null</span>);<span class="tok-comment">

        // Fully recursive iteration including dynamic libraries to detect
        // libc and libc++ linkage.
        </span><span class="tok-kw">for</span> (compile.getCompileDependencies(<span class="tok-null">true</span>)) |some_compile| {
            <span class="tok-kw">for</span> (some_compile.root_module.getGraph().modules) |mod| {
                <span class="tok-kw">if</span> (mod.link_libc == <span class="tok-null">true</span>) compile.is_linking_libc = <span class="tok-null">true</span>;
                <span class="tok-kw">if</span> (mod.link_libcpp == <span class="tok-null">true</span>) compile.is_linking_libcpp = <span class="tok-null">true</span>;
            }
        }

        <span class="tok-kw">var</span> cli_named_modules = <span class="tok-kw">try</span> <a href="std.Build.Step.Compile.CliNamedModules.html">CliNamedModules</a>.<a href="std.Build.Step.Compile.CliNamedModules.html#std.Build.Step.Compile.CliNamedModules.init">init</a>(arena, compile.root_module);<span class="tok-comment">

        // For this loop, don't chase dynamic libraries because their link
        // objects are already linked.
        </span><span class="tok-kw">for</span> (compile.getCompileDependencies(<span class="tok-null">false</span>)) |dep_compile| {
            <span class="tok-kw">for</span> (dep_compile.root_module.getGraph().modules) |mod| {<span class="tok-comment">
                // While walking transitive dependencies, if a given link object is
                // already included in a library, it should not redundantly be
                // placed on the linker line of the dependee.
                </span><span class="tok-kw">const</span> my_responsibility = dep_compile == compile;
                <span class="tok-kw">const</span> already_linked = !my_responsibility <span class="tok-kw">and</span> dep_compile.isDynamicLibrary();<span class="tok-comment">

                // Inherit dependencies on darwin frameworks.
                </span><span class="tok-kw">if</span> (!already_linked) {
                    <span class="tok-kw">for</span> (mod.frameworks.keys(), mod.frameworks.values()) |name, info| {
                        <span class="tok-kw">try</span> frameworks.put(arena, name, info);
                    }
                }<span class="tok-comment">

                // Inherit dependencies on system libraries and static libraries.
                </span><span class="tok-kw">for</span> (mod.link_objects.items) |link_object| {
                    <span class="tok-kw">switch</span> (link_object) {
                        .static_path =&gt; |static_path| {
                            <span class="tok-kw">if</span> (my_responsibility) {
                                <span class="tok-kw">try</span> zig_args.append(static_path.getPath2(mod.owner, step));
                                total_linker_objects += <span class="tok-number">1</span>;
                            }
                        },
                        .system_lib =&gt; |system_lib| {
                            <span class="tok-kw">const</span> system_lib_gop = <span class="tok-kw">try</span> seen_system_libs.getOrPut(arena, system_lib.name);
                            <span class="tok-kw">if</span> (system_lib_gop.found_existing) {
                                <span class="tok-kw">try</span> zig_args.appendSlice(system_lib_gop.value_ptr.*);
                                <span class="tok-kw">continue</span>;
                            } <span class="tok-kw">else</span> {
                                system_lib_gop.value_ptr.* = &amp;.{};
                            }

                            <span class="tok-kw">if</span> (already_linked)
                                <span class="tok-kw">continue</span>;

                            <span class="tok-kw">if</span> ((system_lib.search_strategy != prev_search_strategy <span class="tok-kw">or</span>
                                system_lib.preferred_link_mode != prev_preferred_link_mode) <span class="tok-kw">and</span>
                                compile.linkage != .static)
                            {
                                <span class="tok-kw">switch</span> (system_lib.search_strategy) {
                                    .no_fallback =&gt; <span class="tok-kw">switch</span> (system_lib.preferred_link_mode) {
                                        .dynamic =&gt; <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-search_dylibs_only&quot;</span>),
                                        .static =&gt; <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-search_static_only&quot;</span>),
                                    },
                                    .paths_first =&gt; <span class="tok-kw">switch</span> (system_lib.preferred_link_mode) {
                                        .dynamic =&gt; <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-search_paths_first&quot;</span>),
                                        .static =&gt; <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-search_paths_first_static&quot;</span>),
                                    },
                                    .mode_first =&gt; <span class="tok-kw">switch</span> (system_lib.preferred_link_mode) {
                                        .dynamic =&gt; <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-search_dylibs_first&quot;</span>),
                                        .static =&gt; <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-search_static_first&quot;</span>),
                                    },
                                }
                                prev_search_strategy = system_lib.search_strategy;
                                prev_preferred_link_mode = system_lib.preferred_link_mode;
                            }

                            <span class="tok-kw">const</span> prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = prefix: {
                                <span class="tok-kw">if</span> (system_lib.needed) <span class="tok-kw">break</span> :prefix <span class="tok-str">&quot;-needed-l&quot;</span>;
                                <span class="tok-kw">if</span> (system_lib.weak) <span class="tok-kw">break</span> :prefix <span class="tok-str">&quot;-weak-l&quot;</span>;
                                <span class="tok-kw">break</span> :prefix <span class="tok-str">&quot;-l&quot;</span>;
                            };
                            <span class="tok-kw">switch</span> (system_lib.use_pkg_config) {
                                .no =&gt; <span class="tok-kw">try</span> zig_args.append(b.fmt(<span class="tok-str">&quot;{s}{s}&quot;</span>, .{ prefix, system_lib.name })),
                                .yes, .force =&gt; {
                                    <span class="tok-kw">if</span> (compile.runPkgConfig(system_lib.name)) |result| {
                                        <span class="tok-kw">try</span> zig_args.appendSlice(result.cflags);
                                        <span class="tok-kw">try</span> zig_args.appendSlice(result.libs);
                                        <span class="tok-kw">try</span> seen_system_libs.put(arena, system_lib.name, result.cflags);
                                    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                                        <span class="tok-kw">error</span>.PkgConfigInvalidOutput,
                                        <span class="tok-kw">error</span>.PkgConfigCrashed,
                                        <span class="tok-kw">error</span>.PkgConfigFailed,
                                        <span class="tok-kw">error</span>.PkgConfigNotInstalled,
                                        <span class="tok-kw">error</span>.PackageNotFound,
                                        =&gt; <span class="tok-kw">switch</span> (system_lib.use_pkg_config) {
                                            .yes =&gt; {<span class="tok-comment">
                                                // pkg-config failed, so fall back to linking the library
                                                // by name directly.
                                                </span><span class="tok-kw">try</span> zig_args.append(b.fmt(<span class="tok-str">&quot;{s}{s}&quot;</span>, .{
                                                    prefix,
                                                    system_lib.name,
                                                }));
                                            },
                                            .force =&gt; {
                                                <a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;pkg-config failed for library {s}&quot;</span>, .{system_lib.name});
                                            },
                                            .no =&gt; <span class="tok-kw">unreachable</span>,
                                        },

                                        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
                                    }
                                },
                            }
                        },
                        .other_step =&gt; |other| {
                            <span class="tok-kw">switch</span> (other.kind) {
                                .exe =&gt; <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;cannot link with an executable build artifact&quot;</span>, .{}),
                                .@&quot;test&quot; =&gt; <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;cannot link with a test&quot;</span>, .{}),
                                .obj =&gt; {
                                    <span class="tok-kw">const</span> included_in_lib_or_obj = !my_responsibility <span class="tok-kw">and</span>
                                        (dep_compile.kind == .lib <span class="tok-kw">or</span> dep_compile.kind == .obj);
                                    <span class="tok-kw">if</span> (!already_linked <span class="tok-kw">and</span> !included_in_lib_or_obj) {
                                        <span class="tok-kw">try</span> zig_args.append(other.getEmittedBin().getPath2(b, step));
                                        total_linker_objects += <span class="tok-number">1</span>;
                                    }
                                },
                                .lib =&gt; l: {
                                    <span class="tok-kw">const</span> other_produces_implib = other.producesImplib();
                                    <span class="tok-kw">const</span> other_is_static = other_produces_implib <span class="tok-kw">or</span> other.isStaticLibrary();

                                    <span class="tok-kw">if</span> (compile.isStaticLibrary() <span class="tok-kw">and</span> other_is_static) {<span class="tok-comment">
                                        // Avoid putting a static library inside a static library.
                                        </span><span class="tok-kw">break</span> :l;
                                    }<span class="tok-comment">

                                    // For DLLs, we must link against the implib.
                                    // For everything else, we directly link
                                    // against the library file.
                                    </span><span class="tok-kw">const</span> full_path_lib = <span class="tok-kw">if</span> (other_produces_implib)
                                        other.getGeneratedFilePath(<span class="tok-str">&quot;generated_implib&quot;</span>, &amp;compile.step)
                                    <span class="tok-kw">else</span>
                                        other.getGeneratedFilePath(<span class="tok-str">&quot;generated_bin&quot;</span>, &amp;compile.step);

                                    <span class="tok-kw">try</span> zig_args.append(full_path_lib);
                                    total_linker_objects += <span class="tok-number">1</span>;

                                    <span class="tok-kw">if</span> (other.linkage == .dynamic <span class="tok-kw">and</span>
                                        compile.rootModuleTarget().os.tag != .windows)
                                    {
                                        <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(full_path_lib)) |dirname| {
                                            <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-rpath&quot;</span>);
                                            <span class="tok-kw">try</span> zig_args.append(dirname);
                                        }
                                    }
                                },
                            }
                        },
                        .assembly_file =&gt; |asm_file| l: {
                            <span class="tok-kw">if</span> (!my_responsibility) <span class="tok-kw">break</span> :l;

                            <span class="tok-kw">if</span> (prev_has_cflags) {
                                <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-cflags&quot;</span>);
                                <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--&quot;</span>);
                                prev_has_cflags = <span class="tok-null">false</span>;
                            }
                            <span class="tok-kw">try</span> zig_args.append(asm_file.getPath2(mod.owner, step));
                            total_linker_objects += <span class="tok-number">1</span>;
                        },

                        .c_source_file =&gt; |c_source_file| l: {
                            <span class="tok-kw">if</span> (!my_responsibility) <span class="tok-kw">break</span> :l;

                            <span class="tok-kw">if</span> (prev_has_cflags <span class="tok-kw">or</span> c_source_file.flags.len != <span class="tok-number">0</span>) {
                                <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-cflags&quot;</span>);
                                <span class="tok-kw">for</span> (c_source_file.flags) |arg| {
                                    <span class="tok-kw">try</span> zig_args.append(arg);
                                }
                                <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--&quot;</span>);
                            }
                            prev_has_cflags = (c_source_file.flags.len != <span class="tok-number">0</span>);

                            <span class="tok-kw">if</span> (c_source_file.language) |lang| {
                                <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-x&quot;</span>);
                                <span class="tok-kw">try</span> zig_args.append(lang.internalIdentifier());
                            }

                            <span class="tok-kw">try</span> zig_args.append(c_source_file.file.getPath2(mod.owner, step));

                            <span class="tok-kw">if</span> (c_source_file.language != <span class="tok-null">null</span>) {
                                <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-x&quot;</span>);
                                <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;none&quot;</span>);
                            }
                            total_linker_objects += <span class="tok-number">1</span>;
                        },

                        .c_source_files =&gt; |c_source_files| l: {
                            <span class="tok-kw">if</span> (!my_responsibility) <span class="tok-kw">break</span> :l;

                            <span class="tok-kw">if</span> (prev_has_cflags <span class="tok-kw">or</span> c_source_files.flags.len != <span class="tok-number">0</span>) {
                                <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-cflags&quot;</span>);
                                <span class="tok-kw">for</span> (c_source_files.flags) |arg| {
                                    <span class="tok-kw">try</span> zig_args.append(arg);
                                }
                                <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--&quot;</span>);
                            }
                            prev_has_cflags = (c_source_files.flags.len != <span class="tok-number">0</span>);

                            <span class="tok-kw">if</span> (c_source_files.language) |lang| {
                                <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-x&quot;</span>);
                                <span class="tok-kw">try</span> zig_args.append(lang.internalIdentifier());
                            }

                            <span class="tok-kw">const</span> root_path = c_source_files.root.getPath2(mod.owner, step);
                            <span class="tok-kw">for</span> (c_source_files.files) |file| {
                                <span class="tok-kw">try</span> zig_args.append(b.pathJoin(&amp;.{ root_path, file }));
                            }

                            <span class="tok-kw">if</span> (c_source_files.language != <span class="tok-null">null</span>) {
                                <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-x&quot;</span>);
                                <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;none&quot;</span>);
                            }

                            total_linker_objects += c_source_files.files.len;
                        },

                        .win32_resource_file =&gt; |rc_source_file| l: {
                            <span class="tok-kw">if</span> (!my_responsibility) <span class="tok-kw">break</span> :l;

                            <span class="tok-kw">if</span> (rc_source_file.flags.len == <span class="tok-number">0</span> <span class="tok-kw">and</span> rc_source_file.include_paths.len == <span class="tok-number">0</span>) {
                                <span class="tok-kw">if</span> (prev_has_rcflags) {
                                    <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-rcflags&quot;</span>);
                                    <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--&quot;</span>);
                                    prev_has_rcflags = <span class="tok-null">false</span>;
                                }
                            } <span class="tok-kw">else</span> {
                                <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-rcflags&quot;</span>);
                                <span class="tok-kw">for</span> (rc_source_file.flags) |arg| {
                                    <span class="tok-kw">try</span> zig_args.append(arg);
                                }
                                <span class="tok-kw">for</span> (rc_source_file.include_paths) |include_path| {
                                    <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;/I&quot;</span>);
                                    <span class="tok-kw">try</span> zig_args.append(include_path.getPath2(mod.owner, step));
                                }
                                <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--&quot;</span>);
                                prev_has_rcflags = <span class="tok-null">true</span>;
                            }
                            <span class="tok-kw">try</span> zig_args.append(rc_source_file.file.getPath2(mod.owner, step));
                            total_linker_objects += <span class="tok-number">1</span>;
                        },
                    }
                }<span class="tok-comment">

                // We need to emit the --mod argument here so that the above link objects
                // have the correct parent module, but only if the module is part of
                // this compilation.
                </span><span class="tok-kw">if</span> (!my_responsibility) <span class="tok-kw">continue</span>;
                <span class="tok-kw">if</span> (cli_named_modules.modules.getIndex(mod)) |module_cli_index| {
                    <span class="tok-kw">const</span> module_cli_name = cli_named_modules.names.keys()[module_cli_index];
                    <span class="tok-kw">try</span> mod.appendZigProcessFlags(&amp;zig_args, step);<span class="tok-comment">

                    // --dep arguments
                    </span><span class="tok-kw">try</span> zig_args.ensureUnusedCapacity(mod.import_table.count() * <span class="tok-number">2</span>);
                    <span class="tok-kw">for</span> (mod.import_table.keys(), mod.import_table.values()) |name, import| {
                        <span class="tok-kw">const</span> import_index = cli_named_modules.modules.getIndex(import).?;
                        <span class="tok-kw">const</span> import_cli_name = cli_named_modules.names.keys()[import_index];
                        zig_args.appendAssumeCapacity(<span class="tok-str">&quot;--dep&quot;</span>);
                        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, import_cli_name, name)) {
                            zig_args.appendAssumeCapacity(import_cli_name);
                        } <span class="tok-kw">else</span> {
                            zig_args.appendAssumeCapacity(b.fmt(<span class="tok-str">&quot;{s}={s}&quot;</span>, .{ name, import_cli_name }));
                        }
                    }<span class="tok-comment">

                    // When the CLI sees a -M argument, it determines whether it
                    // implies the existence of a Zig compilation unit based on
                    // whether there is a root source file. If there is no root
                    // source file, then this is not a zig compilation unit - it is
                    // perhaps a set of linker objects, or C source files instead.
                    // Linker objects are added to the CLI globally, while C source
                    // files must have a module parent.
                    </span><span class="tok-kw">if</span> (mod.root_source_file) |lp| {
                        <span class="tok-kw">const</span> src = lp.getPath2(mod.owner, step);
                        <span class="tok-kw">try</span> zig_args.append(b.fmt(<span class="tok-str">&quot;-M{s}={s}&quot;</span>, .{ module_cli_name, src }));
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.Build.Step.Compile.html#std.Build.Step.Compile.moduleNeedsCliArg">moduleNeedsCliArg</a>(mod)) {
                        <span class="tok-kw">try</span> zig_args.append(b.fmt(<span class="tok-str">&quot;-M{s}&quot;</span>, .{module_cli_name}));
                    }
                }
            }
        }

        <span class="tok-kw">if</span> (total_linker_objects == <span class="tok-number">0</span>) {
            <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;the linker needs one or more objects to link&quot;</span>, .{});
        }

        <span class="tok-kw">for</span> (frameworks.keys(), frameworks.values()) |name, info| {
            <span class="tok-kw">if</span> (info.needed) {
                <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-needed_framework&quot;</span>);
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (info.weak) {
                <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-weak_framework&quot;</span>);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-framework&quot;</span>);
            }
            <span class="tok-kw">try</span> zig_args.append(name);
        }

        <span class="tok-kw">if</span> (compile.is_linking_libcpp) {
            <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-lc++&quot;</span>);
        }

        <span class="tok-kw">if</span> (compile.is_linking_libc) {
            <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-lc&quot;</span>);
        }
    }

    <span class="tok-kw">if</span> (compile.win32_manifest) |manifest_file| {
        <span class="tok-kw">try</span> zig_args.append(manifest_file.getPath2(b, step));
    }

    <span class="tok-kw">if</span> (compile.image_base) |image_base| {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--image-base&quot;</span>);
        <span class="tok-kw">try</span> zig_args.append(b.fmt(<span class="tok-str">&quot;0x{x}&quot;</span>, .{image_base}));
    }

    <span class="tok-kw">for</span> (compile.filters) |filter| {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--test-filter&quot;</span>);
        <span class="tok-kw">try</span> zig_args.append(filter);
    }

    <span class="tok-kw">if</span> (compile.test_runner) |test_runner| {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--test-runner&quot;</span>);
        <span class="tok-kw">try</span> zig_args.append(test_runner.path.getPath2(b, step));
    }

    <span class="tok-kw">for</span> (b.debug_log_scopes) |log_scope| {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--debug-log&quot;</span>);
        <span class="tok-kw">try</span> zig_args.append(log_scope);
    }

    <span class="tok-kw">if</span> (b.debug_compile_errors) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--debug-compile-errors&quot;</span>);
    }

    <span class="tok-kw">if</span> (b.verbose_cimport) <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--verbose-cimport&quot;</span>);
    <span class="tok-kw">if</span> (b.verbose_air) <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--verbose-air&quot;</span>);
    <span class="tok-kw">if</span> (b.verbose_llvm_ir) |path| <span class="tok-kw">try</span> zig_args.append(b.fmt(<span class="tok-str">&quot;--verbose-llvm-ir={s}&quot;</span>, .{path}));
    <span class="tok-kw">if</span> (b.verbose_llvm_bc) |path| <span class="tok-kw">try</span> zig_args.append(b.fmt(<span class="tok-str">&quot;--verbose-llvm-bc={s}&quot;</span>, .{path}));
    <span class="tok-kw">if</span> (b.verbose_link <span class="tok-kw">or</span> compile.verbose_link) <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--verbose-link&quot;</span>);
    <span class="tok-kw">if</span> (b.verbose_cc <span class="tok-kw">or</span> compile.verbose_cc) <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--verbose-cc&quot;</span>);
    <span class="tok-kw">if</span> (b.verbose_llvm_cpu_features) <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--verbose-llvm-cpu-features&quot;</span>);

    <span class="tok-kw">if</span> (compile.generated_asm != <span class="tok-null">null</span>) <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-femit-asm&quot;</span>);
    <span class="tok-kw">if</span> (compile.generated_bin == <span class="tok-null">null</span>) <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-fno-emit-bin&quot;</span>);
    <span class="tok-kw">if</span> (compile.generated_docs != <span class="tok-null">null</span>) <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-femit-docs&quot;</span>);
    <span class="tok-kw">if</span> (compile.generated_implib != <span class="tok-null">null</span>) <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-femit-implib&quot;</span>);
    <span class="tok-kw">if</span> (compile.generated_llvm_bc != <span class="tok-null">null</span>) <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-femit-llvm-bc&quot;</span>);
    <span class="tok-kw">if</span> (compile.generated_llvm_ir != <span class="tok-null">null</span>) <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-femit-llvm-ir&quot;</span>);
    <span class="tok-kw">if</span> (compile.generated_h != <span class="tok-null">null</span>) <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-femit-h&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.addFlag">addFlag</a>(&amp;zig_args, <span class="tok-str">&quot;formatted-panics&quot;</span>, compile.formatted_panics);

    <span class="tok-kw">switch</span> (compile.compress_debug_sections) {
        .none =&gt; {},
        .zlib =&gt; <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--compress-debug-sections=zlib&quot;</span>),
        .zstd =&gt; <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--compress-debug-sections=zstd&quot;</span>),
    }

    <span class="tok-kw">if</span> (compile.link_eh_frame_hdr) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--eh-frame-hdr&quot;</span>);
    }
    <span class="tok-kw">if</span> (compile.link_emit_relocs) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--emit-relocs&quot;</span>);
    }
    <span class="tok-kw">if</span> (compile.link_function_sections) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-ffunction-sections&quot;</span>);
    }
    <span class="tok-kw">if</span> (compile.link_data_sections) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-fdata-sections&quot;</span>);
    }
    <span class="tok-kw">if</span> (compile.link_gc_sections) |x| {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-kw">if</span> (x) <span class="tok-str">&quot;--gc-sections&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;--no-gc-sections&quot;</span>);
    }
    <span class="tok-kw">if</span> (!compile.linker_dynamicbase) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--no-dynamicbase&quot;</span>);
    }
    <span class="tok-kw">if</span> (compile.linker_allow_shlib_undefined) |x| {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-kw">if</span> (x) <span class="tok-str">&quot;-fallow-shlib-undefined&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;-fno-allow-shlib-undefined&quot;</span>);
    }
    <span class="tok-kw">if</span> (compile.link_z_notext) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-z&quot;</span>);
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;notext&quot;</span>);
    }
    <span class="tok-kw">if</span> (!compile.link_z_relro) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-z&quot;</span>);
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;norelro&quot;</span>);
    }
    <span class="tok-kw">if</span> (compile.link_z_lazy) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-z&quot;</span>);
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;lazy&quot;</span>);
    }
    <span class="tok-kw">if</span> (compile.link_z_common_page_size) |size| {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-z&quot;</span>);
        <span class="tok-kw">try</span> zig_args.append(b.fmt(<span class="tok-str">&quot;common-page-size={d}&quot;</span>, .{size}));
    }
    <span class="tok-kw">if</span> (compile.link_z_max_page_size) |size| {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-z&quot;</span>);
        <span class="tok-kw">try</span> zig_args.append(b.fmt(<span class="tok-str">&quot;max-page-size={d}&quot;</span>, .{size}));
    }

    <span class="tok-kw">if</span> (compile.libc_file) |libc_file| {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--libc&quot;</span>);
        <span class="tok-kw">try</span> zig_args.append(libc_file.getPath2(b, step));
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.libc_file) |libc_file| {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--libc&quot;</span>);
        <span class="tok-kw">try</span> zig_args.append(libc_file);
    }

    <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--cache-dir&quot;</span>);
    <span class="tok-kw">try</span> zig_args.append(b.cache_root.path <span class="tok-kw">orelse</span> <span class="tok-str">&quot;.&quot;</span>);

    <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--global-cache-dir&quot;</span>);
    <span class="tok-kw">try</span> zig_args.append(b.graph.global_cache_root.path <span class="tok-kw">orelse</span> <span class="tok-str">&quot;.&quot;</span>);

    <span class="tok-kw">if</span> (b.graph.debug_compiler_runtime_libs) <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--debug-rt&quot;</span>);

    <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--name&quot;</span>);
    <span class="tok-kw">try</span> zig_args.append(compile.name);

    <span class="tok-kw">if</span> (compile.linkage) |some| <span class="tok-kw">switch</span> (some) {
        .dynamic =&gt; <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-dynamic&quot;</span>),
        .static =&gt; <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-static&quot;</span>),
    };
    <span class="tok-kw">if</span> (compile.kind == .lib <span class="tok-kw">and</span> compile.linkage != <span class="tok-null">null</span> <span class="tok-kw">and</span> compile.linkage.? == .dynamic) {
        <span class="tok-kw">if</span> (compile.version) |version| {
            <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--version&quot;</span>);
            <span class="tok-kw">try</span> zig_args.append(b.fmt(<span class="tok-str">&quot;{}&quot;</span>, .{version}));
        }

        <span class="tok-kw">if</span> (compile.rootModuleTarget().os.tag.isDarwin()) {
            <span class="tok-kw">const</span> install_name = compile.install_name <span class="tok-kw">orelse</span> b.fmt(<span class="tok-str">&quot;@rpath/{s}{s}{s}&quot;</span>, .{
                compile.rootModuleTarget().libPrefix(),
                compile.name,
                compile.rootModuleTarget().dynamicLibSuffix(),
            });
            <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-install_name&quot;</span>);
            <span class="tok-kw">try</span> zig_args.append(install_name);
        }
    }

    <span class="tok-kw">if</span> (compile.entitlements) |entitlements| {
        <span class="tok-kw">try</span> zig_args.appendSlice(&amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;--entitlements&quot;</span>, entitlements });
    }
    <span class="tok-kw">if</span> (compile.pagezero_size) |pagezero_size| {
        <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrint">allocPrint</a>(arena, <span class="tok-str">&quot;{x}&quot;</span>, .{pagezero_size});
        <span class="tok-kw">try</span> zig_args.appendSlice(&amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;-pagezero_size&quot;</span>, size });
    }
    <span class="tok-kw">if</span> (compile.headerpad_size) |headerpad_size| {
        <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrint">allocPrint</a>(arena, <span class="tok-str">&quot;{x}&quot;</span>, .{headerpad_size});
        <span class="tok-kw">try</span> zig_args.appendSlice(&amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;-headerpad&quot;</span>, size });
    }
    <span class="tok-kw">if</span> (compile.headerpad_max_install_names) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-headerpad_max_install_names&quot;</span>);
    }
    <span class="tok-kw">if</span> (compile.dead_strip_dylibs) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-dead_strip_dylibs&quot;</span>);
    }
    <span class="tok-kw">if</span> (compile.force_load_objc) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-ObjC&quot;</span>);
    }
    <span class="tok-kw">if</span> (compile.discard_local_symbols) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--discard-all&quot;</span>);
    }

    <span class="tok-kw">try</span> <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.addFlag">addFlag</a>(&amp;zig_args, <span class="tok-str">&quot;compiler-rt&quot;</span>, compile.bundle_compiler_rt);
    <span class="tok-kw">try</span> <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.addFlag">addFlag</a>(&amp;zig_args, <span class="tok-str">&quot;ubsan-rt&quot;</span>, compile.bundle_ubsan_rt);
    <span class="tok-kw">try</span> <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.addFlag">addFlag</a>(&amp;zig_args, <span class="tok-str">&quot;dll-export-fns&quot;</span>, compile.dll_export_fns);
    <span class="tok-kw">if</span> (compile.rdynamic) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-rdynamic&quot;</span>);
    }
    <span class="tok-kw">if</span> (compile.import_memory) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--import-memory&quot;</span>);
    }
    <span class="tok-kw">if</span> (compile.export_memory) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--export-memory&quot;</span>);
    }
    <span class="tok-kw">if</span> (compile.import_symbols) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--import-symbols&quot;</span>);
    }
    <span class="tok-kw">if</span> (compile.import_table) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--import-table&quot;</span>);
    }
    <span class="tok-kw">if</span> (compile.export_table) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--export-table&quot;</span>);
    }
    <span class="tok-kw">if</span> (compile.initial_memory) |initial_memory| {
        <span class="tok-kw">try</span> zig_args.append(b.fmt(<span class="tok-str">&quot;--initial-memory={d}&quot;</span>, .{initial_memory}));
    }
    <span class="tok-kw">if</span> (compile.max_memory) |max_memory| {
        <span class="tok-kw">try</span> zig_args.append(b.fmt(<span class="tok-str">&quot;--max-memory={d}&quot;</span>, .{max_memory}));
    }
    <span class="tok-kw">if</span> (compile.shared_memory) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--shared-memory&quot;</span>);
    }
    <span class="tok-kw">if</span> (compile.global_base) |global_base| {
        <span class="tok-kw">try</span> zig_args.append(b.fmt(<span class="tok-str">&quot;--global-base={d}&quot;</span>, .{global_base}));
    }

    <span class="tok-kw">if</span> (compile.wasi_exec_model) |model| {
        <span class="tok-kw">try</span> zig_args.append(b.fmt(<span class="tok-str">&quot;-mexec-model={s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(model)}));
    }
    <span class="tok-kw">if</span> (compile.linker_script) |linker_script| {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--script&quot;</span>);
        <span class="tok-kw">try</span> zig_args.append(linker_script.getPath2(b, step));
    }

    <span class="tok-kw">if</span> (compile.version_script) |version_script| {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--version-script&quot;</span>);
        <span class="tok-kw">try</span> zig_args.append(version_script.getPath2(b, step));
    }
    <span class="tok-kw">if</span> (compile.linker_allow_undefined_version) |x| {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-kw">if</span> (x) <span class="tok-str">&quot;--undefined-version&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;--no-undefined-version&quot;</span>);
    }

    <span class="tok-kw">if</span> (compile.linker_enable_new_dtags) |enabled| {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-kw">if</span> (enabled) <span class="tok-str">&quot;--enable-new-dtags&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;--disable-new-dtags&quot;</span>);
    }

    <span class="tok-kw">if</span> (compile.kind == .@&quot;test&quot;) {
        <span class="tok-kw">if</span> (compile.exec_cmd_args) |exec_cmd_args| {
            <span class="tok-kw">for</span> (exec_cmd_args) |cmd_arg| {
                <span class="tok-kw">if</span> (cmd_arg) |arg| {
                    <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--test-cmd&quot;</span>);
                    <span class="tok-kw">try</span> zig_args.append(arg);
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--test-cmd-bin&quot;</span>);
                }
            }
        }
    }

    <span class="tok-kw">if</span> (compile.no_builtin) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-fno-builtin&quot;</span>);
    }

    <span class="tok-kw">if</span> (b.sysroot) |sysroot| {
        <span class="tok-kw">try</span> zig_args.appendSlice(&amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;--sysroot&quot;</span>, sysroot });
    }<span class="tok-comment">

    // -I and -L arguments that appear after the last --mod argument apply to all modules.
    </span><span class="tok-kw">for</span> (b.search_prefixes.items) |search_prefix| {
        <span class="tok-kw">var</span> prefix_dir = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().openDir(search_prefix, .{}) <span class="tok-kw">catch</span> |err| {
            <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;unable to open prefix directory '{s}': {s}&quot;</span>, .{
                search_prefix, <span class="tok-builtin">@errorName</span>(err),
            });
        };
        <span class="tok-kw">defer</span> prefix_dir.close();<span class="tok-comment">

        // Avoid passing -L and -I flags for nonexistent directories.
        // This prevents a warning, that should probably be upgraded to an error in Zig's
        // CLI parsing code, when the linker sees an -L directory that does not exist.

        </span><span class="tok-kw">if</span> (prefix_dir.accessZ(<span class="tok-str">&quot;lib&quot;</span>, .{})) |_| {
            <span class="tok-kw">try</span> zig_args.appendSlice(&amp;.{
                <span class="tok-str">&quot;-L&quot;</span>, b.pathJoin(&amp;.{ search_prefix, <span class="tok-str">&quot;lib&quot;</span> }),
            });
        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileNotFound =&gt; {},
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;unable to access '{s}/lib' directory: {s}&quot;</span>, .{
                search_prefix, <span class="tok-builtin">@errorName</span>(e),
            }),
        }

        <span class="tok-kw">if</span> (prefix_dir.accessZ(<span class="tok-str">&quot;include&quot;</span>, .{})) |_| {
            <span class="tok-kw">try</span> zig_args.appendSlice(&amp;.{
                <span class="tok-str">&quot;-I&quot;</span>, b.pathJoin(&amp;.{ search_prefix, <span class="tok-str">&quot;include&quot;</span> }),
            });
        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileNotFound =&gt; {},
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;unable to access '{s}/include' directory: {s}&quot;</span>, .{
                search_prefix, <span class="tok-builtin">@errorName</span>(e),
            }),
        }
    }

    <span class="tok-kw">if</span> (compile.rc_includes != .any) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-rcincludes&quot;</span>);
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-builtin">@tagName</span>(compile.rc_includes));
    }

    <span class="tok-kw">try</span> <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.addFlag">addFlag</a>(&amp;zig_args, <span class="tok-str">&quot;each-lib-rpath&quot;</span>, compile.each_lib_rpath);

    <span class="tok-kw">if</span> (compile.build_id) |build_id| {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-kw">switch</span> (build_id) {
            .hexstring =&gt; |hs| b.fmt(<span class="tok-str">&quot;--build-id=0x{s}&quot;</span>, .{
                <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.fmtSliceHexLower">fmtSliceHexLower</a>(hs.toSlice()),
            }),
            .none, .fast, .uuid, .sha1, .md5 =&gt; b.fmt(<span class="tok-str">&quot;--build-id={s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(build_id)}),
        });
    }

    <span class="tok-kw">const</span> opt_zig_lib_dir = <span class="tok-kw">if</span> (compile.zig_lib_dir) |dir|
        dir.getPath2(b, step)
    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.graph.zig_lib_directory.path) |_|
        b.fmt(<span class="tok-str">&quot;{}&quot;</span>, .{b.graph.zig_lib_directory})
    <span class="tok-kw">else</span>
        <span class="tok-null">null</span>;

    <span class="tok-kw">if</span> (opt_zig_lib_dir) |zig_lib_dir| {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--zig-lib-dir&quot;</span>);
        <span class="tok-kw">try</span> zig_args.append(zig_lib_dir);
    }

    <span class="tok-kw">try</span> <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.addFlag">addFlag</a>(&amp;zig_args, <span class="tok-str">&quot;PIE&quot;</span>, compile.pie);
    <span class="tok-kw">try</span> <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.addFlag">addFlag</a>(&amp;zig_args, <span class="tok-str">&quot;lto&quot;</span>, compile.want_lto);
    <span class="tok-kw">try</span> <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.addFlag">addFlag</a>(&amp;zig_args, <span class="tok-str">&quot;sanitize-coverage-trace-pc-guard&quot;</span>, compile.sanitize_coverage_trace_pc_guard);

    <span class="tok-kw">if</span> (compile.subsystem) |subsystem| {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--subsystem&quot;</span>);
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-kw">switch</span> (subsystem) {
            .Console =&gt; <span class="tok-str">&quot;console&quot;</span>,
            .Windows =&gt; <span class="tok-str">&quot;windows&quot;</span>,
            .Posix =&gt; <span class="tok-str">&quot;posix&quot;</span>,
            .Native =&gt; <span class="tok-str">&quot;native&quot;</span>,
            .EfiApplication =&gt; <span class="tok-str">&quot;efi_application&quot;</span>,
            .EfiBootServiceDriver =&gt; <span class="tok-str">&quot;efi_boot_service_driver&quot;</span>,
            .EfiRom =&gt; <span class="tok-str">&quot;efi_rom&quot;</span>,
            .EfiRuntimeDriver =&gt; <span class="tok-str">&quot;efi_runtime_driver&quot;</span>,
        });
    }

    <span class="tok-kw">if</span> (compile.mingw_unicode_entry_point) {
        <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;-municode&quot;</span>);
    }

    <span class="tok-kw">if</span> (compile.error_limit) |err_limit| <span class="tok-kw">try</span> zig_args.appendSlice(&amp;.{
        <span class="tok-str">&quot;--error-limit&quot;</span>,
        b.fmt(<span class="tok-str">&quot;{}&quot;</span>, .{err_limit}),
    });

    <span class="tok-kw">try</span> <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.addFlag">addFlag</a>(&amp;zig_args, <span class="tok-str">&quot;incremental&quot;</span>, b.graph.incremental);

    <span class="tok-kw">try</span> zig_args.append(<span class="tok-str">&quot;--listen=-&quot;</span>);<span class="tok-comment">

    // Windows has an argument length limit of 32,766 characters, macOS 262,144 and Linux
    // 2,097,152. If our args exceed 30 KiB, we instead write them to a &quot;response file&quot; and
    // pass that to zig, e.g. via 'zig build-lib @args.rsp'
    // See @file syntax here: https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html
    </span><span class="tok-kw">var</span> args_length: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (zig_args.items) |arg| {
        args_length += arg.len + <span class="tok-number">1</span>;<span class="tok-comment"> // +1 to account for null terminator
    </span>}
    <span class="tok-kw">if</span> (args_length &gt;= <span class="tok-number">30</span> * <span class="tok-number">1024</span>) {
        <span class="tok-kw">try</span> b.cache_root.handle.makePath(<span class="tok-str">&quot;args&quot;</span>);

        <span class="tok-kw">const</span> args_to_escape = zig_args.items[<span class="tok-number">2</span>..];
        <span class="tok-kw">var</span> escaped_args = <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).initCapacity(arena, args_to_escape.len);
        arg_blk: <span class="tok-kw">for</span> (args_to_escape) |arg| {
            <span class="tok-kw">for</span> (arg, <span class="tok-number">0</span>..) |c, arg_idx| {
                <span class="tok-kw">if</span> (c == <span class="tok-str">'\\'</span> <span class="tok-kw">or</span> c == <span class="tok-str">'&quot;'</span>) {<span class="tok-comment">
                    // Slow path for arguments that need to be escaped. We'll need to allocate and copy
                    </span><span class="tok-kw">var</span> escaped = <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).initCapacity(arena, arg.len + <span class="tok-number">1</span>);
                    <span class="tok-kw">const</span> writer = escaped.writer();
                    <span class="tok-kw">try</span> writer.writeAll(arg[<span class="tok-number">0</span>..arg_idx]);
                    <span class="tok-kw">for</span> (arg[arg_idx..]) |to_escape| {
                        <span class="tok-kw">if</span> (to_escape == <span class="tok-str">'\\'</span> <span class="tok-kw">or</span> to_escape == <span class="tok-str">'&quot;'</span>) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\\'</span>);
                        <span class="tok-kw">try</span> writer.writeByte(to_escape);
                    }
                    escaped_args.appendAssumeCapacity(escaped.items);
                    <span class="tok-kw">continue</span> :arg_blk;
                }
            }
            escaped_args.appendAssumeCapacity(arg);<span class="tok-comment"> // no escaping needed so just use original argument
        </span>}<span class="tok-comment">

        // Write the args to zig-cache/args/&lt;SHA256 hash of args&gt; to avoid conflicts with
        // other zig build commands running in parallel.
        </span><span class="tok-kw">const</span> partially_quoted = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.join">join</a>(arena, <span class="tok-str">&quot;\&quot; \&quot;&quot;</span>, escaped_args.items);
        <span class="tok-kw">const</span> args = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.concat">concat</a>(arena, <span class="tok-type">u8</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;\&quot;&quot;</span>, partially_quoted, <span class="tok-str">&quot;\&quot;&quot;</span> });

        <span class="tok-kw">var</span> args_hash: [<a href="std.crypto.sha2.html#std.crypto.sha2.Sha256">Sha256</a>.<a href="#">digest_length</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <a href="std.crypto.sha2.html#std.crypto.sha2.Sha256">Sha256</a>.<a href="#">hash</a>(args, &amp;args_hash, .{});
        <span class="tok-kw">var</span> args_hex_hash: [<a href="std.crypto.sha2.html#std.crypto.sha2.Sha256">Sha256</a>.<a href="#">digest_length</a> * <span class="tok-number">2</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        _ = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.bufPrint">bufPrint</a>(
            &amp;args_hex_hash,
            <span class="tok-str">&quot;{s}&quot;</span>,
            .{<a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.fmtSliceHexLower">fmtSliceHexLower</a>(&amp;args_hash)},
        );

        <span class="tok-kw">const</span> args_file = <span class="tok-str">&quot;args&quot;</span> ++ <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep_str">sep_str</a> ++ args_hex_hash;
        <span class="tok-kw">try</span> b.cache_root.handle.writeFile(.{ .sub_path = args_file, .data = args });

        <span class="tok-kw">const</span> resolved_args_file = <span class="tok-kw">try</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.concat">concat</a>(arena, <span class="tok-type">u8</span>, &amp;.{
            <span class="tok-str">&quot;@&quot;</span>,
            <span class="tok-kw">try</span> b.cache_root.join(arena, &amp;.{args_file}),
        });

        zig_args.shrinkRetainingCapacity(<span class="tok-number">2</span>);
        <span class="tok-kw">try</span> zig_args.append(resolved_args_file);
    }

    <span class="tok-kw">return</span> <span class="tok-kw">try</span> zig_args.toOwnedSlice();
}

<span class="tok-kw">fn</span> <span class="tok-fn">make</span>(step: *<a href="std.Build.Step.html">Step</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.MakeOptions.html">MakeOptions</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> b = step.owner;
    <span class="tok-kw">const</span> compile: *<a href="std.Build.Step.Compile.html">Compile</a> = <span class="tok-builtin">@fieldParentPtr</span>(<span class="tok-str">&quot;step&quot;</span>, step);

    <span class="tok-kw">const</span> zig_args = <span class="tok-kw">try</span> <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.getZigArgs">getZigArgs</a>(compile, <span class="tok-null">false</span>);

    <span class="tok-kw">const</span> maybe_output_dir = step.evalZigProcess(
        zig_args,
        options.progress_node,
        (b.graph.incremental == <span class="tok-null">true</span>) <span class="tok-kw">and</span> options.watch,
    ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.NeedCompileErrorCheck =&gt; {
            <a href="std.debug.html#std.debug.assert">assert</a>(compile.expect_errors != <span class="tok-null">null</span>);
            <span class="tok-kw">try</span> <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.checkCompileErrors">checkCompileErrors</a>(compile);
            <span class="tok-kw">return</span>;
        },
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };<span class="tok-comment">

    // Update generated files
    </span><span class="tok-kw">if</span> (maybe_output_dir) |output_dir| {
        <span class="tok-kw">if</span> (compile.emit_directory) |lp| {
            lp.path = b.fmt(<span class="tok-str">&quot;{}&quot;</span>, .{output_dir});
        }<span class="tok-comment">

        // -femit-bin[=path]         (default) Output machine code
        </span><span class="tok-kw">if</span> (compile.generated_bin) |bin| {
            bin.path = output_dir.joinString(b.allocator, compile.out_filename) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
        }

        <span class="tok-kw">const</span> sep = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep_str">sep_str</a>;<span class="tok-comment">

        // output PDB if someone requested it
        </span><span class="tok-kw">if</span> (compile.generated_pdb) |pdb| {
            pdb.path = b.fmt(<span class="tok-str">&quot;{}&quot;</span> ++ sep ++ <span class="tok-str">&quot;{s}.pdb&quot;</span>, .{ output_dir, compile.name });
        }<span class="tok-comment">

        // -femit-implib[=path]      (default) Produce an import .lib when building a Windows DLL
        </span><span class="tok-kw">if</span> (compile.generated_implib) |implib| {
            implib.path = b.fmt(<span class="tok-str">&quot;{}&quot;</span> ++ sep ++ <span class="tok-str">&quot;{s}.lib&quot;</span>, .{ output_dir, compile.name });
        }<span class="tok-comment">

        // -femit-h[=path]           Generate a C header file (.h)
        </span><span class="tok-kw">if</span> (compile.generated_h) |lp| {
            lp.path = b.fmt(<span class="tok-str">&quot;{}&quot;</span> ++ sep ++ <span class="tok-str">&quot;{s}.h&quot;</span>, .{ output_dir, compile.name });
        }<span class="tok-comment">

        // -femit-docs[=path]        Create a docs/ dir with html documentation
        </span><span class="tok-kw">if</span> (compile.generated_docs) |generated_docs| {
            generated_docs.path = output_dir.joinString(b.allocator, <span class="tok-str">&quot;docs&quot;</span>) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
        }<span class="tok-comment">

        // -femit-asm[=path]         Output .s (assembly code)
        </span><span class="tok-kw">if</span> (compile.generated_asm) |lp| {
            lp.path = b.fmt(<span class="tok-str">&quot;{}&quot;</span> ++ sep ++ <span class="tok-str">&quot;{s}.s&quot;</span>, .{ output_dir, compile.name });
        }<span class="tok-comment">

        // -femit-llvm-ir[=path]     Produce a .ll file with optimized LLVM IR (requires LLVM extensions)
        </span><span class="tok-kw">if</span> (compile.generated_llvm_ir) |lp| {
            lp.path = b.fmt(<span class="tok-str">&quot;{}&quot;</span> ++ sep ++ <span class="tok-str">&quot;{s}.ll&quot;</span>, .{ output_dir, compile.name });
        }<span class="tok-comment">

        // -femit-llvm-bc[=path]     Produce an optimized LLVM module as a .bc file (requires LLVM extensions)
        </span><span class="tok-kw">if</span> (compile.generated_llvm_bc) |lp| {
            lp.path = b.fmt(<span class="tok-str">&quot;{}&quot;</span> ++ sep ++ <span class="tok-str">&quot;{s}.bc&quot;</span>, .{ output_dir, compile.name });
        }
    }

    <span class="tok-kw">if</span> (compile.kind == .lib <span class="tok-kw">and</span> compile.linkage != <span class="tok-null">null</span> <span class="tok-kw">and</span> compile.linkage.? == .dynamic <span class="tok-kw">and</span>
        compile.version != <span class="tok-null">null</span> <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.html#std.Build.wantSharedLibSymLinks">wantSharedLibSymLinks</a>(compile.rootModuleTarget()))
    {
        <span class="tok-kw">try</span> <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.doAtomicSymLinks">doAtomicSymLinks</a>(
            step,
            compile.getEmittedBin().getPath2(b, step),
            compile.major_only_filename.?,
            compile.name_only_filename.?,
        );
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rebuildInFuzzMode</span>(c: *<a href="std.Build.Step.Compile.html">Compile</a>, progress_node: <a href="std.html">std</a>.<a href="std.Progress.html">Progress</a>.<a href="std.Progress.Node.html">Node</a>) !<a href="std.Build.Cache.Path.html">Path</a> {
    <span class="tok-kw">const</span> gpa = c.step.owner.allocator;

    c.step.result_error_msgs.clearRetainingCapacity();
    c.step.result_stderr = <span class="tok-str">&quot;&quot;</span>;

    c.step.result_error_bundle.deinit(gpa);
    c.step.result_error_bundle = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.ErrorBundle.html">ErrorBundle</a>.<a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.empty">empty</a>;

    <span class="tok-kw">const</span> zig_args = <span class="tok-kw">try</span> <a href="std.Build.Step.Compile.html#std.Build.Step.Compile.getZigArgs">getZigArgs</a>(c, <span class="tok-null">true</span>);
    <span class="tok-kw">const</span> maybe_output_bin_path = <span class="tok-kw">try</span> c.step.evalZigProcess(zig_args, progress_node, <span class="tok-null">false</span>);
    <span class="tok-kw">return</span> maybe_output_bin_path.?;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doAtomicSymLinks</span>(
    step: *<a href="std.Build.Step.html">Step</a>,
    output_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    filename_major_only: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    filename_name_only: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> b = step.owner;
    <span class="tok-kw">const</span> out_dir = <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(output_path) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;.&quot;</span>;
    <span class="tok-kw">const</span> out_basename = <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.basename">basename</a>(output_path);<span class="tok-comment">
    // sym link for libfoo.so.1 to libfoo.so.1.2.3
    </span><span class="tok-kw">const</span> major_only_path = b.pathJoin(&amp;.{ out_dir, filename_major_only });
    <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().atomicSymLink(out_basename, major_only_path, .{}) <span class="tok-kw">catch</span> |err| {
        <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;unable to symlink {s} -&gt; {s}: {s}&quot;</span>, .{
            major_only_path, out_basename, <span class="tok-builtin">@errorName</span>(err),
        });
    };<span class="tok-comment">
    // sym link for libfoo.so to libfoo.so.1
    </span><span class="tok-kw">const</span> name_only_path = b.pathJoin(&amp;.{ out_dir, filename_name_only });
    <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().atomicSymLink(filename_major_only, name_only_path, .{}) <span class="tok-kw">catch</span> |err| {
        <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;Unable to symlink {s} -&gt; {s}: {s}&quot;</span>, .{
            name_only_path, filename_major_only, <span class="tok-builtin">@errorName</span>(err),
        });
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">execPkgConfigList</span>(b: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>, out_code: *<span class="tok-type">u8</span>) (<a href="std.Build.html#std.Build.PkgConfigError">PkgConfigError</a> || <a href="std.Build.html#std.Build.RunError">RunError</a>)![]<span class="tok-kw">const</span> <a href="std.Build.PkgConfigPkg.html">PkgConfigPkg</a> {
    <span class="tok-kw">const</span> pkg_config_exe = b.graph.env_map.get(<span class="tok-str">&quot;PKG_CONFIG&quot;</span>) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;pkg-config&quot;</span>;
    <span class="tok-kw">const</span> stdout = <span class="tok-kw">try</span> b.runAllowFail(&amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ pkg_config_exe, <span class="tok-str">&quot;--list-all&quot;</span> }, out_code, .Ignore);
    <span class="tok-kw">var</span> list = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.PkgConfigPkg.html">PkgConfigPkg</a>).init(b.allocator);
    <span class="tok-kw">errdefer</span> list.deinit();
    <span class="tok-kw">var</span> line_it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a>(<span class="tok-type">u8</span>, stdout, <span class="tok-str">&quot;\r\n&quot;</span>);
    <span class="tok-kw">while</span> (line_it.next()) |line| {
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, line, <span class="tok-str">&quot; \t&quot;</span>).len == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;
        <span class="tok-kw">var</span> tok_it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a>(<span class="tok-type">u8</span>, line, <span class="tok-str">&quot; \t&quot;</span>);
        <span class="tok-kw">try</span> list.append(<a href="std.Build.PkgConfigPkg.html">PkgConfigPkg</a>{
            .name = tok_it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PkgConfigInvalidOutput,
            .desc = tok_it.rest(),
        });
    }
    <span class="tok-kw">return</span> list.toOwnedSlice();
}

<span class="tok-kw">fn</span> <span class="tok-fn">getPkgConfigList</span>(b: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>) ![]<span class="tok-kw">const</span> <a href="std.Build.PkgConfigPkg.html">PkgConfigPkg</a> {
    <span class="tok-kw">if</span> (b.pkg_config_pkg_list) |res| {
        <span class="tok-kw">return</span> res;
    }
    <span class="tok-kw">var</span> code: <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">if</span> (<a href="std.Build.Step.Compile.html#std.Build.Step.Compile.execPkgConfigList">execPkgConfigList</a>(b, &amp;code)) |list| {
        b.pkg_config_pkg_list = list;
        <span class="tok-kw">return</span> list;
    } <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">const</span> result = <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.ProcessTerminated =&gt; <span class="tok-kw">error</span>.PkgConfigCrashed,
            <span class="tok-kw">error</span>.ExecNotSupported =&gt; <span class="tok-kw">error</span>.PkgConfigFailed,
            <span class="tok-kw">error</span>.ExitCodeFailure =&gt; <span class="tok-kw">error</span>.PkgConfigFailed,
            <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">error</span>.PkgConfigNotInstalled,
            <span class="tok-kw">error</span>.InvalidName =&gt; <span class="tok-kw">error</span>.PkgConfigNotInstalled,
            <span class="tok-kw">error</span>.PkgConfigInvalidOutput =&gt; <span class="tok-kw">error</span>.PkgConfigInvalidOutput,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
        };
        b.pkg_config_pkg_list = result;
        <span class="tok-kw">return</span> result;
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">addFlag</span>(args: *<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>), <span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, opt: ?<span class="tok-type">bool</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> cond = opt <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
    <span class="tok-kw">try</span> args.ensureUnusedCapacity(<span class="tok-number">1</span>);
    <span class="tok-kw">if</span> (cond) {
        args.appendAssumeCapacity(<span class="tok-str">&quot;-f&quot;</span> ++ name);
    } <span class="tok-kw">else</span> {
        args.appendAssumeCapacity(<span class="tok-str">&quot;-fno-&quot;</span> ++ name);
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">checkCompileErrors</span>(compile: *<a href="std.Build.Step.Compile.html">Compile</a>) !<span class="tok-type">void</span> {<span class="tok-comment">
    // Clear this field so that it does not get printed by the build runner.
    </span><span class="tok-kw">const</span> actual_eb = compile.step.result_error_bundle;
    compile.step.result_error_bundle = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.ErrorBundle.html">ErrorBundle</a>.<a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.empty">empty</a>;

    <span class="tok-kw">const</span> arena = compile.step.owner.allocator;

    <span class="tok-kw">var</span> actual_errors_list = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(arena);
    <span class="tok-kw">try</span> actual_eb.renderToWriter(.{
        .ttyconf = .no_color,
        .include_reference_trace = <span class="tok-null">false</span>,
        .include_source_line = <span class="tok-null">false</span>,
    }, actual_errors_list.writer());
    <span class="tok-kw">const</span> actual_errors = <span class="tok-kw">try</span> actual_errors_list.toOwnedSlice();<span class="tok-comment">

    // Render the expected lines into a string that we can compare verbatim.
    </span><span class="tok-kw">var</span> expected_generated = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(arena);
    <span class="tok-kw">const</span> expect_errors = compile.expect_errors.?;

    <span class="tok-kw">var</span> actual_line_it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(<span class="tok-type">u8</span>, actual_errors, <span class="tok-str">'\n'</span>);<span class="tok-comment">

    // TODO merge this with the testing.expectEqualStrings logic, and also CheckFile
    </span><span class="tok-kw">switch</span> (expect_errors) {
        .starts_with =&gt; |expect_starts_with| {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u8</span>, actual_errors, expect_starts_with)) <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span> compile.step.fail(
                <span class="tok-str">\\</span>
                <span class="tok-str">\\========= should start with: ============</span>
                <span class="tok-str">\\{s}</span>
                <span class="tok-str">\\========= but not found: ================</span>
                <span class="tok-str">\\{s}</span>
                <span class="tok-str">\\=========================================</span>
            , .{ expect_starts_with, actual_errors });
        },
        .contains =&gt; |expect_line| {
            <span class="tok-kw">while</span> (actual_line_it.next()) |actual_line| {
                <span class="tok-kw">if</span> (!<a href="std.Build.Step.Compile.html#std.Build.Step.Compile.matchCompileError">matchCompileError</a>(actual_line, expect_line)) <span class="tok-kw">continue</span>;
                <span class="tok-kw">return</span>;
            }

            <span class="tok-kw">return</span> compile.step.fail(
                <span class="tok-str">\\</span>
                <span class="tok-str">\\========= should contain: ===============</span>
                <span class="tok-str">\\{s}</span>
                <span class="tok-str">\\========= but not found: ================</span>
                <span class="tok-str">\\{s}</span>
                <span class="tok-str">\\=========================================</span>
            , .{ expect_line, actual_errors });
        },
        .stderr_contains =&gt; |expect_line| {
            <span class="tok-kw">const</span> actual_stderr: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-kw">if</span> (compile.step.result_error_msgs.items.len &gt; <span class="tok-number">0</span>)
                compile.step.result_error_msgs.items[<span class="tok-number">0</span>]
            <span class="tok-kw">else</span>
                &amp;.{};
            compile.step.result_error_msgs.clearRetainingCapacity();

            <span class="tok-kw">var</span> stderr_line_it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(<span class="tok-type">u8</span>, actual_stderr, <span class="tok-str">'\n'</span>);

            <span class="tok-kw">while</span> (stderr_line_it.next()) |actual_line| {
                <span class="tok-kw">if</span> (!<a href="std.Build.Step.Compile.html#std.Build.Step.Compile.matchCompileError">matchCompileError</a>(actual_line, expect_line)) <span class="tok-kw">continue</span>;
                <span class="tok-kw">return</span>;
            }

            <span class="tok-kw">return</span> compile.step.fail(
                <span class="tok-str">\\</span>
                <span class="tok-str">\\========= should contain: ===============</span>
                <span class="tok-str">\\{s}</span>
                <span class="tok-str">\\========= but not found: ================</span>
                <span class="tok-str">\\{s}</span>
                <span class="tok-str">\\=========================================</span>
            , .{ expect_line, actual_stderr });
        },
        .exact =&gt; |expect_lines| {
            <span class="tok-kw">for</span> (expect_lines) |expect_line| {
                <span class="tok-kw">const</span> actual_line = actual_line_it.next() <span class="tok-kw">orelse</span> {
                    <span class="tok-kw">try</span> expected_generated.appendSlice(expect_line);
                    <span class="tok-kw">try</span> expected_generated.append(<span class="tok-str">'\n'</span>);
                    <span class="tok-kw">continue</span>;
                };
                <span class="tok-kw">if</span> (<a href="std.Build.Step.Compile.html#std.Build.Step.Compile.matchCompileError">matchCompileError</a>(actual_line, expect_line)) {
                    <span class="tok-kw">try</span> expected_generated.appendSlice(actual_line);
                    <span class="tok-kw">try</span> expected_generated.append(<span class="tok-str">'\n'</span>);
                    <span class="tok-kw">continue</span>;
                }
                <span class="tok-kw">try</span> expected_generated.appendSlice(expect_line);
                <span class="tok-kw">try</span> expected_generated.append(<span class="tok-str">'\n'</span>);
            }

            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, expected_generated.items, actual_errors)) <span class="tok-kw">return</span>;

            <span class="tok-kw">return</span> compile.step.fail(
                <span class="tok-str">\\</span>
                <span class="tok-str">\\========= expected: =====================</span>
                <span class="tok-str">\\{s}</span>
                <span class="tok-str">\\========= but found: ====================</span>
                <span class="tok-str">\\{s}</span>
                <span class="tok-str">\\=========================================</span>
            , .{ expected_generated.items, actual_errors });
        },
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">matchCompileError</span>(actual: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, expected: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.endsWith">endsWith</a>(<span class="tok-type">u8</span>, actual, expected)) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u8</span>, expected, <span class="tok-str">&quot;:?:?: &quot;</span>)) {
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.endsWith">endsWith</a>(<span class="tok-type">u8</span>, actual, expected[<span class="tok-str">&quot;:?:?: &quot;</span>.len..])) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }<span class="tok-comment">
    // We scan for /?/ in expected line and if there is a match, we match everything
    // up to and after /?/.
    </span><span class="tok-kw">const</span> expected_trim = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, expected, <span class="tok-str">&quot; &quot;</span>);
    <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, expected_trim, <span class="tok-str">&quot;/?/&quot;</span>)) |index| {
        <span class="tok-kw">const</span> actual_trim = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, actual, <span class="tok-str">&quot; &quot;</span>);
        <span class="tok-kw">const</span> lhs = expected_trim[<span class="tok-number">0</span>..index];
        <span class="tok-kw">const</span> rhs = expected_trim[index + <span class="tok-str">&quot;/?/&quot;</span>.len ..];
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u8</span>, actual_trim, lhs) <span class="tok-kw">and</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.endsWith">endsWith</a>(<span class="tok-type">u8</span>, actual_trim, rhs)) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }
    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rootModuleTarget</span>(c: *<a href="std.Build.Step.Compile.html">Compile</a>) <a href="std.html">std</a>.<a href="std.Target.html">Target</a> {<span class="tok-comment">
    // The root module is always given a target, so we know this to be non-null.
    </span><span class="tok-kw">return</span> c.root_module.resolved_target.?.result;
}

<span class="tok-kw">fn</span> <span class="tok-fn">moduleNeedsCliArg</span>(mod: *<span class="tok-kw">const</span> <a href="std.Build.Module.html">Module</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">for</span> (mod.link_objects.items) |o| <span class="tok-kw">switch</span> (o) {
        .c_source_file, .c_source_files, .assembly_file, .win32_resource_file =&gt; <span class="tok-kw">break</span> <span class="tok-null">true</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,
    } <span class="tok-kw">else</span> <span class="tok-null">false</span>;
}

<span class="tok-comment">/// Return the full set of `Step.Compile` which `start` depends on, recursively. `start` itself is</span>
<span class="tok-comment">/// always returned as the first element. If `chase_dynamic` is `false`, then dynamic libraries are</span>
<span class="tok-comment">/// not included, and their dependencies are not considered; if `chase_dynamic` is `true`, dynamic</span>
<span class="tok-comment">/// libraries are treated the same as other linked `Compile`s.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getCompileDependencies</span>(start: *<a href="std.Build.Step.Compile.html">Compile</a>, chase_dynamic: <span class="tok-type">bool</span>) []<span class="tok-kw">const</span> *<a href="std.Build.Step.Compile.html">Compile</a> {
    <span class="tok-kw">const</span> arena = start.step.owner.graph.arena;

    <span class="tok-kw">var</span> compiles: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(*<a href="std.Build.Step.Compile.html">Compile</a>, <span class="tok-type">void</span>) = .empty;
    <span class="tok-kw">var</span> next_idx: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    compiles.putNoClobber(arena, start, {}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);

    <span class="tok-kw">while</span> (next_idx &lt; compiles.count()) {
        <span class="tok-kw">const</span> compile = compiles.keys()[next_idx];
        next_idx += <span class="tok-number">1</span>;

        <span class="tok-kw">for</span> (compile.root_module.getGraph().modules) |mod| {
            <span class="tok-kw">for</span> (mod.link_objects.items) |lo| {
                <span class="tok-kw">switch</span> (lo) {
                    .other_step =&gt; |other_compile| {
                        <span class="tok-kw">if</span> (!chase_dynamic <span class="tok-kw">and</span> other_compile.isDynamicLibrary()) <span class="tok-kw">continue</span>;
                        compiles.put(arena, other_compile, {}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
                    },
                    <span class="tok-kw">else</span> =&gt; {},
                }
            }
        }
    }

    <span class="tok-kw">return</span> compiles.keys();
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
