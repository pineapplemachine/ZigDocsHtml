<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">heap</a></li><li><a href="std.heap.arena_allocator.html" class="">arena_allocator</a></li><li><a href="std.heap.arena_allocator.ArenaAllocator.html" class="active">ArenaAllocator</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.heap.arena_allocator.ArenaAllocator" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.heap.arena_allocator.ArenaAllocator</span><a href="#src.zig-std.heap.arena_allocator.ArenaAllocator">[src]</a></h1><div class="tldDocs"><p>This allocator takes an existing allocator, wraps it, and provides an interface where
you can allocate and then free it all together. Calls to free an individual item only
free the item if it was the most recent allocation, otherwise calls to free do
nothing.</p>
</div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.heap.arena_allocator.ArenaAllocator.State.html">std.heap.arena_allocator.ArenaAllocator.State</a></li><li><a href="std.heap.arena_allocator.ArenaAllocator.ResetMode.html">std.heap.arena_allocator.ArenaAllocator.ResetMode</a></li></ul></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>child_allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>state: <a href="std.heap.arena_allocator.ArenaAllocator.State.html">State</a></code></pre></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.heap.arena_allocator.ArenaAllocator.allocator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">allocator</span><a href="#src.zig-std.heap.arena_allocator.ArenaAllocator.allocator">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocator</span>(self: *<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>) <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.heap.arena_allocator.ArenaAllocator.allocator">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocator</span>(self: *<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>) <a href="std.mem.Allocator.html">Allocator</a> {
    <span class="tok-kw">return</span> .{
        .ptr = self,
        .vtable = &amp;.{
            .alloc = <a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.alloc">alloc</a>,
            .resize = <a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.resize">resize</a>,
            .remap = <a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.remap">remap</a>,
            .free = <a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.free">free</a>,
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.heap.arena_allocator.ArenaAllocator.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.heap.arena_allocator.ArenaAllocator.init">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(child_allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>child_allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.heap.arena_allocator.ArenaAllocator.init">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(child_allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a> {
    <span class="tok-kw">return</span> (<a href="std.heap.arena_allocator.ArenaAllocator.State.html">State</a>{}).promote(child_allocator);
}</code></pre></details></div></div><div class="decl"><h2 id="std.heap.arena_allocator.ArenaAllocator.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.heap.arena_allocator.ArenaAllocator.deinit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.heap.arena_allocator.ArenaAllocator.deinit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>) <span class="tok-type">void</span> {<span class="tok-comment">
    // NOTE: When changing this, make sure `reset()` is adjusted accordingly!

    </span><span class="tok-kw">var</span> it = self.state.buffer_list.first;
    <span class="tok-kw">while</span> (it) |node| {<span class="tok-comment">
        // this has to occur before the free because the free frees node
        </span><span class="tok-kw">const</span> next_it = node.next;
        <span class="tok-kw">const</span> alloc_buf = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(node))[<span class="tok-number">0</span>..node.data];
        self.child_allocator.rawFree(alloc_buf, <a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode_alignment">BufNode_alignment</a>, <span class="tok-builtin">@returnAddress</span>());
        it = next_it;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.heap.arena_allocator.ArenaAllocator.queryCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">queryCapacity</span><a href="#src.zig-std.heap.arena_allocator.ArenaAllocator.queryCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">queryCapacity</span>(self: <a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Queries the current memory use of this arena.
This will <strong>not</strong> include the storage required for internal keeping.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.heap.arena_allocator.ArenaAllocator.queryCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">queryCapacity</span>(self: <a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> size: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> it = self.state.buffer_list.first;
    <span class="tok-kw">while</span> (it) |node| : (it = node.next) {<span class="tok-comment">
        // Compute the actually allocated size excluding the
        // linked list node.
        </span>size += node.data - <span class="tok-builtin">@sizeOf</span>(<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode">BufNode</a>);
    }
    <span class="tok-kw">return</span> size;
}</code></pre></details></div></div><div class="decl"><h2 id="std.heap.arena_allocator.ArenaAllocator.reset" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reset</span><a href="#src.zig-std.heap.arena_allocator.ArenaAllocator.reset">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>, mode: <a href="std.heap.arena_allocator.ArenaAllocator.ResetMode.html">ResetMode</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Resets the arena allocator and frees all allocated memory.</p>
<p><code>mode</code> defines how the currently allocated memory is handled.
See the variant documentation for <code>ResetMode</code> for the effects of each mode.</p>
<p>The function will return whether the reset operation was successful or not.
If the reallocation  failed <code>false</code> is returned. The arena will still be fully
functional in that case, all memory is released. Future allocations just might
be slower.</p>
<p>NOTE: If <code>mode</code> is <code>free_all</code>, the function will always return <code>true</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a></code></pre></div><div><pre><code>mode: <a href="std.heap.arena_allocator.ArenaAllocator.ResetMode.html">ResetMode</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.heap.arena_allocator.ArenaAllocator.reset">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>, mode: <a href="std.heap.arena_allocator.ArenaAllocator.ResetMode.html">ResetMode</a>) <span class="tok-type">bool</span> {<span class="tok-comment">
    // Some words on the implementation:
    // The reset function can be implemented with two basic approaches:
    // - Counting how much bytes were allocated since the last reset, and storing that
    //   information in State. This will make reset fast and alloc only a teeny tiny bit
    //   slower.
    // - Counting how much bytes were allocated by iterating the chunk linked list. This
    //   will make reset slower, but alloc() keeps the same speed when reset() as if reset()
    //   would not exist.
    //
    // The second variant was chosen for implementation, as with more and more calls to reset(),
    // the function will get faster and faster. At one point, the complexity of the function
    // will drop to amortized O(1), as we're only ever having a single chunk that will not be
    // reallocated, and we're not even touching the backing allocator anymore.
    //
    // Thus, only the first hand full of calls to reset() will actually need to iterate the linked
    // list, all future calls are just taking the first node, and only resetting the `end_index`
    // value.
    </span><span class="tok-kw">const</span> requested_capacity = <span class="tok-kw">switch</span> (mode) {
        .retain_capacity =&gt; self.queryCapacity(),
        .retain_with_limit =&gt; |limit| <span class="tok-builtin">@min</span>(limit, self.queryCapacity()),
        .free_all =&gt; <span class="tok-number">0</span>,
    };
    <span class="tok-kw">if</span> (requested_capacity == <span class="tok-number">0</span>) {<span class="tok-comment">
        // just reset when we don't have anything to reallocate
        </span>self.deinit();
        self.state = <a href="std.heap.arena_allocator.ArenaAllocator.State.html">State</a>{};
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }
    <span class="tok-kw">const</span> total_size = requested_capacity + <span class="tok-builtin">@sizeOf</span>(<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode">BufNode</a>);<span class="tok-comment">
    // Free all nodes except for the last one
    </span><span class="tok-kw">var</span> it = self.state.buffer_list.first;
    <span class="tok-kw">const</span> maybe_first_node = <span class="tok-kw">while</span> (it) |node| {<span class="tok-comment">
        // this has to occur before the free because the free frees node
        </span><span class="tok-kw">const</span> next_it = node.next;
        <span class="tok-kw">if</span> (next_it == <span class="tok-null">null</span>)
            <span class="tok-kw">break</span> node;
        <span class="tok-kw">const</span> alloc_buf = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(node))[<span class="tok-number">0</span>..node.data];
        self.child_allocator.rawFree(alloc_buf, <a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode_alignment">BufNode_alignment</a>, <span class="tok-builtin">@returnAddress</span>());
        it = next_it;
    } <span class="tok-kw">else</span> <span class="tok-null">null</span>;
    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>(maybe_first_node == <span class="tok-null">null</span> <span class="tok-kw">or</span> maybe_first_node.?.next == <span class="tok-null">null</span>);<span class="tok-comment">
    // reset the state before we try resizing the buffers, so we definitely have reset the arena to 0.
    </span>self.state.end_index = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (maybe_first_node) |first_node| {
        self.state.buffer_list.first = first_node;<span class="tok-comment">
        // perfect, no need to invoke the child_allocator
        </span><span class="tok-kw">if</span> (first_node.data == total_size)
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        <span class="tok-kw">const</span> first_alloc_buf = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(first_node))[<span class="tok-number">0</span>..first_node.data];
        <span class="tok-kw">if</span> (self.child_allocator.rawResize(first_alloc_buf, <a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode_alignment">BufNode_alignment</a>, total_size, <span class="tok-builtin">@returnAddress</span>())) {<span class="tok-comment">
            // successful resize
            </span>first_node.data = total_size;
        } <span class="tok-kw">else</span> {<span class="tok-comment">
            // manual realloc
            </span><span class="tok-kw">const</span> new_ptr = self.child_allocator.rawAlloc(total_size, <a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode_alignment">BufNode_alignment</a>, <span class="tok-builtin">@returnAddress</span>()) <span class="tok-kw">orelse</span> {<span class="tok-comment">
                // we failed to preheat the arena properly, signal this to the user.
                </span><span class="tok-kw">return</span> <span class="tok-null">false</span>;
            };
            self.child_allocator.rawFree(first_alloc_buf, <a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode_alignment">BufNode_alignment</a>, <span class="tok-builtin">@returnAddress</span>());
            <span class="tok-kw">const</span> node: *<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode">BufNode</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(new_ptr));
            node.* = .{ .data = total_size };
            self.state.buffer_list.first = node;
        }
    }
    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.heap.arena_allocator.ArenaAllocator">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArenaAllocator = <span class="tok-kw">struct</span> {
    child_allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    state: <a href="std.heap.arena_allocator.ArenaAllocator.State.html">State</a>,

    <span class="tok-comment">/// Inner state of ArenaAllocator. Can be stored rather than the entire ArenaAllocator</span>
    <span class="tok-comment">/// as a memory-saving optimization.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> State = <span class="tok-kw">struct</span> {
        buffer_list: <a href="std.html">std</a>.<a href="std.linked_list.html#std.linked_list.SinglyLinkedList">SinglyLinkedList</a>(<span class="tok-type">usize</span>) = .{},
        end_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.heap.arena_allocator.ArenaAllocator.State.html">State</a>, child_allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a> {
            <span class="tok-kw">return</span> .{
                .child_allocator = child_allocator,
                .state = self,
            };
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocator</span>(self: *<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>) <a href="std.mem.Allocator.html">Allocator</a> {
        <span class="tok-kw">return</span> .{
            .ptr = self,
            .vtable = &amp;.{
                .alloc = <a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.alloc">alloc</a>,
                .resize = <a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.resize">resize</a>,
                .remap = <a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.remap">remap</a>,
                .free = <a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.free">free</a>,
            },
        };
    }

    <span class="tok-kw">const</span> BufNode = <a href="std.html">std</a>.<a href="std.linked_list.html#std.linked_list.SinglyLinkedList">SinglyLinkedList</a>(<span class="tok-type">usize</span>).Node;
    <span class="tok-kw">const</span> BufNode_alignment: <a href="std.mem.html">mem</a>.<a href="std.mem.Alignment.html">Alignment</a> = .fromByteUnits(<span class="tok-builtin">@alignOf</span>(<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode">BufNode</a>));

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(child_allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a> {
        <span class="tok-kw">return</span> (<a href="std.heap.arena_allocator.ArenaAllocator.State.html">State</a>{}).promote(child_allocator);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>) <span class="tok-type">void</span> {<span class="tok-comment">
        // NOTE: When changing this, make sure `reset()` is adjusted accordingly!

        </span><span class="tok-kw">var</span> it = self.state.buffer_list.first;
        <span class="tok-kw">while</span> (it) |node| {<span class="tok-comment">
            // this has to occur before the free because the free frees node
            </span><span class="tok-kw">const</span> next_it = node.next;
            <span class="tok-kw">const</span> alloc_buf = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(node))[<span class="tok-number">0</span>..node.data];
            self.child_allocator.rawFree(alloc_buf, <a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode_alignment">BufNode_alignment</a>, <span class="tok-builtin">@returnAddress</span>());
            it = next_it;
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ResetMode = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        <span class="tok-comment">/// Releases all allocated memory in the arena.</span>
        free_all,
        <span class="tok-comment">/// This will pre-heat the arena for future allocations by allocating a</span>
        <span class="tok-comment">/// large enough buffer for all previously done allocations.</span>
        <span class="tok-comment">/// Preheating will speed up the allocation process by invoking the backing allocator</span>
        <span class="tok-comment">/// less often than before. If `reset()` is used in a loop, this means that after the</span>
        <span class="tok-comment">/// biggest operation, no memory allocations are performed anymore.</span>
        retain_capacity,
        <span class="tok-comment">/// This is the same as `retain_capacity`, but the memory will be shrunk to</span>
        <span class="tok-comment">/// this value if it exceeds the limit.</span>
        retain_with_limit: <span class="tok-type">usize</span>,
    };
    <span class="tok-comment">/// Queries the current memory use of this arena.</span>
    <span class="tok-comment">/// This will **not** include the storage required for internal keeping.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">queryCapacity</span>(self: <a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">var</span> size: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> it = self.state.buffer_list.first;
        <span class="tok-kw">while</span> (it) |node| : (it = node.next) {<span class="tok-comment">
            // Compute the actually allocated size excluding the
            // linked list node.
            </span>size += node.data - <span class="tok-builtin">@sizeOf</span>(<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode">BufNode</a>);
        }
        <span class="tok-kw">return</span> size;
    }
    <span class="tok-comment">/// Resets the arena allocator and frees all allocated memory.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `mode` defines how the currently allocated memory is handled.</span>
    <span class="tok-comment">/// See the variant documentation for `ResetMode` for the effects of each mode.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The function will return whether the reset operation was successful or not.</span>
    <span class="tok-comment">/// If the reallocation  failed `false` is returned. The arena will still be fully</span>
    <span class="tok-comment">/// functional in that case, all memory is released. Future allocations just might</span>
    <span class="tok-comment">/// be slower.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// NOTE: If `mode` is `free_all`, the function will always return `true`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>, mode: <a href="std.heap.arena_allocator.ArenaAllocator.ResetMode.html">ResetMode</a>) <span class="tok-type">bool</span> {<span class="tok-comment">
        // Some words on the implementation:
        // The reset function can be implemented with two basic approaches:
        // - Counting how much bytes were allocated since the last reset, and storing that
        //   information in State. This will make reset fast and alloc only a teeny tiny bit
        //   slower.
        // - Counting how much bytes were allocated by iterating the chunk linked list. This
        //   will make reset slower, but alloc() keeps the same speed when reset() as if reset()
        //   would not exist.
        //
        // The second variant was chosen for implementation, as with more and more calls to reset(),
        // the function will get faster and faster. At one point, the complexity of the function
        // will drop to amortized O(1), as we're only ever having a single chunk that will not be
        // reallocated, and we're not even touching the backing allocator anymore.
        //
        // Thus, only the first hand full of calls to reset() will actually need to iterate the linked
        // list, all future calls are just taking the first node, and only resetting the `end_index`
        // value.
        </span><span class="tok-kw">const</span> requested_capacity = <span class="tok-kw">switch</span> (mode) {
            .retain_capacity =&gt; self.queryCapacity(),
            .retain_with_limit =&gt; |limit| <span class="tok-builtin">@min</span>(limit, self.queryCapacity()),
            .free_all =&gt; <span class="tok-number">0</span>,
        };
        <span class="tok-kw">if</span> (requested_capacity == <span class="tok-number">0</span>) {<span class="tok-comment">
            // just reset when we don't have anything to reallocate
            </span>self.deinit();
            self.state = <a href="std.heap.arena_allocator.ArenaAllocator.State.html">State</a>{};
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }
        <span class="tok-kw">const</span> total_size = requested_capacity + <span class="tok-builtin">@sizeOf</span>(<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode">BufNode</a>);<span class="tok-comment">
        // Free all nodes except for the last one
        </span><span class="tok-kw">var</span> it = self.state.buffer_list.first;
        <span class="tok-kw">const</span> maybe_first_node = <span class="tok-kw">while</span> (it) |node| {<span class="tok-comment">
            // this has to occur before the free because the free frees node
            </span><span class="tok-kw">const</span> next_it = node.next;
            <span class="tok-kw">if</span> (next_it == <span class="tok-null">null</span>)
                <span class="tok-kw">break</span> node;
            <span class="tok-kw">const</span> alloc_buf = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(node))[<span class="tok-number">0</span>..node.data];
            self.child_allocator.rawFree(alloc_buf, <a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode_alignment">BufNode_alignment</a>, <span class="tok-builtin">@returnAddress</span>());
            it = next_it;
        } <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>(maybe_first_node == <span class="tok-null">null</span> <span class="tok-kw">or</span> maybe_first_node.?.next == <span class="tok-null">null</span>);<span class="tok-comment">
        // reset the state before we try resizing the buffers, so we definitely have reset the arena to 0.
        </span>self.state.end_index = <span class="tok-number">0</span>;
        <span class="tok-kw">if</span> (maybe_first_node) |first_node| {
            self.state.buffer_list.first = first_node;<span class="tok-comment">
            // perfect, no need to invoke the child_allocator
            </span><span class="tok-kw">if</span> (first_node.data == total_size)
                <span class="tok-kw">return</span> <span class="tok-null">true</span>;
            <span class="tok-kw">const</span> first_alloc_buf = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(first_node))[<span class="tok-number">0</span>..first_node.data];
            <span class="tok-kw">if</span> (self.child_allocator.rawResize(first_alloc_buf, <a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode_alignment">BufNode_alignment</a>, total_size, <span class="tok-builtin">@returnAddress</span>())) {<span class="tok-comment">
                // successful resize
                </span>first_node.data = total_size;
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // manual realloc
                </span><span class="tok-kw">const</span> new_ptr = self.child_allocator.rawAlloc(total_size, <a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode_alignment">BufNode_alignment</a>, <span class="tok-builtin">@returnAddress</span>()) <span class="tok-kw">orelse</span> {<span class="tok-comment">
                    // we failed to preheat the arena properly, signal this to the user.
                    </span><span class="tok-kw">return</span> <span class="tok-null">false</span>;
                };
                self.child_allocator.rawFree(first_alloc_buf, <a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode_alignment">BufNode_alignment</a>, <span class="tok-builtin">@returnAddress</span>());
                <span class="tok-kw">const</span> node: *<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode">BufNode</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(new_ptr));
                node.* = .{ .data = total_size };
                self.state.buffer_list.first = node;
            }
        }
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">createNode</span>(self: *<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>, prev_len: <span class="tok-type">usize</span>, minimum_size: <span class="tok-type">usize</span>) ?*<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode">BufNode</a> {
        <span class="tok-kw">const</span> actual_min_size = minimum_size + (<span class="tok-builtin">@sizeOf</span>(<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode">BufNode</a>) + <span class="tok-number">16</span>);
        <span class="tok-kw">const</span> big_enough_len = prev_len + actual_min_size;
        <span class="tok-kw">const</span> len = big_enough_len + big_enough_len / <span class="tok-number">2</span>;
        <span class="tok-kw">const</span> ptr = self.child_allocator.rawAlloc(len, <a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode_alignment">BufNode_alignment</a>, <span class="tok-builtin">@returnAddress</span>()) <span class="tok-kw">orelse</span>
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        <span class="tok-kw">const</span> buf_node: *<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode">BufNode</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ptr));
        buf_node.* = .{ .data = len };
        self.state.buffer_list.prepend(buf_node);
        self.state.end_index = <span class="tok-number">0</span>;
        <span class="tok-kw">return</span> buf_node;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">alloc</span>(ctx: *<span class="tok-type">anyopaque</span>, n: <span class="tok-type">usize</span>, alignment: <a href="std.mem.html">mem</a>.<a href="std.mem.Alignment.html">Alignment</a>, ra: <span class="tok-type">usize</span>) ?[*]<span class="tok-type">u8</span> {
        <span class="tok-kw">const</span> self: *<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ctx));
        _ = ra;

        <span class="tok-kw">const</span> ptr_align = alignment.toByteUnits();
        <span class="tok-kw">var</span> cur_node = <span class="tok-kw">if</span> (self.state.buffer_list.first) |first_node|
            first_node
        <span class="tok-kw">else</span>
            (self.createNode(<span class="tok-number">0</span>, n + ptr_align) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>);
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">const</span> cur_alloc_buf = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(cur_node))[<span class="tok-number">0</span>..cur_node.data];
            <span class="tok-kw">const</span> cur_buf = cur_alloc_buf[<span class="tok-builtin">@sizeOf</span>(<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode">BufNode</a>)..];
            <span class="tok-kw">const</span> addr = <span class="tok-builtin">@intFromPtr</span>(cur_buf.ptr) + self.state.end_index;
            <span class="tok-kw">const</span> adjusted_addr = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, addr, ptr_align);
            <span class="tok-kw">const</span> adjusted_index = self.state.end_index + (adjusted_addr - addr);
            <span class="tok-kw">const</span> new_end_index = adjusted_index + n;

            <span class="tok-kw">if</span> (new_end_index &lt;= cur_buf.len) {
                <span class="tok-kw">const</span> result = cur_buf[adjusted_index..new_end_index];
                self.state.end_index = new_end_index;
                <span class="tok-kw">return</span> result.ptr;
            }

            <span class="tok-kw">const</span> bigger_buf_size = <span class="tok-builtin">@sizeOf</span>(<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode">BufNode</a>) + new_end_index;
            <span class="tok-kw">if</span> (self.child_allocator.rawResize(cur_alloc_buf, <a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode_alignment">BufNode_alignment</a>, bigger_buf_size, <span class="tok-builtin">@returnAddress</span>())) {
                cur_node.data = bigger_buf_size;
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // Allocate a new node if that's not possible
                </span>cur_node = self.createNode(cur_buf.len, n + ptr_align) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(ctx: *<span class="tok-type">anyopaque</span>, buf: []<span class="tok-type">u8</span>, alignment: <a href="std.mem.html">mem</a>.<a href="std.mem.Alignment.html">Alignment</a>, new_len: <span class="tok-type">usize</span>, ret_addr: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
        <span class="tok-kw">const</span> self: *<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ctx));
        _ = alignment;
        _ = ret_addr;

        <span class="tok-kw">const</span> cur_node = self.state.buffer_list.first <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        <span class="tok-kw">const</span> cur_buf = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(cur_node))[<span class="tok-builtin">@sizeOf</span>(<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode">BufNode</a>)..cur_node.data];
        <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromPtr</span>(cur_buf.ptr) + self.state.end_index != <span class="tok-builtin">@intFromPtr</span>(buf.ptr) + buf.len) {<span class="tok-comment">
            // It's not the most recent allocation, so it cannot be expanded,
            // but it's fine if they want to make it smaller.
            </span><span class="tok-kw">return</span> new_len &lt;= buf.len;
        }

        <span class="tok-kw">if</span> (buf.len &gt;= new_len) {
            self.state.end_index -= buf.len - new_len;
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (cur_buf.len - self.state.end_index &gt;= new_len - buf.len) {
            self.state.end_index += new_len - buf.len;
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">remap</span>(
        context: *<span class="tok-type">anyopaque</span>,
        memory: []<span class="tok-type">u8</span>,
        alignment: <a href="std.mem.html">mem</a>.<a href="std.mem.Alignment.html">Alignment</a>,
        new_len: <span class="tok-type">usize</span>,
        return_address: <span class="tok-type">usize</span>,
    ) ?[*]<span class="tok-type">u8</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.resize">resize</a>(context, memory, alignment, new_len, return_address)) memory.ptr <span class="tok-kw">else</span> <span class="tok-null">null</span>;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">free</span>(ctx: *<span class="tok-type">anyopaque</span>, buf: []<span class="tok-type">u8</span>, alignment: <a href="std.mem.html">mem</a>.<a href="std.mem.Alignment.html">Alignment</a>, ret_addr: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        _ = alignment;
        _ = ret_addr;

        <span class="tok-kw">const</span> self: *<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ctx));

        <span class="tok-kw">const</span> cur_node = self.state.buffer_list.first <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
        <span class="tok-kw">const</span> cur_buf = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(cur_node))[<span class="tok-builtin">@sizeOf</span>(<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.BufNode">BufNode</a>)..cur_node.data];

        <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromPtr</span>(cur_buf.ptr) + self.state.end_index == <span class="tok-builtin">@intFromPtr</span>(buf.ptr) + buf.len) {
            self.state.end_index -= buf.len;
        }
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
