<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">debug</a></li><li><a href="std.debug.SelfInfo.html" class="active">SelfInfo</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.debug.SelfInfo" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.debug.SelfInfo</span><a href="#src.zig-std.debug.SelfInfo">[src]</a></h1><div class="tldDocs"><p>Cross-platform abstraction for this binary's own debug information, with a
goal of minimal code bloat and compilation speed penalty.</p>
</div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.debug.SelfInfo.WindowsModule.html">std.debug.SelfInfo.WindowsModule</a></li><li><a href="std.debug.SelfInfo.UnwindContext.html">std.debug.SelfInfo.UnwindContext</a></li><li><a href="std.debug.SelfInfo.VirtualMachine.html">std.debug.SelfInfo.VirtualMachine</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.debug.SelfInfo.Module" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Module</span><a href="#src.zig-std.debug.SelfInfo.Module">[src]</a></h2><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.debug.SelfInfo.Module.getOFileInfoForAddress" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">getOFileInfoForAddress</span><a href="#src.zig-std.debug.SelfInfo.Module.getOFileInfoForAddress">[src]</a></h3><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>address: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.SelfInfo.Module.getOFileInfoForAddress">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOFileInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !<span class="tok-kw">struct</span> {
    relocated_address: <span class="tok-type">usize</span>,
    symbol: ?*<span class="tok-kw">const</span> <a href="std.debug.SelfInfo.MachoSymbol.html">MachoSymbol</a> = <span class="tok-null">null</span>,
    o_file_info: ?*<a href="std.debug.SelfInfo.Module.OFileInfo.html">OFileInfo</a> = <span class="tok-null">null</span>,
} {
    <span class="tok-kw">nosuspend</span> {<span class="tok-comment">
        // Translate the VA into an address into this object
        </span><span class="tok-kw">const</span> relocated_address = address - self.vmaddr_slide;<span class="tok-comment">

        // Find the .o file where this symbol is defined
        </span><span class="tok-kw">const</span> symbol = <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.machoSearchSymbols">machoSearchSymbols</a>(self.symbols, relocated_address) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> .{
            .relocated_address = relocated_address,
        };<span class="tok-comment">

        // Check if its debug infos are already in the cache
        </span><span class="tok-kw">const</span> o_file_path = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(self.strings[symbol.ofile..], <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> o_file_info = self.ofiles.getPtr(o_file_path) <span class="tok-kw">orelse</span>
            (self.loadOFile(allocator, o_file_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.FileNotFound,
                <span class="tok-kw">error</span>.MissingDebugInfo,
                <span class="tok-kw">error</span>.InvalidDebugInfo,
                =&gt; <span class="tok-kw">return</span> .{
                    .relocated_address = relocated_address,
                    .symbol = symbol,
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
            });

        <span class="tok-kw">return</span> .{
            .relocated_address = relocated_address,
            .symbol = symbol,
            .o_file_info = o_file_info,
        };
    }
}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.debug.SelfInfo.Module.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.debug.SelfInfo.Module.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.SelfInfo.Module.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> it = self.ofiles.iterator();
    <span class="tok-kw">while</span> (it.next()) |entry| {
        <span class="tok-kw">const</span> ofile = entry.value_ptr;
        ofile.di.deinit(allocator);
        ofile.addr_table.deinit();
    }
    self.ofiles.deinit();
    allocator.free(self.symbols);
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.munmap">munmap</a>(self.mapped_memory);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.SelfInfo.Module.getSymbolAtAddress" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getSymbolAtAddress</span><a href="#src.zig-std.debug.SelfInfo.Module.getSymbolAtAddress">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Symbol.html">Symbol</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>address: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.SelfInfo.Module.getSymbolAtAddress">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Symbol.html">Symbol</a> {
    <span class="tok-kw">nosuspend</span> {
        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOFileInfoForAddress(allocator, address);
        <span class="tok-kw">if</span> (result.symbol == <span class="tok-null">null</span>) <span class="tok-kw">return</span> .{};<span class="tok-comment">

        // Take the symbol name from the N_FUN STAB entry, we're going to
        // use it if we fail to find the DWARF infos
        </span><span class="tok-kw">const</span> stab_symbol = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(self.strings[result.symbol.?.strx..], <span class="tok-number">0</span>);
        <span class="tok-kw">if</span> (result.o_file_info == <span class="tok-null">null</span>) <span class="tok-kw">return</span> .{ .name = stab_symbol };<span class="tok-comment">

        // Translate again the address, this time into an address inside the
        // .o file
        </span><span class="tok-kw">const</span> relocated_address_o = result.o_file_info.?.addr_table.get(stab_symbol) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> .{
            .name = <span class="tok-str">&quot;???&quot;</span>,
        };

        <span class="tok-kw">const</span> addr_off = result.relocated_address - result.symbol.?.addr;
        <span class="tok-kw">const</span> o_file_di = &amp;result.o_file_info.?.di;
        <span class="tok-kw">if</span> (o_file_di.findCompileUnit(relocated_address_o)) |compile_unit| {
            <span class="tok-kw">return</span> .{
                .name = o_file_di.getSymbolName(relocated_address_o) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>,
                .compile_unit_name = compile_unit.die.getAttrString(
                    o_file_di,
                    <a href="std.html">std</a>.<a href="std.dwarf.html">dwarf</a>.<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.name">name</a>,
                    o_file_di.section(.debug_str),
                    compile_unit.*,
                ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-str">&quot;???&quot;</span>,
                },
                .source_location = o_file_di.getLineNumberInfo(
                    allocator,
                    compile_unit,
                    relocated_address_o + addr_off,
                ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-null">null</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
                },
            };
        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; {
                <span class="tok-kw">return</span> .{ .name = stab_symbol };
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
        }
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.SelfInfo.Module.getDwarfInfoForAddress" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getDwarfInfoForAddress</span><a href="#src.zig-std.debug.SelfInfo.Module.getDwarfInfoForAddress">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !?*<a href="std.debug.Dwarf.html">Dwarf</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>address: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.SelfInfo.Module.getDwarfInfoForAddress">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !?*<a href="std.debug.Dwarf.html">Dwarf</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> ((<span class="tok-kw">try</span> self.getOFileInfoForAddress(allocator, address)).o_file_info) |o_file_info| &amp;o_file_info.di <span class="tok-kw">else</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.SelfInfo.Module.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.debug.SelfInfo.Module.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.SelfInfo.Module.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (self.dwarf) |*dwarf| {
        dwarf.deinit(allocator);
    }

    <span class="tok-kw">if</span> (self.pdb) |*p| {
        p.deinit();
        allocator.free(self.coff_section_headers);
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.SelfInfo.Module.getSymbolAtAddress" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getSymbolAtAddress</span><a href="#src.zig-std.debug.SelfInfo.Module.getSymbolAtAddress">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Symbol.html">Symbol</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>address: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.SelfInfo.Module.getSymbolAtAddress">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Symbol.html">Symbol</a> {<span class="tok-comment">
    // Translate the VA into an address into this object
    </span><span class="tok-kw">const</span> relocated_address = address - self.base_address;

    <span class="tok-kw">if</span> (self.pdb != <span class="tok-null">null</span>) {
        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> self.getSymbolFromPdb(relocated_address)) |symbol| <span class="tok-kw">return</span> symbol;
    }

    <span class="tok-kw">if</span> (self.dwarf) |*dwarf| {
        <span class="tok-kw">const</span> dwarf_address = relocated_address + self.coff_image_base;
        <span class="tok-kw">return</span> dwarf.getSymbol(allocator, dwarf_address);
    }

    <span class="tok-kw">return</span> .{};
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.SelfInfo.Module.getDwarfInfoForAddress" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getDwarfInfoForAddress</span><a href="#src.zig-std.debug.SelfInfo.Module.getDwarfInfoForAddress">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !?*<a href="std.debug.Dwarf.html">Dwarf</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>address: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.SelfInfo.Module.getDwarfInfoForAddress">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !?*<a href="std.debug.Dwarf.html">Dwarf</a> {
    _ = allocator;
    _ = address;

    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self.debug_data) {
        .dwarf =&gt; |*dwarf| dwarf,
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.SelfInfo.Module.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.debug.SelfInfo.Module.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.SelfInfo.Module.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    _ = self;
    _ = allocator;
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.SelfInfo.Module.getSymbolAtAddress" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getSymbolAtAddress</span><a href="#src.zig-std.debug.SelfInfo.Module.getSymbolAtAddress">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Symbol.html">Symbol</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>address: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.SelfInfo.Module.getSymbolAtAddress">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Symbol.html">Symbol</a> {
    _ = self;
    _ = allocator;
    _ = address;
    <span class="tok-kw">return</span> .{};
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.SelfInfo.Module.getDwarfInfoForAddress" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getDwarfInfoForAddress</span><a href="#src.zig-std.debug.SelfInfo.Module.getDwarfInfoForAddress">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !?*<a href="std.debug.Dwarf.html">Dwarf</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>address: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.SelfInfo.Module.getDwarfInfoForAddress">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !?*<a href="std.debug.Dwarf.html">Dwarf</a> {
    _ = self;
    _ = allocator;
    _ = address;
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.SelfInfo.Module">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Module = <span class="tok-kw">switch</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_os">native_os</a>) {
    .macos, .ios, .watchos, .tvos, .visionos =&gt; <span class="tok-kw">struct</span> {
        base_address: <span class="tok-type">usize</span>,
        vmaddr_slide: <span class="tok-type">usize</span>,
        mapped_memory: []<span class="tok-kw">align</span>(<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        symbols: []<span class="tok-kw">const</span> <a href="std.debug.SelfInfo.MachoSymbol.html">MachoSymbol</a>,
        strings: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        ofiles: <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module.OFileTable">OFileTable</a>,<span class="tok-comment">

        // Backed by the in-memory sections mapped by the loader
        </span>unwind_info: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
        eh_frame: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,

        <span class="tok-kw">const</span> OFileTable = <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.StringHashMap">StringHashMap</a>(<a href="std.debug.SelfInfo.Module.OFileInfo.html">OFileInfo</a>);
        <span class="tok-kw">const</span> OFileInfo = <span class="tok-kw">struct</span> {
            di: <a href="std.debug.Dwarf.html">Dwarf</a>,
            addr_table: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.StringHashMap">StringHashMap</a>(<span class="tok-type">u64</span>),
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">var</span> it = self.ofiles.iterator();
            <span class="tok-kw">while</span> (it.next()) |entry| {
                <span class="tok-kw">const</span> ofile = entry.value_ptr;
                ofile.di.deinit(allocator);
                ofile.addr_table.deinit();
            }
            self.ofiles.deinit();
            allocator.free(self.symbols);
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.munmap">munmap</a>(self.mapped_memory);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">loadOFile</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, o_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !*<a href="std.debug.SelfInfo.Module.OFileInfo.html">OFileInfo</a> {
            <span class="tok-kw">const</span> o_file = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().openFile(o_file_path, .{});
            <span class="tok-kw">const</span> mapped_mem = <span class="tok-kw">try</span> <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.mapWholeFile">mapWholeFile</a>(o_file);

            <span class="tok-kw">const</span> hdr: *<span class="tok-kw">const</span> <a href="std.macho.html">macho</a>.<a href="std.macho.mach_header_64.html">mach_header_64</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(mapped_mem.ptr));
            <span class="tok-kw">if</span> (hdr.magic != <a href="std.html">std</a>.<a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_MAGIC_64">MH_MAGIC_64</a>)
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;

            <span class="tok-kw">var</span> segcmd: ?<a href="std.macho.html">macho</a>.<a href="std.macho.LoadCommandIterator.html">LoadCommandIterator</a>.<a href="std.macho.LoadCommandIterator.LoadCommand.html">LoadCommand</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">var</span> symtabcmd: ?<a href="std.macho.html">macho</a>.<a href="std.macho.symtab_command.html">symtab_command</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">var</span> it = <a href="std.macho.html">macho</a>.<a href="std.macho.LoadCommandIterator.html">LoadCommandIterator</a>{
                .ncmds = hdr.ncmds,
                .buffer = mapped_mem[<span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.mach_header_64.html">mach_header_64</a>)..][<span class="tok-number">0</span>..hdr.sizeofcmds],
            };
            <span class="tok-kw">while</span> (it.next()) |cmd| <span class="tok-kw">switch</span> (cmd.cmd()) {
                .SEGMENT_64 =&gt; segcmd = cmd,
                .SYMTAB =&gt; symtabcmd = cmd.cast(<a href="std.macho.html">macho</a>.<a href="std.macho.symtab_command.html">symtab_command</a>).?,
                <span class="tok-kw">else</span> =&gt; {},
            };

            <span class="tok-kw">if</span> (segcmd == <span class="tok-null">null</span> <span class="tok-kw">or</span> symtabcmd == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;<span class="tok-comment">

            // Parse symbols
            </span><span class="tok-kw">const</span> strtab = <span class="tok-builtin">@as</span>(
                [*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
                <span class="tok-builtin">@ptrCast</span>(&amp;mapped_mem[symtabcmd.?.stroff]),
            )[<span class="tok-number">0</span> .. symtabcmd.?.strsize - <span class="tok-number">1</span> :<span class="tok-number">0</span>];
            <span class="tok-kw">const</span> symtab = <span class="tok-builtin">@as</span>(
                [*]<span class="tok-kw">const</span> <a href="std.macho.html">macho</a>.<a href="std.macho.nlist_64.html">nlist_64</a>,
                <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mapped_mem[symtabcmd.?.symoff])),
            )[<span class="tok-number">0</span>..symtabcmd.?.nsyms];<span class="tok-comment">

            // TODO handle tentative (common) symbols
            </span><span class="tok-kw">var</span> addr_table = <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.StringHashMap">StringHashMap</a>(<span class="tok-type">u64</span>).init(allocator);
            <span class="tok-kw">try</span> addr_table.ensureTotalCapacity(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(symtab.len)));
            <span class="tok-kw">for</span> (symtab) |sym| {
                <span class="tok-kw">if</span> (sym.n_strx == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;
                <span class="tok-kw">if</span> (sym.undf() <span class="tok-kw">or</span> sym.tentative() <span class="tok-kw">or</span> sym.abs()) <span class="tok-kw">continue</span>;
                <span class="tok-kw">const</span> sym_name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(strtab[sym.n_strx..], <span class="tok-number">0</span>);<span class="tok-comment">
                // TODO is it possible to have a symbol collision?
                </span>addr_table.putAssumeCapacityNoClobber(sym_name, sym.n_value);
            }

            <span class="tok-kw">var</span> sections: <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.SectionArray">SectionArray</a> = <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.null_section_array">null_section_array</a>;
            <span class="tok-kw">if</span> (self.eh_frame) |eh_frame| sections[<span class="tok-builtin">@intFromEnum</span>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>.<a href="#">eh_frame</a>)] = .{
                .data = eh_frame,
                .owned = <span class="tok-null">false</span>,
            };

            <span class="tok-kw">for</span> (segcmd.?.getSections()) |sect| {
                <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;__DWARF&quot;</span>, sect.segName())) <span class="tok-kw">continue</span>;

                <span class="tok-kw">var</span> section_index: ?<span class="tok-type">usize</span> = <span class="tok-null">null</span>;
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>).@&quot;enum&quot;.fields, <span class="tok-number">0</span>..) |section, i| {
                    <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;__&quot;</span> ++ section.name, sect.sectName())) section_index = i;
                }
                <span class="tok-kw">if</span> (section_index == <span class="tok-null">null</span>) <span class="tok-kw">continue</span>;

                <span class="tok-kw">const</span> section_bytes = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.chopSlice">chopSlice</a>(mapped_mem, sect.offset, sect.size);
                sections[section_index.?] = .{
                    .data = section_bytes,
                    .virtual_address = <span class="tok-builtin">@intCast</span>(sect.addr),
                    .owned = <span class="tok-null">false</span>,
                };
            }

            <span class="tok-kw">const</span> missing_debug_info =
                sections[<span class="tok-builtin">@intFromEnum</span>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>.<a href="#">debug_info</a>)] == <span class="tok-null">null</span> <span class="tok-kw">or</span>
                sections[<span class="tok-builtin">@intFromEnum</span>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>.<a href="#">debug_abbrev</a>)] == <span class="tok-null">null</span> <span class="tok-kw">or</span>
                sections[<span class="tok-builtin">@intFromEnum</span>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>.<a href="#">debug_str</a>)] == <span class="tok-null">null</span> <span class="tok-kw">or</span>
                sections[<span class="tok-builtin">@intFromEnum</span>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>.<a href="#">debug_line</a>)] == <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (missing_debug_info) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;

            <span class="tok-kw">var</span> di: <a href="std.debug.Dwarf.html">Dwarf</a> = .{
                .endian = .little,
                .sections = sections,
                .is_macho = <span class="tok-null">true</span>,
            };

            <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.open">open</a>(&amp;di, allocator);
            <span class="tok-kw">const</span> info = <a href="std.debug.SelfInfo.Module.OFileInfo.html">OFileInfo</a>{
                .di = di,
                .addr_table = addr_table,
            };<span class="tok-comment">

            // Add the debug info to the cache
            </span><span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.ofiles.getOrPut(o_file_path);
            <a href="std.debug.html#std.debug.assert">assert</a>(!result.found_existing);
            result.value_ptr.* = info;

            <span class="tok-kw">return</span> result.value_ptr;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Symbol.html">Symbol</a> {
            <span class="tok-kw">nosuspend</span> {
                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOFileInfoForAddress(allocator, address);
                <span class="tok-kw">if</span> (result.symbol == <span class="tok-null">null</span>) <span class="tok-kw">return</span> .{};<span class="tok-comment">

                // Take the symbol name from the N_FUN STAB entry, we're going to
                // use it if we fail to find the DWARF infos
                </span><span class="tok-kw">const</span> stab_symbol = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(self.strings[result.symbol.?.strx..], <span class="tok-number">0</span>);
                <span class="tok-kw">if</span> (result.o_file_info == <span class="tok-null">null</span>) <span class="tok-kw">return</span> .{ .name = stab_symbol };<span class="tok-comment">

                // Translate again the address, this time into an address inside the
                // .o file
                </span><span class="tok-kw">const</span> relocated_address_o = result.o_file_info.?.addr_table.get(stab_symbol) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> .{
                    .name = <span class="tok-str">&quot;???&quot;</span>,
                };

                <span class="tok-kw">const</span> addr_off = result.relocated_address - result.symbol.?.addr;
                <span class="tok-kw">const</span> o_file_di = &amp;result.o_file_info.?.di;
                <span class="tok-kw">if</span> (o_file_di.findCompileUnit(relocated_address_o)) |compile_unit| {
                    <span class="tok-kw">return</span> .{
                        .name = o_file_di.getSymbolName(relocated_address_o) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>,
                        .compile_unit_name = compile_unit.die.getAttrString(
                            o_file_di,
                            <a href="std.html">std</a>.<a href="std.dwarf.html">dwarf</a>.<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.name">name</a>,
                            o_file_di.section(.debug_str),
                            compile_unit.*,
                        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                            <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-str">&quot;???&quot;</span>,
                        },
                        .source_location = o_file_di.getLineNumberInfo(
                            allocator,
                            compile_unit,
                            relocated_address_o + addr_off,
                        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                            <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-null">null</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
                        },
                    };
                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; {
                        <span class="tok-kw">return</span> .{ .name = stab_symbol };
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
                }
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOFileInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !<span class="tok-kw">struct</span> {
            relocated_address: <span class="tok-type">usize</span>,
            symbol: ?*<span class="tok-kw">const</span> <a href="std.debug.SelfInfo.MachoSymbol.html">MachoSymbol</a> = <span class="tok-null">null</span>,
            o_file_info: ?*<a href="std.debug.SelfInfo.Module.OFileInfo.html">OFileInfo</a> = <span class="tok-null">null</span>,
        } {
            <span class="tok-kw">nosuspend</span> {<span class="tok-comment">
                // Translate the VA into an address into this object
                </span><span class="tok-kw">const</span> relocated_address = address - self.vmaddr_slide;<span class="tok-comment">

                // Find the .o file where this symbol is defined
                </span><span class="tok-kw">const</span> symbol = <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.machoSearchSymbols">machoSearchSymbols</a>(self.symbols, relocated_address) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> .{
                    .relocated_address = relocated_address,
                };<span class="tok-comment">

                // Check if its debug infos are already in the cache
                </span><span class="tok-kw">const</span> o_file_path = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(self.strings[symbol.ofile..], <span class="tok-number">0</span>);
                <span class="tok-kw">const</span> o_file_info = self.ofiles.getPtr(o_file_path) <span class="tok-kw">orelse</span>
                    (self.loadOFile(allocator, o_file_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                        <span class="tok-kw">error</span>.FileNotFound,
                        <span class="tok-kw">error</span>.MissingDebugInfo,
                        <span class="tok-kw">error</span>.InvalidDebugInfo,
                        =&gt; <span class="tok-kw">return</span> .{
                            .relocated_address = relocated_address,
                            .symbol = symbol,
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
                    });

                <span class="tok-kw">return</span> .{
                    .relocated_address = relocated_address,
                    .symbol = symbol,
                    .o_file_info = o_file_info,
                };
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !?*<a href="std.debug.Dwarf.html">Dwarf</a> {
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> ((<span class="tok-kw">try</span> self.getOFileInfoForAddress(allocator, address)).o_file_info) |o_file_info| &amp;o_file_info.di <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        }
    },
    .uefi, .windows =&gt; <span class="tok-kw">struct</span> {
        base_address: <span class="tok-type">usize</span>,
        pdb: ?<a href="std.debug.Pdb.html">Pdb</a> = <span class="tok-null">null</span>,
        dwarf: ?<a href="std.debug.Dwarf.html">Dwarf</a> = <span class="tok-null">null</span>,
        coff_image_base: <span class="tok-type">u64</span>,

        <span class="tok-comment">/// Only used if pdb is non-null</span>
        coff_section_headers: []<a href="std.coff.html">coff</a>.<a href="std.coff.SectionHeader.html">SectionHeader</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (self.dwarf) |*dwarf| {
                dwarf.deinit(allocator);
            }

            <span class="tok-kw">if</span> (self.pdb) |*p| {
                p.deinit();
                allocator.free(self.coff_section_headers);
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolFromPdb</span>(self: *<span class="tok-builtin">@This</span>(), relocated_address: <span class="tok-type">usize</span>) !?<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Symbol.html">Symbol</a> {
            <span class="tok-kw">var</span> coff_section: *<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <a href="std.coff.html">coff</a>.<a href="std.coff.SectionHeader.html">SectionHeader</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> mod_index = <span class="tok-kw">for</span> (self.pdb.?.sect_contribs) |sect_contrib| {
                <span class="tok-kw">if</span> (sect_contrib.section &gt; self.coff_section_headers.len) <span class="tok-kw">continue</span>;<span class="tok-comment">
                // Remember that SectionContribEntry.Section is 1-based.
                </span>coff_section = &amp;self.coff_section_headers[sect_contrib.section - <span class="tok-number">1</span>];

                <span class="tok-kw">const</span> vaddr_start = coff_section.virtual_address + sect_contrib.offset;
                <span class="tok-kw">const</span> vaddr_end = vaddr_start + sect_contrib.size;
                <span class="tok-kw">if</span> (relocated_address &gt;= vaddr_start <span class="tok-kw">and</span> relocated_address &lt; vaddr_end) {
                    <span class="tok-kw">break</span> sect_contrib.module_index;
                }
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // we have no information to add to the address
                </span><span class="tok-kw">return</span> <span class="tok-null">null</span>;
            };

            <span class="tok-kw">const</span> module = (<span class="tok-kw">try</span> self.pdb.?.getModule(mod_index)) <span class="tok-kw">orelse</span>
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;
            <span class="tok-kw">const</span> obj_basename = <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.basename">basename</a>(module.obj_file_name);

            <span class="tok-kw">const</span> symbol_name = self.pdb.?.getSymbolName(
                module,
                relocated_address - coff_section.virtual_address,
            ) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>;
            <span class="tok-kw">const</span> opt_line_info = <span class="tok-kw">try</span> self.pdb.?.getLineNumberInfo(
                module,
                relocated_address - coff_section.virtual_address,
            );

            <span class="tok-kw">return</span> .{
                .name = symbol_name,
                .compile_unit_name = obj_basename,
                .source_location = opt_line_info,
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Symbol.html">Symbol</a> {<span class="tok-comment">
            // Translate the VA into an address into this object
            </span><span class="tok-kw">const</span> relocated_address = address - self.base_address;

            <span class="tok-kw">if</span> (self.pdb != <span class="tok-null">null</span>) {
                <span class="tok-kw">if</span> (<span class="tok-kw">try</span> self.getSymbolFromPdb(relocated_address)) |symbol| <span class="tok-kw">return</span> symbol;
            }

            <span class="tok-kw">if</span> (self.dwarf) |*dwarf| {
                <span class="tok-kw">const</span> dwarf_address = relocated_address + self.coff_image_base;
                <span class="tok-kw">return</span> dwarf.getSymbol(allocator, dwarf_address);
            }

            <span class="tok-kw">return</span> .{};
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !?*<a href="std.debug.Dwarf.html">Dwarf</a> {
            _ = allocator;
            _ = address;

            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self.debug_data) {
                .dwarf =&gt; |*dwarf| dwarf,
                <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
            };
        }
    },
    .linux, .netbsd, .freebsd, .dragonfly, .openbsd, .haiku, .solaris, .illumos =&gt; <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.ElfModule.html">ElfModule</a>,
    .wasi, .emscripten =&gt; <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            _ = self;
            _ = allocator;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Symbol.html">Symbol</a> {
            _ = self;
            _ = allocator;
            _ = address;
            <span class="tok-kw">return</span> .{};
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !?*<a href="std.debug.Dwarf.html">Dwarf</a> {
            _ = self;
            _ = allocator;
            _ = address;
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }
    },
    <span class="tok-kw">else</span> =&gt; <a href="std.debug.Dwarf.html">Dwarf</a>,
}</code></pre></details></div></div></div></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>address_map: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">usize</span>, *<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module">Module</a>)</code></pre></div><div><pre><code>modules: <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_os">native_os</a> == .windows) <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.debug.SelfInfo.WindowsModule.html">WindowsModule</a>) <span class="tok-kw">else</span> <span class="tok-type">void</span></code></pre></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.debug.SelfInfo.supports_unwinding" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">supports_unwinding</span><a href="#src.zig-std.debug.SelfInfo.supports_unwinding">[src]</a></h2><div class="tldDocs"><p>Tells whether unwinding for the host is implemented.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.SelfInfo.supports_unwinding">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> supports_unwinding = <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.supportsUnwinding">supportsUnwinding</a>(<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>)</code></pre></details></div></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.debug.SelfInfo.OpenError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">OpenError</span><a href="#src.zig-std.debug.SelfInfo.OpenError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>MissingDebugInfo</dt></div><div><dt>UnsupportedOperatingSystem</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.SelfInfo.OpenError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenError = <span class="tok-kw">error</span>{
    MissingDebugInfo,
    UnsupportedOperatingSystem,
} || <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(<a href="std.debug.SelfInfo.html">SelfInfo</a>.<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.init">init</a>)).@&quot;fn&quot;.return_type.?).error_union.error_set</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.debug.SelfInfo.open" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">open</span><a href="#src.zig-std.debug.SelfInfo.open">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">open</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.OpenError">OpenError</a>!<a href="std.debug.SelfInfo.html">SelfInfo</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.SelfInfo.open">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">open</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.OpenError">OpenError</a>!<a href="std.debug.SelfInfo.html">SelfInfo</a> {
    <span class="tok-kw">nosuspend</span> {
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.strip_debug_info">strip_debug_info</a>)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
        <span class="tok-kw">switch</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_os">native_os</a>) {
            .linux,
            .freebsd,
            .netbsd,
            .dragonfly,
            .openbsd,
            .macos,
            .solaris,
            .illumos,
            .windows,
            =&gt; <span class="tok-kw">return</span> <span class="tok-kw">try</span> <a href="std.debug.SelfInfo.html">SelfInfo</a>.<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.init">init</a>(allocator),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedOperatingSystem,
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.SelfInfo.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.debug.SelfInfo.init">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.debug.SelfInfo.html">SelfInfo</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.SelfInfo.init">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.debug.SelfInfo.html">SelfInfo</a> {
    <span class="tok-kw">var</span> debug_info: <a href="std.debug.SelfInfo.html">SelfInfo</a> = .{
        .allocator = allocator,
        .address_map = <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">usize</span>, *<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module">Module</a>).init(allocator),
        .modules = <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_os">native_os</a> == .windows) .{} <span class="tok-kw">else</span> {},
    };

    <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_os">native_os</a> == .windows) {
        <span class="tok-kw">errdefer</span> debug_info.modules.deinit(allocator);

        <span class="tok-kw">const</span> handle = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.CreateToolhelp32Snapshot">CreateToolhelp32Snapshot</a>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TH32CS_SNAPMODULE">TH32CS_SNAPMODULE</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TH32CS_SNAPMODULE32">TH32CS_SNAPMODULE32</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">if</span> (handle == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.INVALID_HANDLE_VALUE">INVALID_HANDLE_VALUE</a>) {
            <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetLastError">GetLastError</a>()) {
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedError">unexpectedError</a>(err),
            }
        }
        <span class="tok-kw">defer</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CloseHandle">CloseHandle</a>(handle);

        <span class="tok-kw">var</span> module_entry: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.MODULEENTRY32.html">MODULEENTRY32</a> = <span class="tok-null">undefined</span>;
        module_entry.dwSize = <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.MODULEENTRY32.html">MODULEENTRY32</a>);
        <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.Module32First">Module32First</a>(handle, &amp;module_entry) == <span class="tok-number">0</span>) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
        }

        <span class="tok-kw">var</span> module_valid = <span class="tok-null">true</span>;
        <span class="tok-kw">while</span> (module_valid) {
            <span class="tok-kw">const</span> module_info = <span class="tok-kw">try</span> debug_info.modules.addOne(allocator);
            <span class="tok-kw">const</span> name = allocator.dupe(<span class="tok-type">u8</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;module_entry.szModule, <span class="tok-number">0</span>)) <span class="tok-kw">catch</span> &amp;.{};
            <span class="tok-kw">errdefer</span> allocator.free(name);

            module_info.* = .{
                .base_address = <span class="tok-builtin">@intFromPtr</span>(module_entry.modBaseAddr),
                .size = module_entry.modBaseSize,
                .name = name,
                .handle = module_entry.hModule,
            };

            module_valid = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.Module32Next">Module32Next</a>(handle, &amp;module_entry) == <span class="tok-number">1</span>;
        }
    }

    <span class="tok-kw">return</span> debug_info;
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.SelfInfo.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.debug.SelfInfo.deinit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.debug.SelfInfo.html">SelfInfo</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.debug.SelfInfo.html">SelfInfo</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.SelfInfo.deinit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.debug.SelfInfo.html">SelfInfo</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> it = self.address_map.iterator();
    <span class="tok-kw">while</span> (it.next()) |entry| {
        <span class="tok-kw">const</span> mdi = entry.value_ptr.*;
        mdi.deinit(self.allocator);
        self.allocator.destroy(mdi);
    }
    self.address_map.deinit();
    <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_os">native_os</a> == .windows) {
        <span class="tok-kw">for</span> (self.modules.items) |module| {
            self.allocator.free(module.name);
            <span class="tok-kw">if</span> (module.mapped_file) |mapped_file| mapped_file.deinit();
        }
        self.modules.deinit(self.allocator);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.SelfInfo.getModuleForAddress" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getModuleForAddress</span><a href="#src.zig-std.debug.SelfInfo.getModuleForAddress">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getModuleForAddress</span>(self: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, address: <span class="tok-type">usize</span>) !*<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module">Module</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.debug.SelfInfo.html">SelfInfo</a></code></pre></div><div><pre><code>address: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.SelfInfo.getModuleForAddress">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getModuleForAddress</span>(self: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, address: <span class="tok-type">usize</span>) !*<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module">Module</a> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a>.<a href="#">isDarwin</a>()) {
        <span class="tok-kw">return</span> self.lookupModuleDyld(address);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> self.lookupModuleWin32(address);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_os">native_os</a> == .haiku) {
        <span class="tok-kw">return</span> self.lookupModuleHaiku(address);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">cpu</a>.<a href="#">arch</a>.<a href="#">isWasm</a>()) {
        <span class="tok-kw">return</span> self.lookupModuleWasm(address);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> self.lookupModuleDl(address);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.SelfInfo.getModuleNameForAddress" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getModuleNameForAddress</span><a href="#src.zig-std.debug.SelfInfo.getModuleNameForAddress">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getModuleNameForAddress</span>(self: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, address: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.debug.SelfInfo.html">SelfInfo</a></code></pre></div><div><pre><code>address: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.SelfInfo.getModuleNameForAddress">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getModuleNameForAddress</span>(self: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, address: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a>.<a href="#">isDarwin</a>()) {
        <span class="tok-kw">return</span> self.lookupModuleNameDyld(address);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> self.lookupModuleNameWin32(address);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_os">native_os</a> == .haiku) {
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">cpu</a>.<a href="#">arch</a>.<a href="#">isWasm</a>()) {
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> self.lookupModuleNameDl(address);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.SelfInfo.readElfDebugInfo" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readElfDebugInfo</span><a href="#src.zig-std.debug.SelfInfo.readElfDebugInfo">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readElfDebugInfo</span>( allocator: <a href="std.mem.Allocator.html">Allocator</a>, elf_filename: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, build_id: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, expected_crc: ?<span class="tok-type">u32</span>, parent_sections: *<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.SectionArray">SectionArray</a>, parent_mapped_mem: ?[]<span class="tok-kw">align</span>(<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) !<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.ElfModule.html">ElfModule</a></code></pre></div><div class="tldDocs"><p>Reads debug info from an ELF file, or the current binary if none in specified.
If the required sections aren't present but a reference to external debug info is,
then this this function will recurse to attempt to load the debug sections from
an external file.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>elf_filename: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>build_id: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>expected_crc: ?<span class="tok-type">u32</span></code></pre></div><div><pre><code>parent_sections: *<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.SectionArray">SectionArray</a></code></pre></div><div><pre><code>parent_mapped_mem: ?[]<span class="tok-kw">align</span>(<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.SelfInfo.readElfDebugInfo">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readElfDebugInfo</span>(
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    elf_filename: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    build_id: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    expected_crc: ?<span class="tok-type">u32</span>,
    parent_sections: *<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.SectionArray">SectionArray</a>,
    parent_mapped_mem: ?[]<span class="tok-kw">align</span>(<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) !<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.ElfModule.html">ElfModule</a> {
    <span class="tok-kw">nosuspend</span> {
        <span class="tok-kw">const</span> elf_file = (<span class="tok-kw">if</span> (elf_filename) |filename| blk: {
            <span class="tok-kw">break</span> :blk <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().openFile(filename, .{});
        } <span class="tok-kw">else</span> <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.openSelfExe">openSelfExe</a>(.{})) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
        };

        <span class="tok-kw">const</span> mapped_mem = <span class="tok-kw">try</span> <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.mapWholeFile">mapWholeFile</a>(elf_file);
        <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.ElfModule.html">ElfModule</a>.<a href="std.debug.Dwarf.ElfModule.html#std.debug.Dwarf.ElfModule.load">load</a>(
            allocator,
            mapped_mem,
            build_id,
            expected_crc,
            parent_sections,
            parent_mapped_mem,
            elf_filename,
        );
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.SelfInfo.unwindFrameMachO" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unwindFrameMachO</span><a href="#src.zig-std.debug.SelfInfo.unwindFrameMachO">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwindFrameMachO</span>( allocator: <a href="std.mem.Allocator.html">Allocator</a>, base_address: <span class="tok-type">usize</span>, context: *<a href="std.debug.SelfInfo.UnwindContext.html">UnwindContext</a>, ma: *<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.MemoryAccessor.html">MemoryAccessor</a>, unwind_info: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, eh_frame: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) !<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Unwind a frame using MachO compact unwind info (from __unwind_info).
If the compact encoding can't encode a way to unwind a frame, it will
defer unwinding to DWARF, in which case <code>.eh_frame</code> will be used if available.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>base_address: <span class="tok-type">usize</span></code></pre></div><div><pre><code>context: *<a href="std.debug.SelfInfo.UnwindContext.html">UnwindContext</a></code></pre></div><div><pre><code>ma: *<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.MemoryAccessor.html">MemoryAccessor</a></code></pre></div><div><pre><code>unwind_info: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>eh_frame: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.SelfInfo.unwindFrameMachO">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwindFrameMachO</span>(
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    base_address: <span class="tok-type">usize</span>,
    context: *<a href="std.debug.SelfInfo.UnwindContext.html">UnwindContext</a>,
    ma: *<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.MemoryAccessor.html">MemoryAccessor</a>,
    unwind_info: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    eh_frame: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) !<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> header = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsValue">bytesAsValue</a>(
        <a href="std.macho.html">macho</a>.<a href="std.macho.unwind_info_section_header.html">unwind_info_section_header</a>,
        unwind_info[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.unwind_info_section_header.html">unwind_info_section_header</a>)],
    );
    <span class="tok-kw">const</span> indices = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(
        <a href="std.macho.html">macho</a>.<a href="std.macho.unwind_info_section_header_index_entry.html">unwind_info_section_header_index_entry</a>,
        unwind_info[header.indexSectionOffset..][<span class="tok-number">0</span> .. header.indexCount * <span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.unwind_info_section_header_index_entry.html">unwind_info_section_header_index_entry</a>)],
    );
    <span class="tok-kw">if</span> (indices.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingUnwindInfo;

    <span class="tok-kw">const</span> mapped_pc = context.pc - base_address;
    <span class="tok-kw">const</span> second_level_index = blk: {
        <span class="tok-kw">var</span> left: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = indices.len;

        <span class="tok-kw">while</span> (len &gt; <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> mid = left + len / <span class="tok-number">2</span>;
            <span class="tok-kw">const</span> offset = indices[mid].functionOffset;
            <span class="tok-kw">if</span> (mapped_pc &lt; offset) {
                len /= <span class="tok-number">2</span>;
            } <span class="tok-kw">else</span> {
                left = mid;
                <span class="tok-kw">if</span> (mapped_pc == offset) <span class="tok-kw">break</span>;
                len -= len / <span class="tok-number">2</span>;
            }
        }<span class="tok-comment">

        // Last index is a sentinel containing the highest address as its functionOffset
        </span><span class="tok-kw">if</span> (indices[left].secondLevelPagesSectionOffset == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingUnwindInfo;
        <span class="tok-kw">break</span> :blk &amp;indices[left];
    };

    <span class="tok-kw">const</span> common_encodings = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(
        <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.compact_unwind_encoding_t">compact_unwind_encoding_t</a>,
        unwind_info[header.commonEncodingsArraySectionOffset..][<span class="tok-number">0</span> .. header.commonEncodingsArrayCount * <span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.compact_unwind_encoding_t">compact_unwind_encoding_t</a>)],
    );

    <span class="tok-kw">const</span> start_offset = second_level_index.secondLevelPagesSectionOffset;
    <span class="tok-kw">const</span> kind = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsValue">bytesAsValue</a>(
        <a href="std.macho.html">macho</a>.<a href="std.macho.UNWIND_SECOND_LEVEL.html">UNWIND_SECOND_LEVEL</a>,
        unwind_info[start_offset..][<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.UNWIND_SECOND_LEVEL.html">UNWIND_SECOND_LEVEL</a>)],
    );

    <span class="tok-kw">const</span> entry: <span class="tok-kw">struct</span> {
        function_offset: <span class="tok-type">usize</span>,
        raw_encoding: <span class="tok-type">u32</span>,
    } = <span class="tok-kw">switch</span> (kind.*) {
        .REGULAR =&gt; blk: {
            <span class="tok-kw">const</span> page_header = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsValue">bytesAsValue</a>(
                <a href="std.macho.html">macho</a>.<a href="std.macho.unwind_info_regular_second_level_page_header.html">unwind_info_regular_second_level_page_header</a>,
                unwind_info[start_offset..][<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.unwind_info_regular_second_level_page_header.html">unwind_info_regular_second_level_page_header</a>)],
            );

            <span class="tok-kw">const</span> entries = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(
                <a href="std.macho.html">macho</a>.<a href="std.macho.unwind_info_regular_second_level_entry.html">unwind_info_regular_second_level_entry</a>,
                unwind_info[start_offset + page_header.entryPageOffset ..][<span class="tok-number">0</span> .. page_header.entryCount * <span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.unwind_info_regular_second_level_entry.html">unwind_info_regular_second_level_entry</a>)],
            );
            <span class="tok-kw">if</span> (entries.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;

            <span class="tok-kw">var</span> left: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = entries.len;
            <span class="tok-kw">while</span> (len &gt; <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> mid = left + len / <span class="tok-number">2</span>;
                <span class="tok-kw">const</span> offset = entries[mid].functionOffset;
                <span class="tok-kw">if</span> (mapped_pc &lt; offset) {
                    len /= <span class="tok-number">2</span>;
                } <span class="tok-kw">else</span> {
                    left = mid;
                    <span class="tok-kw">if</span> (mapped_pc == offset) <span class="tok-kw">break</span>;
                    len -= len / <span class="tok-number">2</span>;
                }
            }

            <span class="tok-kw">break</span> :blk .{
                .function_offset = entries[left].functionOffset,
                .raw_encoding = entries[left].encoding,
            };
        },
        .COMPRESSED =&gt; blk: {
            <span class="tok-kw">const</span> page_header = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsValue">bytesAsValue</a>(
                <a href="std.macho.html">macho</a>.<a href="std.macho.unwind_info_compressed_second_level_page_header.html">unwind_info_compressed_second_level_page_header</a>,
                unwind_info[start_offset..][<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.unwind_info_compressed_second_level_page_header.html">unwind_info_compressed_second_level_page_header</a>)],
            );

            <span class="tok-kw">const</span> entries = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(
                <a href="std.macho.html">macho</a>.<a href="std.macho.UnwindInfoCompressedEntry.html">UnwindInfoCompressedEntry</a>,
                unwind_info[start_offset + page_header.entryPageOffset ..][<span class="tok-number">0</span> .. page_header.entryCount * <span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.UnwindInfoCompressedEntry.html">UnwindInfoCompressedEntry</a>)],
            );
            <span class="tok-kw">if</span> (entries.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;

            <span class="tok-kw">var</span> left: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = entries.len;
            <span class="tok-kw">while</span> (len &gt; <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> mid = left + len / <span class="tok-number">2</span>;
                <span class="tok-kw">const</span> offset = second_level_index.functionOffset + entries[mid].funcOffset;
                <span class="tok-kw">if</span> (mapped_pc &lt; offset) {
                    len /= <span class="tok-number">2</span>;
                } <span class="tok-kw">else</span> {
                    left = mid;
                    <span class="tok-kw">if</span> (mapped_pc == offset) <span class="tok-kw">break</span>;
                    len -= len / <span class="tok-number">2</span>;
                }
            }

            <span class="tok-kw">const</span> entry = entries[left];
            <span class="tok-kw">const</span> function_offset = second_level_index.functionOffset + entry.funcOffset;
            <span class="tok-kw">if</span> (entry.encodingIndex &lt; header.commonEncodingsArrayCount) {
                <span class="tok-kw">if</span> (entry.encodingIndex &gt;= common_encodings.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;
                <span class="tok-kw">break</span> :blk .{
                    .function_offset = function_offset,
                    .raw_encoding = common_encodings[entry.encodingIndex],
                };
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> local_index = <span class="tok-kw">try</span> <a href="std.math.html">math</a>.<a href="std.math.html#std.math.sub">sub</a>(
                    <span class="tok-type">u8</span>,
                    entry.encodingIndex,
                    <a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u8</span>, header.commonEncodingsArrayCount) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo,
                );
                <span class="tok-kw">const</span> local_encodings = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.compact_unwind_encoding_t">compact_unwind_encoding_t</a>,
                    unwind_info[start_offset + page_header.encodingsPageOffset ..][<span class="tok-number">0</span> .. page_header.encodingsCount * <span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.compact_unwind_encoding_t">compact_unwind_encoding_t</a>)],
                );
                <span class="tok-kw">if</span> (local_index &gt;= local_encodings.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;
                <span class="tok-kw">break</span> :blk .{
                    .function_offset = function_offset,
                    .raw_encoding = local_encodings[local_index],
                };
            }
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo,
    };

    <span class="tok-kw">if</span> (entry.raw_encoding == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoUnwindInfo;
    <span class="tok-kw">const</span> reg_context = <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.RegisterContext.html">RegisterContext</a>{
        .eh_frame = <span class="tok-null">false</span>,
        .is_macho = <span class="tok-null">true</span>,
    };

    <span class="tok-kw">const</span> encoding: <a href="std.macho.html">macho</a>.<a href="std.macho.CompactUnwindEncoding.html">CompactUnwindEncoding</a> = <span class="tok-builtin">@bitCast</span>(entry.raw_encoding);
    <span class="tok-kw">const</span> new_ip = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>) {
        .x86_64 =&gt; <span class="tok-kw">switch</span> (encoding.mode.x86_64) {
            .OLD =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedUnwindEncoding,
            .RBP_FRAME =&gt; blk: {
                <span class="tok-kw">const</span> regs: [<span class="tok-number">5</span>]<span class="tok-type">u3</span> = .{
                    encoding.value.x86_64.frame.reg0,
                    encoding.value.x86_64.frame.reg1,
                    encoding.value.x86_64.frame.reg2,
                    encoding.value.x86_64.frame.reg3,
                    encoding.value.x86_64.frame.reg4,
                };

                <span class="tok-kw">const</span> frame_offset = encoding.value.x86_64.frame.frame_offset * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
                <span class="tok-kw">var</span> max_reg: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (regs, <span class="tok-number">0</span>..) |reg, i| {
                    <span class="tok-kw">if</span> (reg &gt; <span class="tok-number">0</span>) max_reg = i;
                }

                <span class="tok-kw">const</span> fp = (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.fpRegNum">fpRegNum</a>(reg_context), reg_context)).*;
                <span class="tok-kw">const</span> new_sp = fp + <span class="tok-number">2</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);<span class="tok-comment">

                // Verify the stack range we're about to read register values from
                </span><span class="tok-kw">if</span> (ma.load(<span class="tok-type">usize</span>, new_sp) == <span class="tok-null">null</span> <span class="tok-kw">or</span> ma.load(<span class="tok-type">usize</span>, fp - frame_offset + max_reg * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)) == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;

                <span class="tok-kw">const</span> ip_ptr = fp + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
                <span class="tok-kw">const</span> new_ip = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(ip_ptr)).*;
                <span class="tok-kw">const</span> new_fp = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(fp)).*;

                (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.fpRegNum">fpRegNum</a>(reg_context), reg_context)).* = new_fp;
                (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.spRegNum">spRegNum</a>(reg_context), reg_context)).* = new_sp;
                (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.ip_reg_num">ip_reg_num</a>, reg_context)).* = new_ip;

                <span class="tok-kw">for</span> (regs, <span class="tok-number">0</span>..) |reg, i| {
                    <span class="tok-kw">if</span> (reg == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;
                    <span class="tok-kw">const</span> addr = fp - frame_offset + i * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
                    <span class="tok-kw">const</span> reg_number = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.compactUnwindToDwarfRegNumber">compactUnwindToDwarfRegNumber</a>(reg);
                    (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, reg_number, reg_context)).* = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*;
                }

                <span class="tok-kw">break</span> :blk new_ip;
            },
            .STACK_IMMD,
            .STACK_IND,
            =&gt; blk: {
                <span class="tok-kw">const</span> sp = (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.spRegNum">spRegNum</a>(reg_context), reg_context)).*;
                <span class="tok-kw">const</span> stack_size = <span class="tok-kw">if</span> (encoding.mode.x86_64 == .STACK_IMMD)
                    <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, encoding.value.x86_64.frameless.stack.direct.stack_size) * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)
                <span class="tok-kw">else</span> stack_size: {<span class="tok-comment">
                    // In .STACK_IND, the stack size is inferred from the subq instruction at the beginning of the function.
                    </span><span class="tok-kw">const</span> sub_offset_addr =
                        base_address +
                        entry.function_offset +
                        encoding.value.x86_64.frameless.stack.indirect.sub_offset;
                    <span class="tok-kw">if</span> (ma.load(<span class="tok-type">usize</span>, sub_offset_addr) == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;<span class="tok-comment">

                    // `sub_offset_addr` points to the offset of the literal within the instruction
                    </span><span class="tok-kw">const</span> sub_operand = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <span class="tok-type">u32</span>, <span class="tok-builtin">@ptrFromInt</span>(sub_offset_addr)).*;
                    <span class="tok-kw">break</span> :stack_size sub_operand + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, encoding.value.x86_64.frameless.stack.indirect.stack_adjust);
                };<span class="tok-comment">

                // Decode the Lehmer-coded sequence of registers.
                // For a description of the encoding see lib/libc/include/any-macos.13-any/mach-o/compact_unwind_encoding.h

                // Decode the variable-based permutation number into its digits. Each digit represents
                // an index into the list of register numbers that weren't yet used in the sequence at
                // the time the digit was added.
                </span><span class="tok-kw">const</span> reg_count = encoding.value.x86_64.frameless.stack_reg_count;
                <span class="tok-kw">const</span> ip_ptr = <span class="tok-kw">if</span> (reg_count &gt; <span class="tok-number">0</span>) reg_blk: {
                    <span class="tok-kw">var</span> digits: [<span class="tok-number">6</span>]<span class="tok-type">u3</span> = <span class="tok-null">undefined</span>;
                    <span class="tok-kw">var</span> accumulator: <span class="tok-type">usize</span> = encoding.value.x86_64.frameless.stack_reg_permutation;
                    <span class="tok-kw">var</span> base: <span class="tok-type">usize</span> = <span class="tok-number">2</span>;
                    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..reg_count) |i| {
                        <span class="tok-kw">const</span> div = accumulator / base;
                        digits[digits.len - <span class="tok-number">1</span> - i] = <span class="tok-builtin">@intCast</span>(accumulator - base * div);
                        accumulator = div;
                        base += <span class="tok-number">1</span>;
                    }

                    <span class="tok-kw">const</span> reg_numbers = [_]<span class="tok-type">u3</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span> };
                    <span class="tok-kw">var</span> registers: [reg_numbers.len]<span class="tok-type">u3</span> = <span class="tok-null">undefined</span>;
                    <span class="tok-kw">var</span> used_indices = [_]<span class="tok-type">bool</span>{<span class="tok-null">false</span>} ** reg_numbers.len;
                    <span class="tok-kw">for</span> (digits[digits.len - reg_count ..], <span class="tok-number">0</span>..) |target_unused_index, i| {
                        <span class="tok-kw">var</span> unused_count: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;
                        <span class="tok-kw">const</span> unused_index = <span class="tok-kw">for</span> (used_indices, <span class="tok-number">0</span>..) |used, index| {
                            <span class="tok-kw">if</span> (!used) {
                                <span class="tok-kw">if</span> (target_unused_index == unused_count) <span class="tok-kw">break</span> index;
                                unused_count += <span class="tok-number">1</span>;
                            }
                        } <span class="tok-kw">else</span> <span class="tok-kw">unreachable</span>;

                        registers[i] = reg_numbers[unused_index];
                        used_indices[unused_index] = <span class="tok-null">true</span>;
                    }

                    <span class="tok-kw">var</span> reg_addr = sp + stack_size - <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, reg_count + <span class="tok-number">1</span>);
                    <span class="tok-kw">if</span> (ma.load(<span class="tok-type">usize</span>, reg_addr) == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;
                    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..reg_count) |i| {
                        <span class="tok-kw">const</span> reg_number = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.compactUnwindToDwarfRegNumber">compactUnwindToDwarfRegNumber</a>(registers[i]);
                        (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, reg_number, reg_context)).* = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(reg_addr)).*;
                        reg_addr += <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
                    }

                    <span class="tok-kw">break</span> :reg_blk reg_addr;
                } <span class="tok-kw">else</span> sp + stack_size - <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);

                <span class="tok-kw">const</span> new_ip = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(ip_ptr)).*;
                <span class="tok-kw">const</span> new_sp = ip_ptr + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
                <span class="tok-kw">if</span> (ma.load(<span class="tok-type">usize</span>, new_sp) == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;

                (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.spRegNum">spRegNum</a>(reg_context), reg_context)).* = new_sp;
                (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.ip_reg_num">ip_reg_num</a>, reg_context)).* = new_ip;

                <span class="tok-kw">break</span> :blk new_ip;
            },
            .DWARF =&gt; {
                <span class="tok-kw">return</span> <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.unwindFrameMachODwarf">unwindFrameMachODwarf</a>(allocator, base_address, context, ma, eh_frame <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingEhFrame, <span class="tok-builtin">@intCast</span>(encoding.value.x86_64.dwarf));
            },
        },
        .aarch64, .aarch64_be =&gt; <span class="tok-kw">switch</span> (encoding.mode.arm64) {
            .OLD =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedUnwindEncoding,
            .FRAMELESS =&gt; blk: {
                <span class="tok-kw">const</span> sp = (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.spRegNum">spRegNum</a>(reg_context), reg_context)).*;
                <span class="tok-kw">const</span> new_sp = sp + encoding.value.arm64.frameless.stack_size * <span class="tok-number">16</span>;
                <span class="tok-kw">const</span> new_ip = (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <span class="tok-number">30</span>, reg_context)).*;
                <span class="tok-kw">if</span> (ma.load(<span class="tok-type">usize</span>, new_sp) == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;
                (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.spRegNum">spRegNum</a>(reg_context), reg_context)).* = new_sp;
                <span class="tok-kw">break</span> :blk new_ip;
            },
            .DWARF =&gt; {
                <span class="tok-kw">return</span> <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.unwindFrameMachODwarf">unwindFrameMachODwarf</a>(allocator, base_address, context, ma, eh_frame <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingEhFrame, <span class="tok-builtin">@intCast</span>(encoding.value.arm64.dwarf));
            },
            .FRAME =&gt; blk: {
                <span class="tok-kw">const</span> fp = (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.fpRegNum">fpRegNum</a>(reg_context), reg_context)).*;
                <span class="tok-kw">const</span> new_sp = fp + <span class="tok-number">16</span>;
                <span class="tok-kw">const</span> ip_ptr = fp + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);

                <span class="tok-kw">const</span> num_restored_pairs: <span class="tok-type">usize</span> =
                    <span class="tok-builtin">@popCount</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u5</span>, <span class="tok-builtin">@bitCast</span>(encoding.value.arm64.frame.x_reg_pairs))) +
                    <span class="tok-builtin">@popCount</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-builtin">@bitCast</span>(encoding.value.arm64.frame.d_reg_pairs)));
                <span class="tok-kw">const</span> min_reg_addr = fp - num_restored_pairs * <span class="tok-number">2</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);

                <span class="tok-kw">if</span> (ma.load(<span class="tok-type">usize</span>, new_sp) == <span class="tok-null">null</span> <span class="tok-kw">or</span> ma.load(<span class="tok-type">usize</span>, min_reg_addr) == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;

                <span class="tok-kw">var</span> reg_addr = fp - <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(encoding.value.arm64.frame.x_reg_pairs)).@&quot;struct&quot;.fields, <span class="tok-number">0</span>..) |field, i| {
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(encoding.value.arm64.frame.x_reg_pairs, field.name) != <span class="tok-number">0</span>) {
                        (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <span class="tok-number">19</span> + i, reg_context)).* = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(reg_addr)).*;
                        reg_addr += <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
                        (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <span class="tok-number">20</span> + i, reg_context)).* = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(reg_addr)).*;
                        reg_addr += <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
                    }
                }

                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(encoding.value.arm64.frame.d_reg_pairs)).@&quot;struct&quot;.fields, <span class="tok-number">0</span>..) |field, i| {
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(encoding.value.arm64.frame.d_reg_pairs, field.name) != <span class="tok-number">0</span>) {<span class="tok-comment">
                        // Only the lower half of the 128-bit V registers are restored during unwinding
                        </span><span class="tok-builtin">@memcpy</span>(
                            <span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(context.thread_context, <span class="tok-number">64</span> + <span class="tok-number">8</span> + i, context.reg_context),
                            <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(<span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(reg_addr))),
                        );
                        reg_addr += <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
                        <span class="tok-builtin">@memcpy</span>(
                            <span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(context.thread_context, <span class="tok-number">64</span> + <span class="tok-number">9</span> + i, context.reg_context),
                            <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(<span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(reg_addr))),
                        );
                        reg_addr += <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
                    }
                }

                <span class="tok-kw">const</span> new_ip = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(ip_ptr)).*;
                <span class="tok-kw">const</span> new_fp = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(fp)).*;

                (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.fpRegNum">fpRegNum</a>(reg_context), reg_context)).* = new_fp;
                (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.ip_reg_num">ip_reg_num</a>, reg_context)).* = new_ip;

                <span class="tok-kw">break</span> :blk new_ip;
            },
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedArch,
    };

    context.pc = <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.stripInstructionPtrAuthCode">stripInstructionPtrAuthCode</a>(new_ip);
    <span class="tok-kw">if</span> (context.pc &gt; <span class="tok-number">0</span>) context.pc -= <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> new_ip;
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.SelfInfo.stripInstructionPtrAuthCode" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">stripInstructionPtrAuthCode</span><a href="#src.zig-std.debug.SelfInfo.stripInstructionPtrAuthCode">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">stripInstructionPtrAuthCode</span>(ptr: <span class="tok-type">usize</span>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Some platforms use pointer authentication - the upper bits of instruction pointers contain a signature.
This function clears these signature bits to make the pointer usable.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>ptr: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.SelfInfo.stripInstructionPtrAuthCode">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">stripInstructionPtrAuthCode</span>(ptr: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_arch">native_arch</a>.<a href="#">isAARCH64</a>()) {<span class="tok-comment">
        // `hint 0x07` maps to `xpaclri` (or `nop` if the hardware doesn't support it)
        // The save / restore is because `xpaclri` operates on x30 (LR)
        </span><span class="tok-kw">return</span> <span class="tok-kw">asm</span> (
            <span class="tok-str">\\mov x16, x30</span>
            <span class="tok-str">\\mov x30, x15</span>
            <span class="tok-str">\\hint 0x07</span>
            <span class="tok-str">\\mov x15, x30</span>
            <span class="tok-str">\\mov x30, x16</span>
            : [ret] <span class="tok-str">&quot;={x15}&quot;</span> (-&gt; <span class="tok-type">usize</span>),
            : [ptr] <span class="tok-str">&quot;{x15}&quot;</span> (ptr),
            : <span class="tok-str">&quot;x16&quot;</span>
        );
    }

    <span class="tok-kw">return</span> ptr;
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.SelfInfo.unwindFrameDwarf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unwindFrameDwarf</span><a href="#src.zig-std.debug.SelfInfo.unwindFrameDwarf">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwindFrameDwarf</span>( allocator: <a href="std.mem.Allocator.html">Allocator</a>, di: *<a href="std.debug.Dwarf.html">Dwarf</a>, base_address: <span class="tok-type">usize</span>, context: *<a href="std.debug.SelfInfo.UnwindContext.html">UnwindContext</a>, ma: *<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.MemoryAccessor.html">MemoryAccessor</a>, explicit_fde_offset: ?<span class="tok-type">usize</span>, ) !<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Unwind a stack frame using DWARF unwinding info, updating the register context.</p>
<p>If <code>.eh_frame_hdr</code> is available and complete, it will be used to binary search for the FDE.
Otherwise, a linear scan of <code>.eh_frame</code> and <code>.debug_frame</code> is done to find the FDE. The latter
may require lazily loading the data in those sections.</p>
<p><code>explicit_fde_offset</code> is for cases where the FDE offset is known, such as when __unwind_info
defers unwinding to DWARF. This is an offset into the <code>.eh_frame</code> section.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>di: *<a href="std.debug.Dwarf.html">Dwarf</a></code></pre></div><div><pre><code>base_address: <span class="tok-type">usize</span></code></pre></div><div><pre><code>context: *<a href="std.debug.SelfInfo.UnwindContext.html">UnwindContext</a></code></pre></div><div><pre><code>ma: *<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.MemoryAccessor.html">MemoryAccessor</a></code></pre></div><div><pre><code>explicit_fde_offset: ?<span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.SelfInfo.unwindFrameDwarf">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwindFrameDwarf</span>(
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    di: *<a href="std.debug.Dwarf.html">Dwarf</a>,
    base_address: <span class="tok-type">usize</span>,
    context: *<a href="std.debug.SelfInfo.UnwindContext.html">UnwindContext</a>,
    ma: *<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.MemoryAccessor.html">MemoryAccessor</a>,
    explicit_fde_offset: ?<span class="tok-type">usize</span>,
) !<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (!<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.supports_unwinding">supports_unwinding</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedCpuArchitecture;
    <span class="tok-kw">if</span> (context.pc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;<span class="tok-comment">

    // Find the FDE and CIE
    </span><span class="tok-kw">const</span> cie, <span class="tok-kw">const</span> fde = <span class="tok-kw">if</span> (explicit_fde_offset) |fde_offset| blk: {
        <span class="tok-kw">const</span> dwarf_section: Dwarf.Section.Id = .eh_frame;
        <span class="tok-kw">const</span> frame_section = di.section(dwarf_section) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingFDE;
        <span class="tok-kw">if</span> (fde_offset &gt;= frame_section.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingFDE;

        <span class="tok-kw">var</span> fbr: std.debug.FixedBufferReader = .{
            .buf = frame_section,
            .pos = fde_offset,
            .endian = di.endian,
        };

        <span class="tok-kw">const</span> fde_entry_header = <span class="tok-kw">try</span> Dwarf.EntryHeader.read(&amp;fbr, <span class="tok-null">null</span>, dwarf_section);
        <span class="tok-kw">if</span> (fde_entry_header.<span class="tok-type">type</span> != .fde) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingFDE;

        <span class="tok-kw">const</span> cie_offset = fde_entry_header.<span class="tok-type">type</span>.fde;
        <span class="tok-kw">try</span> fbr.seekTo(cie_offset);

        fbr.endian = native_endian;
        <span class="tok-kw">const</span> cie_entry_header = <span class="tok-kw">try</span> Dwarf.EntryHeader.read(&amp;fbr, <span class="tok-null">null</span>, dwarf_section);
        <span class="tok-kw">if</span> (cie_entry_header.<span class="tok-type">type</span> != .cie) <span class="tok-kw">return</span> Dwarf.bad();

        <span class="tok-kw">const</span> cie = <span class="tok-kw">try</span> Dwarf.CommonInformationEntry.parse(
            cie_entry_header.entry_bytes,
            <span class="tok-number">0</span>,
            <span class="tok-null">true</span>,
            cie_entry_header.format,
            dwarf_section,
            cie_entry_header.length_offset,
            <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),
            native_endian,
        );
        <span class="tok-kw">const</span> fde = <span class="tok-kw">try</span> Dwarf.FrameDescriptionEntry.parse(
            fde_entry_header.entry_bytes,
            <span class="tok-number">0</span>,
            <span class="tok-null">true</span>,
            cie,
            <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),
            native_endian,
        );

        <span class="tok-kw">break</span> :blk .{ cie, fde };
    } <span class="tok-kw">else</span> blk: {<span class="tok-comment">
        // `.eh_frame_hdr` may be incomplete. We'll try it first, but if the lookup fails, we fall
        // back to loading `.eh_frame`/`.debug_frame` and using those from that point on.

        </span><span class="tok-kw">if</span> (di.eh_frame_hdr) |header| hdr: {
            <span class="tok-kw">const</span> eh_frame_len = <span class="tok-kw">if</span> (di.section(.eh_frame)) |eh_frame| eh_frame.len <span class="tok-kw">else</span> <span class="tok-null">null</span>;

            <span class="tok-kw">var</span> cie: Dwarf.CommonInformationEntry = <span class="tok-null">undefined</span>;
            <span class="tok-kw">var</span> fde: Dwarf.FrameDescriptionEntry = <span class="tok-null">undefined</span>;

            header.findEntry(
                ma,
                eh_frame_len,
                <span class="tok-builtin">@intFromPtr</span>(di.section(.eh_frame_hdr).?.ptr),
                context.pc,
                &amp;cie,
                &amp;fde,
            ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; {<span class="tok-comment">
                    // `.eh_frame_hdr` appears to be incomplete, so go ahead and populate `cie_map`
                    // and `fde_list`, and fall back to the binary search logic below.
                    </span><span class="tok-kw">try</span> di.scanCieFdeInfo(allocator, base_address);<span class="tok-comment">

                    // Since `.eh_frame_hdr` is incomplete, we're very likely to get more lookup
                    // failures using it, and we've just built a complete, sorted list of FDEs
                    // anyway, so just stop using `.eh_frame_hdr` altogether.
                    </span>di.eh_frame_hdr = <span class="tok-null">null</span>;

                    <span class="tok-kw">break</span> :hdr;
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
            };

            <span class="tok-kw">break</span> :blk .{ cie, fde };
        }

        <span class="tok-kw">const</span> index = std.sort.binarySearch(Dwarf.FrameDescriptionEntry, di.fde_list.items, context.pc, <span class="tok-kw">struct</span> {
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">compareFn</span>(pc: <span class="tok-type">usize</span>, item: Dwarf.FrameDescriptionEntry) std.math.Order {
                <span class="tok-kw">if</span> (pc &lt; item.pc_begin) <span class="tok-kw">return</span> .lt;

                <span class="tok-kw">const</span> range_end = item.pc_begin + item.pc_range;
                <span class="tok-kw">if</span> (pc &lt; range_end) <span class="tok-kw">return</span> .eq;

                <span class="tok-kw">return</span> .gt;
            }
        }.compareFn);

        <span class="tok-kw">const</span> fde = <span class="tok-kw">if</span> (index) |i| di.fde_list.items[i] <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingFDE;
        <span class="tok-kw">const</span> cie = di.cie_map.get(fde.cie_length_offset) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingCIE;

        <span class="tok-kw">break</span> :blk .{ cie, fde };
    };

    <span class="tok-kw">var</span> expression_context: <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.expression.html">expression</a>.<a href="std.debug.Dwarf.expression.Context.html">Context</a> = .{
        .format = cie.format,
        .memory_accessor = ma,
        .compile_unit = di.findCompileUnit(fde.pc_begin) <span class="tok-kw">catch</span> <span class="tok-null">null</span>,
        .thread_context = context.thread_context,
        .reg_context = context.reg_context,
        .cfa = context.cfa,
    };

    context.vm.reset();
    context.reg_context.eh_frame = cie.version != <span class="tok-number">4</span>;
    context.reg_context.is_macho = di.is_macho;

    <span class="tok-kw">const</span> row = <span class="tok-kw">try</span> context.vm.runToNative(context.allocator, context.pc, cie, fde);
    context.cfa = <span class="tok-kw">switch</span> (row.cfa.rule) {
        .val_offset =&gt; |offset| blk: {
            <span class="tok-kw">const</span> register = row.cfa.register <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFARule;
            <span class="tok-kw">const</span> value = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">usize</span>, (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(context.thread_context, register, context.reg_context))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_endian">native_endian</a>);
            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.applyOffset">applyOffset</a>(value, offset);
        },
        .expression =&gt; |expr| blk: {
            context.stack_machine.reset();
            <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> context.stack_machine.run(
                expr,
                context.allocator,
                expression_context,
                context.cfa,
            );

            <span class="tok-kw">if</span> (value) |v| {
                <span class="tok-kw">if</span> (v != .generic) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpressionValue;
                <span class="tok-kw">break</span> :blk v.generic;
            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoExpressionValue;
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFARule,
    };

    <span class="tok-kw">if</span> (ma.load(<span class="tok-type">usize</span>, context.cfa.?) == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFA;
    expression_context.cfa = context.cfa;<span class="tok-comment">

    // Buffering the modifications is done because copying the thread context is not portable,
    // some implementations (ie. darwin) use internal pointers to the mcontext.
    </span><span class="tok-kw">var</span> arena = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.init">init</a>(context.allocator);
    <span class="tok-kw">defer</span> arena.deinit();
    <span class="tok-kw">const</span> update_allocator = arena.allocator();

    <span class="tok-kw">const</span> RegisterUpdate = <span class="tok-kw">struct</span> {<span class="tok-comment">
        // Backed by thread_context
        </span>dest: []<span class="tok-type">u8</span>,<span class="tok-comment">
        // Backed by arena
        </span>src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        prev: ?*<span class="tok-builtin">@This</span>(),
    };

    <span class="tok-kw">var</span> update_tail: ?*RegisterUpdate = <span class="tok-null">null</span>;
    <span class="tok-kw">var</span> has_return_address = <span class="tok-null">true</span>;
    <span class="tok-kw">for</span> (context.vm.rowColumns(row)) |column| {
        <span class="tok-kw">if</span> (column.register) |register| {
            <span class="tok-kw">if</span> (register == cie.return_address_register) {
                has_return_address = column.rule != .<span class="tok-null">undefined</span>;
            }

            <span class="tok-kw">const</span> dest = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(context.thread_context, register, context.reg_context);
            <span class="tok-kw">const</span> src = <span class="tok-kw">try</span> update_allocator.alloc(<span class="tok-type">u8</span>, dest.len);

            <span class="tok-kw">const</span> prev = update_tail;
            update_tail = <span class="tok-kw">try</span> update_allocator.create(RegisterUpdate);
            update_tail.?.* = .{
                .dest = dest,
                .src = src,
                .prev = prev,
            };

            <span class="tok-kw">try</span> column.resolveValue(
                context,
                expression_context,
                ma,
                src,
            );
        }
    }<span class="tok-comment">

    // On all implemented architectures, the CFA is defined as being the previous frame's SP
    </span>(<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.spRegNum">spRegNum</a>(context.reg_context), context.reg_context)).* = context.cfa.?;

    <span class="tok-kw">while</span> (update_tail) |tail| {
        <span class="tok-builtin">@memcpy</span>(tail.dest, tail.src);
        update_tail = tail.prev;
    }

    <span class="tok-kw">if</span> (has_return_address) {
        context.pc = <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.stripInstructionPtrAuthCode">stripInstructionPtrAuthCode</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">usize</span>, (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(
            context.thread_context,
            cie.return_address_register,
            context.reg_context,
        ))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_endian">native_endian</a>));
    } <span class="tok-kw">else</span> {
        context.pc = <span class="tok-number">0</span>;
    }

    (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.ip_reg_num">ip_reg_num</a>, context.reg_context)).* = context.pc;<span class="tok-comment">

    // The call instruction will have pushed the address of the instruction that follows the call as the return address.
    // This next instruction may be past the end of the function if the caller was `noreturn` (ie. the last instruction in
    // the function was the call). If we were to look up an FDE entry using the return address directly, it could end up
    // either not finding an FDE at all, or using the next FDE in the program, producing incorrect results. To prevent this,
    // we subtract one so that the next lookup is guaranteed to land inside the
    //
    // The exception to this rule is signal frames, where we return execution would be returned to the instruction
    // that triggered the handler.
    </span><span class="tok-kw">const</span> return_address = context.pc;
    <span class="tok-kw">if</span> (context.pc &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> !cie.isSignalFrame()) context.pc -= <span class="tok-number">1</span>;

    <span class="tok-kw">return</span> return_address;
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.SelfInfo.supportsUnwinding" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">supportsUnwinding</span><a href="#src.zig-std.debug.SelfInfo.supportsUnwinding">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supportsUnwinding</span>(target: <a href="std.html">std</a>.<a href="std.Target.html">Target</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Tells whether unwinding for this target is <em>implemented</em> here in the Zig
standard library.</p>
<p>See also <code><a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.supportsUnwinding">Dwarf.abi.supportsUnwinding</a></code> which tells whether Dwarf supports
unwinding on that target <em>in theory</em>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>target: <a href="std.html">std</a>.<a href="std.Target.html">Target</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.SelfInfo.supportsUnwinding">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supportsUnwinding</span>(target: <a href="std.html">std</a>.<a href="std.Target.html">Target</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (target.cpu.arch) {
        .x86 =&gt; <span class="tok-kw">switch</span> (target.os.tag) {
            .linux, .netbsd, .solaris, .illumos =&gt; <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
        },
        .x86_64 =&gt; <span class="tok-kw">switch</span> (target.os.tag) {
            .linux, .netbsd, .freebsd, .openbsd, .macos, .ios, .solaris, .illumos =&gt; <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
        },
        .arm, .armeb, .thumb, .thumbeb =&gt; <span class="tok-kw">switch</span> (target.os.tag) {
            .linux =&gt; <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
        },
        .aarch64, .aarch64_be =&gt; <span class="tok-kw">switch</span> (target.os.tag) {
            .linux, .netbsd, .freebsd, .macos, .ios =&gt; <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
        },<span class="tok-comment">
        // Unwinding is possible on other targets but this implementation does
        // not support them...yet!
        </span><span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
    };
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.debug.SelfInfo">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! Cross-platform abstraction for this binary's own debug information, with a</span>
<span class="tok-comment">//! goal of minimal code bloat and compilation speed penalty.</span>

<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> native_os = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>;
<span class="tok-kw">const</span> native_endian = <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_arch">native_arch</a>.<a href="#">endian</a>();
<span class="tok-kw">const</span> native_arch = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>;

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../std.zig&quot;</span>);
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> Allocator = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> windows = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>;
<span class="tok-kw">const</span> macho = <a href="std.html">std</a>.<a href="std.macho.html">macho</a>;
<span class="tok-kw">const</span> fs = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>;
<span class="tok-kw">const</span> coff = <a href="std.html">std</a>.<a href="std.coff.html">coff</a>;
<span class="tok-kw">const</span> pdb = <a href="std.html">std</a>.<a href="std.pdb.html">pdb</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> posix = <a href="std.html">std</a>.<a href="std.posix.html">posix</a>;
<span class="tok-kw">const</span> elf = <a href="std.html">std</a>.<a href="std.elf.html">elf</a>;
<span class="tok-kw">const</span> Dwarf = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Dwarf.html">Dwarf</a>;
<span class="tok-kw">const</span> Pdb = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Pdb.html">Pdb</a>;
<span class="tok-kw">const</span> File = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>;
<span class="tok-kw">const</span> math = <a href="std.html">std</a>.<a href="std.math.html">math</a>;
<span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;
<span class="tok-kw">const</span> StackIterator = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.StackIterator.html">StackIterator</a>;
<span class="tok-kw">const</span> regBytes = <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>;
<span class="tok-kw">const</span> regValueNative = <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>;

<span class="tok-kw">const</span> SelfInfo = <span class="tok-builtin">@This</span>();

<span class="tok-kw">const</span> root = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);

allocator: <a href="std.mem.Allocator.html">Allocator</a>,
address_map: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">usize</span>, *<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module">Module</a>),
modules: <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_os">native_os</a> == .windows) <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.debug.SelfInfo.WindowsModule.html">WindowsModule</a>) <span class="tok-kw">else</span> <span class="tok-type">void</span>,

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenError = <span class="tok-kw">error</span>{
    MissingDebugInfo,
    UnsupportedOperatingSystem,
} || <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(<a href="std.debug.SelfInfo.html">SelfInfo</a>.<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.init">init</a>)).@&quot;fn&quot;.return_type.?).error_union.error_set;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">open</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.OpenError">OpenError</a>!<a href="std.debug.SelfInfo.html">SelfInfo</a> {
    <span class="tok-kw">nosuspend</span> {
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.strip_debug_info">strip_debug_info</a>)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
        <span class="tok-kw">switch</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_os">native_os</a>) {
            .linux,
            .freebsd,
            .netbsd,
            .dragonfly,
            .openbsd,
            .macos,
            .solaris,
            .illumos,
            .windows,
            =&gt; <span class="tok-kw">return</span> <span class="tok-kw">try</span> <a href="std.debug.SelfInfo.html">SelfInfo</a>.<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.init">init</a>(allocator),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedOperatingSystem,
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.debug.SelfInfo.html">SelfInfo</a> {
    <span class="tok-kw">var</span> debug_info: <a href="std.debug.SelfInfo.html">SelfInfo</a> = .{
        .allocator = allocator,
        .address_map = <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">usize</span>, *<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module">Module</a>).init(allocator),
        .modules = <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_os">native_os</a> == .windows) .{} <span class="tok-kw">else</span> {},
    };

    <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_os">native_os</a> == .windows) {
        <span class="tok-kw">errdefer</span> debug_info.modules.deinit(allocator);

        <span class="tok-kw">const</span> handle = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.CreateToolhelp32Snapshot">CreateToolhelp32Snapshot</a>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TH32CS_SNAPMODULE">TH32CS_SNAPMODULE</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TH32CS_SNAPMODULE32">TH32CS_SNAPMODULE32</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">if</span> (handle == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.INVALID_HANDLE_VALUE">INVALID_HANDLE_VALUE</a>) {
            <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetLastError">GetLastError</a>()) {
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedError">unexpectedError</a>(err),
            }
        }
        <span class="tok-kw">defer</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CloseHandle">CloseHandle</a>(handle);

        <span class="tok-kw">var</span> module_entry: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.MODULEENTRY32.html">MODULEENTRY32</a> = <span class="tok-null">undefined</span>;
        module_entry.dwSize = <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.MODULEENTRY32.html">MODULEENTRY32</a>);
        <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.Module32First">Module32First</a>(handle, &amp;module_entry) == <span class="tok-number">0</span>) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
        }

        <span class="tok-kw">var</span> module_valid = <span class="tok-null">true</span>;
        <span class="tok-kw">while</span> (module_valid) {
            <span class="tok-kw">const</span> module_info = <span class="tok-kw">try</span> debug_info.modules.addOne(allocator);
            <span class="tok-kw">const</span> name = allocator.dupe(<span class="tok-type">u8</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;module_entry.szModule, <span class="tok-number">0</span>)) <span class="tok-kw">catch</span> &amp;.{};
            <span class="tok-kw">errdefer</span> allocator.free(name);

            module_info.* = .{
                .base_address = <span class="tok-builtin">@intFromPtr</span>(module_entry.modBaseAddr),
                .size = module_entry.modBaseSize,
                .name = name,
                .handle = module_entry.hModule,
            };

            module_valid = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.Module32Next">Module32Next</a>(handle, &amp;module_entry) == <span class="tok-number">1</span>;
        }
    }

    <span class="tok-kw">return</span> debug_info;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.debug.SelfInfo.html">SelfInfo</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> it = self.address_map.iterator();
    <span class="tok-kw">while</span> (it.next()) |entry| {
        <span class="tok-kw">const</span> mdi = entry.value_ptr.*;
        mdi.deinit(self.allocator);
        self.allocator.destroy(mdi);
    }
    self.address_map.deinit();
    <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_os">native_os</a> == .windows) {
        <span class="tok-kw">for</span> (self.modules.items) |module| {
            self.allocator.free(module.name);
            <span class="tok-kw">if</span> (module.mapped_file) |mapped_file| mapped_file.deinit();
        }
        self.modules.deinit(self.allocator);
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getModuleForAddress</span>(self: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, address: <span class="tok-type">usize</span>) !*<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module">Module</a> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a>.<a href="#">isDarwin</a>()) {
        <span class="tok-kw">return</span> self.lookupModuleDyld(address);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> self.lookupModuleWin32(address);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_os">native_os</a> == .haiku) {
        <span class="tok-kw">return</span> self.lookupModuleHaiku(address);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">cpu</a>.<a href="#">arch</a>.<a href="#">isWasm</a>()) {
        <span class="tok-kw">return</span> self.lookupModuleWasm(address);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> self.lookupModuleDl(address);
    }
}<span class="tok-comment">

// Returns the module name for a given address.
// This can be called when getModuleForAddress fails, so implementations should provide
// a path that doesn't rely on any side-effects of a prior successful module lookup.
</span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getModuleNameForAddress</span>(self: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, address: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a>.<a href="#">isDarwin</a>()) {
        <span class="tok-kw">return</span> self.lookupModuleNameDyld(address);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> self.lookupModuleNameWin32(address);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_os">native_os</a> == .haiku) {
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">cpu</a>.<a href="#">arch</a>.<a href="#">isWasm</a>()) {
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> self.lookupModuleNameDl(address);
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleDyld</span>(self: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, address: <span class="tok-type">usize</span>) !*<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module">Module</a> {
    <span class="tok-kw">const</span> image_count = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.darwin.html#std.c.darwin._dyld_image_count">_dyld_image_count</a>();

    <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; image_count) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> header = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.darwin.html#std.c.darwin._dyld_get_image_header">_dyld_get_image_header</a>(i) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
        <span class="tok-kw">const</span> base_address = <span class="tok-builtin">@intFromPtr</span>(header);
        <span class="tok-kw">if</span> (address &lt; base_address) <span class="tok-kw">continue</span>;
        <span class="tok-kw">const</span> vmaddr_slide = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.darwin.html#std.c.darwin._dyld_get_image_vmaddr_slide">_dyld_get_image_vmaddr_slide</a>(i);

        <span class="tok-kw">var</span> it = <a href="std.macho.html">macho</a>.<a href="std.macho.LoadCommandIterator.html">LoadCommandIterator</a>{
            .ncmds = header.ncmds,
            .buffer = <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@as</span>(
                [*]<span class="tok-type">u8</span>,
                <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-builtin">@intFromPtr</span>(header) + <span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.mach_header_64.html">mach_header_64</a>)),
            )[<span class="tok-number">0</span>..header.sizeofcmds]),
        };

        <span class="tok-kw">var</span> unwind_info: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;
        <span class="tok-kw">var</span> eh_frame: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;
        <span class="tok-kw">while</span> (it.next()) |cmd| <span class="tok-kw">switch</span> (cmd.cmd()) {
            .SEGMENT_64 =&gt; {
                <span class="tok-kw">const</span> segment_cmd = cmd.cast(<a href="std.macho.html">macho</a>.<a href="std.macho.segment_command_64.html">segment_command_64</a>).?;
                <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;__TEXT&quot;</span>, segment_cmd.segName())) <span class="tok-kw">continue</span>;

                <span class="tok-kw">const</span> seg_start = segment_cmd.vmaddr + vmaddr_slide;
                <span class="tok-kw">const</span> seg_end = seg_start + segment_cmd.vmsize;
                <span class="tok-kw">if</span> (address &gt;= seg_start <span class="tok-kw">and</span> address &lt; seg_end) {
                    <span class="tok-kw">if</span> (self.address_map.get(base_address)) |obj_di| {
                        <span class="tok-kw">return</span> obj_di;
                    }

                    <span class="tok-kw">for</span> (cmd.getSections()) |sect| {
                        <span class="tok-kw">const</span> sect_addr: <span class="tok-type">usize</span> = <span class="tok-builtin">@intCast</span>(sect.addr);
                        <span class="tok-kw">const</span> sect_size: <span class="tok-type">usize</span> = <span class="tok-builtin">@intCast</span>(sect.size);
                        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;__unwind_info&quot;</span>, sect.sectName())) {
                            unwind_info = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(sect_addr + vmaddr_slide))[<span class="tok-number">0</span>..sect_size];
                        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;__eh_frame&quot;</span>, sect.sectName())) {
                            eh_frame = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(sect_addr + vmaddr_slide))[<span class="tok-number">0</span>..sect_size];
                        }
                    }

                    <span class="tok-kw">const</span> obj_di = <span class="tok-kw">try</span> self.allocator.create(<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module">Module</a>);
                    <span class="tok-kw">errdefer</span> self.allocator.destroy(obj_di);

                    <span class="tok-kw">const</span> macho_path = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.darwin.html#std.c.darwin._dyld_get_image_name">_dyld_get_image_name</a>(i), <span class="tok-number">0</span>);
                    <span class="tok-kw">const</span> macho_file = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().openFile(macho_path, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                        <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
                    };
                    obj_di.* = <span class="tok-kw">try</span> <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.readMachODebugInfo">readMachODebugInfo</a>(self.allocator, macho_file);
                    obj_di.base_address = base_address;
                    obj_di.vmaddr_slide = vmaddr_slide;
                    obj_di.unwind_info = unwind_info;
                    obj_di.eh_frame = eh_frame;

                    <span class="tok-kw">try</span> self.address_map.putNoClobber(base_address, obj_di);

                    <span class="tok-kw">return</span> obj_di;
                }
            },
            <span class="tok-kw">else</span> =&gt; {},
        };
    }

    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
}

<span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleNameDyld</span>(self: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, address: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    _ = self;
    <span class="tok-kw">const</span> image_count = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.darwin.html#std.c.darwin._dyld_image_count">_dyld_image_count</a>();

    <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; image_count) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> header = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.darwin.html#std.c.darwin._dyld_get_image_header">_dyld_get_image_header</a>(i) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
        <span class="tok-kw">const</span> base_address = <span class="tok-builtin">@intFromPtr</span>(header);
        <span class="tok-kw">if</span> (address &lt; base_address) <span class="tok-kw">continue</span>;
        <span class="tok-kw">const</span> vmaddr_slide = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.darwin.html#std.c.darwin._dyld_get_image_vmaddr_slide">_dyld_get_image_vmaddr_slide</a>(i);

        <span class="tok-kw">var</span> it = <a href="std.macho.html">macho</a>.<a href="std.macho.LoadCommandIterator.html">LoadCommandIterator</a>{
            .ncmds = header.ncmds,
            .buffer = <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@as</span>(
                [*]<span class="tok-type">u8</span>,
                <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-builtin">@intFromPtr</span>(header) + <span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.mach_header_64.html">mach_header_64</a>)),
            )[<span class="tok-number">0</span>..header.sizeofcmds]),
        };

        <span class="tok-kw">while</span> (it.next()) |cmd| <span class="tok-kw">switch</span> (cmd.cmd()) {
            .SEGMENT_64 =&gt; {
                <span class="tok-kw">const</span> segment_cmd = cmd.cast(<a href="std.macho.html">macho</a>.<a href="std.macho.segment_command_64.html">segment_command_64</a>).?;
                <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;__TEXT&quot;</span>, segment_cmd.segName())) <span class="tok-kw">continue</span>;

                <span class="tok-kw">const</span> original_address = address - vmaddr_slide;
                <span class="tok-kw">const</span> seg_start = segment_cmd.vmaddr;
                <span class="tok-kw">const</span> seg_end = seg_start + segment_cmd.vmsize;
                <span class="tok-kw">if</span> (original_address &gt;= seg_start <span class="tok-kw">and</span> original_address &lt; seg_end) {
                    <span class="tok-kw">return</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.basename">basename</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.darwin.html#std.c.darwin._dyld_get_image_name">_dyld_get_image_name</a>(i), <span class="tok-number">0</span>));
                }
            },
            <span class="tok-kw">else</span> =&gt; {},
        };
    }

    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleWin32</span>(self: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, address: <span class="tok-type">usize</span>) !*<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module">Module</a> {
    <span class="tok-kw">for</span> (self.modules.items) |*module| {
        <span class="tok-kw">if</span> (address &gt;= module.base_address <span class="tok-kw">and</span> address &lt; module.base_address + module.size) {
            <span class="tok-kw">if</span> (self.address_map.get(module.base_address)) |obj_di| {
                <span class="tok-kw">return</span> obj_di;
            }

            <span class="tok-kw">const</span> obj_di = <span class="tok-kw">try</span> self.allocator.create(<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module">Module</a>);
            <span class="tok-kw">errdefer</span> self.allocator.destroy(obj_di);

            <span class="tok-kw">const</span> mapped_module = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(module.base_address))[<span class="tok-number">0</span>..module.size];
            <span class="tok-kw">var</span> coff_obj = <span class="tok-kw">try</span> <a href="std.coff.html">coff</a>.<a href="std.coff.Coff.html">Coff</a>.<a href="std.coff.Coff.html#std.coff.Coff.init">init</a>(mapped_module, <span class="tok-null">true</span>);<span class="tok-comment">

            // The string table is not mapped into memory by the loader, so if a section name is in the
            // string table then we have to map the full image file from disk. This can happen when
            // a binary is produced with -gdwarf, since the section names are longer than 8 bytes.
            </span><span class="tok-kw">if</span> (coff_obj.strtabRequired()) {
                <span class="tok-kw">var</span> name_buffer: [<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PATH_MAX_WIDE">PATH_MAX_WIDE</a> + <span class="tok-number">4</span>:<span class="tok-number">0</span>]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">
                // openFileAbsoluteW requires the prefix to be present
                </span><span class="tok-builtin">@memcpy</span>(name_buffer[<span class="tok-number">0</span>..<span class="tok-number">4</span>], &amp;[_]<span class="tok-type">u16</span>{ <span class="tok-str">'\\'</span>, <span class="tok-str">'?'</span>, <span class="tok-str">'?'</span>, <span class="tok-str">'\\'</span> });

                <span class="tok-kw">const</span> process_handle = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetCurrentProcess">GetCurrentProcess</a>();
                <span class="tok-kw">const</span> len = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.K32GetModuleFileNameExW">GetModuleFileNameExW</a>(
                    process_handle,
                    module.handle,
                    <span class="tok-builtin">@ptrCast</span>(&amp;name_buffer[<span class="tok-number">4</span>]),
                    <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PATH_MAX_WIDE">PATH_MAX_WIDE</a>,
                );

                <span class="tok-kw">if</span> (len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
                <span class="tok-kw">const</span> coff_file = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.openFileAbsoluteW">openFileAbsoluteW</a>(name_buffer[<span class="tok-number">0</span> .. len + <span class="tok-number">4</span> :<span class="tok-number">0</span>], .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
                };
                <span class="tok-kw">errdefer</span> coff_file.close();

                <span class="tok-kw">var</span> section_handle: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">const</span> create_section_rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtCreateSection">NtCreateSection</a>(
                    &amp;section_handle,
                    <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.STANDARD_RIGHTS_REQUIRED">STANDARD_RIGHTS_REQUIRED</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SECTION_QUERY">SECTION_QUERY</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SECTION_MAP_READ">SECTION_MAP_READ</a>,
                    <span class="tok-null">null</span>,
                    <span class="tok-null">null</span>,
                    <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PAGE_READONLY">PAGE_READONLY</a>,<span class="tok-comment">
                    // The documentation states that if no AllocationAttribute is specified, then SEC_COMMIT is the default.
                    // In practice, this isn't the case and specifying 0 will result in INVALID_PARAMETER_6.
                    </span><a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SEC_COMMIT">SEC_COMMIT</a>,
                    coff_file.handle,
                );
                <span class="tok-kw">if</span> (create_section_rc != .SUCCESS) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
                <span class="tok-kw">errdefer</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CloseHandle">CloseHandle</a>(section_handle);

                <span class="tok-kw">var</span> coff_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">var</span> base_ptr: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">const</span> map_section_rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtMapViewOfSection">NtMapViewOfSection</a>(
                    section_handle,
                    process_handle,
                    <span class="tok-builtin">@ptrCast</span>(&amp;base_ptr),
                    <span class="tok-null">null</span>,
                    <span class="tok-number">0</span>,
                    <span class="tok-null">null</span>,
                    &amp;coff_len,
                    .ViewUnmap,
                    <span class="tok-number">0</span>,
                    <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PAGE_READONLY">PAGE_READONLY</a>,
                );
                <span class="tok-kw">if</span> (map_section_rc != .SUCCESS) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
                <span class="tok-kw">errdefer</span> <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtUnmapViewOfSection">NtUnmapViewOfSection</a>(process_handle, <span class="tok-builtin">@ptrFromInt</span>(base_ptr)) == .SUCCESS);

                <span class="tok-kw">const</span> section_view = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(base_ptr))[<span class="tok-number">0</span>..coff_len];
                coff_obj = <span class="tok-kw">try</span> <a href="std.coff.html">coff</a>.<a href="std.coff.Coff.html">Coff</a>.<a href="std.coff.Coff.html#std.coff.Coff.init">init</a>(section_view, <span class="tok-null">false</span>);

                module.mapped_file = .{
                    .file = coff_file,
                    .section_handle = section_handle,
                    .section_view = section_view,
                };
            }
            <span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (module.mapped_file) |mapped_file| mapped_file.deinit();

            obj_di.* = <span class="tok-kw">try</span> <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.readCoffDebugInfo">readCoffDebugInfo</a>(self.allocator, &amp;coff_obj);
            obj_di.base_address = module.base_address;

            <span class="tok-kw">try</span> self.address_map.putNoClobber(module.base_address, obj_di);
            <span class="tok-kw">return</span> obj_di;
        }
    }

    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
}

<span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleNameWin32</span>(self: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, address: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">for</span> (self.modules.items) |module| {
        <span class="tok-kw">if</span> (address &gt;= module.base_address <span class="tok-kw">and</span> address &lt; module.base_address + module.size) {
            <span class="tok-kw">return</span> module.name;
        }
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleNameDl</span>(self: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, address: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    _ = self;

    <span class="tok-kw">var</span> ctx: <span class="tok-kw">struct</span> {<span class="tok-comment">
        // Input
        </span>address: <span class="tok-type">usize</span>,<span class="tok-comment">
        // Output
        </span>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;&quot;</span>,
    } = .{ .address = address };
    <span class="tok-kw">const</span> CtxTy = <span class="tok-builtin">@TypeOf</span>(ctx);

    <span class="tok-kw">if</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.dl_iterate_phdr">dl_iterate_phdr</a>(&amp;ctx, <span class="tok-kw">error</span>{Found}, <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">callback</span>(info: *<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.dl_phdr_info">dl_phdr_info</a>, size: <span class="tok-type">usize</span>, context: *CtxTy) !<span class="tok-type">void</span> {
            _ = size;
            <span class="tok-kw">if</span> (context.address &lt; info.addr) <span class="tok-kw">return</span>;
            <span class="tok-kw">const</span> phdrs = info.phdr[<span class="tok-number">0</span>..info.phnum];
            <span class="tok-kw">for</span> (phdrs) |*phdr| {
                <span class="tok-kw">if</span> (phdr.p_type != <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_LOAD">PT_LOAD</a>) <span class="tok-kw">continue</span>;

                <span class="tok-kw">const</span> seg_start = info.addr +% phdr.p_vaddr;
                <span class="tok-kw">const</span> seg_end = seg_start + phdr.p_memsz;
                <span class="tok-kw">if</span> (context.address &gt;= seg_start <span class="tok-kw">and</span> context.address &lt; seg_end) {
                    context.name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(info.name, <span class="tok-number">0</span>) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;
                    <span class="tok-kw">break</span>;
                }
            } <span class="tok-kw">else</span> <span class="tok-kw">return</span>;

            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Found;
        }
    }.callback)) {
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.Found =&gt; <span class="tok-kw">return</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.basename">basename</a>(ctx.name),
    }

    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleDl</span>(self: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, address: <span class="tok-type">usize</span>) !*<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module">Module</a> {
    <span class="tok-kw">var</span> ctx: <span class="tok-kw">struct</span> {<span class="tok-comment">
        // Input
        </span>address: <span class="tok-type">usize</span>,<span class="tok-comment">
        // Output
        </span>base_address: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,
        build_id: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
        gnu_eh_frame: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
    } = .{ .address = address };
    <span class="tok-kw">const</span> CtxTy = <span class="tok-builtin">@TypeOf</span>(ctx);

    <span class="tok-kw">if</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.dl_iterate_phdr">dl_iterate_phdr</a>(&amp;ctx, <span class="tok-kw">error</span>{Found}, <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">callback</span>(info: *<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.dl_phdr_info">dl_phdr_info</a>, size: <span class="tok-type">usize</span>, context: *CtxTy) !<span class="tok-type">void</span> {
            _ = size;<span class="tok-comment">
            // The base address is too high
            </span><span class="tok-kw">if</span> (context.address &lt; info.addr)
                <span class="tok-kw">return</span>;

            <span class="tok-kw">const</span> phdrs = info.phdr[<span class="tok-number">0</span>..info.phnum];
            <span class="tok-kw">for</span> (phdrs) |*phdr| {
                <span class="tok-kw">if</span> (phdr.p_type != <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_LOAD">PT_LOAD</a>) <span class="tok-kw">continue</span>;<span class="tok-comment">

                // Overflowing addition is used to handle the case of VSDOs having a p_vaddr = 0xffffffffff700000
                </span><span class="tok-kw">const</span> seg_start = info.addr +% phdr.p_vaddr;
                <span class="tok-kw">const</span> seg_end = seg_start + phdr.p_memsz;
                <span class="tok-kw">if</span> (context.address &gt;= seg_start <span class="tok-kw">and</span> context.address &lt; seg_end) {<span class="tok-comment">
                    // Android libc uses NULL instead of an empty string to mark the
                    // main program
                    </span>context.name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(info.name, <span class="tok-number">0</span>) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;
                    context.base_address = info.addr;
                    <span class="tok-kw">break</span>;
                }
            } <span class="tok-kw">else</span> <span class="tok-kw">return</span>;

            <span class="tok-kw">for</span> (info.phdr[<span class="tok-number">0</span>..info.phnum]) |phdr| {
                <span class="tok-kw">switch</span> (phdr.p_type) {
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_NOTE">PT_NOTE</a> =&gt; {<span class="tok-comment">
                        // Look for .note.gnu.build-id
                        </span><span class="tok-kw">const</span> note_bytes = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(info.addr + phdr.p_vaddr))[<span class="tok-number">0</span>..phdr.p_memsz];
                        <span class="tok-kw">const</span> name_size = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, note_bytes[<span class="tok-number">0</span>..<span class="tok-number">4</span>], <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_endian">native_endian</a>);
                        <span class="tok-kw">if</span> (name_size != <span class="tok-number">4</span>) <span class="tok-kw">continue</span>;
                        <span class="tok-kw">const</span> desc_size = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, note_bytes[<span class="tok-number">4</span>..<span class="tok-number">8</span>], <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_endian">native_endian</a>);
                        <span class="tok-kw">const</span> note_type = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, note_bytes[<span class="tok-number">8</span>..<span class="tok-number">12</span>], <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_endian">native_endian</a>);
                        <span class="tok-kw">if</span> (note_type != <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.NT_GNU_BUILD_ID">NT_GNU_BUILD_ID</a>) <span class="tok-kw">continue</span>;
                        <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;GNU\x00&quot;</span>, note_bytes[<span class="tok-number">12</span>..<span class="tok-number">16</span>])) <span class="tok-kw">continue</span>;
                        context.build_id = note_bytes[<span class="tok-number">16</span>..][<span class="tok-number">0</span>..desc_size];
                    },
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_GNU_EH_FRAME">PT_GNU_EH_FRAME</a> =&gt; {
                        context.gnu_eh_frame = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(info.addr + phdr.p_vaddr))[<span class="tok-number">0</span>..phdr.p_memsz];
                    },
                    <span class="tok-kw">else</span> =&gt; {},
                }
            }<span class="tok-comment">

            // Stop the iteration
            </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.Found;
        }
    }.callback)) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.Found =&gt; {},
    }

    <span class="tok-kw">if</span> (self.address_map.get(ctx.base_address)) |obj_di| {
        <span class="tok-kw">return</span> obj_di;
    }

    <span class="tok-kw">const</span> obj_di = <span class="tok-kw">try</span> self.allocator.create(<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module">Module</a>);
    <span class="tok-kw">errdefer</span> self.allocator.destroy(obj_di);

    <span class="tok-kw">var</span> sections: <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.SectionArray">SectionArray</a> = <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.null_section_array">null_section_array</a>;
    <span class="tok-kw">if</span> (ctx.gnu_eh_frame) |eh_frame_hdr| {<span class="tok-comment">
        // This is a special case - pointer offsets inside .eh_frame_hdr
        // are encoded relative to its base address, so we must use the
        // version that is already memory mapped, and not the one that
        // will be mapped separately from the ELF file.
        </span>sections[<span class="tok-builtin">@intFromEnum</span>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>.<a href="#">eh_frame_hdr</a>)] = .{
            .data = eh_frame_hdr,
            .owned = <span class="tok-null">false</span>,
        };
    }

    obj_di.* = <span class="tok-kw">try</span> <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.readElfDebugInfo">readElfDebugInfo</a>(self.allocator, <span class="tok-kw">if</span> (ctx.name.len &gt; <span class="tok-number">0</span>) ctx.name <span class="tok-kw">else</span> <span class="tok-null">null</span>, ctx.build_id, <span class="tok-null">null</span>, &amp;sections, <span class="tok-null">null</span>);
    obj_di.base_address = ctx.base_address;<span class="tok-comment">

    // Missing unwind info isn't treated as a failure, as the unwinder will fall back to FP-based unwinding
    </span>obj_di.dwarf.scanAllUnwindInfo(self.allocator, ctx.base_address) <span class="tok-kw">catch</span> {};

    <span class="tok-kw">try</span> self.address_map.putNoClobber(ctx.base_address, obj_di);

    <span class="tok-kw">return</span> obj_di;
}

<span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleHaiku</span>(self: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, address: <span class="tok-type">usize</span>) !*<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module">Module</a> {
    _ = self;
    _ = address;
    <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO implement lookup module for Haiku&quot;</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleWasm</span>(self: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, address: <span class="tok-type">usize</span>) !*<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module">Module</a> {
    _ = self;
    _ = address;
    <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO implement lookup module for Wasm&quot;</span>);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Module = <span class="tok-kw">switch</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_os">native_os</a>) {
    .macos, .ios, .watchos, .tvos, .visionos =&gt; <span class="tok-kw">struct</span> {
        base_address: <span class="tok-type">usize</span>,
        vmaddr_slide: <span class="tok-type">usize</span>,
        mapped_memory: []<span class="tok-kw">align</span>(<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        symbols: []<span class="tok-kw">const</span> <a href="std.debug.SelfInfo.MachoSymbol.html">MachoSymbol</a>,
        strings: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        ofiles: <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module.OFileTable">OFileTable</a>,<span class="tok-comment">

        // Backed by the in-memory sections mapped by the loader
        </span>unwind_info: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
        eh_frame: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,

        <span class="tok-kw">const</span> OFileTable = <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.StringHashMap">StringHashMap</a>(<a href="std.debug.SelfInfo.Module.OFileInfo.html">OFileInfo</a>);
        <span class="tok-kw">const</span> OFileInfo = <span class="tok-kw">struct</span> {
            di: <a href="std.debug.Dwarf.html">Dwarf</a>,
            addr_table: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.StringHashMap">StringHashMap</a>(<span class="tok-type">u64</span>),
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">var</span> it = self.ofiles.iterator();
            <span class="tok-kw">while</span> (it.next()) |entry| {
                <span class="tok-kw">const</span> ofile = entry.value_ptr;
                ofile.di.deinit(allocator);
                ofile.addr_table.deinit();
            }
            self.ofiles.deinit();
            allocator.free(self.symbols);
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.munmap">munmap</a>(self.mapped_memory);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">loadOFile</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, o_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !*<a href="std.debug.SelfInfo.Module.OFileInfo.html">OFileInfo</a> {
            <span class="tok-kw">const</span> o_file = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().openFile(o_file_path, .{});
            <span class="tok-kw">const</span> mapped_mem = <span class="tok-kw">try</span> <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.mapWholeFile">mapWholeFile</a>(o_file);

            <span class="tok-kw">const</span> hdr: *<span class="tok-kw">const</span> <a href="std.macho.html">macho</a>.<a href="std.macho.mach_header_64.html">mach_header_64</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(mapped_mem.ptr));
            <span class="tok-kw">if</span> (hdr.magic != <a href="std.html">std</a>.<a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_MAGIC_64">MH_MAGIC_64</a>)
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;

            <span class="tok-kw">var</span> segcmd: ?<a href="std.macho.html">macho</a>.<a href="std.macho.LoadCommandIterator.html">LoadCommandIterator</a>.<a href="std.macho.LoadCommandIterator.LoadCommand.html">LoadCommand</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">var</span> symtabcmd: ?<a href="std.macho.html">macho</a>.<a href="std.macho.symtab_command.html">symtab_command</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">var</span> it = <a href="std.macho.html">macho</a>.<a href="std.macho.LoadCommandIterator.html">LoadCommandIterator</a>{
                .ncmds = hdr.ncmds,
                .buffer = mapped_mem[<span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.mach_header_64.html">mach_header_64</a>)..][<span class="tok-number">0</span>..hdr.sizeofcmds],
            };
            <span class="tok-kw">while</span> (it.next()) |cmd| <span class="tok-kw">switch</span> (cmd.cmd()) {
                .SEGMENT_64 =&gt; segcmd = cmd,
                .SYMTAB =&gt; symtabcmd = cmd.cast(<a href="std.macho.html">macho</a>.<a href="std.macho.symtab_command.html">symtab_command</a>).?,
                <span class="tok-kw">else</span> =&gt; {},
            };

            <span class="tok-kw">if</span> (segcmd == <span class="tok-null">null</span> <span class="tok-kw">or</span> symtabcmd == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;<span class="tok-comment">

            // Parse symbols
            </span><span class="tok-kw">const</span> strtab = <span class="tok-builtin">@as</span>(
                [*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
                <span class="tok-builtin">@ptrCast</span>(&amp;mapped_mem[symtabcmd.?.stroff]),
            )[<span class="tok-number">0</span> .. symtabcmd.?.strsize - <span class="tok-number">1</span> :<span class="tok-number">0</span>];
            <span class="tok-kw">const</span> symtab = <span class="tok-builtin">@as</span>(
                [*]<span class="tok-kw">const</span> <a href="std.macho.html">macho</a>.<a href="std.macho.nlist_64.html">nlist_64</a>,
                <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mapped_mem[symtabcmd.?.symoff])),
            )[<span class="tok-number">0</span>..symtabcmd.?.nsyms];<span class="tok-comment">

            // TODO handle tentative (common) symbols
            </span><span class="tok-kw">var</span> addr_table = <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.StringHashMap">StringHashMap</a>(<span class="tok-type">u64</span>).init(allocator);
            <span class="tok-kw">try</span> addr_table.ensureTotalCapacity(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(symtab.len)));
            <span class="tok-kw">for</span> (symtab) |sym| {
                <span class="tok-kw">if</span> (sym.n_strx == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;
                <span class="tok-kw">if</span> (sym.undf() <span class="tok-kw">or</span> sym.tentative() <span class="tok-kw">or</span> sym.abs()) <span class="tok-kw">continue</span>;
                <span class="tok-kw">const</span> sym_name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(strtab[sym.n_strx..], <span class="tok-number">0</span>);<span class="tok-comment">
                // TODO is it possible to have a symbol collision?
                </span>addr_table.putAssumeCapacityNoClobber(sym_name, sym.n_value);
            }

            <span class="tok-kw">var</span> sections: <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.SectionArray">SectionArray</a> = <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.null_section_array">null_section_array</a>;
            <span class="tok-kw">if</span> (self.eh_frame) |eh_frame| sections[<span class="tok-builtin">@intFromEnum</span>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>.<a href="#">eh_frame</a>)] = .{
                .data = eh_frame,
                .owned = <span class="tok-null">false</span>,
            };

            <span class="tok-kw">for</span> (segcmd.?.getSections()) |sect| {
                <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;__DWARF&quot;</span>, sect.segName())) <span class="tok-kw">continue</span>;

                <span class="tok-kw">var</span> section_index: ?<span class="tok-type">usize</span> = <span class="tok-null">null</span>;
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>).@&quot;enum&quot;.fields, <span class="tok-number">0</span>..) |section, i| {
                    <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;__&quot;</span> ++ section.name, sect.sectName())) section_index = i;
                }
                <span class="tok-kw">if</span> (section_index == <span class="tok-null">null</span>) <span class="tok-kw">continue</span>;

                <span class="tok-kw">const</span> section_bytes = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.chopSlice">chopSlice</a>(mapped_mem, sect.offset, sect.size);
                sections[section_index.?] = .{
                    .data = section_bytes,
                    .virtual_address = <span class="tok-builtin">@intCast</span>(sect.addr),
                    .owned = <span class="tok-null">false</span>,
                };
            }

            <span class="tok-kw">const</span> missing_debug_info =
                sections[<span class="tok-builtin">@intFromEnum</span>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>.<a href="#">debug_info</a>)] == <span class="tok-null">null</span> <span class="tok-kw">or</span>
                sections[<span class="tok-builtin">@intFromEnum</span>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>.<a href="#">debug_abbrev</a>)] == <span class="tok-null">null</span> <span class="tok-kw">or</span>
                sections[<span class="tok-builtin">@intFromEnum</span>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>.<a href="#">debug_str</a>)] == <span class="tok-null">null</span> <span class="tok-kw">or</span>
                sections[<span class="tok-builtin">@intFromEnum</span>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>.<a href="#">debug_line</a>)] == <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (missing_debug_info) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;

            <span class="tok-kw">var</span> di: <a href="std.debug.Dwarf.html">Dwarf</a> = .{
                .endian = .little,
                .sections = sections,
                .is_macho = <span class="tok-null">true</span>,
            };

            <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.open">open</a>(&amp;di, allocator);
            <span class="tok-kw">const</span> info = <a href="std.debug.SelfInfo.Module.OFileInfo.html">OFileInfo</a>{
                .di = di,
                .addr_table = addr_table,
            };<span class="tok-comment">

            // Add the debug info to the cache
            </span><span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.ofiles.getOrPut(o_file_path);
            <a href="std.debug.html#std.debug.assert">assert</a>(!result.found_existing);
            result.value_ptr.* = info;

            <span class="tok-kw">return</span> result.value_ptr;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Symbol.html">Symbol</a> {
            <span class="tok-kw">nosuspend</span> {
                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOFileInfoForAddress(allocator, address);
                <span class="tok-kw">if</span> (result.symbol == <span class="tok-null">null</span>) <span class="tok-kw">return</span> .{};<span class="tok-comment">

                // Take the symbol name from the N_FUN STAB entry, we're going to
                // use it if we fail to find the DWARF infos
                </span><span class="tok-kw">const</span> stab_symbol = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(self.strings[result.symbol.?.strx..], <span class="tok-number">0</span>);
                <span class="tok-kw">if</span> (result.o_file_info == <span class="tok-null">null</span>) <span class="tok-kw">return</span> .{ .name = stab_symbol };<span class="tok-comment">

                // Translate again the address, this time into an address inside the
                // .o file
                </span><span class="tok-kw">const</span> relocated_address_o = result.o_file_info.?.addr_table.get(stab_symbol) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> .{
                    .name = <span class="tok-str">&quot;???&quot;</span>,
                };

                <span class="tok-kw">const</span> addr_off = result.relocated_address - result.symbol.?.addr;
                <span class="tok-kw">const</span> o_file_di = &amp;result.o_file_info.?.di;
                <span class="tok-kw">if</span> (o_file_di.findCompileUnit(relocated_address_o)) |compile_unit| {
                    <span class="tok-kw">return</span> .{
                        .name = o_file_di.getSymbolName(relocated_address_o) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>,
                        .compile_unit_name = compile_unit.die.getAttrString(
                            o_file_di,
                            <a href="std.html">std</a>.<a href="std.dwarf.html">dwarf</a>.<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.name">name</a>,
                            o_file_di.section(.debug_str),
                            compile_unit.*,
                        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                            <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-str">&quot;???&quot;</span>,
                        },
                        .source_location = o_file_di.getLineNumberInfo(
                            allocator,
                            compile_unit,
                            relocated_address_o + addr_off,
                        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                            <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-null">null</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
                        },
                    };
                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; {
                        <span class="tok-kw">return</span> .{ .name = stab_symbol };
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
                }
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOFileInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !<span class="tok-kw">struct</span> {
            relocated_address: <span class="tok-type">usize</span>,
            symbol: ?*<span class="tok-kw">const</span> <a href="std.debug.SelfInfo.MachoSymbol.html">MachoSymbol</a> = <span class="tok-null">null</span>,
            o_file_info: ?*<a href="std.debug.SelfInfo.Module.OFileInfo.html">OFileInfo</a> = <span class="tok-null">null</span>,
        } {
            <span class="tok-kw">nosuspend</span> {<span class="tok-comment">
                // Translate the VA into an address into this object
                </span><span class="tok-kw">const</span> relocated_address = address - self.vmaddr_slide;<span class="tok-comment">

                // Find the .o file where this symbol is defined
                </span><span class="tok-kw">const</span> symbol = <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.machoSearchSymbols">machoSearchSymbols</a>(self.symbols, relocated_address) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> .{
                    .relocated_address = relocated_address,
                };<span class="tok-comment">

                // Check if its debug infos are already in the cache
                </span><span class="tok-kw">const</span> o_file_path = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(self.strings[symbol.ofile..], <span class="tok-number">0</span>);
                <span class="tok-kw">const</span> o_file_info = self.ofiles.getPtr(o_file_path) <span class="tok-kw">orelse</span>
                    (self.loadOFile(allocator, o_file_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                        <span class="tok-kw">error</span>.FileNotFound,
                        <span class="tok-kw">error</span>.MissingDebugInfo,
                        <span class="tok-kw">error</span>.InvalidDebugInfo,
                        =&gt; <span class="tok-kw">return</span> .{
                            .relocated_address = relocated_address,
                            .symbol = symbol,
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
                    });

                <span class="tok-kw">return</span> .{
                    .relocated_address = relocated_address,
                    .symbol = symbol,
                    .o_file_info = o_file_info,
                };
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !?*<a href="std.debug.Dwarf.html">Dwarf</a> {
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> ((<span class="tok-kw">try</span> self.getOFileInfoForAddress(allocator, address)).o_file_info) |o_file_info| &amp;o_file_info.di <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        }
    },
    .uefi, .windows =&gt; <span class="tok-kw">struct</span> {
        base_address: <span class="tok-type">usize</span>,
        pdb: ?<a href="std.debug.Pdb.html">Pdb</a> = <span class="tok-null">null</span>,
        dwarf: ?<a href="std.debug.Dwarf.html">Dwarf</a> = <span class="tok-null">null</span>,
        coff_image_base: <span class="tok-type">u64</span>,

        <span class="tok-comment">/// Only used if pdb is non-null</span>
        coff_section_headers: []<a href="std.coff.html">coff</a>.<a href="std.coff.SectionHeader.html">SectionHeader</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (self.dwarf) |*dwarf| {
                dwarf.deinit(allocator);
            }

            <span class="tok-kw">if</span> (self.pdb) |*p| {
                p.deinit();
                allocator.free(self.coff_section_headers);
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolFromPdb</span>(self: *<span class="tok-builtin">@This</span>(), relocated_address: <span class="tok-type">usize</span>) !?<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Symbol.html">Symbol</a> {
            <span class="tok-kw">var</span> coff_section: *<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <a href="std.coff.html">coff</a>.<a href="std.coff.SectionHeader.html">SectionHeader</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> mod_index = <span class="tok-kw">for</span> (self.pdb.?.sect_contribs) |sect_contrib| {
                <span class="tok-kw">if</span> (sect_contrib.section &gt; self.coff_section_headers.len) <span class="tok-kw">continue</span>;<span class="tok-comment">
                // Remember that SectionContribEntry.Section is 1-based.
                </span>coff_section = &amp;self.coff_section_headers[sect_contrib.section - <span class="tok-number">1</span>];

                <span class="tok-kw">const</span> vaddr_start = coff_section.virtual_address + sect_contrib.offset;
                <span class="tok-kw">const</span> vaddr_end = vaddr_start + sect_contrib.size;
                <span class="tok-kw">if</span> (relocated_address &gt;= vaddr_start <span class="tok-kw">and</span> relocated_address &lt; vaddr_end) {
                    <span class="tok-kw">break</span> sect_contrib.module_index;
                }
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // we have no information to add to the address
                </span><span class="tok-kw">return</span> <span class="tok-null">null</span>;
            };

            <span class="tok-kw">const</span> module = (<span class="tok-kw">try</span> self.pdb.?.getModule(mod_index)) <span class="tok-kw">orelse</span>
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;
            <span class="tok-kw">const</span> obj_basename = <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.basename">basename</a>(module.obj_file_name);

            <span class="tok-kw">const</span> symbol_name = self.pdb.?.getSymbolName(
                module,
                relocated_address - coff_section.virtual_address,
            ) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>;
            <span class="tok-kw">const</span> opt_line_info = <span class="tok-kw">try</span> self.pdb.?.getLineNumberInfo(
                module,
                relocated_address - coff_section.virtual_address,
            );

            <span class="tok-kw">return</span> .{
                .name = symbol_name,
                .compile_unit_name = obj_basename,
                .source_location = opt_line_info,
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Symbol.html">Symbol</a> {<span class="tok-comment">
            // Translate the VA into an address into this object
            </span><span class="tok-kw">const</span> relocated_address = address - self.base_address;

            <span class="tok-kw">if</span> (self.pdb != <span class="tok-null">null</span>) {
                <span class="tok-kw">if</span> (<span class="tok-kw">try</span> self.getSymbolFromPdb(relocated_address)) |symbol| <span class="tok-kw">return</span> symbol;
            }

            <span class="tok-kw">if</span> (self.dwarf) |*dwarf| {
                <span class="tok-kw">const</span> dwarf_address = relocated_address + self.coff_image_base;
                <span class="tok-kw">return</span> dwarf.getSymbol(allocator, dwarf_address);
            }

            <span class="tok-kw">return</span> .{};
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !?*<a href="std.debug.Dwarf.html">Dwarf</a> {
            _ = allocator;
            _ = address;

            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self.debug_data) {
                .dwarf =&gt; |*dwarf| dwarf,
                <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
            };
        }
    },
    .linux, .netbsd, .freebsd, .dragonfly, .openbsd, .haiku, .solaris, .illumos =&gt; <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.ElfModule.html">ElfModule</a>,
    .wasi, .emscripten =&gt; <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            _ = self;
            _ = allocator;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Symbol.html">Symbol</a> {
            _ = self;
            _ = allocator;
            _ = address;
            <span class="tok-kw">return</span> .{};
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !?*<a href="std.debug.Dwarf.html">Dwarf</a> {
            _ = self;
            _ = allocator;
            _ = address;
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }
    },
    <span class="tok-kw">else</span> =&gt; <a href="std.debug.Dwarf.html">Dwarf</a>,
};

<span class="tok-comment">/// How is this different than `Module` when the host is Windows?</span>
<span class="tok-comment">/// Why are both stored in the `SelfInfo` struct?</span>
<span class="tok-comment">/// Boy, it sure would be nice if someone added documentation comments for this</span>
<span class="tok-comment">/// struct explaining it.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> WindowsModule = <span class="tok-kw">struct</span> {
    base_address: <span class="tok-type">usize</span>,
    size: <span class="tok-type">u32</span>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    handle: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HMODULE">HMODULE</a>,<span class="tok-comment">

    // Set when the image file needed to be mapped from disk
    </span>mapped_file: ?<span class="tok-kw">struct</span> {
        file: <a href="std.fs.File.html">File</a>,
        section_handle: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a>,
        section_view: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> process_handle = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetCurrentProcess">GetCurrentProcess</a>();
            <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtUnmapViewOfSection">NtUnmapViewOfSection</a>(process_handle, <span class="tok-builtin">@constCast</span>(<span class="tok-builtin">@ptrCast</span>(self.section_view.ptr))) == .SUCCESS);
            <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CloseHandle">CloseHandle</a>(self.section_handle);
            self.file.close();
        }
    } = <span class="tok-null">null</span>,
};

<span class="tok-comment">/// This takes ownership of macho_file: users of this function should not close</span>
<span class="tok-comment">/// it themselves, even on error.</span>
<span class="tok-comment">/// TODO it's weird to take ownership even on error, rework this code.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">readMachODebugInfo</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, macho_file: <a href="std.fs.File.html">File</a>) !<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module">Module</a> {
    <span class="tok-kw">const</span> mapped_mem = <span class="tok-kw">try</span> <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.mapWholeFile">mapWholeFile</a>(macho_file);

    <span class="tok-kw">const</span> hdr: *<span class="tok-kw">const</span> <a href="std.macho.html">macho</a>.<a href="std.macho.mach_header_64.html">mach_header_64</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(mapped_mem.ptr));
    <span class="tok-kw">if</span> (hdr.magic != <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_MAGIC_64">MH_MAGIC_64</a>)
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;

    <span class="tok-kw">var</span> it = <a href="std.macho.html">macho</a>.<a href="std.macho.LoadCommandIterator.html">LoadCommandIterator</a>{
        .ncmds = hdr.ncmds,
        .buffer = mapped_mem[<span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.mach_header_64.html">mach_header_64</a>)..][<span class="tok-number">0</span>..hdr.sizeofcmds],
    };
    <span class="tok-kw">const</span> symtab = <span class="tok-kw">while</span> (it.next()) |cmd| <span class="tok-kw">switch</span> (cmd.cmd()) {
        .SYMTAB =&gt; <span class="tok-kw">break</span> cmd.cast(<a href="std.macho.html">macho</a>.<a href="std.macho.symtab_command.html">symtab_command</a>).?,
        <span class="tok-kw">else</span> =&gt; {},
    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;

    <span class="tok-kw">const</span> syms = <span class="tok-builtin">@as</span>(
        [*]<span class="tok-kw">const</span> <a href="std.macho.html">macho</a>.<a href="std.macho.nlist_64.html">nlist_64</a>,
        <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mapped_mem[symtab.symoff])),
    )[<span class="tok-number">0</span>..symtab.nsyms];
    <span class="tok-kw">const</span> strings = mapped_mem[symtab.stroff..][<span class="tok-number">0</span> .. symtab.strsize - <span class="tok-number">1</span> :<span class="tok-number">0</span>];

    <span class="tok-kw">const</span> symbols_buf = <span class="tok-kw">try</span> allocator.alloc(<a href="std.debug.SelfInfo.MachoSymbol.html">MachoSymbol</a>, syms.len);

    <span class="tok-kw">var</span> ofile: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> last_sym: <a href="std.debug.SelfInfo.MachoSymbol.html">MachoSymbol</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> symbol_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> state: <span class="tok-kw">enum</span> {
        <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.init">init</a>,
        oso_open,
        oso_close,
        bnsym,
        fun_strx,
        fun_size,
        ensym,
    } = .init;

    <span class="tok-kw">for</span> (syms) |*sym| {
        <span class="tok-kw">if</span> (!sym.stab()) <span class="tok-kw">continue</span>;<span class="tok-comment">

        // TODO handle globals N_GSYM, and statics N_STSYM
        </span><span class="tok-kw">switch</span> (sym.n_type) {
            <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.N_OSO">N_OSO</a> =&gt; {
                <span class="tok-kw">switch</span> (state) {
                    .init, .oso_close =&gt; {
                        state = .oso_open;
                        ofile = sym.n_strx;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,
                }
            },
            <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.N_BNSYM">N_BNSYM</a> =&gt; {
                <span class="tok-kw">switch</span> (state) {
                    .oso_open, .ensym =&gt; {
                        state = .bnsym;
                        last_sym = .{
                            .strx = <span class="tok-number">0</span>,
                            .addr = sym.n_value,
                            .size = <span class="tok-number">0</span>,
                            .ofile = ofile,
                        };
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,
                }
            },
            <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.N_FUN">N_FUN</a> =&gt; {
                <span class="tok-kw">switch</span> (state) {
                    .bnsym =&gt; {
                        state = .fun_strx;
                        last_sym.strx = sym.n_strx;
                    },
                    .fun_strx =&gt; {
                        state = .fun_size;
                        last_sym.size = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(sym.n_value));
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,
                }
            },
            <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.N_ENSYM">N_ENSYM</a> =&gt; {
                <span class="tok-kw">switch</span> (state) {
                    .fun_size =&gt; {
                        state = .ensym;
                        symbols_buf[symbol_index] = last_sym;
                        symbol_index += <span class="tok-number">1</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,
                }
            },
            <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.N_SO">N_SO</a> =&gt; {
                <span class="tok-kw">switch</span> (state) {
                    .init, .oso_close =&gt; {},
                    .oso_open, .ensym =&gt; {
                        state = .oso_close;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,
                }
            },
            <span class="tok-kw">else</span> =&gt; {},
        }
    }

    <span class="tok-kw">switch</span> (state) {
        .init =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,
        .oso_close =&gt; {},
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,
    }

    <span class="tok-kw">const</span> symbols = <span class="tok-kw">try</span> allocator.realloc(symbols_buf, symbol_index);<span class="tok-comment">

    // Even though lld emits symbols in ascending order, this debug code
    // should work for programs linked in any valid way.
    // This sort is so that we can binary search later.
    </span><a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sort">sort</a>(<a href="std.debug.SelfInfo.MachoSymbol.html">MachoSymbol</a>, symbols, {}, <a href="std.debug.SelfInfo.MachoSymbol.html">MachoSymbol</a>.<a href="std.debug.SelfInfo.MachoSymbol.html#std.debug.SelfInfo.MachoSymbol.addressLessThan">addressLessThan</a>);

    <span class="tok-kw">return</span> .{
        .base_address = <span class="tok-null">undefined</span>,
        .vmaddr_slide = <span class="tok-null">undefined</span>,
        .mapped_memory = mapped_mem,
        .ofiles = <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module">Module</a>.<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module.OFileTable">OFileTable</a>.<a href="#">init</a>(allocator),
        .symbols = symbols,
        .strings = strings,
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">readCoffDebugInfo</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, coff_obj: *<a href="std.coff.html">coff</a>.<a href="std.coff.Coff.html">Coff</a>) !<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module">Module</a> {
    <span class="tok-kw">nosuspend</span> {
        <span class="tok-kw">var</span> di: <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.Module">Module</a> = .{
            .base_address = <span class="tok-null">undefined</span>,
            .coff_image_base = coff_obj.getImageBase(),
            .coff_section_headers = <span class="tok-null">undefined</span>,
        };

        <span class="tok-kw">if</span> (coff_obj.getSectionByName(<span class="tok-str">&quot;.debug_info&quot;</span>)) |_| {<span class="tok-comment">
            // This coff file has embedded DWARF debug info
            </span><span class="tok-kw">var</span> sections: <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.SectionArray">SectionArray</a> = <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.null_section_array">null_section_array</a>;
            <span class="tok-kw">errdefer</span> <span class="tok-kw">for</span> (sections) |section| <span class="tok-kw">if</span> (section) |s| <span class="tok-kw">if</span> (s.owned) allocator.free(s.data);

            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>).@&quot;enum&quot;.fields, <span class="tok-number">0</span>..) |section, i| {
                sections[i] = <span class="tok-kw">if</span> (coff_obj.getSectionByName(<span class="tok-str">&quot;.&quot;</span> ++ section.name)) |section_header| blk: {
                    <span class="tok-kw">break</span> :blk .{
                        .data = <span class="tok-kw">try</span> coff_obj.getSectionDataAlloc(section_header, allocator),
                        .virtual_address = section_header.virtual_address,
                        .owned = <span class="tok-null">true</span>,
                    };
                } <span class="tok-kw">else</span> <span class="tok-null">null</span>;
            }

            <span class="tok-kw">var</span> dwarf: <a href="std.debug.Dwarf.html">Dwarf</a> = .{
                .endian = <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_endian">native_endian</a>,
                .sections = sections,
                .is_macho = <span class="tok-null">false</span>,
            };

            <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.open">open</a>(&amp;dwarf, allocator);
            di.dwarf = dwarf;
        }

        <span class="tok-kw">const</span> raw_path = <span class="tok-kw">try</span> coff_obj.getPdbPath() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> di;
        <span class="tok-kw">const</span> path = blk: {
            <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(raw_path)) {
                <span class="tok-kw">break</span> :blk raw_path;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> self_dir = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.selfExeDirPathAlloc">selfExeDirPathAlloc</a>(allocator);
                <span class="tok-kw">defer</span> allocator.free(self_dir);
                <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>(allocator, &amp;.{ self_dir, raw_path });
            }
        };
        <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (path.ptr != raw_path.ptr) allocator.free(path);

        di.pdb = <a href="std.debug.Pdb.html">Pdb</a>.<a href="std.debug.Pdb.html#std.debug.Pdb.init">init</a>(allocator, path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileNotFound, <span class="tok-kw">error</span>.IsDir =&gt; {
                <span class="tok-kw">if</span> (di.dwarf == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
                <span class="tok-kw">return</span> di;
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
        };
        <span class="tok-kw">try</span> di.pdb.?.parseInfoStream();
        <span class="tok-kw">try</span> di.pdb.?.parseDbiStream();

        <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;coff_obj.guid, &amp;di.pdb.?.guid) <span class="tok-kw">or</span> coff_obj.age != di.pdb.?.age)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;<span class="tok-comment">

        // Only used by the pdb path
        </span>di.coff_section_headers = <span class="tok-kw">try</span> coff_obj.getSectionHeadersAlloc(allocator);
        <span class="tok-kw">errdefer</span> allocator.free(di.coff_section_headers);

        <span class="tok-kw">return</span> di;
    }
}

<span class="tok-comment">/// Reads debug info from an ELF file, or the current binary if none in specified.</span>
<span class="tok-comment">/// If the required sections aren't present but a reference to external debug info is,</span>
<span class="tok-comment">/// then this this function will recurse to attempt to load the debug sections from</span>
<span class="tok-comment">/// an external file.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readElfDebugInfo</span>(
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    elf_filename: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    build_id: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    expected_crc: ?<span class="tok-type">u32</span>,
    parent_sections: *<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.SectionArray">SectionArray</a>,
    parent_mapped_mem: ?[]<span class="tok-kw">align</span>(<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) !<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.ElfModule.html">ElfModule</a> {
    <span class="tok-kw">nosuspend</span> {
        <span class="tok-kw">const</span> elf_file = (<span class="tok-kw">if</span> (elf_filename) |filename| blk: {
            <span class="tok-kw">break</span> :blk <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().openFile(filename, .{});
        } <span class="tok-kw">else</span> <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.openSelfExe">openSelfExe</a>(.{})) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
        };

        <span class="tok-kw">const</span> mapped_mem = <span class="tok-kw">try</span> <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.mapWholeFile">mapWholeFile</a>(elf_file);
        <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.ElfModule.html">ElfModule</a>.<a href="std.debug.Dwarf.ElfModule.html#std.debug.Dwarf.ElfModule.load">load</a>(
            allocator,
            mapped_mem,
            build_id,
            expected_crc,
            parent_sections,
            parent_mapped_mem,
            elf_filename,
        );
    }
}

<span class="tok-kw">const</span> MachoSymbol = <span class="tok-kw">struct</span> {
    strx: <span class="tok-type">u32</span>,
    addr: <span class="tok-type">u64</span>,
    size: <span class="tok-type">u32</span>,
    ofile: <span class="tok-type">u32</span>,

    <span class="tok-comment">/// Returns the address from the macho file</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">address</span>(self: <a href="std.debug.SelfInfo.MachoSymbol.html">MachoSymbol</a>) <span class="tok-type">u64</span> {
        <span class="tok-kw">return</span> self.addr;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addressLessThan</span>(context: <span class="tok-type">void</span>, lhs: <a href="std.debug.SelfInfo.MachoSymbol.html">MachoSymbol</a>, rhs: <a href="std.debug.SelfInfo.MachoSymbol.html">MachoSymbol</a>) <span class="tok-type">bool</span> {
        _ = context;
        <span class="tok-kw">return</span> lhs.addr &lt; rhs.addr;
    }
};

<span class="tok-comment">/// Takes ownership of file, even on error.</span>
<span class="tok-comment">/// TODO it's weird to take ownership even on error, rework this code.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">mapWholeFile</span>(file: <a href="std.fs.File.html">File</a>) ![]<span class="tok-kw">align</span>(<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">nosuspend</span> {
        <span class="tok-kw">defer</span> file.close();

        <span class="tok-kw">const</span> file_len = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> file.getEndPos()) <span class="tok-kw">orelse</span> <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>);
        <span class="tok-kw">const</span> mapped_mem = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mmap">mmap</a>(
            <span class="tok-null">null</span>,
            file_len,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PROT">PROT</a>.<a href="#">READ</a>,
            .{ .TYPE = .SHARED },
            file.handle,
            <span class="tok-number">0</span>,
        );
        <span class="tok-kw">errdefer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.munmap">munmap</a>(mapped_mem);

        <span class="tok-kw">return</span> mapped_mem;
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">machoSearchSymbols</span>(symbols: []<span class="tok-kw">const</span> <a href="std.debug.SelfInfo.MachoSymbol.html">MachoSymbol</a>, address: <span class="tok-type">usize</span>) ?*<span class="tok-kw">const</span> <a href="std.debug.SelfInfo.MachoSymbol.html">MachoSymbol</a> {
    <span class="tok-kw">var</span> min: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> max: <span class="tok-type">usize</span> = symbols.len - <span class="tok-number">1</span>;
    <span class="tok-kw">while</span> (min &lt; max) {
        <span class="tok-kw">const</span> mid = min + (max - min) / <span class="tok-number">2</span>;
        <span class="tok-kw">const</span> curr = &amp;symbols[mid];
        <span class="tok-kw">const</span> next = &amp;symbols[mid + <span class="tok-number">1</span>];
        <span class="tok-kw">if</span> (address &gt;= next.address()) {
            min = mid + <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (address &lt; curr.address()) {
            max = mid;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> curr;
        }
    }

    <span class="tok-kw">const</span> max_sym = &amp;symbols[symbols.len - <span class="tok-number">1</span>];
    <span class="tok-kw">if</span> (address &gt;= max_sym.address())
        <span class="tok-kw">return</span> max_sym;

    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">test</span> machoSearchSymbols {
    <span class="tok-kw">const</span> symbols = [_]<a href="std.debug.SelfInfo.MachoSymbol.html">MachoSymbol</a>{
        .{ .addr = <span class="tok-number">100</span>, .strx = <span class="tok-null">undefined</span>, .size = <span class="tok-null">undefined</span>, .ofile = <span class="tok-null">undefined</span> },
        .{ .addr = <span class="tok-number">200</span>, .strx = <span class="tok-null">undefined</span>, .size = <span class="tok-null">undefined</span>, .ofile = <span class="tok-null">undefined</span> },
        .{ .addr = <span class="tok-number">300</span>, .strx = <span class="tok-null">undefined</span>, .size = <span class="tok-null">undefined</span>, .ofile = <span class="tok-null">undefined</span> },
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.machoSearchSymbols">machoSearchSymbols</a>(&amp;symbols, <span class="tok-number">0</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.machoSearchSymbols">machoSearchSymbols</a>(&amp;symbols, <span class="tok-number">99</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(&amp;symbols[<span class="tok-number">0</span>], <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.machoSearchSymbols">machoSearchSymbols</a>(&amp;symbols, <span class="tok-number">100</span>).?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(&amp;symbols[<span class="tok-number">0</span>], <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.machoSearchSymbols">machoSearchSymbols</a>(&amp;symbols, <span class="tok-number">150</span>).?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(&amp;symbols[<span class="tok-number">0</span>], <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.machoSearchSymbols">machoSearchSymbols</a>(&amp;symbols, <span class="tok-number">199</span>).?);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(&amp;symbols[<span class="tok-number">1</span>], <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.machoSearchSymbols">machoSearchSymbols</a>(&amp;symbols, <span class="tok-number">200</span>).?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(&amp;symbols[<span class="tok-number">1</span>], <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.machoSearchSymbols">machoSearchSymbols</a>(&amp;symbols, <span class="tok-number">250</span>).?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(&amp;symbols[<span class="tok-number">1</span>], <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.machoSearchSymbols">machoSearchSymbols</a>(&amp;symbols, <span class="tok-number">299</span>).?);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(&amp;symbols[<span class="tok-number">2</span>], <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.machoSearchSymbols">machoSearchSymbols</a>(&amp;symbols, <span class="tok-number">300</span>).?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(&amp;symbols[<span class="tok-number">2</span>], <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.machoSearchSymbols">machoSearchSymbols</a>(&amp;symbols, <span class="tok-number">301</span>).?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(&amp;symbols[<span class="tok-number">2</span>], <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.machoSearchSymbols">machoSearchSymbols</a>(&amp;symbols, <span class="tok-number">5000</span>).?);
}

<span class="tok-comment">/// Unwind a frame using MachO compact unwind info (from __unwind_info).</span>
<span class="tok-comment">/// If the compact encoding can't encode a way to unwind a frame, it will</span>
<span class="tok-comment">/// defer unwinding to DWARF, in which case `.eh_frame` will be used if available.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwindFrameMachO</span>(
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    base_address: <span class="tok-type">usize</span>,
    context: *<a href="std.debug.SelfInfo.UnwindContext.html">UnwindContext</a>,
    ma: *<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.MemoryAccessor.html">MemoryAccessor</a>,
    unwind_info: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    eh_frame: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) !<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> header = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsValue">bytesAsValue</a>(
        <a href="std.macho.html">macho</a>.<a href="std.macho.unwind_info_section_header.html">unwind_info_section_header</a>,
        unwind_info[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.unwind_info_section_header.html">unwind_info_section_header</a>)],
    );
    <span class="tok-kw">const</span> indices = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(
        <a href="std.macho.html">macho</a>.<a href="std.macho.unwind_info_section_header_index_entry.html">unwind_info_section_header_index_entry</a>,
        unwind_info[header.indexSectionOffset..][<span class="tok-number">0</span> .. header.indexCount * <span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.unwind_info_section_header_index_entry.html">unwind_info_section_header_index_entry</a>)],
    );
    <span class="tok-kw">if</span> (indices.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingUnwindInfo;

    <span class="tok-kw">const</span> mapped_pc = context.pc - base_address;
    <span class="tok-kw">const</span> second_level_index = blk: {
        <span class="tok-kw">var</span> left: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = indices.len;

        <span class="tok-kw">while</span> (len &gt; <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> mid = left + len / <span class="tok-number">2</span>;
            <span class="tok-kw">const</span> offset = indices[mid].functionOffset;
            <span class="tok-kw">if</span> (mapped_pc &lt; offset) {
                len /= <span class="tok-number">2</span>;
            } <span class="tok-kw">else</span> {
                left = mid;
                <span class="tok-kw">if</span> (mapped_pc == offset) <span class="tok-kw">break</span>;
                len -= len / <span class="tok-number">2</span>;
            }
        }<span class="tok-comment">

        // Last index is a sentinel containing the highest address as its functionOffset
        </span><span class="tok-kw">if</span> (indices[left].secondLevelPagesSectionOffset == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingUnwindInfo;
        <span class="tok-kw">break</span> :blk &amp;indices[left];
    };

    <span class="tok-kw">const</span> common_encodings = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(
        <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.compact_unwind_encoding_t">compact_unwind_encoding_t</a>,
        unwind_info[header.commonEncodingsArraySectionOffset..][<span class="tok-number">0</span> .. header.commonEncodingsArrayCount * <span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.compact_unwind_encoding_t">compact_unwind_encoding_t</a>)],
    );

    <span class="tok-kw">const</span> start_offset = second_level_index.secondLevelPagesSectionOffset;
    <span class="tok-kw">const</span> kind = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsValue">bytesAsValue</a>(
        <a href="std.macho.html">macho</a>.<a href="std.macho.UNWIND_SECOND_LEVEL.html">UNWIND_SECOND_LEVEL</a>,
        unwind_info[start_offset..][<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.UNWIND_SECOND_LEVEL.html">UNWIND_SECOND_LEVEL</a>)],
    );

    <span class="tok-kw">const</span> entry: <span class="tok-kw">struct</span> {
        function_offset: <span class="tok-type">usize</span>,
        raw_encoding: <span class="tok-type">u32</span>,
    } = <span class="tok-kw">switch</span> (kind.*) {
        .REGULAR =&gt; blk: {
            <span class="tok-kw">const</span> page_header = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsValue">bytesAsValue</a>(
                <a href="std.macho.html">macho</a>.<a href="std.macho.unwind_info_regular_second_level_page_header.html">unwind_info_regular_second_level_page_header</a>,
                unwind_info[start_offset..][<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.unwind_info_regular_second_level_page_header.html">unwind_info_regular_second_level_page_header</a>)],
            );

            <span class="tok-kw">const</span> entries = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(
                <a href="std.macho.html">macho</a>.<a href="std.macho.unwind_info_regular_second_level_entry.html">unwind_info_regular_second_level_entry</a>,
                unwind_info[start_offset + page_header.entryPageOffset ..][<span class="tok-number">0</span> .. page_header.entryCount * <span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.unwind_info_regular_second_level_entry.html">unwind_info_regular_second_level_entry</a>)],
            );
            <span class="tok-kw">if</span> (entries.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;

            <span class="tok-kw">var</span> left: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = entries.len;
            <span class="tok-kw">while</span> (len &gt; <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> mid = left + len / <span class="tok-number">2</span>;
                <span class="tok-kw">const</span> offset = entries[mid].functionOffset;
                <span class="tok-kw">if</span> (mapped_pc &lt; offset) {
                    len /= <span class="tok-number">2</span>;
                } <span class="tok-kw">else</span> {
                    left = mid;
                    <span class="tok-kw">if</span> (mapped_pc == offset) <span class="tok-kw">break</span>;
                    len -= len / <span class="tok-number">2</span>;
                }
            }

            <span class="tok-kw">break</span> :blk .{
                .function_offset = entries[left].functionOffset,
                .raw_encoding = entries[left].encoding,
            };
        },
        .COMPRESSED =&gt; blk: {
            <span class="tok-kw">const</span> page_header = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsValue">bytesAsValue</a>(
                <a href="std.macho.html">macho</a>.<a href="std.macho.unwind_info_compressed_second_level_page_header.html">unwind_info_compressed_second_level_page_header</a>,
                unwind_info[start_offset..][<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.unwind_info_compressed_second_level_page_header.html">unwind_info_compressed_second_level_page_header</a>)],
            );

            <span class="tok-kw">const</span> entries = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(
                <a href="std.macho.html">macho</a>.<a href="std.macho.UnwindInfoCompressedEntry.html">UnwindInfoCompressedEntry</a>,
                unwind_info[start_offset + page_header.entryPageOffset ..][<span class="tok-number">0</span> .. page_header.entryCount * <span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.UnwindInfoCompressedEntry.html">UnwindInfoCompressedEntry</a>)],
            );
            <span class="tok-kw">if</span> (entries.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;

            <span class="tok-kw">var</span> left: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = entries.len;
            <span class="tok-kw">while</span> (len &gt; <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> mid = left + len / <span class="tok-number">2</span>;
                <span class="tok-kw">const</span> offset = second_level_index.functionOffset + entries[mid].funcOffset;
                <span class="tok-kw">if</span> (mapped_pc &lt; offset) {
                    len /= <span class="tok-number">2</span>;
                } <span class="tok-kw">else</span> {
                    left = mid;
                    <span class="tok-kw">if</span> (mapped_pc == offset) <span class="tok-kw">break</span>;
                    len -= len / <span class="tok-number">2</span>;
                }
            }

            <span class="tok-kw">const</span> entry = entries[left];
            <span class="tok-kw">const</span> function_offset = second_level_index.functionOffset + entry.funcOffset;
            <span class="tok-kw">if</span> (entry.encodingIndex &lt; header.commonEncodingsArrayCount) {
                <span class="tok-kw">if</span> (entry.encodingIndex &gt;= common_encodings.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;
                <span class="tok-kw">break</span> :blk .{
                    .function_offset = function_offset,
                    .raw_encoding = common_encodings[entry.encodingIndex],
                };
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> local_index = <span class="tok-kw">try</span> <a href="std.math.html">math</a>.<a href="std.math.html#std.math.sub">sub</a>(
                    <span class="tok-type">u8</span>,
                    entry.encodingIndex,
                    <a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u8</span>, header.commonEncodingsArrayCount) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo,
                );
                <span class="tok-kw">const</span> local_encodings = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.compact_unwind_encoding_t">compact_unwind_encoding_t</a>,
                    unwind_info[start_offset + page_header.encodingsPageOffset ..][<span class="tok-number">0</span> .. page_header.encodingsCount * <span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.compact_unwind_encoding_t">compact_unwind_encoding_t</a>)],
                );
                <span class="tok-kw">if</span> (local_index &gt;= local_encodings.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;
                <span class="tok-kw">break</span> :blk .{
                    .function_offset = function_offset,
                    .raw_encoding = local_encodings[local_index],
                };
            }
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo,
    };

    <span class="tok-kw">if</span> (entry.raw_encoding == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoUnwindInfo;
    <span class="tok-kw">const</span> reg_context = <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.RegisterContext.html">RegisterContext</a>{
        .eh_frame = <span class="tok-null">false</span>,
        .is_macho = <span class="tok-null">true</span>,
    };

    <span class="tok-kw">const</span> encoding: <a href="std.macho.html">macho</a>.<a href="std.macho.CompactUnwindEncoding.html">CompactUnwindEncoding</a> = <span class="tok-builtin">@bitCast</span>(entry.raw_encoding);
    <span class="tok-kw">const</span> new_ip = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>) {
        .x86_64 =&gt; <span class="tok-kw">switch</span> (encoding.mode.x86_64) {
            .OLD =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedUnwindEncoding,
            .RBP_FRAME =&gt; blk: {
                <span class="tok-kw">const</span> regs: [<span class="tok-number">5</span>]<span class="tok-type">u3</span> = .{
                    encoding.value.x86_64.frame.reg0,
                    encoding.value.x86_64.frame.reg1,
                    encoding.value.x86_64.frame.reg2,
                    encoding.value.x86_64.frame.reg3,
                    encoding.value.x86_64.frame.reg4,
                };

                <span class="tok-kw">const</span> frame_offset = encoding.value.x86_64.frame.frame_offset * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
                <span class="tok-kw">var</span> max_reg: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (regs, <span class="tok-number">0</span>..) |reg, i| {
                    <span class="tok-kw">if</span> (reg &gt; <span class="tok-number">0</span>) max_reg = i;
                }

                <span class="tok-kw">const</span> fp = (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.fpRegNum">fpRegNum</a>(reg_context), reg_context)).*;
                <span class="tok-kw">const</span> new_sp = fp + <span class="tok-number">2</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);<span class="tok-comment">

                // Verify the stack range we're about to read register values from
                </span><span class="tok-kw">if</span> (ma.load(<span class="tok-type">usize</span>, new_sp) == <span class="tok-null">null</span> <span class="tok-kw">or</span> ma.load(<span class="tok-type">usize</span>, fp - frame_offset + max_reg * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)) == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;

                <span class="tok-kw">const</span> ip_ptr = fp + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
                <span class="tok-kw">const</span> new_ip = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(ip_ptr)).*;
                <span class="tok-kw">const</span> new_fp = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(fp)).*;

                (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.fpRegNum">fpRegNum</a>(reg_context), reg_context)).* = new_fp;
                (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.spRegNum">spRegNum</a>(reg_context), reg_context)).* = new_sp;
                (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.ip_reg_num">ip_reg_num</a>, reg_context)).* = new_ip;

                <span class="tok-kw">for</span> (regs, <span class="tok-number">0</span>..) |reg, i| {
                    <span class="tok-kw">if</span> (reg == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;
                    <span class="tok-kw">const</span> addr = fp - frame_offset + i * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
                    <span class="tok-kw">const</span> reg_number = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.compactUnwindToDwarfRegNumber">compactUnwindToDwarfRegNumber</a>(reg);
                    (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, reg_number, reg_context)).* = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*;
                }

                <span class="tok-kw">break</span> :blk new_ip;
            },
            .STACK_IMMD,
            .STACK_IND,
            =&gt; blk: {
                <span class="tok-kw">const</span> sp = (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.spRegNum">spRegNum</a>(reg_context), reg_context)).*;
                <span class="tok-kw">const</span> stack_size = <span class="tok-kw">if</span> (encoding.mode.x86_64 == .STACK_IMMD)
                    <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, encoding.value.x86_64.frameless.stack.direct.stack_size) * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)
                <span class="tok-kw">else</span> stack_size: {<span class="tok-comment">
                    // In .STACK_IND, the stack size is inferred from the subq instruction at the beginning of the function.
                    </span><span class="tok-kw">const</span> sub_offset_addr =
                        base_address +
                        entry.function_offset +
                        encoding.value.x86_64.frameless.stack.indirect.sub_offset;
                    <span class="tok-kw">if</span> (ma.load(<span class="tok-type">usize</span>, sub_offset_addr) == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;<span class="tok-comment">

                    // `sub_offset_addr` points to the offset of the literal within the instruction
                    </span><span class="tok-kw">const</span> sub_operand = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <span class="tok-type">u32</span>, <span class="tok-builtin">@ptrFromInt</span>(sub_offset_addr)).*;
                    <span class="tok-kw">break</span> :stack_size sub_operand + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, encoding.value.x86_64.frameless.stack.indirect.stack_adjust);
                };<span class="tok-comment">

                // Decode the Lehmer-coded sequence of registers.
                // For a description of the encoding see lib/libc/include/any-macos.13-any/mach-o/compact_unwind_encoding.h

                // Decode the variable-based permutation number into its digits. Each digit represents
                // an index into the list of register numbers that weren't yet used in the sequence at
                // the time the digit was added.
                </span><span class="tok-kw">const</span> reg_count = encoding.value.x86_64.frameless.stack_reg_count;
                <span class="tok-kw">const</span> ip_ptr = <span class="tok-kw">if</span> (reg_count &gt; <span class="tok-number">0</span>) reg_blk: {
                    <span class="tok-kw">var</span> digits: [<span class="tok-number">6</span>]<span class="tok-type">u3</span> = <span class="tok-null">undefined</span>;
                    <span class="tok-kw">var</span> accumulator: <span class="tok-type">usize</span> = encoding.value.x86_64.frameless.stack_reg_permutation;
                    <span class="tok-kw">var</span> base: <span class="tok-type">usize</span> = <span class="tok-number">2</span>;
                    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..reg_count) |i| {
                        <span class="tok-kw">const</span> div = accumulator / base;
                        digits[digits.len - <span class="tok-number">1</span> - i] = <span class="tok-builtin">@intCast</span>(accumulator - base * div);
                        accumulator = div;
                        base += <span class="tok-number">1</span>;
                    }

                    <span class="tok-kw">const</span> reg_numbers = [_]<span class="tok-type">u3</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span> };
                    <span class="tok-kw">var</span> registers: [reg_numbers.len]<span class="tok-type">u3</span> = <span class="tok-null">undefined</span>;
                    <span class="tok-kw">var</span> used_indices = [_]<span class="tok-type">bool</span>{<span class="tok-null">false</span>} ** reg_numbers.len;
                    <span class="tok-kw">for</span> (digits[digits.len - reg_count ..], <span class="tok-number">0</span>..) |target_unused_index, i| {
                        <span class="tok-kw">var</span> unused_count: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;
                        <span class="tok-kw">const</span> unused_index = <span class="tok-kw">for</span> (used_indices, <span class="tok-number">0</span>..) |used, index| {
                            <span class="tok-kw">if</span> (!used) {
                                <span class="tok-kw">if</span> (target_unused_index == unused_count) <span class="tok-kw">break</span> index;
                                unused_count += <span class="tok-number">1</span>;
                            }
                        } <span class="tok-kw">else</span> <span class="tok-kw">unreachable</span>;

                        registers[i] = reg_numbers[unused_index];
                        used_indices[unused_index] = <span class="tok-null">true</span>;
                    }

                    <span class="tok-kw">var</span> reg_addr = sp + stack_size - <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, reg_count + <span class="tok-number">1</span>);
                    <span class="tok-kw">if</span> (ma.load(<span class="tok-type">usize</span>, reg_addr) == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;
                    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..reg_count) |i| {
                        <span class="tok-kw">const</span> reg_number = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.compactUnwindToDwarfRegNumber">compactUnwindToDwarfRegNumber</a>(registers[i]);
                        (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, reg_number, reg_context)).* = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(reg_addr)).*;
                        reg_addr += <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
                    }

                    <span class="tok-kw">break</span> :reg_blk reg_addr;
                } <span class="tok-kw">else</span> sp + stack_size - <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);

                <span class="tok-kw">const</span> new_ip = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(ip_ptr)).*;
                <span class="tok-kw">const</span> new_sp = ip_ptr + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
                <span class="tok-kw">if</span> (ma.load(<span class="tok-type">usize</span>, new_sp) == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;

                (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.spRegNum">spRegNum</a>(reg_context), reg_context)).* = new_sp;
                (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.ip_reg_num">ip_reg_num</a>, reg_context)).* = new_ip;

                <span class="tok-kw">break</span> :blk new_ip;
            },
            .DWARF =&gt; {
                <span class="tok-kw">return</span> <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.unwindFrameMachODwarf">unwindFrameMachODwarf</a>(allocator, base_address, context, ma, eh_frame <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingEhFrame, <span class="tok-builtin">@intCast</span>(encoding.value.x86_64.dwarf));
            },
        },
        .aarch64, .aarch64_be =&gt; <span class="tok-kw">switch</span> (encoding.mode.arm64) {
            .OLD =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedUnwindEncoding,
            .FRAMELESS =&gt; blk: {
                <span class="tok-kw">const</span> sp = (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.spRegNum">spRegNum</a>(reg_context), reg_context)).*;
                <span class="tok-kw">const</span> new_sp = sp + encoding.value.arm64.frameless.stack_size * <span class="tok-number">16</span>;
                <span class="tok-kw">const</span> new_ip = (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <span class="tok-number">30</span>, reg_context)).*;
                <span class="tok-kw">if</span> (ma.load(<span class="tok-type">usize</span>, new_sp) == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;
                (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.spRegNum">spRegNum</a>(reg_context), reg_context)).* = new_sp;
                <span class="tok-kw">break</span> :blk new_ip;
            },
            .DWARF =&gt; {
                <span class="tok-kw">return</span> <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.unwindFrameMachODwarf">unwindFrameMachODwarf</a>(allocator, base_address, context, ma, eh_frame <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingEhFrame, <span class="tok-builtin">@intCast</span>(encoding.value.arm64.dwarf));
            },
            .FRAME =&gt; blk: {
                <span class="tok-kw">const</span> fp = (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.fpRegNum">fpRegNum</a>(reg_context), reg_context)).*;
                <span class="tok-kw">const</span> new_sp = fp + <span class="tok-number">16</span>;
                <span class="tok-kw">const</span> ip_ptr = fp + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);

                <span class="tok-kw">const</span> num_restored_pairs: <span class="tok-type">usize</span> =
                    <span class="tok-builtin">@popCount</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u5</span>, <span class="tok-builtin">@bitCast</span>(encoding.value.arm64.frame.x_reg_pairs))) +
                    <span class="tok-builtin">@popCount</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-builtin">@bitCast</span>(encoding.value.arm64.frame.d_reg_pairs)));
                <span class="tok-kw">const</span> min_reg_addr = fp - num_restored_pairs * <span class="tok-number">2</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);

                <span class="tok-kw">if</span> (ma.load(<span class="tok-type">usize</span>, new_sp) == <span class="tok-null">null</span> <span class="tok-kw">or</span> ma.load(<span class="tok-type">usize</span>, min_reg_addr) == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;

                <span class="tok-kw">var</span> reg_addr = fp - <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(encoding.value.arm64.frame.x_reg_pairs)).@&quot;struct&quot;.fields, <span class="tok-number">0</span>..) |field, i| {
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(encoding.value.arm64.frame.x_reg_pairs, field.name) != <span class="tok-number">0</span>) {
                        (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <span class="tok-number">19</span> + i, reg_context)).* = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(reg_addr)).*;
                        reg_addr += <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
                        (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <span class="tok-number">20</span> + i, reg_context)).* = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(reg_addr)).*;
                        reg_addr += <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
                    }
                }

                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(encoding.value.arm64.frame.d_reg_pairs)).@&quot;struct&quot;.fields, <span class="tok-number">0</span>..) |field, i| {
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(encoding.value.arm64.frame.d_reg_pairs, field.name) != <span class="tok-number">0</span>) {<span class="tok-comment">
                        // Only the lower half of the 128-bit V registers are restored during unwinding
                        </span><span class="tok-builtin">@memcpy</span>(
                            <span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(context.thread_context, <span class="tok-number">64</span> + <span class="tok-number">8</span> + i, context.reg_context),
                            <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(<span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(reg_addr))),
                        );
                        reg_addr += <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
                        <span class="tok-builtin">@memcpy</span>(
                            <span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(context.thread_context, <span class="tok-number">64</span> + <span class="tok-number">9</span> + i, context.reg_context),
                            <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(<span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(reg_addr))),
                        );
                        reg_addr += <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
                    }
                }

                <span class="tok-kw">const</span> new_ip = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(ip_ptr)).*;
                <span class="tok-kw">const</span> new_fp = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(fp)).*;

                (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.fpRegNum">fpRegNum</a>(reg_context), reg_context)).* = new_fp;
                (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.ip_reg_num">ip_reg_num</a>, reg_context)).* = new_ip;

                <span class="tok-kw">break</span> :blk new_ip;
            },
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedArch,
    };

    context.pc = <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.stripInstructionPtrAuthCode">stripInstructionPtrAuthCode</a>(new_ip);
    <span class="tok-kw">if</span> (context.pc &gt; <span class="tok-number">0</span>) context.pc -= <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> new_ip;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnwindContext = <span class="tok-kw">struct</span> {
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    cfa: ?<span class="tok-type">usize</span>,
    pc: <span class="tok-type">usize</span>,
    thread_context: *<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a>,
    reg_context: <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.RegisterContext.html">RegisterContext</a>,
    vm: <a href="std.debug.SelfInfo.VirtualMachine.html">VirtualMachine</a>,
    stack_machine: <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.expression.html">expression</a>.<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">StackMachine</a>(.{ .call_frame_context = <span class="tok-null">true</span> }),

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(
        allocator: <a href="std.mem.Allocator.html">Allocator</a>,
        thread_context: *<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a>,
    ) !<a href="std.debug.SelfInfo.UnwindContext.html">UnwindContext</a> {
        <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.supports_unwinding">supports_unwinding</a>);

        <span class="tok-kw">const</span> pc = <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.stripInstructionPtrAuthCode">stripInstructionPtrAuthCode</a>(
            (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.ip_reg_num">ip_reg_num</a>, <span class="tok-null">null</span>)).*,
        );

        <span class="tok-kw">const</span> context_copy = <span class="tok-kw">try</span> allocator.create(<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a>);
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.copyContext">copyContext</a>(thread_context, context_copy);

        <span class="tok-kw">return</span> .{
            .allocator = allocator,
            .cfa = <span class="tok-null">null</span>,
            .pc = pc,
            .thread_context = context_copy,
            .reg_context = <span class="tok-null">undefined</span>,
            .vm = .{},
            .stack_machine = .{},
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.debug.SelfInfo.UnwindContext.html">UnwindContext</a>) <span class="tok-type">void</span> {
        self.vm.deinit(self.allocator);
        self.stack_machine.deinit(self.allocator);
        self.allocator.destroy(self.thread_context);
        self.* = <span class="tok-null">undefined</span>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getFp</span>(self: *<span class="tok-kw">const</span> <a href="std.debug.SelfInfo.UnwindContext.html">UnwindContext</a>) !<span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(self.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.fpRegNum">fpRegNum</a>(self.reg_context), self.reg_context)).*;
    }
};

<span class="tok-comment">/// Some platforms use pointer authentication - the upper bits of instruction pointers contain a signature.</span>
<span class="tok-comment">/// This function clears these signature bits to make the pointer usable.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">stripInstructionPtrAuthCode</span>(ptr: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_arch">native_arch</a>.<a href="#">isAARCH64</a>()) {<span class="tok-comment">
        // `hint 0x07` maps to `xpaclri` (or `nop` if the hardware doesn't support it)
        // The save / restore is because `xpaclri` operates on x30 (LR)
        </span><span class="tok-kw">return</span> <span class="tok-kw">asm</span> (
            <span class="tok-str">\\mov x16, x30</span>
            <span class="tok-str">\\mov x30, x15</span>
            <span class="tok-str">\\hint 0x07</span>
            <span class="tok-str">\\mov x15, x30</span>
            <span class="tok-str">\\mov x30, x16</span>
            : [ret] <span class="tok-str">&quot;={x15}&quot;</span> (-&gt; <span class="tok-type">usize</span>),
            : [ptr] <span class="tok-str">&quot;{x15}&quot;</span> (ptr),
            : <span class="tok-str">&quot;x16&quot;</span>
        );
    }

    <span class="tok-kw">return</span> ptr;
}

<span class="tok-comment">/// Unwind a stack frame using DWARF unwinding info, updating the register context.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// If `.eh_frame_hdr` is available and complete, it will be used to binary search for the FDE.</span>
<span class="tok-comment">/// Otherwise, a linear scan of `.eh_frame` and `.debug_frame` is done to find the FDE. The latter</span>
<span class="tok-comment">/// may require lazily loading the data in those sections.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `explicit_fde_offset` is for cases where the FDE offset is known, such as when __unwind_info</span>
<span class="tok-comment">/// defers unwinding to DWARF. This is an offset into the `.eh_frame` section.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwindFrameDwarf</span>(
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    di: *<a href="std.debug.Dwarf.html">Dwarf</a>,
    base_address: <span class="tok-type">usize</span>,
    context: *<a href="std.debug.SelfInfo.UnwindContext.html">UnwindContext</a>,
    ma: *<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.MemoryAccessor.html">MemoryAccessor</a>,
    explicit_fde_offset: ?<span class="tok-type">usize</span>,
) !<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (!<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.supports_unwinding">supports_unwinding</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedCpuArchitecture;
    <span class="tok-kw">if</span> (context.pc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;<span class="tok-comment">

    // Find the FDE and CIE
    </span><span class="tok-kw">const</span> cie, <span class="tok-kw">const</span> fde = <span class="tok-kw">if</span> (explicit_fde_offset) |fde_offset| blk: {
        <span class="tok-kw">const</span> dwarf_section: Dwarf.Section.Id = .eh_frame;
        <span class="tok-kw">const</span> frame_section = di.section(dwarf_section) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingFDE;
        <span class="tok-kw">if</span> (fde_offset &gt;= frame_section.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingFDE;

        <span class="tok-kw">var</span> fbr: std.debug.FixedBufferReader = .{
            .buf = frame_section,
            .pos = fde_offset,
            .endian = di.endian,
        };

        <span class="tok-kw">const</span> fde_entry_header = <span class="tok-kw">try</span> Dwarf.EntryHeader.read(&amp;fbr, <span class="tok-null">null</span>, dwarf_section);
        <span class="tok-kw">if</span> (fde_entry_header.<span class="tok-type">type</span> != .fde) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingFDE;

        <span class="tok-kw">const</span> cie_offset = fde_entry_header.<span class="tok-type">type</span>.fde;
        <span class="tok-kw">try</span> fbr.seekTo(cie_offset);

        fbr.endian = native_endian;
        <span class="tok-kw">const</span> cie_entry_header = <span class="tok-kw">try</span> Dwarf.EntryHeader.read(&amp;fbr, <span class="tok-null">null</span>, dwarf_section);
        <span class="tok-kw">if</span> (cie_entry_header.<span class="tok-type">type</span> != .cie) <span class="tok-kw">return</span> Dwarf.bad();

        <span class="tok-kw">const</span> cie = <span class="tok-kw">try</span> Dwarf.CommonInformationEntry.parse(
            cie_entry_header.entry_bytes,
            <span class="tok-number">0</span>,
            <span class="tok-null">true</span>,
            cie_entry_header.format,
            dwarf_section,
            cie_entry_header.length_offset,
            <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),
            native_endian,
        );
        <span class="tok-kw">const</span> fde = <span class="tok-kw">try</span> Dwarf.FrameDescriptionEntry.parse(
            fde_entry_header.entry_bytes,
            <span class="tok-number">0</span>,
            <span class="tok-null">true</span>,
            cie,
            <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),
            native_endian,
        );

        <span class="tok-kw">break</span> :blk .{ cie, fde };
    } <span class="tok-kw">else</span> blk: {<span class="tok-comment">
        // `.eh_frame_hdr` may be incomplete. We'll try it first, but if the lookup fails, we fall
        // back to loading `.eh_frame`/`.debug_frame` and using those from that point on.

        </span><span class="tok-kw">if</span> (di.eh_frame_hdr) |header| hdr: {
            <span class="tok-kw">const</span> eh_frame_len = <span class="tok-kw">if</span> (di.section(.eh_frame)) |eh_frame| eh_frame.len <span class="tok-kw">else</span> <span class="tok-null">null</span>;

            <span class="tok-kw">var</span> cie: Dwarf.CommonInformationEntry = <span class="tok-null">undefined</span>;
            <span class="tok-kw">var</span> fde: Dwarf.FrameDescriptionEntry = <span class="tok-null">undefined</span>;

            header.findEntry(
                ma,
                eh_frame_len,
                <span class="tok-builtin">@intFromPtr</span>(di.section(.eh_frame_hdr).?.ptr),
                context.pc,
                &amp;cie,
                &amp;fde,
            ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; {<span class="tok-comment">
                    // `.eh_frame_hdr` appears to be incomplete, so go ahead and populate `cie_map`
                    // and `fde_list`, and fall back to the binary search logic below.
                    </span><span class="tok-kw">try</span> di.scanCieFdeInfo(allocator, base_address);<span class="tok-comment">

                    // Since `.eh_frame_hdr` is incomplete, we're very likely to get more lookup
                    // failures using it, and we've just built a complete, sorted list of FDEs
                    // anyway, so just stop using `.eh_frame_hdr` altogether.
                    </span>di.eh_frame_hdr = <span class="tok-null">null</span>;

                    <span class="tok-kw">break</span> :hdr;
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
            };

            <span class="tok-kw">break</span> :blk .{ cie, fde };
        }

        <span class="tok-kw">const</span> index = std.sort.binarySearch(Dwarf.FrameDescriptionEntry, di.fde_list.items, context.pc, <span class="tok-kw">struct</span> {
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">compareFn</span>(pc: <span class="tok-type">usize</span>, item: Dwarf.FrameDescriptionEntry) std.math.Order {
                <span class="tok-kw">if</span> (pc &lt; item.pc_begin) <span class="tok-kw">return</span> .lt;

                <span class="tok-kw">const</span> range_end = item.pc_begin + item.pc_range;
                <span class="tok-kw">if</span> (pc &lt; range_end) <span class="tok-kw">return</span> .eq;

                <span class="tok-kw">return</span> .gt;
            }
        }.compareFn);

        <span class="tok-kw">const</span> fde = <span class="tok-kw">if</span> (index) |i| di.fde_list.items[i] <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingFDE;
        <span class="tok-kw">const</span> cie = di.cie_map.get(fde.cie_length_offset) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingCIE;

        <span class="tok-kw">break</span> :blk .{ cie, fde };
    };

    <span class="tok-kw">var</span> expression_context: <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.expression.html">expression</a>.<a href="std.debug.Dwarf.expression.Context.html">Context</a> = .{
        .format = cie.format,
        .memory_accessor = ma,
        .compile_unit = di.findCompileUnit(fde.pc_begin) <span class="tok-kw">catch</span> <span class="tok-null">null</span>,
        .thread_context = context.thread_context,
        .reg_context = context.reg_context,
        .cfa = context.cfa,
    };

    context.vm.reset();
    context.reg_context.eh_frame = cie.version != <span class="tok-number">4</span>;
    context.reg_context.is_macho = di.is_macho;

    <span class="tok-kw">const</span> row = <span class="tok-kw">try</span> context.vm.runToNative(context.allocator, context.pc, cie, fde);
    context.cfa = <span class="tok-kw">switch</span> (row.cfa.rule) {
        .val_offset =&gt; |offset| blk: {
            <span class="tok-kw">const</span> register = row.cfa.register <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFARule;
            <span class="tok-kw">const</span> value = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">usize</span>, (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(context.thread_context, register, context.reg_context))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_endian">native_endian</a>);
            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.applyOffset">applyOffset</a>(value, offset);
        },
        .expression =&gt; |expr| blk: {
            context.stack_machine.reset();
            <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> context.stack_machine.run(
                expr,
                context.allocator,
                expression_context,
                context.cfa,
            );

            <span class="tok-kw">if</span> (value) |v| {
                <span class="tok-kw">if</span> (v != .generic) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpressionValue;
                <span class="tok-kw">break</span> :blk v.generic;
            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoExpressionValue;
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFARule,
    };

    <span class="tok-kw">if</span> (ma.load(<span class="tok-type">usize</span>, context.cfa.?) == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFA;
    expression_context.cfa = context.cfa;<span class="tok-comment">

    // Buffering the modifications is done because copying the thread context is not portable,
    // some implementations (ie. darwin) use internal pointers to the mcontext.
    </span><span class="tok-kw">var</span> arena = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.init">init</a>(context.allocator);
    <span class="tok-kw">defer</span> arena.deinit();
    <span class="tok-kw">const</span> update_allocator = arena.allocator();

    <span class="tok-kw">const</span> RegisterUpdate = <span class="tok-kw">struct</span> {<span class="tok-comment">
        // Backed by thread_context
        </span>dest: []<span class="tok-type">u8</span>,<span class="tok-comment">
        // Backed by arena
        </span>src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        prev: ?*<span class="tok-builtin">@This</span>(),
    };

    <span class="tok-kw">var</span> update_tail: ?*RegisterUpdate = <span class="tok-null">null</span>;
    <span class="tok-kw">var</span> has_return_address = <span class="tok-null">true</span>;
    <span class="tok-kw">for</span> (context.vm.rowColumns(row)) |column| {
        <span class="tok-kw">if</span> (column.register) |register| {
            <span class="tok-kw">if</span> (register == cie.return_address_register) {
                has_return_address = column.rule != .<span class="tok-null">undefined</span>;
            }

            <span class="tok-kw">const</span> dest = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(context.thread_context, register, context.reg_context);
            <span class="tok-kw">const</span> src = <span class="tok-kw">try</span> update_allocator.alloc(<span class="tok-type">u8</span>, dest.len);

            <span class="tok-kw">const</span> prev = update_tail;
            update_tail = <span class="tok-kw">try</span> update_allocator.create(RegisterUpdate);
            update_tail.?.* = .{
                .dest = dest,
                .src = src,
                .prev = prev,
            };

            <span class="tok-kw">try</span> column.resolveValue(
                context,
                expression_context,
                ma,
                src,
            );
        }
    }<span class="tok-comment">

    // On all implemented architectures, the CFA is defined as being the previous frame's SP
    </span>(<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.spRegNum">spRegNum</a>(context.reg_context), context.reg_context)).* = context.cfa.?;

    <span class="tok-kw">while</span> (update_tail) |tail| {
        <span class="tok-builtin">@memcpy</span>(tail.dest, tail.src);
        update_tail = tail.prev;
    }

    <span class="tok-kw">if</span> (has_return_address) {
        context.pc = <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.stripInstructionPtrAuthCode">stripInstructionPtrAuthCode</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">usize</span>, (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(
            context.thread_context,
            cie.return_address_register,
            context.reg_context,
        ))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_endian">native_endian</a>));
    } <span class="tok-kw">else</span> {
        context.pc = <span class="tok-number">0</span>;
    }

    (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(context.thread_context, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.ip_reg_num">ip_reg_num</a>, context.reg_context)).* = context.pc;<span class="tok-comment">

    // The call instruction will have pushed the address of the instruction that follows the call as the return address.
    // This next instruction may be past the end of the function if the caller was `noreturn` (ie. the last instruction in
    // the function was the call). If we were to look up an FDE entry using the return address directly, it could end up
    // either not finding an FDE at all, or using the next FDE in the program, producing incorrect results. To prevent this,
    // we subtract one so that the next lookup is guaranteed to land inside the
    //
    // The exception to this rule is signal frames, where we return execution would be returned to the instruction
    // that triggered the handler.
    </span><span class="tok-kw">const</span> return_address = context.pc;
    <span class="tok-kw">if</span> (context.pc &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> !cie.isSignalFrame()) context.pc -= <span class="tok-number">1</span>;

    <span class="tok-kw">return</span> return_address;
}

<span class="tok-kw">fn</span> <span class="tok-fn">fpRegNum</span>(reg_context: <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.RegisterContext.html">RegisterContext</a>) <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.fpRegNum">fpRegNum</a>(<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_arch">native_arch</a>, reg_context);
}

<span class="tok-kw">fn</span> <span class="tok-fn">spRegNum</span>(reg_context: <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.RegisterContext.html">RegisterContext</a>) <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.spRegNum">spRegNum</a>(<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_arch">native_arch</a>, reg_context);
}

<span class="tok-kw">const</span> ip_reg_num = <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.ipRegNum">ipRegNum</a>(<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_arch">native_arch</a>).?;

<span class="tok-comment">/// Tells whether unwinding for the host is implemented.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> supports_unwinding = <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.supportsUnwinding">supportsUnwinding</a>(<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>);

<span class="tok-kw">comptime</span> {
    <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.supports_unwinding">supports_unwinding</a>) <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.supportsUnwinding">supportsUnwinding</a>(<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>));
}

<span class="tok-comment">/// Tells whether unwinding for this target is *implemented* here in the Zig</span>
<span class="tok-comment">/// standard library.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See also `Dwarf.abi.supportsUnwinding` which tells whether Dwarf supports</span>
<span class="tok-comment">/// unwinding on that target *in theory*.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supportsUnwinding</span>(target: <a href="std.html">std</a>.<a href="std.Target.html">Target</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (target.cpu.arch) {
        .x86 =&gt; <span class="tok-kw">switch</span> (target.os.tag) {
            .linux, .netbsd, .solaris, .illumos =&gt; <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
        },
        .x86_64 =&gt; <span class="tok-kw">switch</span> (target.os.tag) {
            .linux, .netbsd, .freebsd, .openbsd, .macos, .ios, .solaris, .illumos =&gt; <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
        },
        .arm, .armeb, .thumb, .thumbeb =&gt; <span class="tok-kw">switch</span> (target.os.tag) {
            .linux =&gt; <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
        },
        .aarch64, .aarch64_be =&gt; <span class="tok-kw">switch</span> (target.os.tag) {
            .linux, .netbsd, .freebsd, .macos, .ios =&gt; <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
        },<span class="tok-comment">
        // Unwinding is possible on other targets but this implementation does
        // not support them...yet!
        </span><span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">unwindFrameMachODwarf</span>(
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    base_address: <span class="tok-type">usize</span>,
    context: *<a href="std.debug.SelfInfo.UnwindContext.html">UnwindContext</a>,
    ma: *<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.MemoryAccessor.html">MemoryAccessor</a>,
    eh_frame: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    fde_offset: <span class="tok-type">usize</span>,
) !<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> di: <a href="std.debug.Dwarf.html">Dwarf</a> = .{
        .endian = <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_endian">native_endian</a>,
        .is_macho = <span class="tok-null">true</span>,
    };
    <span class="tok-kw">defer</span> di.deinit(context.allocator);

    di.sections[<span class="tok-builtin">@intFromEnum</span>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>.<a href="#">eh_frame</a>)] = .{
        .data = eh_frame,
        .owned = <span class="tok-null">false</span>,
    };

    <span class="tok-kw">return</span> <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.unwindFrameDwarf">unwindFrameDwarf</a>(allocator, &amp;di, base_address, context, ma, fde_offset);
}

<span class="tok-comment">/// This is a virtual machine that runs DWARF call frame instructions.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> VirtualMachine = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// See section 6.4.1 of the DWARF5 specification for details on each</span>
    <span class="tok-kw">const</span> RegisterRule = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {<span class="tok-comment">
        // The spec says that the default rule for each column is the undefined rule.
        // However, it also allows ABI / compiler authors to specify alternate defaults, so
        // there is a distinction made here.
        </span>default: <span class="tok-type">void</span>,
        <span class="tok-null">undefined</span>: <span class="tok-type">void</span>,
        same_value: <span class="tok-type">void</span>,<span class="tok-comment">
        // offset(N)
        </span>offset: <span class="tok-type">i64</span>,<span class="tok-comment">
        // val_offset(N)
        </span>val_offset: <span class="tok-type">i64</span>,<span class="tok-comment">
        // register(R)
        </span>register: <span class="tok-type">u8</span>,<span class="tok-comment">
        // expression(E)
        </span>expression: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,<span class="tok-comment">
        // val_expression(E)
        </span>val_expression: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,<span class="tok-comment">
        // Augmenter-defined rule
        </span>architectural: <span class="tok-type">void</span>,
    };

    <span class="tok-comment">/// Each row contains unwinding rules for a set of registers.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Row = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// Offset from `FrameDescriptionEntry.pc_begin`</span>
        offset: <span class="tok-type">u64</span> = <span class="tok-number">0</span>,
        <span class="tok-comment">/// Special-case column that defines the CFA (Canonical Frame Address) rule.</span>
        <span class="tok-comment">/// The register field of this column defines the register that CFA is derived from.</span>
        cfa: <a href="std.debug.SelfInfo.VirtualMachine.Column.html">Column</a> = .{},
        <span class="tok-comment">/// The register fields in these columns define the register the rule applies to.</span>
        columns: <a href="std.debug.SelfInfo.VirtualMachine.ColumnRange.html">ColumnRange</a> = .{},
        <span class="tok-comment">/// Indicates that the next write to any column in this row needs to copy</span>
        <span class="tok-comment">/// the backing column storage first, as it may be referenced by previous rows.</span>
        copy_on_write: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Column = <span class="tok-kw">struct</span> {
        register: ?<span class="tok-type">u8</span> = <span class="tok-null">null</span>,
        rule: <a href="std.debug.SelfInfo.VirtualMachine.RegisterRule.html">RegisterRule</a> = .{ .default = {} },

        <span class="tok-comment">/// Resolves the register rule and places the result into `out` (see regBytes)</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resolveValue</span>(
            self: <a href="std.debug.SelfInfo.VirtualMachine.Column.html">Column</a>,
            context: *<a href="std.debug.SelfInfo.html">SelfInfo</a>.<a href="std.debug.SelfInfo.UnwindContext.html">UnwindContext</a>,
            expression_context: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.expression.html">expression</a>.<a href="std.debug.Dwarf.expression.Context.html">Context</a>,
            ma: *<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.MemoryAccessor.html">MemoryAccessor</a>,
            out: []<span class="tok-type">u8</span>,
        ) !<span class="tok-type">void</span> {
            <span class="tok-kw">switch</span> (self.rule) {
                .default =&gt; {
                    <span class="tok-kw">const</span> register = self.register <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidRegister;
                    <span class="tok-kw">try</span> <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.getRegDefaultValue">getRegDefaultValue</a>(register, context, out);
                },
                .<span class="tok-null">undefined</span> =&gt; {
                    <span class="tok-builtin">@memset</span>(out, <span class="tok-null">undefined</span>);
                },
                .same_value =&gt; {<span class="tok-comment">
                    // TODO: This copy could be eliminated if callers always copy the state then call this function to update it
                    </span><span class="tok-kw">const</span> register = self.register <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidRegister;
                    <span class="tok-kw">const</span> src = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(context.thread_context, register, context.reg_context);
                    <span class="tok-kw">if</span> (src.len != out.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.RegisterSizeMismatch;
                    <span class="tok-builtin">@memcpy</span>(out, src);
                },
                .offset =&gt; |offset| {
                    <span class="tok-kw">if</span> (context.cfa) |cfa| {
                        <span class="tok-kw">const</span> addr = <span class="tok-kw">try</span> <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.applyOffset">applyOffset</a>(cfa, offset);
                        <span class="tok-kw">if</span> (ma.load(<span class="tok-type">usize</span>, addr) == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidAddress;
                        <span class="tok-kw">const</span> ptr: *<span class="tok-kw">const</span> <span class="tok-type">usize</span> = <span class="tok-builtin">@ptrFromInt</span>(addr);
                        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">usize</span>, out[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], ptr.*, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_endian">native_endian</a>);
                    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFA;
                },
                .val_offset =&gt; |offset| {
                    <span class="tok-kw">if</span> (context.cfa) |cfa| {
                        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">usize</span>, out[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <span class="tok-kw">try</span> <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.applyOffset">applyOffset</a>(cfa, offset), <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_endian">native_endian</a>);
                    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFA;
                },
                .register =&gt; |register| {
                    <span class="tok-kw">const</span> src = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(context.thread_context, register, context.reg_context);
                    <span class="tok-kw">if</span> (src.len != out.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.RegisterSizeMismatch;
                    <span class="tok-builtin">@memcpy</span>(out, <span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(context.thread_context, register, context.reg_context));
                },
                .expression =&gt; |expression| {
                    context.stack_machine.reset();
                    <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> context.stack_machine.run(expression, context.allocator, expression_context, context.cfa.?);
                    <span class="tok-kw">const</span> addr = <span class="tok-kw">if</span> (value) |v| blk: {
                        <span class="tok-kw">if</span> (v != .generic) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpressionValue;
                        <span class="tok-kw">break</span> :blk v.generic;
                    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoExpressionValue;

                    <span class="tok-kw">if</span> (ma.load(<span class="tok-type">usize</span>, addr) == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpressionAddress;
                    <span class="tok-kw">const</span> ptr: *<span class="tok-type">usize</span> = <span class="tok-builtin">@ptrFromInt</span>(addr);
                    <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">usize</span>, out[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], ptr.*, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_endian">native_endian</a>);
                },
                .val_expression =&gt; |expression| {
                    context.stack_machine.reset();
                    <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> context.stack_machine.run(expression, context.allocator, expression_context, context.cfa.?);
                    <span class="tok-kw">if</span> (value) |v| {
                        <span class="tok-kw">if</span> (v != .generic) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpressionValue;
                        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">usize</span>, out[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], v.generic, <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_endian">native_endian</a>);
                    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoExpressionValue;
                },
                .architectural =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedRegisterRule,
            }
        }
    };

    <span class="tok-kw">const</span> ColumnRange = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// Index into `columns` of the first column in this row.</span>
        start: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>,
        len: <span class="tok-type">u8</span> = <span class="tok-number">0</span>,
    };

    columns: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.debug.SelfInfo.VirtualMachine.Column.html">Column</a>) = .empty,
    stack: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.debug.SelfInfo.VirtualMachine.ColumnRange.html">ColumnRange</a>) = .empty,
    current_row: <a href="std.debug.SelfInfo.VirtualMachine.Row.html">Row</a> = .{},

    <span class="tok-comment">/// The result of executing the CIE's initial_instructions</span>
    cie_row: ?<a href="std.debug.SelfInfo.VirtualMachine.Row.html">Row</a> = <span class="tok-null">null</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.debug.SelfInfo.VirtualMachine.html">VirtualMachine</a>, allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
        self.stack.deinit(allocator);
        self.columns.deinit(allocator);
        self.* = <span class="tok-null">undefined</span>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.debug.SelfInfo.VirtualMachine.html">VirtualMachine</a>) <span class="tok-type">void</span> {
        self.stack.clearRetainingCapacity();
        self.columns.clearRetainingCapacity();
        self.current_row = .{};
        self.cie_row = <span class="tok-null">null</span>;
    }

    <span class="tok-comment">/// Return a slice backed by the row's non-CFA columns</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rowColumns</span>(self: <a href="std.debug.SelfInfo.VirtualMachine.html">VirtualMachine</a>, row: <a href="std.debug.SelfInfo.VirtualMachine.Row.html">Row</a>) []<a href="std.debug.SelfInfo.VirtualMachine.Column.html">Column</a> {
        <span class="tok-kw">if</span> (row.columns.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> &amp;.{};
        <span class="tok-kw">return</span> self.columns.items[row.columns.start..][<span class="tok-number">0</span>..row.columns.len];
    }

    <span class="tok-comment">/// Either retrieves or adds a column for `register` (non-CFA) in the current row.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">getOrAddColumn</span>(self: *<a href="std.debug.SelfInfo.VirtualMachine.html">VirtualMachine</a>, allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, register: <span class="tok-type">u8</span>) !*<a href="std.debug.SelfInfo.VirtualMachine.Column.html">Column</a> {
        <span class="tok-kw">for</span> (self.rowColumns(self.current_row)) |*c| {
            <span class="tok-kw">if</span> (c.register == register) <span class="tok-kw">return</span> c;
        }

        <span class="tok-kw">if</span> (self.current_row.columns.len == <span class="tok-number">0</span>) {
            self.current_row.columns.start = self.columns.items.len;
        }
        self.current_row.columns.len += <span class="tok-number">1</span>;

        <span class="tok-kw">const</span> column = <span class="tok-kw">try</span> self.columns.addOne(allocator);
        column.* = .{
            .register = register,
        };

        <span class="tok-kw">return</span> column;
    }

    <span class="tok-comment">/// Runs the CIE instructions, then the FDE instructions. Execution halts</span>
    <span class="tok-comment">/// once the row that corresponds to `pc` is known, and the row is returned.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">runTo</span>(
        self: *<a href="std.debug.SelfInfo.VirtualMachine.html">VirtualMachine</a>,
        allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>,
        pc: <span class="tok-type">u64</span>,
        cie: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.CommonInformationEntry.html">CommonInformationEntry</a>,
        fde: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.FrameDescriptionEntry.html">FrameDescriptionEntry</a>,
        addr_size_bytes: <span class="tok-type">u8</span>,
        endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>,
    ) !<a href="std.debug.SelfInfo.VirtualMachine.Row.html">Row</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.cie_row == <span class="tok-null">null</span>);
        <span class="tok-kw">if</span> (pc &lt; fde.pc_begin <span class="tok-kw">or</span> pc &gt;= fde.pc_begin + fde.pc_range) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressOutOfRange;

        <span class="tok-kw">var</span> prev_row: <a href="std.debug.SelfInfo.VirtualMachine.Row.html">Row</a> = self.current_row;

        <span class="tok-kw">var</span> cie_stream = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(cie.initial_instructions);
        <span class="tok-kw">var</span> fde_stream = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(fde.instructions);
        <span class="tok-kw">var</span> streams = [_]*<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.FixedBufferStream">FixedBufferStream</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>){
            &amp;cie_stream,
            &amp;fde_stream,
        };

        <span class="tok-kw">for</span> (&amp;streams, <span class="tok-number">0</span>..) |stream, i| {
            <span class="tok-kw">while</span> (stream.pos &lt; stream.buffer.len) {
                <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.call_frame.html">call_frame</a>.<a href="std.debug.Dwarf.call_frame.Instruction.html">Instruction</a>.<a href="std.debug.Dwarf.call_frame.Instruction.html#std.debug.Dwarf.call_frame.Instruction.read">read</a>(stream, addr_size_bytes, endian);
                prev_row = <span class="tok-kw">try</span> self.step(allocator, cie, i == <span class="tok-number">0</span>, instruction);
                <span class="tok-kw">if</span> (pc &lt; fde.pc_begin + self.current_row.offset) <span class="tok-kw">return</span> prev_row;
            }
        }

        <span class="tok-kw">return</span> self.current_row;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">runToNative</span>(
        self: *<a href="std.debug.SelfInfo.VirtualMachine.html">VirtualMachine</a>,
        allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>,
        pc: <span class="tok-type">u64</span>,
        cie: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.CommonInformationEntry.html">CommonInformationEntry</a>,
        fde: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.FrameDescriptionEntry.html">FrameDescriptionEntry</a>,
    ) !<a href="std.debug.SelfInfo.VirtualMachine.Row.html">Row</a> {
        <span class="tok-kw">return</span> self.runTo(allocator, pc, cie, fde, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>), <a href="std.debug.SelfInfo.html#std.debug.SelfInfo.native_endian">native_endian</a>);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">resolveCopyOnWrite</span>(self: *<a href="std.debug.SelfInfo.VirtualMachine.html">VirtualMachine</a>, allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (!self.current_row.copy_on_write) <span class="tok-kw">return</span>;

        <span class="tok-kw">const</span> new_start = self.columns.items.len;
        <span class="tok-kw">if</span> (self.current_row.columns.len &gt; <span class="tok-number">0</span>) {
            <span class="tok-kw">try</span> self.columns.ensureUnusedCapacity(allocator, self.current_row.columns.len);
            self.columns.appendSliceAssumeCapacity(self.rowColumns(self.current_row));
            self.current_row.columns.start = new_start;
        }
    }

    <span class="tok-comment">/// Executes a single instruction.</span>
    <span class="tok-comment">/// If this instruction is from the CIE, `is_initial` should be set.</span>
    <span class="tok-comment">/// Returns the value of `current_row` before executing this instruction.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">step</span>(
        self: *<a href="std.debug.SelfInfo.VirtualMachine.html">VirtualMachine</a>,
        allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>,
        cie: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.CommonInformationEntry.html">CommonInformationEntry</a>,
        is_initial: <span class="tok-type">bool</span>,
        instruction: <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.call_frame.html">call_frame</a>.<a href="std.debug.Dwarf.call_frame.Instruction.html">Instruction</a>,
    ) !<a href="std.debug.SelfInfo.VirtualMachine.Row.html">Row</a> {<span class="tok-comment">
        // CIE instructions must be run before FDE instructions
        </span><a href="std.debug.html#std.debug.assert">assert</a>(!is_initial <span class="tok-kw">or</span> self.cie_row == <span class="tok-null">null</span>);
        <span class="tok-kw">if</span> (!is_initial <span class="tok-kw">and</span> self.cie_row == <span class="tok-null">null</span>) {
            self.cie_row = self.current_row;
            self.current_row.copy_on_write = <span class="tok-null">true</span>;
        }

        <span class="tok-kw">const</span> prev_row = self.current_row;
        <span class="tok-kw">switch</span> (instruction) {
            .set_loc =&gt; |i| {
                <span class="tok-kw">if</span> (i.address &lt;= self.current_row.offset) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidOperation;<span class="tok-comment">
                // TODO: Check cie.segment_selector_size != 0 for DWARFV4
                </span>self.current_row.offset = i.address;
            },
            <span class="tok-kw">inline</span> .advance_loc,
            .advance_loc1,
            .advance_loc2,
            .advance_loc4,
            =&gt; |i| {
                self.current_row.offset += i.delta * cie.code_alignment_factor;
                self.current_row.copy_on_write = <span class="tok-null">true</span>;
            },
            <span class="tok-kw">inline</span> .offset,
            .offset_extended,
            .offset_extended_sf,
            =&gt; |i| {
                <span class="tok-kw">try</span> self.resolveCopyOnWrite(allocator);
                <span class="tok-kw">const</span> column = <span class="tok-kw">try</span> self.getOrAddColumn(allocator, i.register);
                column.rule = .{ .offset = <span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-builtin">@intCast</span>(i.offset)) * cie.data_alignment_factor };
            },
            <span class="tok-kw">inline</span> .restore,
            .restore_extended,
            =&gt; |i| {
                <span class="tok-kw">try</span> self.resolveCopyOnWrite(allocator);
                <span class="tok-kw">if</span> (self.cie_row) |cie_row| {
                    <span class="tok-kw">const</span> column = <span class="tok-kw">try</span> self.getOrAddColumn(allocator, i.register);
                    column.rule = <span class="tok-kw">for</span> (self.rowColumns(cie_row)) |cie_column| {
                        <span class="tok-kw">if</span> (cie_column.register == i.register) <span class="tok-kw">break</span> cie_column.rule;
                    } <span class="tok-kw">else</span> .{ .default = {} };
                } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidOperation;
            },
            .nop =&gt; {},
            .<span class="tok-null">undefined</span> =&gt; |i| {
                <span class="tok-kw">try</span> self.resolveCopyOnWrite(allocator);
                <span class="tok-kw">const</span> column = <span class="tok-kw">try</span> self.getOrAddColumn(allocator, i.register);
                column.rule = .{ .<span class="tok-null">undefined</span> = {} };
            },
            .same_value =&gt; |i| {
                <span class="tok-kw">try</span> self.resolveCopyOnWrite(allocator);
                <span class="tok-kw">const</span> column = <span class="tok-kw">try</span> self.getOrAddColumn(allocator, i.register);
                column.rule = .{ .same_value = {} };
            },
            .register =&gt; |i| {
                <span class="tok-kw">try</span> self.resolveCopyOnWrite(allocator);
                <span class="tok-kw">const</span> column = <span class="tok-kw">try</span> self.getOrAddColumn(allocator, i.register);
                column.rule = .{ .register = i.target_register };
            },
            .remember_state =&gt; {
                <span class="tok-kw">try</span> self.stack.append(allocator, self.current_row.columns);
                self.current_row.copy_on_write = <span class="tok-null">true</span>;
            },
            .restore_state =&gt; {
                <span class="tok-kw">const</span> restored_columns = self.stack.pop() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidOperation;
                self.columns.shrinkRetainingCapacity(self.columns.items.len - self.current_row.columns.len);
                <span class="tok-kw">try</span> self.columns.ensureUnusedCapacity(allocator, restored_columns.len);

                self.current_row.columns.start = self.columns.items.len;
                self.current_row.columns.len = restored_columns.len;
                self.columns.appendSliceAssumeCapacity(self.columns.items[restored_columns.start..][<span class="tok-number">0</span>..restored_columns.len]);
            },
            .def_cfa =&gt; |i| {
                <span class="tok-kw">try</span> self.resolveCopyOnWrite(allocator);
                self.current_row.cfa = .{
                    .register = i.register,
                    .rule = .{ .val_offset = <span class="tok-builtin">@intCast</span>(i.offset) },
                };
            },
            .def_cfa_sf =&gt; |i| {
                <span class="tok-kw">try</span> self.resolveCopyOnWrite(allocator);
                self.current_row.cfa = .{
                    .register = i.register,
                    .rule = .{ .val_offset = i.offset * cie.data_alignment_factor },
                };
            },
            .def_cfa_register =&gt; |i| {
                <span class="tok-kw">try</span> self.resolveCopyOnWrite(allocator);
                <span class="tok-kw">if</span> (self.current_row.cfa.register == <span class="tok-null">null</span> <span class="tok-kw">or</span> self.current_row.cfa.rule != .val_offset) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidOperation;
                self.current_row.cfa.register = i.register;
            },
            .def_cfa_offset =&gt; |i| {
                <span class="tok-kw">try</span> self.resolveCopyOnWrite(allocator);
                <span class="tok-kw">if</span> (self.current_row.cfa.register == <span class="tok-null">null</span> <span class="tok-kw">or</span> self.current_row.cfa.rule != .val_offset) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidOperation;
                self.current_row.cfa.rule = .{
                    .val_offset = <span class="tok-builtin">@intCast</span>(i.offset),
                };
            },
            .def_cfa_offset_sf =&gt; |i| {
                <span class="tok-kw">try</span> self.resolveCopyOnWrite(allocator);
                <span class="tok-kw">if</span> (self.current_row.cfa.register == <span class="tok-null">null</span> <span class="tok-kw">or</span> self.current_row.cfa.rule != .val_offset) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidOperation;
                self.current_row.cfa.rule = .{
                    .val_offset = i.offset * cie.data_alignment_factor,
                };
            },
            .def_cfa_expression =&gt; |i| {
                <span class="tok-kw">try</span> self.resolveCopyOnWrite(allocator);
                self.current_row.cfa.register = <span class="tok-null">undefined</span>;
                self.current_row.cfa.rule = .{
                    .expression = i.block,
                };
            },
            .expression =&gt; |i| {
                <span class="tok-kw">try</span> self.resolveCopyOnWrite(allocator);
                <span class="tok-kw">const</span> column = <span class="tok-kw">try</span> self.getOrAddColumn(allocator, i.register);
                column.rule = .{
                    .expression = i.block,
                };
            },
            .val_offset =&gt; |i| {
                <span class="tok-kw">try</span> self.resolveCopyOnWrite(allocator);
                <span class="tok-kw">const</span> column = <span class="tok-kw">try</span> self.getOrAddColumn(allocator, i.register);
                column.rule = .{
                    .val_offset = <span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-builtin">@intCast</span>(i.offset)) * cie.data_alignment_factor,
                };
            },
            .val_offset_sf =&gt; |i| {
                <span class="tok-kw">try</span> self.resolveCopyOnWrite(allocator);
                <span class="tok-kw">const</span> column = <span class="tok-kw">try</span> self.getOrAddColumn(allocator, i.register);
                column.rule = .{
                    .val_offset = i.offset * cie.data_alignment_factor,
                };
            },
            .val_expression =&gt; |i| {
                <span class="tok-kw">try</span> self.resolveCopyOnWrite(allocator);
                <span class="tok-kw">const</span> column = <span class="tok-kw">try</span> self.getOrAddColumn(allocator, i.register);
                column.rule = .{
                    .val_expression = i.block,
                };
            },
        }

        <span class="tok-kw">return</span> prev_row;
    }
};

<span class="tok-comment">/// Returns the ABI-defined default value this register has in the unwinding table</span>
<span class="tok-comment">/// before running any of the CIE instructions. The DWARF spec defines these as having</span>
<span class="tok-comment">/// the .undefined rule by default, but allows ABI authors to override that.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">getRegDefaultValue</span>(reg_number: <span class="tok-type">u8</span>, context: *<a href="std.debug.SelfInfo.UnwindContext.html">UnwindContext</a>, out: []<span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>) {
        .aarch64, .aarch64_be =&gt; {<span class="tok-comment">
            // Callee-saved registers are initialized as if they had the .same_value rule
            </span><span class="tok-kw">if</span> (reg_number &gt;= <span class="tok-number">19</span> <span class="tok-kw">and</span> reg_number &lt;= <span class="tok-number">28</span>) {
                <span class="tok-kw">const</span> src = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(context.thread_context, reg_number, context.reg_context);
                <span class="tok-kw">if</span> (src.len != out.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.RegisterSizeMismatch;
                <span class="tok-builtin">@memcpy</span>(out, src);
                <span class="tok-kw">return</span>;
            }
        },
        <span class="tok-kw">else</span> =&gt; {},
    }

    <span class="tok-builtin">@memset</span>(out, <span class="tok-null">undefined</span>);
}

<span class="tok-comment">/// Since register rules are applied (usually) during a panic,</span>
<span class="tok-comment">/// checked addition / subtraction is used so that we can return</span>
<span class="tok-comment">/// an error and fall back to FP-based unwinding.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">applyOffset</span>(base: <span class="tok-type">usize</span>, offset: <span class="tok-type">i64</span>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (offset &gt;= <span class="tok-number">0</span>)
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(<span class="tok-type">usize</span>, base, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(offset)))
    <span class="tok-kw">else</span>
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.sub">sub</a>(<span class="tok-type">usize</span>, base, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(-offset)));
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
