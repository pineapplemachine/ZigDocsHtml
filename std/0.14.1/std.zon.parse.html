<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">zon</a></li><li><a href="std.zon.parse.html" class="active">parse</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.zon.parse" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.zon.parse</span><a href="#src.zig-std.zon.parse">[src]</a></h1><div class="tldDocs"><p>The simplest way to parse ZON at runtime is to use <code><a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a></code>. If you need to parse ZON at
compile time, you may use <code>@import</code>.</p>
<p>Parsing from individual Zoir nodes is also available:</p>
<ul>
<li><code><a href="std.zon.parse.html#std.zon.parse.fromZoir">fromZoir</a></code></li>
<li><code><a href="std.zon.parse.html#std.zon.parse.fromZoirNode">fromZoirNode</a></code></li>
</ul>
<p>For lower level control, it is possible to operate on <code><a href="std.zig.Zoir.html">std.zig.Zoir</a></code> directly.</p>
</div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.zon.parse.Options.html">std.zon.parse.Options</a></li><li><a href="std.zon.parse.Error.html">std.zon.parse.Error</a></li><li><a href="std.zon.parse.Status.html">std.zon.parse.Status</a></li></ul></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.zon.parse.fromSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromSlice</span><a href="#src.zig-std.zon.parse.fromSlice">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromSlice</span>( T: <span class="tok-type">type</span>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, source: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, status: ?*<a href="std.zon.parse.Status.html">Status</a>, options: <a href="std.zon.parse.Options.html">Options</a>, ) <span class="tok-kw">error</span>{ OutOfMemory, ParseZon }!T</code></pre></div><div class="tldDocs"><p>Parses the given slice as ZON.</p>
<p>Returns <code>error.OutOfMemory</code> on allocation failure, or <code>error.ParseZon</code> error if the ZON is
invalid or can not be deserialized into type <code>T</code>.</p>
<p>When the parser returns <code>error.ParseZon</code>, it will also store a human readable explanation in
<code>status</code> if non null. If status is not null, it must be initialized to <code>.{}</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre><div class="fieldDocs"><p>The type to deserialize into. May not be or contain any of the following types:</p>
<ul>
<li>Any comptime-only type, except in a comptime field</li>
<li><code>type</code></li>
<li><code>void</code>, except as a union payload</li>
<li><code>noreturn</code></li>
<li>An error set/error union</li>
<li>A many-pointer or C-pointer</li>
<li>An opaque type, including <code>anyopaque</code></li>
<li>An async frame type, including <code>anyframe</code> and <code>anyframe-&gt;T</code></li>
<li>A function</li>
</ul>
<p>All other types are valid. Unsupported types will fail at compile time.</p>
</div></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>source: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>status: ?*<a href="std.zon.parse.Status.html">Status</a></code></pre></div><div><pre><code>options: <a href="std.zon.parse.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zon.parse.fromSlice">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromSlice</span>(
    <span class="tok-comment">/// The type to deserialize into. May not be or contain any of the following types:</span>
    <span class="tok-comment">/// * Any comptime-only type, except in a comptime field</span>
    <span class="tok-comment">/// * `type`</span>
    <span class="tok-comment">/// * `void`, except as a union payload</span>
    <span class="tok-comment">/// * `noreturn`</span>
    <span class="tok-comment">/// * An error set/error union</span>
    <span class="tok-comment">/// * A many-pointer or C-pointer</span>
    <span class="tok-comment">/// * An opaque type, including `anyopaque`</span>
    <span class="tok-comment">/// * An async frame type, including `anyframe` and `anyframe-&gt;T`</span>
    <span class="tok-comment">/// * A function</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// All other types are valid. Unsupported types will fail at compile time.</span>
    T: <span class="tok-type">type</span>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    source: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    status: ?*<a href="std.zon.parse.Status.html">Status</a>,
    options: <a href="std.zon.parse.Options.html">Options</a>,
) <span class="tok-kw">error</span>{ OutOfMemory, ParseZon }!T {
    <span class="tok-kw">if</span> (status) |s| s.assertEmpty();

    <span class="tok-kw">var</span> ast = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.parse">parse</a>(gpa, source, .zon);
    <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (status == <span class="tok-null">null</span>) ast.deinit(gpa);
    <span class="tok-kw">if</span> (status) |s| s.ast = ast;<span class="tok-comment">

    // If there's no status, Zoir exists for the lifetime of this function. If there is a status,
    // ownership is transferred to status.
    </span><span class="tok-kw">var</span> zoir = <span class="tok-kw">try</span> <a href="std.zig.ZonGen.html">ZonGen</a>.<a href="std.zig.ZonGen.html#std.zig.ZonGen.generate">generate</a>(gpa, ast, .{ .parse_str_lits = <span class="tok-null">false</span> });
    <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (status == <span class="tok-null">null</span>) zoir.deinit(gpa);

    <span class="tok-kw">if</span> (status) |s| s.* = .{};
    <span class="tok-kw">return</span> <a href="std.zon.parse.html#std.zon.parse.fromZoir">fromZoir</a>(T, gpa, ast, zoir, status, options);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zon.parse.fromZoir" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromZoir</span><a href="#src.zig-std.zon.parse.fromZoir">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromZoir</span>( T: <span class="tok-type">type</span>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ast: <a href="std.zig.Ast.html">Ast</a>, zoir: <a href="std.zig.Zoir.html">Zoir</a>, status: ?*<a href="std.zon.parse.Status.html">Status</a>, options: <a href="std.zon.parse.Options.html">Options</a>, ) <span class="tok-kw">error</span>{ OutOfMemory, ParseZon }!T</code></pre></div><div class="tldDocs"><p>Like <code><a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a></code>, but operates on <code><a href="std.zig.Zoir.html">Zoir</a></code> instead of ZON source.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ast: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>zoir: <a href="std.zig.Zoir.html">Zoir</a></code></pre></div><div><pre><code>status: ?*<a href="std.zon.parse.Status.html">Status</a></code></pre></div><div><pre><code>options: <a href="std.zon.parse.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zon.parse.fromZoir">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromZoir</span>(
    T: <span class="tok-type">type</span>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    ast: <a href="std.zig.Ast.html">Ast</a>,
    zoir: <a href="std.zig.Zoir.html">Zoir</a>,
    status: ?*<a href="std.zon.parse.Status.html">Status</a>,
    options: <a href="std.zon.parse.Options.html">Options</a>,
) <span class="tok-kw">error</span>{ OutOfMemory, ParseZon }!T {
    <span class="tok-kw">return</span> <a href="std.zon.parse.html#std.zon.parse.fromZoirNode">fromZoirNode</a>(T, gpa, ast, zoir, .root, status, options);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zon.parse.fromZoirNode" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromZoirNode</span><a href="#src.zig-std.zon.parse.fromZoirNode">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromZoirNode</span>( T: <span class="tok-type">type</span>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ast: <a href="std.zig.Ast.html">Ast</a>, zoir: <a href="std.zig.Zoir.html">Zoir</a>, node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>, status: ?*<a href="std.zon.parse.Status.html">Status</a>, options: <a href="std.zon.parse.Options.html">Options</a>, ) <span class="tok-kw">error</span>{ OutOfMemory, ParseZon }!T</code></pre></div><div class="tldDocs"><p>Like <code><a href="std.zon.parse.html#std.zon.parse.fromZoir">fromZoir</a></code>, but the parse starts on <code>node</code> instead of root.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ast: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>zoir: <a href="std.zig.Zoir.html">Zoir</a></code></pre></div><div><pre><code>node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a></code></pre></div><div><pre><code>status: ?*<a href="std.zon.parse.Status.html">Status</a></code></pre></div><div><pre><code>options: <a href="std.zon.parse.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zon.parse.fromZoirNode">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromZoirNode</span>(
    T: <span class="tok-type">type</span>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    ast: <a href="std.zig.Ast.html">Ast</a>,
    zoir: <a href="std.zig.Zoir.html">Zoir</a>,
    node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>,
    status: ?*<a href="std.zon.parse.Status.html">Status</a>,
    options: <a href="std.zon.parse.Options.html">Options</a>,
) <span class="tok-kw">error</span>{ OutOfMemory, ParseZon }!T {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(T));

    <span class="tok-kw">if</span> (status) |s| {
        s.assertEmpty();
        s.ast = ast;
        s.zoir = zoir;
    }

    <span class="tok-kw">if</span> (zoir.hasCompileErrors()) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ParseZon;
    }

    <span class="tok-kw">var</span> parser: <a href="std.zon.parse.Parser.html">Parser</a> = .{
        .gpa = gpa,
        .ast = ast,
        .zoir = zoir,
        .options = options,
        .status = status,
    };

    <span class="tok-kw">return</span> parser.parseExpr(T, node);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zon.parse.free" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">free</span><a href="#src.zig-std.zon.parse.free">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">free</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, value: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Frees ZON values.</p>
<p>Provided for convenience, you may also free these values on your own using the same allocator
passed into the parser.</p>
<p>Asserts at comptime that sufficient information is available via the type system to free this
value. Untagged unions, for example, will fail this assert.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zon.parse.free">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">free</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, value: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> Value = <span class="tok-builtin">@TypeOf</span>(value);

    _ = <a href="std.zon.parse.html#std.zon.parse.valid_types">valid_types</a>;
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(Value)) {
        .<span class="tok-type">bool</span>, .int, .float, .@&quot;enum&quot; =&gt; {},
        .pointer =&gt; |pointer| {
            <span class="tok-kw">switch</span> (pointer.size) {
                .one =&gt; {
                    <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, value.*);
                    gpa.destroy(value);
                },
                .slice =&gt; {
                    <span class="tok-kw">for</span> (value) |item| {
                        <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, item);
                    }
                    gpa.free(value);
                },
                .many, .c =&gt; <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>,
            }
        },
        .array =&gt; <span class="tok-kw">for</span> (value) |item| {
            <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, item);
        },
        .@&quot;struct&quot; =&gt; |@&quot;struct&quot;| <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (@&quot;struct&quot;.fields) |field| {
            <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, <span class="tok-builtin">@field</span>(value, field.name));
        },
        .@&quot;union&quot; =&gt; |@&quot;union&quot;| <span class="tok-kw">if</span> (@&quot;union&quot;.tag_type == <span class="tok-null">null</span>) {
            <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(Value)) <span class="tok-kw">unreachable</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">switch</span> (value) {
            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |_, tag| {
                <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, <span class="tok-builtin">@field</span>(value, <span class="tok-builtin">@tagName</span>(tag)));
            },
        },
        .optional =&gt; <span class="tok-kw">if</span> (value) |some| {
            <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, some);
        },
        .vector =&gt; |vector| <span class="tok-kw">for</span> (<span class="tok-number">0</span>..vector.len) |i| <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, value[i]),
        .<span class="tok-type">void</span> =&gt; {},
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>,
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.zon.parse">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! The simplest way to parse ZON at runtime is to use `fromSlice`. If you need to parse ZON at</span>
<span class="tok-comment">//! compile time, you may use `@import`.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! Parsing from individual Zoir nodes is also available:</span>
<span class="tok-comment">//! * `fromZoir`</span>
<span class="tok-comment">//! * `fromZoirNode`</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! For lower level control, it is possible to operate on `std.zig.Zoir` directly.</span>

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> Allocator = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> Ast = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Ast.html">Ast</a>;
<span class="tok-kw">const</span> Zoir = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Zoir.html">Zoir</a>;
<span class="tok-kw">const</span> ZonGen = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.ZonGen.html">ZonGen</a>;
<span class="tok-kw">const</span> TokenIndex = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>;
<span class="tok-kw">const</span> Base = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.number_literal.html">number_literal</a>.<a href="std.zig.number_literal.Base.html">Base</a>;
<span class="tok-kw">const</span> StrLitErr = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.string_literal.html">string_literal</a>.<a href="std.zig.string_literal.Error.html">Error</a>;
<span class="tok-kw">const</span> NumberLiteralError = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.number_literal.html">number_literal</a>.<a href="std.zig.number_literal.Error.html">Error</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> ArrayListUnmanaged = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>;

<span class="tok-comment">/// Rename when adding or removing support for a type.</span>
<span class="tok-kw">const</span> valid_types = {};

<span class="tok-comment">/// Configuration for the runtime parser.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Options = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// If true, unknown fields do not error.</span>
    ignore_unknown_fields: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    <span class="tok-comment">/// If true, the parser cleans up partially parsed values on error. This requires some extra</span>
    <span class="tok-comment">/// bookkeeping, so you may want to turn it off if you don't need this feature (e.g. because</span>
    <span class="tok-comment">/// you're using arena allocation.)</span>
    free_on_error: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    zoir: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.CompileError.html">CompileError</a>,
    type_check: <a href="std.zon.parse.Error.html">Error</a>.<a href="std.zon.parse.Error.TypeCheckFailure.html">TypeCheckFailure</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Note = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        zoir: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.CompileError.html">CompileError</a>.<a href="std.zig.Zoir.CompileError.Note.html">Note</a>,
        type_check: <a href="std.zon.parse.Error.TypeCheckFailure.html">TypeCheckFailure</a>.<a href="std.zon.parse.Error.TypeCheckFailure.Note.html">Note</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {
            index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
            err: <a href="std.zon.parse.Error.html">Error</a>,
            status: *<span class="tok-kw">const</span> <a href="std.zon.parse.Status.html">Status</a>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<span class="tok-builtin">@This</span>()) ?<a href="std.zon.parse.Error.Note.html">Note</a> {
                <span class="tok-kw">switch</span> (self.err) {
                    .zoir =&gt; |err| {
                        <span class="tok-kw">if</span> (self.index &gt;= err.note_count) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                        <span class="tok-kw">const</span> zoir = self.status.zoir.?;
                        <span class="tok-kw">const</span> note = err.getNotes(zoir)[self.index];
                        self.index += <span class="tok-number">1</span>;
                        <span class="tok-kw">return</span> .{ .zoir = note };
                    },
                    .type_check =&gt; |err| {
                        <span class="tok-kw">if</span> (self.index &gt;= err.getNoteCount()) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                        <span class="tok-kw">const</span> note = err.getNote(self.index);
                        self.index += <span class="tok-number">1</span>;
                        <span class="tok-kw">return</span> .{ .type_check = note };
                    },
                }
            }
        };

        <span class="tok-kw">fn</span> <span class="tok-fn">formatMessage</span>(
            self: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            <span class="tok-kw">comptime</span> f: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
            writer: <span class="tok-kw">anytype</span>,
        ) !<span class="tok-type">void</span> {
            _ = f;
            _ = options;<span class="tok-comment">

            // Just writes the string for now, but we're keeping this behind a formatter so we have
            // the option to extend it in the future to print more advanced messages (like `Error`
            // does) without breaking the API.
            </span><span class="tok-kw">try</span> writer.writeAll(self);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmtMessage</span>(self: <a href="std.zon.parse.Error.Note.html">Note</a>, status: *<span class="tok-kw">const</span> <a href="std.zon.parse.Status.html">Status</a>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.Formatter">Formatter</a>(<a href="std.zon.parse.Error.Note.html">Note</a>.<a href="std.zon.parse.Error.Note.html#std.zon.parse.Error.Note.formatMessage">formatMessage</a>) {
            <span class="tok-kw">return</span> .{ .data = <span class="tok-kw">switch</span> (self) {
                .zoir =&gt; |note| note.msg.get(status.zoir.?),
                .type_check =&gt; |note| note.msg,
            } };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLocation</span>(self: <a href="std.zon.parse.Error.Note.html">Note</a>, status: *<span class="tok-kw">const</span> <a href="std.zon.parse.Status.html">Status</a>) <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Location.html">Location</a> {
            <span class="tok-kw">const</span> ast = status.ast.?;
            <span class="tok-kw">switch</span> (self) {
                .zoir =&gt; |note| <span class="tok-kw">return</span> <a href="std.zon.parse.Error.html#std.zon.parse.Error.zoirErrorLocation">zoirErrorLocation</a>(ast, note.token, note.node_or_offset),
                .type_check =&gt; |note| <span class="tok-kw">return</span> ast.tokenLocation(note.offset, note.token),
            }
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {
        index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
        status: *<span class="tok-kw">const</span> <a href="std.zon.parse.Status.html">Status</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<span class="tok-builtin">@This</span>()) ?<a href="std.zon.parse.Error.html">Error</a> {
            <span class="tok-kw">const</span> zoir = self.status.zoir <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;

            <span class="tok-kw">if</span> (self.index &lt; zoir.compile_errors.len) {
                <span class="tok-kw">const</span> result: <a href="std.zon.parse.Error.html">Error</a> = .{ .zoir = zoir.compile_errors[self.index] };
                self.index += <span class="tok-number">1</span>;
                <span class="tok-kw">return</span> result;
            }

            <span class="tok-kw">if</span> (self.status.type_check) |err| {
                <span class="tok-kw">if</span> (self.index == zoir.compile_errors.len) {
                    <span class="tok-kw">const</span> result: <a href="std.zon.parse.Error.html">Error</a> = .{ .type_check = err };
                    self.index += <span class="tok-number">1</span>;
                    <span class="tok-kw">return</span> result;
                }
            }

            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }
    };

    <span class="tok-kw">const</span> TypeCheckFailure = <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Note = <span class="tok-kw">struct</span> {
            token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            offset: <span class="tok-type">u32</span>,
            msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            owned: <span class="tok-type">bool</span>,

            <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <span class="tok-builtin">@This</span>(), gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
                <span class="tok-kw">if</span> (self.owned) gpa.free(self.msg);
            }
        };

        message: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        owned: <span class="tok-type">bool</span>,
        token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        offset: <span class="tok-type">u32</span>,
        note: ?<span class="tok-builtin">@This</span>().Note,

        <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <span class="tok-builtin">@This</span>(), gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (self.note) |note| note.deinit(gpa);
            <span class="tok-kw">if</span> (self.owned) gpa.free(self.message);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getNoteCount</span>(self: <span class="tok-builtin">@This</span>()) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@intFromBool</span>(self.note != <span class="tok-null">null</span>);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getNote</span>(self: <span class="tok-builtin">@This</span>(), index: <span class="tok-type">usize</span>) <span class="tok-builtin">@This</span>().Note {
            <a href="std.debug.html#std.debug.assert">assert</a>(index == <span class="tok-number">0</span>);
            <span class="tok-kw">return</span> self.note.?;
        }
    };

    <span class="tok-kw">const</span> FormatMessage = <span class="tok-kw">struct</span> {
        err: <a href="std.zon.parse.Error.html">Error</a>,
        status: *<span class="tok-kw">const</span> <a href="std.zon.parse.Status.html">Status</a>,
    };

    <span class="tok-kw">fn</span> <span class="tok-fn">formatMessage</span>(
        self: <a href="std.zon.parse.Error.FormatMessage.html">FormatMessage</a>,
        <span class="tok-kw">comptime</span> f: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) !<span class="tok-type">void</span> {
        _ = f;
        _ = options;
        <span class="tok-kw">switch</span> (self.err) {
            .zoir =&gt; |err| <span class="tok-kw">try</span> writer.writeAll(err.msg.get(self.status.zoir.?)),
            .type_check =&gt; |tc| <span class="tok-kw">try</span> writer.writeAll(tc.message),
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmtMessage</span>(self: <span class="tok-builtin">@This</span>(), status: *<span class="tok-kw">const</span> <a href="std.zon.parse.Status.html">Status</a>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.Formatter">Formatter</a>(<a href="std.zon.parse.Error.html#std.zon.parse.Error.formatMessage">formatMessage</a>) {
        <span class="tok-kw">return</span> .{ .data = .{
            .err = self,
            .status = status,
        } };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLocation</span>(self: <span class="tok-builtin">@This</span>(), status: *<span class="tok-kw">const</span> <a href="std.zon.parse.Status.html">Status</a>) <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Location.html">Location</a> {
        <span class="tok-kw">const</span> ast = status.ast.?;
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
            .zoir =&gt; |err| <span class="tok-kw">return</span> <a href="std.zon.parse.Error.html#std.zon.parse.Error.zoirErrorLocation">zoirErrorLocation</a>(
                status.ast.?,
                err.token,
                err.node_or_offset,
            ),
            .type_check =&gt; |err| <span class="tok-kw">return</span> ast.tokenLocation(err.offset, err.token),
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterateNotes</span>(self: <span class="tok-builtin">@This</span>(), status: *<span class="tok-kw">const</span> <a href="std.zon.parse.Status.html">Status</a>) <a href="std.zon.parse.Error.Note.html">Note</a>.<a href="std.zon.parse.Error.Note.Iterator.html">Iterator</a> {
        <span class="tok-kw">return</span> .{ .err = self, .status = status };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">zoirErrorLocation</span>(ast: <a href="std.zig.Ast.html">Ast</a>, maybe_token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>, node_or_offset: <span class="tok-type">u32</span>) <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Location.html">Location</a> {
        <span class="tok-kw">if</span> (maybe_token == <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.CompileError.html">CompileError</a>.<a href="std.zig.Zoir.CompileError.html#std.zig.Zoir.CompileError.invalid_token">invalid_token</a>) {
            <span class="tok-kw">const</span> main_tokens = ast.nodes.items(.main_token);
            <span class="tok-kw">const</span> ast_node = node_or_offset;
            <span class="tok-kw">const</span> token = main_tokens[ast_node];
            <span class="tok-kw">return</span> ast.tokenLocation(<span class="tok-number">0</span>, token);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">var</span> location = ast.tokenLocation(<span class="tok-number">0</span>, maybe_token);
            location.column += node_or_offset;
            <span class="tok-kw">return</span> location;
        }
    }
};

<span class="tok-comment">/// Information about the success or failure of a parse.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Status = <span class="tok-kw">struct</span> {
    ast: ?<a href="std.zig.Ast.html">Ast</a> = <span class="tok-null">null</span>,
    zoir: ?<a href="std.zig.Zoir.html">Zoir</a> = <span class="tok-null">null</span>,
    type_check: ?<a href="std.zon.parse.Error.html">Error</a>.<a href="std.zon.parse.Error.TypeCheckFailure.html">TypeCheckFailure</a> = <span class="tok-null">null</span>,

    <span class="tok-kw">fn</span> <span class="tok-fn">assertEmpty</span>(self: <a href="std.zon.parse.Status.html">Status</a>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.ast == <span class="tok-null">null</span>);
        <a href="std.debug.html#std.debug.assert">assert</a>(self.zoir == <span class="tok-null">null</span>);
        <a href="std.debug.html#std.debug.assert">assert</a>(self.type_check == <span class="tok-null">null</span>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.zon.parse.Status.html">Status</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (self.ast) |*ast| ast.deinit(gpa);
        <span class="tok-kw">if</span> (self.zoir) |*zoir| zoir.deinit(gpa);
        <span class="tok-kw">if</span> (self.type_check) |tc| tc.deinit(gpa);
        self.* = <span class="tok-null">undefined</span>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterateErrors</span>(self: *<span class="tok-kw">const</span> <a href="std.zon.parse.Status.html">Status</a>) <a href="std.zon.parse.Error.html">Error</a>.<a href="std.zon.parse.Error.Iterator.html">Iterator</a> {
        <span class="tok-kw">return</span> .{ .status = self };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>(),
        <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) !<span class="tok-type">void</span> {
        _ = fmt;
        _ = options;
        <span class="tok-kw">var</span> errors = self.iterateErrors();
        <span class="tok-kw">while</span> (errors.next()) |err| {
            <span class="tok-kw">const</span> loc = err.getLocation(self);
            <span class="tok-kw">const</span> msg = err.fmtMessage(self);
            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{}:{}: error: {}\n&quot;</span>, .{ loc.line + <span class="tok-number">1</span>, loc.column + <span class="tok-number">1</span>, msg });

            <span class="tok-kw">var</span> notes = err.iterateNotes(self);
            <span class="tok-kw">while</span> (notes.next()) |note| {
                <span class="tok-kw">const</span> note_loc = note.getLocation(self);
                <span class="tok-kw">const</span> note_msg = note.fmtMessage(self);
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{}:{}: note: {s}\n&quot;</span>, .{
                    note_loc.line + <span class="tok-number">1</span>,
                    note_loc.column + <span class="tok-number">1</span>,
                    note_msg,
                });
            }
        }
    }
};

<span class="tok-comment">/// Parses the given slice as ZON.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Returns `error.OutOfMemory` on allocation failure, or `error.ParseZon` error if the ZON is</span>
<span class="tok-comment">/// invalid or can not be deserialized into type `T`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// When the parser returns `error.ParseZon`, it will also store a human readable explanation in</span>
<span class="tok-comment">/// `status` if non null. If status is not null, it must be initialized to `.{}`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromSlice</span>(
    <span class="tok-comment">/// The type to deserialize into. May not be or contain any of the following types:</span>
    <span class="tok-comment">/// * Any comptime-only type, except in a comptime field</span>
    <span class="tok-comment">/// * `type`</span>
    <span class="tok-comment">/// * `void`, except as a union payload</span>
    <span class="tok-comment">/// * `noreturn`</span>
    <span class="tok-comment">/// * An error set/error union</span>
    <span class="tok-comment">/// * A many-pointer or C-pointer</span>
    <span class="tok-comment">/// * An opaque type, including `anyopaque`</span>
    <span class="tok-comment">/// * An async frame type, including `anyframe` and `anyframe-&gt;T`</span>
    <span class="tok-comment">/// * A function</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// All other types are valid. Unsupported types will fail at compile time.</span>
    T: <span class="tok-type">type</span>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    source: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    status: ?*<a href="std.zon.parse.Status.html">Status</a>,
    options: <a href="std.zon.parse.Options.html">Options</a>,
) <span class="tok-kw">error</span>{ OutOfMemory, ParseZon }!T {
    <span class="tok-kw">if</span> (status) |s| s.assertEmpty();

    <span class="tok-kw">var</span> ast = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.parse">parse</a>(gpa, source, .zon);
    <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (status == <span class="tok-null">null</span>) ast.deinit(gpa);
    <span class="tok-kw">if</span> (status) |s| s.ast = ast;<span class="tok-comment">

    // If there's no status, Zoir exists for the lifetime of this function. If there is a status,
    // ownership is transferred to status.
    </span><span class="tok-kw">var</span> zoir = <span class="tok-kw">try</span> <a href="std.zig.ZonGen.html">ZonGen</a>.<a href="std.zig.ZonGen.html#std.zig.ZonGen.generate">generate</a>(gpa, ast, .{ .parse_str_lits = <span class="tok-null">false</span> });
    <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (status == <span class="tok-null">null</span>) zoir.deinit(gpa);

    <span class="tok-kw">if</span> (status) |s| s.* = .{};
    <span class="tok-kw">return</span> <a href="std.zon.parse.html#std.zon.parse.fromZoir">fromZoir</a>(T, gpa, ast, zoir, status, options);
}

<span class="tok-comment">/// Like `fromSlice`, but operates on `Zoir` instead of ZON source.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromZoir</span>(
    T: <span class="tok-type">type</span>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    ast: <a href="std.zig.Ast.html">Ast</a>,
    zoir: <a href="std.zig.Zoir.html">Zoir</a>,
    status: ?*<a href="std.zon.parse.Status.html">Status</a>,
    options: <a href="std.zon.parse.Options.html">Options</a>,
) <span class="tok-kw">error</span>{ OutOfMemory, ParseZon }!T {
    <span class="tok-kw">return</span> <a href="std.zon.parse.html#std.zon.parse.fromZoirNode">fromZoirNode</a>(T, gpa, ast, zoir, .root, status, options);
}

<span class="tok-comment">/// Like `fromZoir`, but the parse starts on `node` instead of root.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromZoirNode</span>(
    T: <span class="tok-type">type</span>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    ast: <a href="std.zig.Ast.html">Ast</a>,
    zoir: <a href="std.zig.Zoir.html">Zoir</a>,
    node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>,
    status: ?*<a href="std.zon.parse.Status.html">Status</a>,
    options: <a href="std.zon.parse.Options.html">Options</a>,
) <span class="tok-kw">error</span>{ OutOfMemory, ParseZon }!T {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(T));

    <span class="tok-kw">if</span> (status) |s| {
        s.assertEmpty();
        s.ast = ast;
        s.zoir = zoir;
    }

    <span class="tok-kw">if</span> (zoir.hasCompileErrors()) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ParseZon;
    }

    <span class="tok-kw">var</span> parser: <a href="std.zon.parse.Parser.html">Parser</a> = .{
        .gpa = gpa,
        .ast = ast,
        .zoir = zoir,
        .options = options,
        .status = status,
    };

    <span class="tok-kw">return</span> parser.parseExpr(T, node);
}

<span class="tok-comment">/// Frees ZON values.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Provided for convenience, you may also free these values on your own using the same allocator</span>
<span class="tok-comment">/// passed into the parser.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Asserts at comptime that sufficient information is available via the type system to free this</span>
<span class="tok-comment">/// value. Untagged unions, for example, will fail this assert.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">free</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, value: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> Value = <span class="tok-builtin">@TypeOf</span>(value);

    _ = <a href="std.zon.parse.html#std.zon.parse.valid_types">valid_types</a>;
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(Value)) {
        .<span class="tok-type">bool</span>, .int, .float, .@&quot;enum&quot; =&gt; {},
        .pointer =&gt; |pointer| {
            <span class="tok-kw">switch</span> (pointer.size) {
                .one =&gt; {
                    <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, value.*);
                    gpa.destroy(value);
                },
                .slice =&gt; {
                    <span class="tok-kw">for</span> (value) |item| {
                        <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, item);
                    }
                    gpa.free(value);
                },
                .many, .c =&gt; <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>,
            }
        },
        .array =&gt; <span class="tok-kw">for</span> (value) |item| {
            <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, item);
        },
        .@&quot;struct&quot; =&gt; |@&quot;struct&quot;| <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (@&quot;struct&quot;.fields) |field| {
            <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, <span class="tok-builtin">@field</span>(value, field.name));
        },
        .@&quot;union&quot; =&gt; |@&quot;union&quot;| <span class="tok-kw">if</span> (@&quot;union&quot;.tag_type == <span class="tok-null">null</span>) {
            <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(Value)) <span class="tok-kw">unreachable</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">switch</span> (value) {
            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |_, tag| {
                <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, <span class="tok-builtin">@field</span>(value, <span class="tok-builtin">@tagName</span>(tag)));
            },
        },
        .optional =&gt; <span class="tok-kw">if</span> (value) |some| {
            <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, some);
        },
        .vector =&gt; |vector| <span class="tok-kw">for</span> (<span class="tok-number">0</span>..vector.len) |i| <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, value[i]),
        .<span class="tok-type">void</span> =&gt; {},
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>,
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">requiresAllocator</span>(T: <span class="tok-type">type</span>) <span class="tok-type">bool</span> {
    _ = <a href="std.zon.parse.html#std.zon.parse.valid_types">valid_types</a>;
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .pointer =&gt; <span class="tok-null">true</span>,
        .array =&gt; |array| <span class="tok-kw">return</span> array.len &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> <a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(array.child),
        .@&quot;struct&quot; =&gt; |@&quot;struct&quot;| <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (@&quot;struct&quot;.fields) |field| {
            <span class="tok-kw">if</span> (<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(field.<span class="tok-type">type</span>)) {
                <span class="tok-kw">break</span> <span class="tok-null">true</span>;
            }
        } <span class="tok-kw">else</span> <span class="tok-null">false</span>,
        .@&quot;union&quot; =&gt; |@&quot;union&quot;| <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (@&quot;union&quot;.fields) |field| {
            <span class="tok-kw">if</span> (<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(field.<span class="tok-type">type</span>)) {
                <span class="tok-kw">break</span> <span class="tok-null">true</span>;
            }
        } <span class="tok-kw">else</span> <span class="tok-null">false</span>,
        .optional =&gt; |optional| <a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(optional.child),
        .vector =&gt; |vector| <span class="tok-kw">return</span> vector.len &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> <a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(vector.child),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
    };
}

<span class="tok-kw">const</span> Parser = <span class="tok-kw">struct</span> {
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    ast: <a href="std.zig.Ast.html">Ast</a>,
    zoir: <a href="std.zig.Zoir.html">Zoir</a>,
    status: ?*<a href="std.zon.parse.Status.html">Status</a>,
    options: <a href="std.zon.parse.Options.html">Options</a>,

    <span class="tok-kw">fn</span> <span class="tok-fn">parseExpr</span>(self: *<span class="tok-builtin">@This</span>(), T: <span class="tok-type">type</span>, node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>) <span class="tok-kw">error</span>{ ParseZon, OutOfMemory }!T {
        <span class="tok-kw">return</span> self.parseExprInner(T, node) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WrongType =&gt; <span class="tok-kw">return</span> self.failExpectedType(T, node),
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseExprInner</span>(
        self: *<span class="tok-builtin">@This</span>(),
        T: <span class="tok-type">type</span>,
        node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>,
    ) <span class="tok-kw">error</span>{ ParseZon, OutOfMemory, WrongType }!T {
        <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
            .optional =&gt; |optional| <span class="tok-kw">if</span> (node.get(self.zoir) == .<span class="tok-null">null</span>) {
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.parseExprInner(optional.child, node);
            },
            .<span class="tok-type">bool</span> =&gt; <span class="tok-kw">return</span> self.parseBool(node),
            .int =&gt; <span class="tok-kw">return</span> self.parseInt(T, node),
            .float =&gt; <span class="tok-kw">return</span> self.parseFloat(T, node),
            .@&quot;enum&quot; =&gt; <span class="tok-kw">return</span> self.parseEnumLiteral(T, node),
            .pointer =&gt; |pointer| <span class="tok-kw">switch</span> (pointer.size) {
                .one =&gt; {
                    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.gpa.create(pointer.child);
                    <span class="tok-kw">errdefer</span> self.gpa.destroy(result);
                    result.* = <span class="tok-kw">try</span> self.parseExprInner(pointer.child, node);
                    <span class="tok-kw">return</span> result;
                },
                .slice =&gt; <span class="tok-kw">return</span> self.parseSlicePointer(T, node),
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>,
            },
            .array =&gt; <span class="tok-kw">return</span> self.parseArray(T, node),
            .@&quot;struct&quot; =&gt; |@&quot;struct&quot;| <span class="tok-kw">if</span> (@&quot;struct&quot;.is_tuple)
                <span class="tok-kw">return</span> self.parseTuple(T, node)
            <span class="tok-kw">else</span>
                <span class="tok-kw">return</span> self.parseStruct(T, node),
            .@&quot;union&quot; =&gt; <span class="tok-kw">return</span> self.parseUnion(T, node),
            .vector =&gt; <span class="tok-kw">return</span> self.parseVector(T, node),

            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>,
        }
    }

    <span class="tok-comment">/// Prints a message of the form `expected T` where T is first converted to a ZON type. For</span>
    <span class="tok-comment">/// example, `**?**u8` becomes `?u8`, and types that involve user specified type names are just</span>
    <span class="tok-comment">/// referred to by the type of container.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">failExpectedType</span>(
        self: <span class="tok-builtin">@This</span>(),
        T: <span class="tok-type">type</span>,
        node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>,
    ) <span class="tok-kw">error</span>{ ParseZon, OutOfMemory } {
        <span class="tok-builtin">@branchHint</span>(.cold);
        <span class="tok-kw">return</span> self.failExpectedTypeInner(T, <span class="tok-null">false</span>, node);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">failExpectedTypeInner</span>(
        self: <span class="tok-builtin">@This</span>(),
        T: <span class="tok-type">type</span>,
        opt: <span class="tok-type">bool</span>,
        node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>,
    ) <span class="tok-kw">error</span>{ ParseZon, OutOfMemory } {
        _ = <a href="std.zon.parse.html#std.zon.parse.valid_types">valid_types</a>;
        <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
            .@&quot;struct&quot; =&gt; |@&quot;struct&quot;| <span class="tok-kw">if</span> (@&quot;struct&quot;.is_tuple) {
                <span class="tok-kw">if</span> (opt) {
                    <span class="tok-kw">return</span> self.failNode(node, <span class="tok-str">&quot;expected optional tuple&quot;</span>);
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">return</span> self.failNode(node, <span class="tok-str">&quot;expected tuple&quot;</span>);
                }
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">if</span> (opt) {
                    <span class="tok-kw">return</span> self.failNode(node, <span class="tok-str">&quot;expected optional struct&quot;</span>);
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">return</span> self.failNode(node, <span class="tok-str">&quot;expected struct&quot;</span>);
                }
            },
            .@&quot;union&quot; =&gt; <span class="tok-kw">if</span> (opt) {
                <span class="tok-kw">return</span> self.failNode(node, <span class="tok-str">&quot;expected optional union&quot;</span>);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> self.failNode(node, <span class="tok-str">&quot;expected union&quot;</span>);
            },
            .array =&gt; <span class="tok-kw">if</span> (opt) {
                <span class="tok-kw">return</span> self.failNode(node, <span class="tok-str">&quot;expected optional array&quot;</span>);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> self.failNode(node, <span class="tok-str">&quot;expected array&quot;</span>);
            },
            .pointer =&gt; |pointer| <span class="tok-kw">switch</span> (pointer.size) {
                .one =&gt; <span class="tok-kw">return</span> self.failExpectedTypeInner(pointer.child, opt, node),
                .slice =&gt; {
                    <span class="tok-kw">if</span> (pointer.child == <span class="tok-type">u8</span> <span class="tok-kw">and</span>
                        pointer.is_const <span class="tok-kw">and</span>
                        (pointer.sentinel() == <span class="tok-null">null</span> <span class="tok-kw">or</span> pointer.sentinel() == <span class="tok-number">0</span>) <span class="tok-kw">and</span>
                        pointer.alignment == <span class="tok-number">1</span>)
                    {
                        <span class="tok-kw">if</span> (opt) {
                            <span class="tok-kw">return</span> self.failNode(node, <span class="tok-str">&quot;expected optional string&quot;</span>);
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">return</span> self.failNode(node, <span class="tok-str">&quot;expected string&quot;</span>);
                        }
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">if</span> (opt) {
                            <span class="tok-kw">return</span> self.failNode(node, <span class="tok-str">&quot;expected optional array&quot;</span>);
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">return</span> self.failNode(node, <span class="tok-str">&quot;expected array&quot;</span>);
                        }
                    }
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>,
            },
            .vector, .<span class="tok-type">bool</span>, .int, .float =&gt; <span class="tok-kw">if</span> (opt) {
                <span class="tok-kw">return</span> self.failNodeFmt(node, <span class="tok-str">&quot;expected type '{s}'&quot;</span>, .{<span class="tok-builtin">@typeName</span>(?T)});
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> self.failNodeFmt(node, <span class="tok-str">&quot;expected type '{s}'&quot;</span>, .{<span class="tok-builtin">@typeName</span>(T)});
            },
            .@&quot;enum&quot; =&gt; <span class="tok-kw">if</span> (opt) {
                <span class="tok-kw">return</span> self.failNode(node, <span class="tok-str">&quot;expected optional enum literal&quot;</span>);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> self.failNode(node, <span class="tok-str">&quot;expected enum literal&quot;</span>);
            },
            .optional =&gt; |optional| {
                <span class="tok-kw">return</span> self.failExpectedTypeInner(optional.child, <span class="tok-null">true</span>, node);
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>,
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseBool</span>(self: <span class="tok-builtin">@This</span>(), node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>) !<span class="tok-type">bool</span> {
        <span class="tok-kw">switch</span> (node.get(self.zoir)) {
            .<span class="tok-null">true</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,
            .<span class="tok-null">false</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WrongType,
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseInt</span>(self: <span class="tok-builtin">@This</span>(), T: <span class="tok-type">type</span>, node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>) !T {
        <span class="tok-kw">switch</span> (node.get(self.zoir)) {
            .int_literal =&gt; |int| <span class="tok-kw">switch</span> (int) {
                .small =&gt; |val| <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(T, val) <span class="tok-kw">orelse</span>
                    self.failCannotRepresent(T, node),
                .big =&gt; |val| <span class="tok-kw">return</span> val.toInt(T) <span class="tok-kw">catch</span>
                    self.failCannotRepresent(T, node),
            },
            .float_literal =&gt; |val| <span class="tok-kw">return</span> <a href="std.zon.parse.html#std.zon.parse.intFromFloatExact">intFromFloatExact</a>(T, val) <span class="tok-kw">orelse</span>
                self.failCannotRepresent(T, node),

            .char_literal =&gt; |val| <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(T, val) <span class="tok-kw">orelse</span>
                self.failCannotRepresent(T, node),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WrongType,
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseFloat</span>(self: <span class="tok-builtin">@This</span>(), T: <span class="tok-type">type</span>, node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>) !T {
        <span class="tok-kw">switch</span> (node.get(self.zoir)) {
            .int_literal =&gt; |int| <span class="tok-kw">switch</span> (int) {
                .small =&gt; |val| <span class="tok-kw">return</span> <span class="tok-builtin">@floatFromInt</span>(val),
                .big =&gt; |val| <span class="tok-kw">return</span> val.toFloat(T),
            },
            .float_literal =&gt; |val| <span class="tok-kw">return</span> <span class="tok-builtin">@floatCast</span>(val),
            .pos_inf =&gt; <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.inf">inf</a>(T),
            .neg_inf =&gt; <span class="tok-kw">return</span> -<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.inf">inf</a>(T),
            .nan =&gt; <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.nan">nan</a>(T),
            .char_literal =&gt; |val| <span class="tok-kw">return</span> <span class="tok-builtin">@floatFromInt</span>(val),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WrongType,
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseEnumLiteral</span>(self: <span class="tok-builtin">@This</span>(), T: <span class="tok-type">type</span>, node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>) !T {
        <span class="tok-kw">switch</span> (node.get(self.zoir)) {
            .enum_literal =&gt; |field_name| {<span class="tok-comment">
                // Create a comptime string map for the enum fields
                </span><span class="tok-kw">const</span> enum_fields = <span class="tok-builtin">@typeInfo</span>(T).@&quot;enum&quot;.fields;
                <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> kvs_list: [enum_fields.len]<span class="tok-kw">struct</span> { []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, T } = <span class="tok-null">undefined</span>;
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (enum_fields, <span class="tok-number">0</span>..) |field, i| {
                    kvs_list[i] = .{ field.name, <span class="tok-builtin">@enumFromInt</span>(field.value) };
                }
                <span class="tok-kw">const</span> enum_tags = <a href="std.html">std</a>.<a href="std.static_string_map.html#std.static_string_map.StaticStringMap">StaticStringMap</a>(T).initComptime(kvs_list);<span class="tok-comment">

                // Get the tag if it exists
                </span><span class="tok-kw">const</span> field_name_str = field_name.get(self.zoir);
                <span class="tok-kw">return</span> enum_tags.get(field_name_str) <span class="tok-kw">orelse</span>
                    self.failUnexpected(T, <span class="tok-str">&quot;enum literal&quot;</span>, node, <span class="tok-null">null</span>, field_name_str);
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WrongType,
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseSlicePointer</span>(self: *<span class="tok-builtin">@This</span>(), T: <span class="tok-type">type</span>, node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>) !T {
        <span class="tok-kw">switch</span> (node.get(self.zoir)) {
            .string_literal =&gt; <span class="tok-kw">return</span> self.parseString(T, node),
            .array_literal =&gt; |nodes| <span class="tok-kw">return</span> self.parseSlice(T, nodes),
            .empty_literal =&gt; <span class="tok-kw">return</span> self.parseSlice(T, .{ .start = node, .len = <span class="tok-number">0</span> }),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WrongType,
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseString</span>(self: *<span class="tok-builtin">@This</span>(), T: <span class="tok-type">type</span>, node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>) !T {
        <span class="tok-kw">const</span> ast_node = node.getAstNode(self.zoir);
        <span class="tok-kw">const</span> pointer = <span class="tok-builtin">@typeInfo</span>(T).pointer;
        <span class="tok-kw">var</span> size_hint = <a href="std.zig.ZonGen.html">ZonGen</a>.<a href="std.zig.ZonGen.html#std.zig.ZonGen.strLitSizeHint">strLitSizeHint</a>(self.ast, ast_node);
        <span class="tok-kw">if</span> (pointer.sentinel() != <span class="tok-null">null</span>) size_hint += <span class="tok-number">1</span>;

        <span class="tok-kw">var</span> buf: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>) = <span class="tok-kw">try</span> .initCapacity(self.gpa, size_hint);
        <span class="tok-kw">defer</span> buf.deinit(self.gpa);
        <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> <a href="std.zig.ZonGen.html">ZonGen</a>.<a href="std.zig.ZonGen.html#std.zig.ZonGen.parseStrLit">parseStrLit</a>(self.ast, ast_node, buf.writer(self.gpa))) {
            .success =&gt; {},
            .failure =&gt; |err| {
                <span class="tok-kw">const</span> token = self.ast.nodes.items(.main_token)[ast_node];
                <span class="tok-kw">const</span> raw_string = self.ast.tokenSlice(token);
                <span class="tok-kw">return</span> self.failTokenFmt(token, <span class="tok-builtin">@intCast</span>(err.offset()), <span class="tok-str">&quot;{s}&quot;</span>, .{err.fmt(raw_string)});
            },
        }

        <span class="tok-kw">if</span> (pointer.child != <span class="tok-type">u8</span> <span class="tok-kw">or</span>
            pointer.size != .slice <span class="tok-kw">or</span>
            !pointer.is_const <span class="tok-kw">or</span>
            (pointer.sentinel() != <span class="tok-null">null</span> <span class="tok-kw">and</span> pointer.sentinel() != <span class="tok-number">0</span>) <span class="tok-kw">or</span>
            pointer.alignment != <span class="tok-number">1</span>)
        {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WrongType;
        }

        <span class="tok-kw">if</span> (pointer.sentinel() != <span class="tok-null">null</span>) {
            <span class="tok-kw">return</span> buf.toOwnedSliceSentinel(self.gpa, <span class="tok-number">0</span>);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> buf.toOwnedSlice(self.gpa);
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseSlice</span>(self: *<span class="tok-builtin">@This</span>(), T: <span class="tok-type">type</span>, nodes: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>.<a href="std.zig.Zoir.Node.Index.Range.html">Range</a>) !T {
        <span class="tok-kw">const</span> pointer = <span class="tok-builtin">@typeInfo</span>(T).pointer;<span class="tok-comment">

        // Make sure we're working with a slice
        </span><span class="tok-kw">switch</span> (pointer.size) {
            .slice =&gt; {},
            .one, .many, .c =&gt; <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>,
        }<span class="tok-comment">

        // Allocate the slice
        </span><span class="tok-kw">const</span> slice = <span class="tok-kw">try</span> self.gpa.allocWithOptions(
            pointer.child,
            nodes.len,
            pointer.alignment,
            pointer.sentinel(),
        );
        <span class="tok-kw">errdefer</span> self.gpa.free(slice);<span class="tok-comment">

        // Parse the elements and return the slice
        </span><span class="tok-kw">for</span> (slice, <span class="tok-number">0</span>..) |*elem, i| {
            <span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (self.options.free_on_error) {
                <span class="tok-kw">for</span> (slice[<span class="tok-number">0</span>..i]) |item| {
                    <a href="std.zon.parse.html#std.zon.parse.free">free</a>(self.gpa, item);
                }
            };
            elem.* = <span class="tok-kw">try</span> self.parseExpr(pointer.child, nodes.at(<span class="tok-builtin">@intCast</span>(i)));
        }

        <span class="tok-kw">return</span> slice;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseArray</span>(self: *<span class="tok-builtin">@This</span>(), T: <span class="tok-type">type</span>, node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>) !T {
        <span class="tok-kw">const</span> nodes: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>.<a href="std.zig.Zoir.Node.Index.Range.html">Range</a> = <span class="tok-kw">switch</span> (node.get(self.zoir)) {
            .array_literal =&gt; |nodes| nodes,
            .empty_literal =&gt; .{ .start = node, .len = <span class="tok-number">0</span> },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WrongType,
        };

        <span class="tok-kw">const</span> array_info = <span class="tok-builtin">@typeInfo</span>(T).array;<span class="tok-comment">

        // Check if the size matches
        </span><span class="tok-kw">if</span> (nodes.len &lt; array_info.len) {
            <span class="tok-kw">return</span> self.failNodeFmt(
                node,
                <span class="tok-str">&quot;expected {} array elements; found {}&quot;</span>,
                .{ array_info.len, nodes.len },
            );
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (nodes.len &gt; array_info.len) {
            <span class="tok-kw">return</span> self.failNodeFmt(
                nodes.at(array_info.len),
                <span class="tok-str">&quot;index {} outside of array of length {}&quot;</span>,
                .{ array_info.len, array_info.len },
            );
        }<span class="tok-comment">

        // Parse the elements and return the array
        </span><span class="tok-kw">var</span> result: T = <span class="tok-null">undefined</span>;
        <span class="tok-kw">for</span> (&amp;result, <span class="tok-number">0</span>..) |*elem, i| {<span class="tok-comment">
            // If we fail to parse this field, free all fields before it
            </span><span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (self.options.free_on_error) {
                <span class="tok-kw">for</span> (result[<span class="tok-number">0</span>..i]) |item| {
                    <a href="std.zon.parse.html#std.zon.parse.free">free</a>(self.gpa, item);
                }
            };

            elem.* = <span class="tok-kw">try</span> self.parseExpr(array_info.child, nodes.at(<span class="tok-builtin">@intCast</span>(i)));
        }
        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseStruct</span>(self: *<span class="tok-builtin">@This</span>(), T: <span class="tok-type">type</span>, node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>) !T {
        <span class="tok-kw">const</span> repr = node.get(self.zoir);
        <span class="tok-kw">const</span> fields: <span class="tok-builtin">@FieldType</span>(<a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>, <span class="tok-str">&quot;struct_literal&quot;</span>) = <span class="tok-kw">switch</span> (repr) {
            .struct_literal =&gt; |nodes| nodes,
            .empty_literal =&gt; .{ .names = &amp;.{}, .vals = .{ .start = node, .len = <span class="tok-number">0</span> } },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WrongType,
        };

        <span class="tok-kw">const</span> field_infos = <span class="tok-builtin">@typeInfo</span>(T).@&quot;struct&quot;.fields;<span class="tok-comment">

        // Build a map from field name to index.
        // The special value `comptime_field` indicates that this is actually a comptime field.
        </span><span class="tok-kw">const</span> comptime_field = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>);
        <span class="tok-kw">const</span> field_indices: <a href="std.html">std</a>.<a href="std.static_string_map.html#std.static_string_map.StaticStringMap">StaticStringMap</a>(<span class="tok-type">usize</span>) = <span class="tok-kw">comptime</span> b: {
            <span class="tok-kw">var</span> kvs_list: [field_infos.len]<span class="tok-kw">struct</span> { []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-type">usize</span> } = <span class="tok-null">undefined</span>;
            <span class="tok-kw">for</span> (&amp;kvs_list, field_infos, <span class="tok-number">0</span>..) |*kv, field, i| {
                kv.* = .{ field.name, <span class="tok-kw">if</span> (field.is_comptime) comptime_field <span class="tok-kw">else</span> i };
            }
            <span class="tok-kw">break</span> :b .initComptime(kvs_list);
        };<span class="tok-comment">

        // Parse the struct
        </span><span class="tok-kw">var</span> result: T = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> field_found: [field_infos.len]<span class="tok-type">bool</span> = <span class="tok-builtin">@splat</span>(<span class="tok-null">false</span>);<span class="tok-comment">

        // If we fail partway through, free all already initialized fields
        </span><span class="tok-kw">var</span> initialized: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (self.options.free_on_error <span class="tok-kw">and</span> field_infos.len &gt; <span class="tok-number">0</span>) {
            <span class="tok-kw">for</span> (fields.names[<span class="tok-number">0</span>..initialized]) |name_runtime| {
                <span class="tok-kw">switch</span> (field_indices.get(name_runtime.get(self.zoir)) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>) {
                    <span class="tok-kw">inline</span> <span class="tok-number">0</span>...(field_infos.len - <span class="tok-number">1</span>) =&gt; |name_index| {
                        <span class="tok-kw">const</span> name = field_infos[name_index].name;
                        <a href="std.zon.parse.html#std.zon.parse.free">free</a>(self.gpa, <span class="tok-builtin">@field</span>(result, name));
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Can't be out of bounds
                </span>}
            }
        };<span class="tok-comment">

        // Fill in the fields we found
        </span><span class="tok-kw">for</span> (<span class="tok-number">0</span>..fields.names.len) |i| {
            <span class="tok-kw">const</span> name = fields.names[i].get(self.zoir);
            <span class="tok-kw">const</span> field_index = field_indices.get(name) <span class="tok-kw">orelse</span> {
                <span class="tok-kw">if</span> (self.options.ignore_unknown_fields) <span class="tok-kw">continue</span>;
                <span class="tok-kw">return</span> self.failUnexpected(T, <span class="tok-str">&quot;field&quot;</span>, node, i, name);
            };
            <span class="tok-kw">if</span> (field_index == comptime_field) {
                <span class="tok-kw">return</span> self.failComptimeField(node, i);
            }<span class="tok-comment">

            // Mark the field as found. Assert that the found array is not zero length to satisfy
            // the type checker (it can't be since we made it into an iteration of this loop.)
            </span><span class="tok-kw">if</span> (field_found.len == <span class="tok-number">0</span>) <span class="tok-kw">unreachable</span>;
            field_found[field_index] = <span class="tok-null">true</span>;

            <span class="tok-kw">switch</span> (field_index) {
                <span class="tok-kw">inline</span> <span class="tok-number">0</span>...(field_infos.len - <span class="tok-number">1</span>) =&gt; |j| {
                    <span class="tok-kw">if</span> (field_infos[j].is_comptime) <span class="tok-kw">unreachable</span>;

                    <span class="tok-builtin">@field</span>(result, field_infos[j].name) = <span class="tok-kw">try</span> self.parseExpr(
                        field_infos[j].<span class="tok-type">type</span>,
                        fields.vals.at(<span class="tok-builtin">@intCast</span>(i)),
                    );
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Can't be out of bounds
            </span>}

            initialized += <span class="tok-number">1</span>;
        }<span class="tok-comment">

        // Fill in any missing default fields
        </span><span class="tok-kw">inline</span> <span class="tok-kw">for</span> (field_found, <span class="tok-number">0</span>..) |found, i| {
            <span class="tok-kw">if</span> (!found) {
                <span class="tok-kw">const</span> field_info = field_infos[i];
                <span class="tok-kw">if</span> (field_info.default_value_ptr) |default| {
                    <span class="tok-kw">const</span> typed: *<span class="tok-kw">const</span> field_info.<span class="tok-type">type</span> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(default));
                    <span class="tok-builtin">@field</span>(result, field_info.name) = typed.*;
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">return</span> self.failNodeFmt(
                        node,
                        <span class="tok-str">&quot;missing required field {s}&quot;</span>,
                        .{field_infos[i].name},
                    );
                }
            }
        }

        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseTuple</span>(self: *<span class="tok-builtin">@This</span>(), T: <span class="tok-type">type</span>, node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>) !T {
        <span class="tok-kw">const</span> nodes: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>.<a href="std.zig.Zoir.Node.Index.Range.html">Range</a> = <span class="tok-kw">switch</span> (node.get(self.zoir)) {
            .array_literal =&gt; |nodes| nodes,
            .empty_literal =&gt; .{ .start = node, .len = <span class="tok-number">0</span> },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WrongType,
        };

        <span class="tok-kw">var</span> result: T = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> field_infos = <span class="tok-builtin">@typeInfo</span>(T).@&quot;struct&quot;.fields;

        <span class="tok-kw">if</span> (nodes.len &gt; field_infos.len) {
            <span class="tok-kw">return</span> self.failNodeFmt(
                nodes.at(field_infos.len),
                <span class="tok-str">&quot;index {} outside of tuple length {}&quot;</span>,
                .{ field_infos.len, field_infos.len },
            );
        }

        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..field_infos.len) |i| {<span class="tok-comment">
            // Check if we're out of bounds
            </span><span class="tok-kw">if</span> (i &gt;= nodes.len) {
                <span class="tok-kw">if</span> (field_infos[i].default_value_ptr) |default| {
                    <span class="tok-kw">const</span> typed: *<span class="tok-kw">const</span> field_infos[i].<span class="tok-type">type</span> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(default));
                    <span class="tok-builtin">@field</span>(result, field_infos[i].name) = typed.*;
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">return</span> self.failNodeFmt(node, <span class="tok-str">&quot;missing tuple field with index {}&quot;</span>, .{i});
                }
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // If we fail to parse this field, free all fields before it
                </span><span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (self.options.free_on_error) {
                    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..i) |j| {
                        <span class="tok-kw">if</span> (j &gt;= i) <span class="tok-kw">break</span>;
                        <a href="std.zon.parse.html#std.zon.parse.free">free</a>(self.gpa, result[j]);
                    }
                };

                <span class="tok-kw">if</span> (field_infos[i].is_comptime) {
                    <span class="tok-kw">return</span> self.failComptimeField(node, i);
                } <span class="tok-kw">else</span> {
                    result[i] = <span class="tok-kw">try</span> self.parseExpr(field_infos[i].<span class="tok-type">type</span>, nodes.at(i));
                }
            }
        }

        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseUnion</span>(self: *<span class="tok-builtin">@This</span>(), T: <span class="tok-type">type</span>, node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>) !T {
        <span class="tok-kw">const</span> @&quot;union&quot; = <span class="tok-builtin">@typeInfo</span>(T).@&quot;union&quot;;
        <span class="tok-kw">const</span> field_infos = @&quot;union&quot;.fields;

        <span class="tok-kw">if</span> (field_infos.len == <span class="tok-number">0</span>) <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>;<span class="tok-comment">

        // Gather info on the fields
        </span><span class="tok-kw">const</span> field_indices = b: {
            <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> kvs_list: [field_infos.len]<span class="tok-kw">struct</span> { []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-type">usize</span> } = <span class="tok-null">undefined</span>;
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (field_infos, <span class="tok-number">0</span>..) |field, i| {
                kvs_list[i] = .{ field.name, i };
            }
            <span class="tok-kw">break</span> :b <a href="std.html">std</a>.<a href="std.static_string_map.html#std.static_string_map.StaticStringMap">StaticStringMap</a>(<span class="tok-type">usize</span>).initComptime(kvs_list);
        };<span class="tok-comment">

        // Parse the union
        </span><span class="tok-kw">switch</span> (node.get(self.zoir)) {
            .enum_literal =&gt; |field_name| {<span class="tok-comment">
                // The union must be tagged for an enum literal to coerce to it
                </span><span class="tok-kw">if</span> (@&quot;union&quot;.tag_type == <span class="tok-null">null</span>) {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WrongType;
                }<span class="tok-comment">

                // Get the index of the named field. We don't use `parseEnum` here as
                // the order of the enum and the order of the union might not match!
                </span><span class="tok-kw">const</span> field_index = b: {
                    <span class="tok-kw">const</span> field_name_str = field_name.get(self.zoir);
                    <span class="tok-kw">break</span> :b field_indices.get(field_name_str) <span class="tok-kw">orelse</span>
                        <span class="tok-kw">return</span> self.failUnexpected(T, <span class="tok-str">&quot;field&quot;</span>, node, <span class="tok-null">null</span>, field_name_str);
                };<span class="tok-comment">

                // Initialize the union from the given field.
                </span><span class="tok-kw">switch</span> (field_index) {
                    <span class="tok-kw">inline</span> <span class="tok-number">0</span>...field_infos.len - <span class="tok-number">1</span> =&gt; |i| {<span class="tok-comment">
                        // Fail if the field is not void
                        </span><span class="tok-kw">if</span> (field_infos[i].<span class="tok-type">type</span> != <span class="tok-type">void</span>)
                            <span class="tok-kw">return</span> self.failNode(node, <span class="tok-str">&quot;expected union&quot;</span>);<span class="tok-comment">

                        // Instantiate the union
                        </span><span class="tok-kw">return</span> <span class="tok-builtin">@unionInit</span>(T, field_infos[i].name, {});
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Can't be out of bounds
                </span>}
            },
            .struct_literal =&gt; |struct_fields| {
                <span class="tok-kw">if</span> (struct_fields.names.len != <span class="tok-number">1</span>) {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WrongType;
                }<span class="tok-comment">

                // Fill in the field we found
                </span><span class="tok-kw">const</span> field_name = struct_fields.names[<span class="tok-number">0</span>];
                <span class="tok-kw">const</span> field_name_str = field_name.get(self.zoir);
                <span class="tok-kw">const</span> field_val = struct_fields.vals.at(<span class="tok-number">0</span>);
                <span class="tok-kw">const</span> field_index = field_indices.get(field_name_str) <span class="tok-kw">orelse</span>
                    <span class="tok-kw">return</span> self.failUnexpected(T, <span class="tok-str">&quot;field&quot;</span>, node, <span class="tok-number">0</span>, field_name_str);

                <span class="tok-kw">switch</span> (field_index) {
                    <span class="tok-kw">inline</span> <span class="tok-number">0</span>...field_infos.len - <span class="tok-number">1</span> =&gt; |i| {
                        <span class="tok-kw">if</span> (field_infos[i].<span class="tok-type">type</span> == <span class="tok-type">void</span>) {
                            <span class="tok-kw">return</span> self.failNode(field_val, <span class="tok-str">&quot;expected type 'void'&quot;</span>);
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> self.parseExpr(field_infos[i].<span class="tok-type">type</span>, field_val);
                            <span class="tok-kw">return</span> <span class="tok-builtin">@unionInit</span>(T, field_infos[i].name, value);
                        }
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Can't be out of bounds
                </span>}
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WrongType,
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseVector</span>(
        self: *<span class="tok-builtin">@This</span>(),
        T: <span class="tok-type">type</span>,
        node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>,
    ) !T {
        <span class="tok-kw">const</span> vector_info = <span class="tok-builtin">@typeInfo</span>(T).vector;

        <span class="tok-kw">const</span> nodes: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>.<a href="std.zig.Zoir.Node.Index.Range.html">Range</a> = <span class="tok-kw">switch</span> (node.get(self.zoir)) {
            .array_literal =&gt; |nodes| nodes,
            .empty_literal =&gt; .{ .start = node, .len = <span class="tok-number">0</span> },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WrongType,
        };

        <span class="tok-kw">var</span> result: T = <span class="tok-null">undefined</span>;

        <span class="tok-kw">if</span> (nodes.len != vector_info.len) {
            <span class="tok-kw">return</span> self.failNodeFmt(
                node,
                <span class="tok-str">&quot;expected {} vector elements; found {}&quot;</span>,
                .{ vector_info.len, nodes.len },
            );
        }

        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..vector_info.len) |i| {
            <span class="tok-kw">errdefer</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..i) |j| <a href="std.zon.parse.html#std.zon.parse.free">free</a>(self.gpa, result[j]);
            result[i] = <span class="tok-kw">try</span> self.parseExpr(vector_info.child, nodes.at(<span class="tok-builtin">@intCast</span>(i)));
        }

        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">failTokenFmt</span>(
        self: <span class="tok-builtin">@This</span>(),
        token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        offset: <span class="tok-type">u32</span>,
        <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        args: <span class="tok-kw">anytype</span>,
    ) <span class="tok-kw">error</span>{ OutOfMemory, ParseZon } {
        <span class="tok-builtin">@branchHint</span>(.cold);
        <span class="tok-kw">return</span> self.failTokenFmtNote(token, offset, fmt, args, <span class="tok-null">null</span>);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">failTokenFmtNote</span>(
        self: <span class="tok-builtin">@This</span>(),
        token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        offset: <span class="tok-type">u32</span>,
        <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        args: <span class="tok-kw">anytype</span>,
        note: ?<a href="std.zon.parse.Error.html">Error</a>.<a href="std.zon.parse.Error.TypeCheckFailure.html">TypeCheckFailure</a>.<a href="std.zon.parse.Error.TypeCheckFailure.Note.html">Note</a>,
    ) <span class="tok-kw">error</span>{ OutOfMemory, ParseZon } {
        <span class="tok-builtin">@branchHint</span>(.cold);
        <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(args.len &gt; <span class="tok-number">0</span>);
        <span class="tok-kw">if</span> (self.status) |s| s.type_check = .{
            .token = token,
            .offset = offset,
            .message = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrint">allocPrint</a>(self.gpa, fmt, args) <span class="tok-kw">catch</span> |err| {
                <span class="tok-kw">if</span> (note) |n| n.deinit(self.gpa);
                <span class="tok-kw">return</span> err;
            },
            .owned = <span class="tok-null">true</span>,
            .note = note,
        };
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ParseZon;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">failNodeFmt</span>(
        self: <span class="tok-builtin">@This</span>(),
        node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>,
        <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        args: <span class="tok-kw">anytype</span>,
    ) <span class="tok-kw">error</span>{ OutOfMemory, ParseZon } {
        <span class="tok-builtin">@branchHint</span>(.cold);
        <span class="tok-kw">const</span> main_tokens = self.ast.nodes.items(.main_token);
        <span class="tok-kw">const</span> token = main_tokens[node.getAstNode(self.zoir)];
        <span class="tok-kw">return</span> self.failTokenFmt(token, <span class="tok-number">0</span>, fmt, args);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">failToken</span>(
        self: <span class="tok-builtin">@This</span>(),
        failure: <a href="std.zon.parse.Error.html">Error</a>.<a href="std.zon.parse.Error.TypeCheckFailure.html">TypeCheckFailure</a>,
    ) <span class="tok-kw">error</span>{ParseZon} {
        <span class="tok-builtin">@branchHint</span>(.cold);
        <span class="tok-kw">if</span> (self.status) |s| s.type_check = failure;
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ParseZon;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">failNode</span>(
        self: <span class="tok-builtin">@This</span>(),
        node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>,
        message: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <span class="tok-kw">error</span>{ParseZon} {
        <span class="tok-builtin">@branchHint</span>(.cold);
        <span class="tok-kw">const</span> main_tokens = self.ast.nodes.items(.main_token);
        <span class="tok-kw">const</span> token = main_tokens[node.getAstNode(self.zoir)];
        <span class="tok-kw">return</span> self.failToken(.{
            .token = token,
            .offset = <span class="tok-number">0</span>,
            .message = message,
            .owned = <span class="tok-null">false</span>,
            .note = <span class="tok-null">null</span>,
        });
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">failCannotRepresent</span>(
        self: <span class="tok-builtin">@This</span>(),
        T: <span class="tok-type">type</span>,
        node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>,
    ) <span class="tok-kw">error</span>{ OutOfMemory, ParseZon } {
        <span class="tok-builtin">@branchHint</span>(.cold);
        <span class="tok-kw">return</span> self.failNodeFmt(node, <span class="tok-str">&quot;type '{s}' cannot represent value&quot;</span>, .{<span class="tok-builtin">@typeName</span>(T)});
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">failUnexpected</span>(
        self: <span class="tok-builtin">@This</span>(),
        T: <span class="tok-type">type</span>,
        item_kind: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>,
        field: ?<span class="tok-type">usize</span>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <span class="tok-kw">error</span>{ OutOfMemory, ParseZon } {
        <span class="tok-builtin">@branchHint</span>(.cold);
        <span class="tok-kw">const</span> token = <span class="tok-kw">if</span> (field) |f| b: {
            <span class="tok-kw">var</span> buf: [<span class="tok-number">2</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> struct_init = self.ast.fullStructInit(&amp;buf, node.getAstNode(self.zoir)).?;
            <span class="tok-kw">const</span> field_node = struct_init.ast.fields[f];
            <span class="tok-kw">break</span> :b self.ast.firstToken(field_node) - <span class="tok-number">2</span>;
        } <span class="tok-kw">else</span> b: {
            <span class="tok-kw">const</span> main_tokens = self.ast.nodes.items(.main_token);
            <span class="tok-kw">break</span> :b main_tokens[node.getAstNode(self.zoir)];
        };
        <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
            <span class="tok-kw">inline</span> .@&quot;struct&quot;, .@&quot;union&quot;, .@&quot;enum&quot; =&gt; |info| {
                <span class="tok-kw">const</span> note: <a href="std.zon.parse.Error.html">Error</a>.<a href="std.zon.parse.Error.TypeCheckFailure.html">TypeCheckFailure</a>.<a href="std.zon.parse.Error.TypeCheckFailure.Note.html">Note</a> = <span class="tok-kw">if</span> (info.fields.len == <span class="tok-number">0</span>) b: {
                    <span class="tok-kw">break</span> :b .{
                        .token = token,
                        .offset = <span class="tok-number">0</span>,
                        .msg = <span class="tok-str">&quot;none expected&quot;</span>,
                        .owned = <span class="tok-null">false</span>,
                    };
                } <span class="tok-kw">else</span> b: {
                    <span class="tok-kw">const</span> msg = <span class="tok-str">&quot;supported: &quot;</span>;
                    <span class="tok-kw">var</span> buf: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>) = <span class="tok-kw">try</span> .initCapacity(self.gpa, <span class="tok-number">64</span>);
                    <span class="tok-kw">defer</span> buf.deinit(self.gpa);
                    <span class="tok-kw">const</span> writer = buf.writer(self.gpa);
                    <span class="tok-kw">try</span> writer.writeAll(msg);
                    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (info.fields, <span class="tok-number">0</span>..) |field_info, i| {
                        <span class="tok-kw">if</span> (i != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;, &quot;</span>);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;'{p_}'&quot;</span>, .{<a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.fmtId">fmtId</a>(field_info.name)});
                    }
                    <span class="tok-kw">break</span> :b .{
                        .token = token,
                        .offset = <span class="tok-number">0</span>,
                        .msg = <span class="tok-kw">try</span> buf.toOwnedSlice(self.gpa),
                        .owned = <span class="tok-null">true</span>,
                    };
                };
                <span class="tok-kw">return</span> self.failTokenFmtNote(
                    token,
                    <span class="tok-number">0</span>,
                    <span class="tok-str">&quot;unexpected {s} '{s}'&quot;</span>,
                    .{ item_kind, name },
                    note,
                );
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>,
        }
    }<span class="tok-comment">

    // Technically we could do this if we were willing to do a deep equal to verify
    // the value matched, but doing so doesn't seem to support any real use cases
    // so isn't worth the complexity at the moment.
    </span><span class="tok-kw">fn</span> <span class="tok-fn">failComptimeField</span>(
        self: <span class="tok-builtin">@This</span>(),
        node: <a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.Node.html">Node</a>.<a href="std.zig.Zoir.Node.Index.html">Index</a>,
        field: <span class="tok-type">usize</span>,
    ) <span class="tok-kw">error</span>{ OutOfMemory, ParseZon } {
        <span class="tok-builtin">@branchHint</span>(.cold);
        <span class="tok-kw">const</span> ast_node = node.getAstNode(self.zoir);
        <span class="tok-kw">var</span> buf: [<span class="tok-number">2</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> token = <span class="tok-kw">if</span> (self.ast.fullStructInit(&amp;buf, ast_node)) |struct_init| b: {
            <span class="tok-kw">const</span> field_node = struct_init.ast.fields[field];
            <span class="tok-kw">break</span> :b self.ast.firstToken(field_node);
        } <span class="tok-kw">else</span> b: {
            <span class="tok-kw">const</span> array_init = self.ast.fullArrayInit(&amp;buf, ast_node).?;
            <span class="tok-kw">const</span> value_node = array_init.ast.elements[field];
            <span class="tok-kw">break</span> :b self.ast.firstToken(value_node);
        };
        <span class="tok-kw">return</span> self.failToken(.{
            .token = token,
            .offset = <span class="tok-number">0</span>,
            .message = <span class="tok-str">&quot;cannot initialize comptime field&quot;</span>,
            .owned = <span class="tok-null">false</span>,
            .note = <span class="tok-null">null</span>,
        });
    }
};

<span class="tok-kw">fn</span> <span class="tok-fn">intFromFloatExact</span>(T: <span class="tok-type">type</span>, value: <span class="tok-kw">anytype</span>) ?T {
    <span class="tok-kw">if</span> (value &gt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(T) <span class="tok-kw">or</span> value &lt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.minInt">minInt</a>(T)) {
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }

    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.isnan.html#std.math.isnan.isNan">isNan</a>(value) <span class="tok-kw">or</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.trunc">trunc</a>(value) != value) {
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }

    <span class="tok-kw">return</span> <span class="tok-builtin">@intFromFloat</span>(value);
}

<span class="tok-kw">fn</span> <span class="tok-fn">canParseType</span>(T: <span class="tok-type">type</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">comptime</span> <span class="tok-kw">return</span> <a href="std.zon.parse.html#std.zon.parse.canParseTypeInner">canParseTypeInner</a>(T, &amp;.{}, <span class="tok-null">false</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">canParseTypeInner</span>(
    T: <span class="tok-type">type</span>,
    <span class="tok-comment">/// Visited structs and unions, to avoid infinite recursion.</span>
    <span class="tok-comment">/// Tracking more types is unnecessary, and a little complex due to optional nesting.</span>
    visited: []<span class="tok-kw">const</span> <span class="tok-type">type</span>,
    parent_is_optional: <span class="tok-type">bool</span>,
) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .<span class="tok-type">bool</span>,
        .int,
        .float,
        .<span class="tok-null">null</span>,
        .@&quot;enum&quot;,
        =&gt; <span class="tok-null">true</span>,

        .<span class="tok-type">noreturn</span>,
        .<span class="tok-type">void</span>,
        .<span class="tok-type">type</span>,
        .<span class="tok-null">undefined</span>,
        .error_union,
        .error_set,
        .@&quot;fn&quot;,
        .frame,
        .@&quot;anyframe&quot;,
        .@&quot;opaque&quot;,
        .<span class="tok-type">comptime_int</span>,
        .<span class="tok-type">comptime_float</span>,
        .enum_literal,
        =&gt; <span class="tok-null">false</span>,

        .pointer =&gt; |pointer| <span class="tok-kw">switch</span> (pointer.size) {
            .one =&gt; <a href="std.zon.parse.html#std.zon.parse.canParseTypeInner">canParseTypeInner</a>(pointer.child, visited, parent_is_optional),
            .slice =&gt; <a href="std.zon.parse.html#std.zon.parse.canParseTypeInner">canParseTypeInner</a>(pointer.child, visited, <span class="tok-null">false</span>),
            .many, .c =&gt; <span class="tok-null">false</span>,
        },

        .optional =&gt; |optional| <span class="tok-kw">if</span> (parent_is_optional)
            <span class="tok-null">false</span>
        <span class="tok-kw">else</span>
            <a href="std.zon.parse.html#std.zon.parse.canParseTypeInner">canParseTypeInner</a>(optional.child, visited, <span class="tok-null">true</span>),

        .array =&gt; |array| <a href="std.zon.parse.html#std.zon.parse.canParseTypeInner">canParseTypeInner</a>(array.child, visited, <span class="tok-null">false</span>),
        .vector =&gt; |vector| <a href="std.zon.parse.html#std.zon.parse.canParseTypeInner">canParseTypeInner</a>(vector.child, visited, <span class="tok-null">false</span>),

        .@&quot;struct&quot; =&gt; |@&quot;struct&quot;| {
            <span class="tok-kw">for</span> (visited) |V| <span class="tok-kw">if</span> (T == V) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
            <span class="tok-kw">const</span> new_visited = visited ++ .{T};
            <span class="tok-kw">for</span> (@&quot;struct&quot;.fields) |field| {
                <span class="tok-kw">if</span> (!field.is_comptime <span class="tok-kw">and</span> !<a href="std.zon.parse.html#std.zon.parse.canParseTypeInner">canParseTypeInner</a>(field.<span class="tok-type">type</span>, new_visited, <span class="tok-null">false</span>)) {
                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                }
            }
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
        .@&quot;union&quot; =&gt; |@&quot;union&quot;| {
            <span class="tok-kw">for</span> (visited) |V| <span class="tok-kw">if</span> (T == V) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
            <span class="tok-kw">const</span> new_visited = visited ++ .{T};
            <span class="tok-kw">for</span> (@&quot;union&quot;.fields) |field| {
                <span class="tok-kw">if</span> (field.<span class="tok-type">type</span> != <span class="tok-type">void</span> <span class="tok-kw">and</span> !<a href="std.zon.parse.html#std.zon.parse.canParseTypeInner">canParseTypeInner</a>(field.<span class="tok-type">type</span>, new_visited, <span class="tok-null">false</span>)) {
                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                }
            }
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
    };
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon parse canParseType&quot;</span> {
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(<span class="tok-type">void</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(<span class="tok-kw">struct</span> { f: [*]<span class="tok-type">u8</span> }));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(<span class="tok-kw">struct</span> { <span class="tok-kw">error</span>{foo} }));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(<span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) { a: <span class="tok-type">void</span>, b: [*c]<span class="tok-type">u8</span> }));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">0</span>, [*c]<span class="tok-type">u8</span>)));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(*?[*c]<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(<span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) { _ }));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(<span class="tok-kw">union</span> { foo: <span class="tok-type">void</span> }));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(<span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) { foo: <span class="tok-type">void</span> }));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(<span class="tok-type">comptime_float</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(<span class="tok-type">comptime_int</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(<span class="tok-kw">struct</span> { <span class="tok-kw">comptime</span> foo: ??<span class="tok-type">u8</span> = <span class="tok-null">null</span> }));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(<span class="tok-builtin">@TypeOf</span>(.foo)));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(?<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(*?*<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(?<span class="tok-kw">struct</span> {
        foo: ?<span class="tok-kw">struct</span> {
            ?<span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
                a: ?<span class="tok-builtin">@Vector</span>(<span class="tok-number">0</span>, ?*<span class="tok-type">u8</span>),
            },
            ?<span class="tok-kw">struct</span> {
                f: ?[]?<span class="tok-type">u8</span>,
            },
        },
    }));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(??<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(?*?<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(*?*?*<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(<span class="tok-kw">struct</span> { x: <span class="tok-type">comptime_int</span> = <span class="tok-number">2</span> }));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(<span class="tok-kw">struct</span> { x: <span class="tok-type">comptime_float</span> = <span class="tok-number">2</span> }));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(<span class="tok-kw">struct</span> { <span class="tok-kw">comptime</span> x: <span class="tok-builtin">@TypeOf</span>(.foo) = .foo }));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(<span class="tok-kw">struct</span> { <span class="tok-type">comptime_int</span> }));
    <span class="tok-kw">const</span> Recursive = <span class="tok-kw">struct</span> { foo: ?*<span class="tok-builtin">@This</span>() };
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(Recursive));<span class="tok-comment">

    // Make sure we validate nested optional before we early out due to already having seen
    // a type recursion!
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<span class="tok-kw">comptime</span> <a href="std.zon.parse.html#std.zon.parse.canParseType">canParseType</a>(<span class="tok-kw">struct</span> {
        add_to_visited: ?<span class="tok-type">u8</span>,
        retrieve_from_visited: ??<span class="tok-type">u8</span>,
    }));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon requiresAllocator&quot;</span> {
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(<span class="tok-type">f32</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(<span class="tok-kw">enum</span> { foo }));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(<span class="tok-kw">struct</span> { <span class="tok-type">f32</span> }));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(<span class="tok-kw">struct</span> { x: <span class="tok-type">f32</span> }));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>([<span class="tok-number">0</span>][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>([<span class="tok-number">2</span>]<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(<span class="tok-kw">union</span> { x: <span class="tok-type">f32</span>, y: <span class="tok-type">f32</span> }));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(<span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) { x: <span class="tok-type">f32</span>, y: <span class="tok-type">f32</span> }));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(?<span class="tok-type">f32</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(<span class="tok-type">void</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(<span class="tok-builtin">@TypeOf</span>(<span class="tok-null">null</span>)));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">u8</span>)));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">0</span>, *<span class="tok-kw">const</span> <span class="tok-type">u8</span>)));

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>([]<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(*<span class="tok-kw">struct</span> { <span class="tok-type">u8</span>, <span class="tok-type">u8</span> }));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>([<span class="tok-number">1</span>][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(<span class="tok-kw">struct</span> { x: <span class="tok-type">i32</span>, y: []<span class="tok-type">u8</span> }));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(<span class="tok-kw">union</span> { x: <span class="tok-type">i32</span>, y: []<span class="tok-type">u8</span> }));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(<span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) { x: <span class="tok-type">i32</span>, y: []<span class="tok-type">u8</span> }));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(?[]<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.zon.parse.html#std.zon.parse.requiresAllocator">requiresAllocator</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, *<span class="tok-kw">const</span> <span class="tok-type">u8</span>)));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon ast errors&quot;</span> {
    <span class="tok-kw">const</span> gpa = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;
    <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
    <span class="tok-kw">defer</span> status.deinit(gpa);
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
        <span class="tok-kw">error</span>.ParseZon,
        <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-kw">struct</span> {}, gpa, <span class="tok-str">&quot;.{.x = 1 .y = 2}&quot;</span>, &amp;status, .{}),
    );
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:13: error: expected ',' after initializer\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon comments&quot;</span> {
    <span class="tok-kw">const</span> gpa = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">10</span>), <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">u8</span>, gpa,
        <span class="tok-str">\\// comment</span>
        <span class="tok-str">\\10 // comment</span>
        <span class="tok-str">\\// comment</span>
    , <span class="tok-null">null</span>, .{}));

    {
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">u8</span>, gpa,
            <span class="tok-str">\\//! comment</span>
            <span class="tok-str">\\10 // comment</span>
            <span class="tok-str">\\// comment</span>
        , &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:1: error: expected expression, found 'a document comment'\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon failure/oom formatting&quot;</span> {
    <span class="tok-kw">const</span> gpa = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;
    <span class="tok-kw">var</span> failing_allocator = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.FailingAllocator.html">FailingAllocator</a>.<a href="std.testing.FailingAllocator.html#std.testing.FailingAllocator.init">init</a>(gpa, .{
        .fail_index = <span class="tok-number">0</span>,
        .resize_fail_index = <span class="tok-number">0</span>,
    });
    <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
    <span class="tok-kw">defer</span> status.deinit(gpa);
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.OutOfMemory, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
        []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        failing_allocator.allocator(),
        <span class="tok-str">&quot;\&quot;foo\&quot;&quot;</span>,
        &amp;status,
        .{},
    ));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon fromSlice syntax error&quot;</span> {
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
        <span class="tok-kw">error</span>.ParseZon,
        <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">u8</span>, <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;.{&quot;</span>, <span class="tok-null">null</span>, .{}),
    );
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon optional&quot;</span> {
    <span class="tok-kw">const</span> gpa = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;<span class="tok-comment">

    // Basic usage
    </span>{
        <span class="tok-kw">const</span> none = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(?<span class="tok-type">u32</span>, gpa, <span class="tok-str">&quot;null&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(none == <span class="tok-null">null</span>);
        <span class="tok-kw">const</span> some = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(?<span class="tok-type">u32</span>, gpa, <span class="tok-str">&quot;1&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(some.? == <span class="tok-number">1</span>);
    }<span class="tok-comment">

    // Deep free
    </span>{
        <span class="tok-kw">const</span> none = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;null&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(none == <span class="tok-null">null</span>);
        <span class="tok-kw">const</span> some = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;\&quot;foo\&quot;&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, some);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;foo&quot;</span>, some.?);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon unions&quot;</span> {
    <span class="tok-kw">const</span> gpa = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;<span class="tok-comment">

    // Unions
    </span>{
        <span class="tok-kw">const</span> Tagged = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) { x: <span class="tok-type">f32</span>, @&quot;y y&quot;: <span class="tok-type">bool</span>, z, @&quot;z z&quot; };
        <span class="tok-kw">const</span> Untagged = <span class="tok-kw">union</span> { x: <span class="tok-type">f32</span>, @&quot;y y&quot;: <span class="tok-type">bool</span>, z: <span class="tok-type">void</span>, @&quot;z z&quot;: <span class="tok-type">void</span> };

        <span class="tok-kw">const</span> tagged_x = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Tagged, gpa, <span class="tok-str">&quot;.{.x = 1.5}&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Tagged{ .x = <span class="tok-number">1.5</span> }, tagged_x);
        <span class="tok-kw">const</span> tagged_y = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Tagged, gpa, <span class="tok-str">&quot;.{.@\&quot;y y\&quot; = true}&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Tagged{ .@&quot;y y&quot; = <span class="tok-null">true</span> }, tagged_y);
        <span class="tok-kw">const</span> tagged_z_shorthand = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Tagged, gpa, <span class="tok-str">&quot;.z&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(Tagged, .z), tagged_z_shorthand);
        <span class="tok-kw">const</span> tagged_zz_shorthand = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Tagged, gpa, <span class="tok-str">&quot;.@\&quot;z z\&quot;&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(Tagged, .@&quot;z z&quot;), tagged_zz_shorthand);

        <span class="tok-kw">const</span> untagged_x = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Untagged, gpa, <span class="tok-str">&quot;.{.x = 1.5}&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(untagged_x.x == <span class="tok-number">1.5</span>);
        <span class="tok-kw">const</span> untagged_y = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Untagged, gpa, <span class="tok-str">&quot;.{.@\&quot;y y\&quot; = true}&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(untagged_y.@&quot;y y&quot;);
    }<span class="tok-comment">

    // Deep free
    </span>{
        <span class="tok-kw">const</span> Union = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) { bar: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, baz: <span class="tok-type">bool</span> };

        <span class="tok-kw">const</span> noalloc = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Union, gpa, <span class="tok-str">&quot;.{.baz = false}&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Union{ .baz = <span class="tok-null">false</span> }, noalloc);

        <span class="tok-kw">const</span> alloc = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Union, gpa, <span class="tok-str">&quot;.{.bar = \&quot;qux\&quot;}&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, alloc);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualDeep">expectEqualDeep</a>(Union{ .bar = <span class="tok-str">&quot;qux&quot;</span> }, alloc);
    }<span class="tok-comment">

    // Unknown field
    </span>{
        <span class="tok-kw">const</span> Union = <span class="tok-kw">union</span> { x: <span class="tok-type">f32</span>, y: <span class="tok-type">f32</span> };
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Union, gpa, <span class="tok-str">&quot;.{.z=2.5}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">\\1:4: error: unexpected field 'z'</span>
            <span class="tok-str">\\1:4: note: supported: 'x', 'y'</span>
            <span class="tok-str">\\</span>
        ,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Explicit void field
    </span>{
        <span class="tok-kw">const</span> Union = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) { x: <span class="tok-type">void</span> };
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Union, gpa, <span class="tok-str">&quot;.{.x=1}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:6: error: expected type 'void'\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // Extra field
    </span>{
        <span class="tok-kw">const</span> Union = <span class="tok-kw">union</span> { x: <span class="tok-type">f32</span>, y: <span class="tok-type">bool</span> };
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Union, gpa, <span class="tok-str">&quot;.{.x = 1.5, .y = true}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:2: error: expected union\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // No fields
    </span>{
        <span class="tok-kw">const</span> Union = <span class="tok-kw">union</span> { x: <span class="tok-type">f32</span>, y: <span class="tok-type">bool</span> };
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Union, gpa, <span class="tok-str">&quot;.{}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:2: error: expected union\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // Enum literals cannot coerce into untagged unions
    </span>{
        <span class="tok-kw">const</span> Union = <span class="tok-kw">union</span> { x: <span class="tok-type">void</span> };
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Union, gpa, <span class="tok-str">&quot;.x&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:2: error: expected union\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // Unknown field for enum literal coercion
    </span>{
        <span class="tok-kw">const</span> Union = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) { x: <span class="tok-type">void</span> };
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Union, gpa, <span class="tok-str">&quot;.y&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">\\1:2: error: unexpected field 'y'</span>
            <span class="tok-str">\\1:2: note: supported: 'x'</span>
            <span class="tok-str">\\</span>
        ,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Non void field for enum literal coercion
    </span>{
        <span class="tok-kw">const</span> Union = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) { x: <span class="tok-type">f32</span> };
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Union, gpa, <span class="tok-str">&quot;.x&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:2: error: expected union\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon structs&quot;</span> {
    <span class="tok-kw">const</span> gpa = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;<span class="tok-comment">

    // Structs (various sizes tested since they're parsed differently)
    </span>{
        <span class="tok-kw">const</span> Vec0 = <span class="tok-kw">struct</span> {};
        <span class="tok-kw">const</span> Vec1 = <span class="tok-kw">struct</span> { x: <span class="tok-type">f32</span> };
        <span class="tok-kw">const</span> Vec2 = <span class="tok-kw">struct</span> { x: <span class="tok-type">f32</span>, y: <span class="tok-type">f32</span> };
        <span class="tok-kw">const</span> Vec3 = <span class="tok-kw">struct</span> { x: <span class="tok-type">f32</span>, y: <span class="tok-type">f32</span>, z: <span class="tok-type">f32</span> };

        <span class="tok-kw">const</span> zero = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Vec0, gpa, <span class="tok-str">&quot;.{}&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Vec0{}, zero);

        <span class="tok-kw">const</span> one = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Vec1, gpa, <span class="tok-str">&quot;.{.x = 1.2}&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Vec1{ .x = <span class="tok-number">1.2</span> }, one);

        <span class="tok-kw">const</span> two = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Vec2, gpa, <span class="tok-str">&quot;.{.x = 1.2, .y = 3.4}&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Vec2{ .x = <span class="tok-number">1.2</span>, .y = <span class="tok-number">3.4</span> }, two);

        <span class="tok-kw">const</span> three = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Vec3, gpa, <span class="tok-str">&quot;.{.x = 1.2, .y = 3.4, .z = 5.6}&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Vec3{ .x = <span class="tok-number">1.2</span>, .y = <span class="tok-number">3.4</span>, .z = <span class="tok-number">5.6</span> }, three);
    }<span class="tok-comment">

    // Deep free (structs and arrays)
    </span>{
        <span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> { bar: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, baz: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> };

        <span class="tok-kw">const</span> parsed = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
            Foo,
            gpa,
            <span class="tok-str">&quot;.{.bar = \&quot;qux\&quot;, .baz = .{\&quot;a\&quot;, \&quot;b\&quot;}}&quot;</span>,
            <span class="tok-null">null</span>,
            .{},
        );
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, parsed);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualDeep">expectEqualDeep</a>(Foo{ .bar = <span class="tok-str">&quot;qux&quot;</span>, .baz = &amp;.{ <span class="tok-str">&quot;a&quot;</span>, <span class="tok-str">&quot;b&quot;</span> } }, parsed);
    }<span class="tok-comment">

    // Unknown field
    </span>{
        <span class="tok-kw">const</span> Vec2 = <span class="tok-kw">struct</span> { x: <span class="tok-type">f32</span>, y: <span class="tok-type">f32</span> };
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Vec2, gpa, <span class="tok-str">&quot;.{.x=1.5, .z=2.5}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">\\1:12: error: unexpected field 'z'</span>
            <span class="tok-str">\\1:12: note: supported: 'x', 'y'</span>
            <span class="tok-str">\\</span>
        ,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Duplicate field
    </span>{
        <span class="tok-kw">const</span> Vec2 = <span class="tok-kw">struct</span> { x: <span class="tok-type">f32</span>, y: <span class="tok-type">f32</span> };
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Vec2, gpa, <span class="tok-str">&quot;.{.x=1.5, .x=2.5, .x=3.5}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">\\1:4: error: duplicate struct field name</span>
            <span class="tok-str">\\1:12: note: duplicate name here</span>
            <span class="tok-str">\\</span>
        , <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // Ignore unknown fields
    </span>{
        <span class="tok-kw">const</span> Vec2 = <span class="tok-kw">struct</span> { x: <span class="tok-type">f32</span>, y: <span class="tok-type">f32</span> = <span class="tok-number">2.0</span> };
        <span class="tok-kw">const</span> parsed = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Vec2, gpa, <span class="tok-str">&quot;.{ .x = 1.0, .z = 3.0 }&quot;</span>, <span class="tok-null">null</span>, .{
            .ignore_unknown_fields = <span class="tok-null">true</span>,
        });
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Vec2{ .x = <span class="tok-number">1.0</span>, .y = <span class="tok-number">2.0</span> }, parsed);
    }<span class="tok-comment">

    // Unknown field when struct has no fields (regression test)
    </span>{
        <span class="tok-kw">const</span> Vec2 = <span class="tok-kw">struct</span> {};
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Vec2, gpa, <span class="tok-str">&quot;.{.x=1.5, .z=2.5}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">\\1:4: error: unexpected field 'x'</span>
            <span class="tok-str">\\1:4: note: none expected</span>
            <span class="tok-str">\\</span>
        , <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // Missing field
    </span>{
        <span class="tok-kw">const</span> Vec2 = <span class="tok-kw">struct</span> { x: <span class="tok-type">f32</span>, y: <span class="tok-type">f32</span> };
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Vec2, gpa, <span class="tok-str">&quot;.{.x=1.5}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:2: error: missing required field y\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // Default field
    </span>{
        <span class="tok-kw">const</span> Vec2 = <span class="tok-kw">struct</span> { x: <span class="tok-type">f32</span>, y: <span class="tok-type">f32</span> = <span class="tok-number">1.5</span> };
        <span class="tok-kw">const</span> parsed = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Vec2, gpa, <span class="tok-str">&quot;.{.x = 1.2}&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Vec2{ .x = <span class="tok-number">1.2</span>, .y = <span class="tok-number">1.5</span> }, parsed);
    }<span class="tok-comment">

    // Comptime field
    </span>{
        <span class="tok-kw">const</span> Vec2 = <span class="tok-kw">struct</span> { x: <span class="tok-type">f32</span>, <span class="tok-kw">comptime</span> y: <span class="tok-type">f32</span> = <span class="tok-number">1.5</span> };
        <span class="tok-kw">const</span> parsed = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Vec2, gpa, <span class="tok-str">&quot;.{.x = 1.2}&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Vec2{ .x = <span class="tok-number">1.2</span>, .y = <span class="tok-number">1.5</span> }, parsed);
    }<span class="tok-comment">

    // Comptime field assignment
    </span>{
        <span class="tok-kw">const</span> Vec2 = <span class="tok-kw">struct</span> { x: <span class="tok-type">f32</span>, <span class="tok-kw">comptime</span> y: <span class="tok-type">f32</span> = <span class="tok-number">1.5</span> };
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">const</span> parsed = <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Vec2, gpa, <span class="tok-str">&quot;.{.x = 1.2, .y = 1.5}&quot;</span>, &amp;status, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, parsed);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">\\1:18: error: cannot initialize comptime field</span>
            <span class="tok-str">\\</span>
        , <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // Enum field (regression test, we were previously getting the field name in an
    // incorrect way that broke for enum values)
    </span>{
        <span class="tok-kw">const</span> Vec0 = <span class="tok-kw">struct</span> { x: <span class="tok-kw">enum</span> { x } };
        <span class="tok-kw">const</span> parsed = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Vec0, gpa, <span class="tok-str">&quot;.{ .x = .x }&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Vec0{ .x = .x }, parsed);
    }<span class="tok-comment">

    // Enum field and struct field with @
    </span>{
        <span class="tok-kw">const</span> Vec0 = <span class="tok-kw">struct</span> { @&quot;x x&quot;: <span class="tok-kw">enum</span> { @&quot;x x&quot; } };
        <span class="tok-kw">const</span> parsed = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Vec0, gpa, <span class="tok-str">&quot;.{ .@\&quot;x x\&quot; = .@\&quot;x x\&quot; }&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Vec0{ .@&quot;x x&quot; = .@&quot;x x&quot; }, parsed);
    }<span class="tok-comment">

    // Type expressions are not allowed
    </span>{<span class="tok-comment">
        // Structs
        </span>{
            <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
            <span class="tok-kw">defer</span> status.deinit(gpa);
            <span class="tok-kw">const</span> parsed = <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-kw">struct</span> {}, gpa, <span class="tok-str">&quot;Empty{}&quot;</span>, &amp;status, .{});
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, parsed);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
                <span class="tok-str">\\1:1: error: types are not available in ZON</span>
                <span class="tok-str">\\1:1: note: replace the type with '.'</span>
                <span class="tok-str">\\</span>
            , <span class="tok-str">&quot;{}&quot;</span>, .{status});
        }<span class="tok-comment">

        // Arrays
        </span>{
            <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
            <span class="tok-kw">defer</span> status.deinit(gpa);
            <span class="tok-kw">const</span> parsed = <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([<span class="tok-number">3</span>]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;[3]u8{1, 2, 3}&quot;</span>, &amp;status, .{});
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, parsed);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
                <span class="tok-str">\\1:1: error: types are not available in ZON</span>
                <span class="tok-str">\\1:1: note: replace the type with '.'</span>
                <span class="tok-str">\\</span>
            , <span class="tok-str">&quot;{}&quot;</span>, .{status});
        }<span class="tok-comment">

        // Slices
        </span>{
            <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
            <span class="tok-kw">defer</span> status.deinit(gpa);
            <span class="tok-kw">const</span> parsed = <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;[]u8{1, 2, 3}&quot;</span>, &amp;status, .{});
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, parsed);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
                <span class="tok-str">\\1:1: error: types are not available in ZON</span>
                <span class="tok-str">\\1:1: note: replace the type with '.'</span>
                <span class="tok-str">\\</span>
            , <span class="tok-str">&quot;{}&quot;</span>, .{status});
        }<span class="tok-comment">

        // Tuples
        </span>{
            <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
            <span class="tok-kw">defer</span> status.deinit(gpa);
            <span class="tok-kw">const</span> parsed = <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
                <span class="tok-kw">struct</span> { <span class="tok-type">u8</span>, <span class="tok-type">u8</span>, <span class="tok-type">u8</span> },
                gpa,
                <span class="tok-str">&quot;Tuple{1, 2, 3}&quot;</span>,
                &amp;status,
                .{},
            );
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, parsed);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
                <span class="tok-str">\\1:1: error: types are not available in ZON</span>
                <span class="tok-str">\\1:1: note: replace the type with '.'</span>
                <span class="tok-str">\\</span>
            , <span class="tok-str">&quot;{}&quot;</span>, .{status});
        }<span class="tok-comment">

        // Nested
        </span>{
            <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
            <span class="tok-kw">defer</span> status.deinit(gpa);
            <span class="tok-kw">const</span> parsed = <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-kw">struct</span> {}, gpa, <span class="tok-str">&quot;.{ .x = Tuple{1, 2, 3} }&quot;</span>, &amp;status, .{});
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, parsed);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
                <span class="tok-str">\\1:9: error: types are not available in ZON</span>
                <span class="tok-str">\\1:9: note: replace the type with '.'</span>
                <span class="tok-str">\\</span>
            , <span class="tok-str">&quot;{}&quot;</span>, .{status});
        }
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon tuples&quot;</span> {
    <span class="tok-kw">const</span> gpa = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;<span class="tok-comment">

    // Structs (various sizes tested since they're parsed differently)
    </span>{
        <span class="tok-kw">const</span> Tuple0 = <span class="tok-kw">struct</span> {};
        <span class="tok-kw">const</span> Tuple1 = <span class="tok-kw">struct</span> { <span class="tok-type">f32</span> };
        <span class="tok-kw">const</span> Tuple2 = <span class="tok-kw">struct</span> { <span class="tok-type">f32</span>, <span class="tok-type">bool</span> };
        <span class="tok-kw">const</span> Tuple3 = <span class="tok-kw">struct</span> { <span class="tok-type">f32</span>, <span class="tok-type">bool</span>, <span class="tok-type">u8</span> };

        <span class="tok-kw">const</span> zero = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Tuple0, gpa, <span class="tok-str">&quot;.{}&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Tuple0{}, zero);

        <span class="tok-kw">const</span> one = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Tuple1, gpa, <span class="tok-str">&quot;.{1.2}&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Tuple1{<span class="tok-number">1.2</span>}, one);

        <span class="tok-kw">const</span> two = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Tuple2, gpa, <span class="tok-str">&quot;.{1.2, true}&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Tuple2{ <span class="tok-number">1.2</span>, <span class="tok-null">true</span> }, two);

        <span class="tok-kw">const</span> three = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Tuple3, gpa, <span class="tok-str">&quot;.{1.2, false, 3}&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Tuple3{ <span class="tok-number">1.2</span>, <span class="tok-null">false</span>, <span class="tok-number">3</span> }, three);
    }<span class="tok-comment">

    // Deep free
    </span>{
        <span class="tok-kw">const</span> Tuple = <span class="tok-kw">struct</span> { []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, []<span class="tok-kw">const</span> <span class="tok-type">u8</span> };
        <span class="tok-kw">const</span> parsed = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Tuple, gpa, <span class="tok-str">&quot;.{\&quot;hello\&quot;, \&quot;world\&quot;}&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, parsed);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualDeep">expectEqualDeep</a>(Tuple{ <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-str">&quot;world&quot;</span> }, parsed);
    }<span class="tok-comment">

    // Extra field
    </span>{
        <span class="tok-kw">const</span> Tuple = <span class="tok-kw">struct</span> { <span class="tok-type">f32</span>, <span class="tok-type">bool</span> };
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Tuple, gpa, <span class="tok-str">&quot;.{0.5, true, 123}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:14: error: index 2 outside of tuple length 2\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // Extra field
    </span>{
        <span class="tok-kw">const</span> Tuple = <span class="tok-kw">struct</span> { <span class="tok-type">f32</span>, <span class="tok-type">bool</span> };
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Tuple, gpa, <span class="tok-str">&quot;.{0.5}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:2: error: missing tuple field with index 1\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Tuple with unexpected field names
    </span>{
        <span class="tok-kw">const</span> Tuple = <span class="tok-kw">struct</span> { <span class="tok-type">f32</span> };
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Tuple, gpa, <span class="tok-str">&quot;.{.foo = 10.0}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:2: error: expected tuple\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // Struct with missing field names
    </span>{
        <span class="tok-kw">const</span> Struct = <span class="tok-kw">struct</span> { foo: <span class="tok-type">f32</span> };
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Struct, gpa, <span class="tok-str">&quot;.{10.0}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:2: error: expected struct\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // Comptime field
    </span>{
        <span class="tok-kw">const</span> Vec2 = <span class="tok-kw">struct</span> { <span class="tok-type">f32</span>, <span class="tok-kw">comptime</span> <span class="tok-type">f32</span> = <span class="tok-number">1.5</span> };
        <span class="tok-kw">const</span> parsed = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Vec2, gpa, <span class="tok-str">&quot;.{ 1.2 }&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Vec2{ <span class="tok-number">1.2</span>, <span class="tok-number">1.5</span> }, parsed);
    }<span class="tok-comment">

    // Comptime field assignment
    </span>{
        <span class="tok-kw">const</span> Vec2 = <span class="tok-kw">struct</span> { <span class="tok-type">f32</span>, <span class="tok-kw">comptime</span> <span class="tok-type">f32</span> = <span class="tok-number">1.5</span> };
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">const</span> parsed = <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Vec2, gpa, <span class="tok-str">&quot;.{ 1.2, 1.5}&quot;</span>, &amp;status, .{});
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, parsed);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">\\1:9: error: cannot initialize comptime field</span>
            <span class="tok-str">\\</span>
        , <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }
}<span class="tok-comment">

// Test sizes 0 to 3 since small sizes get parsed differently
</span><span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon arrays and slices&quot;</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_c) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;<span class="tok-comment"> // https://github.com/ziglang/zig/issues/20881

    </span><span class="tok-kw">const</span> gpa = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;<span class="tok-comment">

    // Literals
    </span>{<span class="tok-comment">
        // Arrays
        </span>{
            <span class="tok-kw">const</span> zero = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([<span class="tok-number">0</span>]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{}&quot;</span>, <span class="tok-null">null</span>, .{});
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;<span class="tok-builtin">@as</span>([<span class="tok-number">0</span>]<span class="tok-type">u8</span>, .{}), &amp;zero);

            <span class="tok-kw">const</span> one = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([<span class="tok-number">1</span>]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{'a'}&quot;</span>, <span class="tok-null">null</span>, .{});
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;<span class="tok-builtin">@as</span>([<span class="tok-number">1</span>]<span class="tok-type">u8</span>, .{<span class="tok-str">'a'</span>}), &amp;one);

            <span class="tok-kw">const</span> two = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([<span class="tok-number">2</span>]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{'a', 'b'}&quot;</span>, <span class="tok-null">null</span>, .{});
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;<span class="tok-builtin">@as</span>([<span class="tok-number">2</span>]<span class="tok-type">u8</span>, .{ <span class="tok-str">'a'</span>, <span class="tok-str">'b'</span> }), &amp;two);

            <span class="tok-kw">const</span> two_comma = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([<span class="tok-number">2</span>]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{'a', 'b',}&quot;</span>, <span class="tok-null">null</span>, .{});
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;<span class="tok-builtin">@as</span>([<span class="tok-number">2</span>]<span class="tok-type">u8</span>, .{ <span class="tok-str">'a'</span>, <span class="tok-str">'b'</span> }), &amp;two_comma);

            <span class="tok-kw">const</span> three = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([<span class="tok-number">3</span>]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{'a', 'b', 'c'}&quot;</span>, <span class="tok-null">null</span>, .{});
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;.{ <span class="tok-str">'a'</span>, <span class="tok-str">'b'</span>, <span class="tok-str">'c'</span> }, &amp;three);

            <span class="tok-kw">const</span> sentinel = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([<span class="tok-number">3</span>:<span class="tok-str">'z'</span>]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{'a', 'b', 'c'}&quot;</span>, <span class="tok-null">null</span>, .{});
            <span class="tok-kw">const</span> expected_sentinel: [<span class="tok-number">3</span>:<span class="tok-str">'z'</span>]<span class="tok-type">u8</span> = .{ <span class="tok-str">'a'</span>, <span class="tok-str">'b'</span>, <span class="tok-str">'c'</span> };
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;expected_sentinel, &amp;sentinel);
        }<span class="tok-comment">

        // Slice literals
        </span>{
            <span class="tok-kw">const</span> zero = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{}&quot;</span>, <span class="tok-null">null</span>, .{});
            <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, zero);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-builtin">@as</span>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, &amp;.{}), zero);

            <span class="tok-kw">const</span> one = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{'a'}&quot;</span>, <span class="tok-null">null</span>, .{});
            <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, one);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;.{<span class="tok-str">'a'</span>}, one);

            <span class="tok-kw">const</span> two = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{'a', 'b'}&quot;</span>, <span class="tok-null">null</span>, .{});
            <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, two);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;.{ <span class="tok-str">'a'</span>, <span class="tok-str">'b'</span> }, two);

            <span class="tok-kw">const</span> two_comma = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{'a', 'b',}&quot;</span>, <span class="tok-null">null</span>, .{});
            <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, two_comma);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;.{ <span class="tok-str">'a'</span>, <span class="tok-str">'b'</span> }, two_comma);

            <span class="tok-kw">const</span> three = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{'a', 'b', 'c'}&quot;</span>, <span class="tok-null">null</span>, .{});
            <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, three);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;.{ <span class="tok-str">'a'</span>, <span class="tok-str">'b'</span>, <span class="tok-str">'c'</span> }, three);

            <span class="tok-kw">const</span> sentinel = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([:<span class="tok-str">'z'</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{'a', 'b', 'c'}&quot;</span>, <span class="tok-null">null</span>, .{});
            <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, sentinel);
            <span class="tok-kw">const</span> expected_sentinel: [:<span class="tok-str">'z'</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;.{ <span class="tok-str">'a'</span>, <span class="tok-str">'b'</span>, <span class="tok-str">'c'</span> };
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, expected_sentinel, sentinel);
        }
    }<span class="tok-comment">

    // Deep free
    </span>{<span class="tok-comment">
        // Arrays
        </span>{
            <span class="tok-kw">const</span> parsed = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([<span class="tok-number">1</span>][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{\&quot;abc\&quot;}&quot;</span>, <span class="tok-null">null</span>, .{});
            <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, parsed);
            <span class="tok-kw">const</span> expected: [<span class="tok-number">1</span>][]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = .{<span class="tok-str">&quot;abc&quot;</span>};
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualDeep">expectEqualDeep</a>(expected, parsed);
        }<span class="tok-comment">

        // Slice literals
        </span>{
            <span class="tok-kw">const</span> parsed = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{\&quot;abc\&quot;}&quot;</span>, <span class="tok-null">null</span>, .{});
            <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, parsed);
            <span class="tok-kw">const</span> expected: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;.{<span class="tok-str">&quot;abc&quot;</span>};
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualDeep">expectEqualDeep</a>(expected, parsed);
        }
    }<span class="tok-comment">

    // Sentinels and alignment
    </span>{<span class="tok-comment">
        // Arrays
        </span>{
            <span class="tok-kw">const</span> sentinel = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([<span class="tok-number">1</span>:<span class="tok-number">2</span>]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{1}&quot;</span>, <span class="tok-null">null</span>, .{});
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>), sentinel.len);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>), sentinel[<span class="tok-number">0</span>]);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">2</span>), sentinel[<span class="tok-number">1</span>]);
        }<span class="tok-comment">

        // Slice literals
        </span>{
            <span class="tok-kw">const</span> sentinel = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([:<span class="tok-number">2</span>]<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{1}&quot;</span>, <span class="tok-null">null</span>, .{});
            <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, sentinel);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>), sentinel.len);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>), sentinel[<span class="tok-number">0</span>]);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">2</span>), sentinel[<span class="tok-number">1</span>]);
        }
    }<span class="tok-comment">

    // Expect 0 find 3
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([<span class="tok-number">0</span>]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{'a', 'b', 'c'}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:3: error: index 0 outside of array of length 0\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Expect 1 find 2
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([<span class="tok-number">1</span>]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{'a', 'b'}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:8: error: index 1 outside of array of length 1\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Expect 2 find 1
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([<span class="tok-number">2</span>]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{'a'}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:2: error: expected 2 array elements; found 1\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Expect 3 find 0
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([<span class="tok-number">3</span>]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:2: error: expected 3 array elements; found 0\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Wrong inner type
    </span>{<span class="tok-comment">
        // Array
        </span>{
            <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
            <span class="tok-kw">defer</span> status.deinit(gpa);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
                <span class="tok-kw">error</span>.ParseZon,
                <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([<span class="tok-number">3</span>]<span class="tok-type">bool</span>, gpa, <span class="tok-str">&quot;.{'a', 'b', 'c'}&quot;</span>, &amp;status, .{}),
            );
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:3: error: expected type 'bool'\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
        }<span class="tok-comment">

        // Slice
        </span>{
            <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
            <span class="tok-kw">defer</span> status.deinit(gpa);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
                <span class="tok-kw">error</span>.ParseZon,
                <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-type">bool</span>, gpa, <span class="tok-str">&quot;.{'a', 'b', 'c'}&quot;</span>, &amp;status, .{}),
            );
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:3: error: expected type 'bool'\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
        }
    }<span class="tok-comment">

    // Complete wrong type
    </span>{<span class="tok-comment">
        // Array
        </span>{
            <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
            <span class="tok-kw">defer</span> status.deinit(gpa);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
                <span class="tok-kw">error</span>.ParseZon,
                <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([<span class="tok-number">3</span>]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;'a'&quot;</span>, &amp;status, .{}),
            );
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected array\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
        }<span class="tok-comment">

        // Slice
        </span>{
            <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
            <span class="tok-kw">defer</span> status.deinit(gpa);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
                <span class="tok-kw">error</span>.ParseZon,
                <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;'a'&quot;</span>, &amp;status, .{}),
            );
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected array\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
        }
    }<span class="tok-comment">

    // Address of is not allowed (indirection for slices in ZON is implicit)
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;  &amp;.{'a', 'b', 'c'}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:3: error: pointers are not available in ZON\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon string literal&quot;</span> {
    <span class="tok-kw">const</span> gpa = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;<span class="tok-comment">

    // Basic string literal
    </span>{
        <span class="tok-kw">const</span> parsed = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;\&quot;abc\&quot;&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, parsed);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-builtin">@as</span>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-str">&quot;abc&quot;</span>), parsed);
    }<span class="tok-comment">

    // String literal with escape characters
    </span>{
        <span class="tok-kw">const</span> parsed = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;\&quot;ab\\nc\&quot;&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, parsed);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-builtin">@as</span>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-str">&quot;ab\nc&quot;</span>), parsed);
    }<span class="tok-comment">

    // String literal with embedded null
    </span>{
        <span class="tok-kw">const</span> parsed = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;\&quot;ab\\x00c\&quot;&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, parsed);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-builtin">@as</span>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-str">&quot;ab\x00c&quot;</span>), parsed);
    }<span class="tok-comment">

    // Passing string literal to a mutable slice
    </span>{
        {
            <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
            <span class="tok-kw">defer</span> status.deinit(gpa);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
                <span class="tok-kw">error</span>.ParseZon,
                <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;\&quot;abcd\&quot;&quot;</span>, &amp;status, .{}),
            );
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected array\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
        }

        {
            <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
            <span class="tok-kw">defer</span> status.deinit(gpa);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
                <span class="tok-kw">error</span>.ParseZon,
                <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;\\\\abcd&quot;</span>, &amp;status, .{}),
            );
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected array\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
        }
    }<span class="tok-comment">

    // Passing string literal to a array
    </span>{
        {
            <span class="tok-kw">var</span> ast = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.parse">parse</a>(gpa, <span class="tok-str">&quot;\&quot;abcd\&quot;&quot;</span>, .zon);
            <span class="tok-kw">defer</span> ast.deinit(gpa);
            <span class="tok-kw">var</span> zoir = <span class="tok-kw">try</span> <a href="std.zig.ZonGen.html">ZonGen</a>.<a href="std.zig.ZonGen.html#std.zig.ZonGen.generate">generate</a>(gpa, ast, .{ .parse_str_lits = <span class="tok-null">false</span> });
            <span class="tok-kw">defer</span> zoir.deinit(gpa);
            <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
            <span class="tok-kw">defer</span> status.deinit(gpa);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
                <span class="tok-kw">error</span>.ParseZon,
                <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([<span class="tok-number">4</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;\&quot;abcd\&quot;&quot;</span>, &amp;status, .{}),
            );
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected array\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
        }

        {
            <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
            <span class="tok-kw">defer</span> status.deinit(gpa);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
                <span class="tok-kw">error</span>.ParseZon,
                <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([<span class="tok-number">4</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;\\\\abcd&quot;</span>, &amp;status, .{}),
            );
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected array\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
        }
    }<span class="tok-comment">

    // Zero terminated slices
    </span>{
        {
            <span class="tok-kw">const</span> parsed: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
                [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
                gpa,
                <span class="tok-str">&quot;\&quot;abc\&quot;&quot;</span>,
                <span class="tok-null">null</span>,
                .{},
            );
            <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, parsed);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;abc&quot;</span>, parsed);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>), parsed[<span class="tok-number">3</span>]);
        }

        {
            <span class="tok-kw">const</span> parsed: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
                [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
                gpa,
                <span class="tok-str">&quot;\\\\abc&quot;</span>,
                <span class="tok-null">null</span>,
                .{},
            );
            <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, parsed);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;abc&quot;</span>, parsed);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>), parsed[<span class="tok-number">3</span>]);
        }
    }<span class="tok-comment">

    // Other value terminated slices
    </span>{
        {
            <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
            <span class="tok-kw">defer</span> status.deinit(gpa);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
                <span class="tok-kw">error</span>.ParseZon,
                <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([:<span class="tok-number">1</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;\&quot;foo\&quot;&quot;</span>, &amp;status, .{}),
            );
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected array\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
        }

        {
            <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
            <span class="tok-kw">defer</span> status.deinit(gpa);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
                <span class="tok-kw">error</span>.ParseZon,
                <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([:<span class="tok-number">1</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;\\\\foo&quot;</span>, &amp;status, .{}),
            );
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected array\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
        }
    }<span class="tok-comment">

    // Expecting string literal, getting something else
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;true&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected string\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // Expecting string literal, getting an incompatible tuple
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{false}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:3: error: expected type 'u8'\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // Invalid string literal
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-kw">const</span> <span class="tok-type">i8</span>, gpa, <span class="tok-str">&quot;\&quot;\\a\&quot;&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:3: error: invalid escape character: 'a'\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // Slice wrong child type
    </span>{
        {
            <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
            <span class="tok-kw">defer</span> status.deinit(gpa);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
                <span class="tok-kw">error</span>.ParseZon,
                <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-kw">const</span> <span class="tok-type">i8</span>, gpa, <span class="tok-str">&quot;\&quot;a\&quot;&quot;</span>, &amp;status, .{}),
            );
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected array\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
        }

        {
            <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
            <span class="tok-kw">defer</span> status.deinit(gpa);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
                <span class="tok-kw">error</span>.ParseZon,
                <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-kw">const</span> <span class="tok-type">i8</span>, gpa, <span class="tok-str">&quot;\\\\a&quot;</span>, &amp;status, .{}),
            );
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected array\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
        }
    }<span class="tok-comment">

    // Bad alignment
    </span>{
        {
            <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
            <span class="tok-kw">defer</span> status.deinit(gpa);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
                <span class="tok-kw">error</span>.ParseZon,
                <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-kw">align</span>(<span class="tok-number">2</span>) <span class="tok-kw">const</span> <span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;\&quot;abc\&quot;&quot;</span>, &amp;status, .{}),
            );
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected array\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
        }

        {
            <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
            <span class="tok-kw">defer</span> status.deinit(gpa);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
                <span class="tok-kw">error</span>.ParseZon,
                <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>([]<span class="tok-kw">align</span>(<span class="tok-number">2</span>) <span class="tok-kw">const</span> <span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;\\\\abc&quot;</span>, &amp;status, .{}),
            );
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected array\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
        }
    }<span class="tok-comment">

    // Multi line strings
    </span><span class="tok-kw">inline</span> <span class="tok-kw">for</span> (.{ []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> }) |String| {<span class="tok-comment">
        // Nested
        </span>{
            <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
                message: String,
                message2: String,
                message3: String,
            };
            <span class="tok-kw">const</span> parsed = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(S, gpa,
                <span class="tok-str">\\.{</span>
                <span class="tok-str">\\    .message =</span>
                <span class="tok-str">\\        \\hello, world!</span>
                <span class="tok-str">\\</span>
                <span class="tok-str">\\        \\this is a multiline string!</span>
                <span class="tok-str">\\        \\</span>
                <span class="tok-str">\\        \\...</span>
                <span class="tok-str">\\</span>
                <span class="tok-str">\\    ,</span>
                <span class="tok-str">\\    .message2 =</span>
                <span class="tok-str">\\        \\this too...sort of.</span>
                <span class="tok-str">\\    ,</span>
                <span class="tok-str">\\    .message3 =</span>
                <span class="tok-str">\\        \\</span>
                <span class="tok-str">\\        \\and this.</span>
                <span class="tok-str">\\}</span>
            , <span class="tok-null">null</span>, .{});
            <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, parsed);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(
                <span class="tok-str">&quot;hello, world!\nthis is a multiline string!\n\n...&quot;</span>,
                parsed.message,
            );
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;this too...sort of.&quot;</span>, parsed.message2);
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;\nand this.&quot;</span>, parsed.message3);
        }
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon enum literals&quot;</span> {
    <span class="tok-kw">const</span> gpa = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;

    <span class="tok-kw">const</span> Enum = <span class="tok-kw">enum</span> {
        foo,
        bar,
        baz,
        @&quot;ab\nc&quot;,
    };<span class="tok-comment">

    // Tags that exist
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Enum.foo, <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Enum, gpa, <span class="tok-str">&quot;.foo&quot;</span>, <span class="tok-null">null</span>, .{}));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Enum.bar, <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Enum, gpa, <span class="tok-str">&quot;.bar&quot;</span>, <span class="tok-null">null</span>, .{}));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Enum.baz, <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Enum, gpa, <span class="tok-str">&quot;.baz&quot;</span>, <span class="tok-null">null</span>, .{}));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        Enum.@&quot;ab\nc&quot;,
        <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Enum, gpa, <span class="tok-str">&quot;.@\&quot;ab\\nc\&quot;&quot;</span>, <span class="tok-null">null</span>, .{}),
    );<span class="tok-comment">

    // Bad tag
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Enum, gpa, <span class="tok-str">&quot;.qux&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">\\1:2: error: unexpected enum literal 'qux'</span>
            <span class="tok-str">\\1:2: note: supported: 'foo', 'bar', 'baz', '@&quot;ab\nc&quot;'</span>
            <span class="tok-str">\\</span>
        ,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Bad tag that's too long for parser
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Enum, gpa, <span class="tok-str">&quot;.@\&quot;foobarbaz\&quot;&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">\\1:2: error: unexpected enum literal 'foobarbaz'</span>
            <span class="tok-str">\\1:2: note: supported: 'foo', 'bar', 'baz', '@&quot;ab\nc&quot;'</span>
            <span class="tok-str">\\</span>
        ,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Bad type
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Enum, gpa, <span class="tok-str">&quot;true&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected enum literal\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // Test embedded nulls in an identifier
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Enum, gpa, <span class="tok-str">&quot;.@\&quot;\\x00\&quot;&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:2: error: identifier cannot contain null bytes\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon parse bool&quot;</span> {
    <span class="tok-kw">const</span> gpa = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;<span class="tok-comment">

    // Correct floats
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">true</span>, <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">bool</span>, gpa, <span class="tok-str">&quot;true&quot;</span>, <span class="tok-null">null</span>, .{}));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">bool</span>, gpa, <span class="tok-str">&quot;false&quot;</span>, <span class="tok-null">null</span>, .{}));<span class="tok-comment">

    // Errors
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">bool</span>, gpa, <span class="tok-str">&quot; foo&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">\\1:2: error: invalid expression</span>
            <span class="tok-str">\\1:2: note: ZON allows identifiers 'true', 'false', 'null', 'inf', and 'nan'</span>
            <span class="tok-str">\\1:2: note: precede identifier with '.' for an enum literal</span>
            <span class="tok-str">\\</span>
        , <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }
    {
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">bool</span>, gpa, <span class="tok-str">&quot;123&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected type 'bool'\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon intFromFloatExact&quot;</span> {<span class="tok-comment">
    // Valid conversions
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">10</span>), <a href="std.zon.parse.html#std.zon.parse.intFromFloatExact">intFromFloatExact</a>(<span class="tok-type">u8</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-number">10.0</span>)).?);
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, -<span class="tok-number">123</span>), <a href="std.zon.parse.html#std.zon.parse.intFromFloatExact">intFromFloatExact</a>(<span class="tok-type">i8</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, -<span class="tok-number">123.0</span>))).?);
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i16</span>, <span class="tok-number">45</span>), <a href="std.zon.parse.html#std.zon.parse.intFromFloatExact">intFromFloatExact</a>(<span class="tok-type">i16</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">f128</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">f128</span>, <span class="tok-number">45.0</span>))).?);<span class="tok-comment">

    // Out of range
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">u4</span>, <span class="tok-null">null</span>), <a href="std.zon.parse.html#std.zon.parse.intFromFloatExact">intFromFloatExact</a>(<span class="tok-type">u4</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-number">16.0</span>)));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i4</span>, <span class="tok-null">null</span>), <a href="std.zon.parse.html#std.zon.parse.intFromFloatExact">intFromFloatExact</a>(<span class="tok-type">i4</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, -<span class="tok-number">17.0</span>)));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">u8</span>, <span class="tok-null">null</span>), <a href="std.zon.parse.html#std.zon.parse.intFromFloatExact">intFromFloatExact</a>(<span class="tok-type">u8</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">f128</span>, -<span class="tok-number">2.0</span>)));<span class="tok-comment">

    // Not a whole number
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">u8</span>, <span class="tok-null">null</span>), <a href="std.zon.parse.html#std.zon.parse.intFromFloatExact">intFromFloatExact</a>(<span class="tok-type">u8</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-number">0.5</span>)));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i8</span>, <span class="tok-null">null</span>), <a href="std.zon.parse.html#std.zon.parse.intFromFloatExact">intFromFloatExact</a>(<span class="tok-type">i8</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-number">0.01</span>)));<span class="tok-comment">

    // Infinity and NaN
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">u8</span>, <span class="tok-null">null</span>), <a href="std.zon.parse.html#std.zon.parse.intFromFloatExact">intFromFloatExact</a>(<span class="tok-type">u8</span>, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.inf">inf</a>(<span class="tok-type">f32</span>)));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">u8</span>, <span class="tok-null">null</span>), <a href="std.zon.parse.html#std.zon.parse.intFromFloatExact">intFromFloatExact</a>(<span class="tok-type">u8</span>, -<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.inf">inf</a>(<span class="tok-type">f32</span>)));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">u8</span>, <span class="tok-null">null</span>), <a href="std.zon.parse.html#std.zon.parse.intFromFloatExact">intFromFloatExact</a>(<span class="tok-type">u8</span>, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.nan">nan</a>(<span class="tok-type">f32</span>)));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon parse int&quot;</span> {
    <span class="tok-kw">const</span> gpa = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;<span class="tok-comment">

    // Test various numbers and types
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">10</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;10&quot;</span>, <span class="tok-null">null</span>, .{}));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i16</span>, <span class="tok-number">24</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i16</span>, gpa, <span class="tok-str">&quot;24&quot;</span>, <span class="tok-null">null</span>, .{}));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i14</span>, -<span class="tok-number">4</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i14</span>, gpa, <span class="tok-str">&quot;-4&quot;</span>, <span class="tok-null">null</span>, .{}));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, -<span class="tok-number">123</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i32</span>, gpa, <span class="tok-str">&quot;-123&quot;</span>, <span class="tok-null">null</span>, .{}));<span class="tok-comment">

    // Test limits
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, <span class="tok-number">127</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i8</span>, gpa, <span class="tok-str">&quot;127&quot;</span>, <span class="tok-null">null</span>, .{}));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, -<span class="tok-number">128</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i8</span>, gpa, <span class="tok-str">&quot;-128&quot;</span>, <span class="tok-null">null</span>, .{}));<span class="tok-comment">

    // Test characters
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-str">'a'</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;'a'&quot;</span>, <span class="tok-null">null</span>, .{}));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-str">'z'</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;'z'&quot;</span>, <span class="tok-null">null</span>, .{}));<span class="tok-comment">

    // Test big integers
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@as</span>(<span class="tok-type">u65</span>, <span class="tok-number">36893488147419103231</span>),
        <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">u65</span>, gpa, <span class="tok-str">&quot;36893488147419103231&quot;</span>, <span class="tok-null">null</span>, .{}),
    );
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@as</span>(<span class="tok-type">u65</span>, <span class="tok-number">36893488147419103231</span>),
        <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">u65</span>, gpa, <span class="tok-str">&quot;368934_881_474191032_31&quot;</span>, <span class="tok-null">null</span>, .{}),
    );<span class="tok-comment">

    // Test big integer limits
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@as</span>(<span class="tok-type">i66</span>, <span class="tok-number">36893488147419103231</span>),
        <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i66</span>, gpa, <span class="tok-str">&quot;36893488147419103231&quot;</span>, <span class="tok-null">null</span>, .{}),
    );
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@as</span>(<span class="tok-type">i66</span>, -<span class="tok-number">36893488147419103232</span>),
        <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i66</span>, gpa, <span class="tok-str">&quot;-36893488147419103232&quot;</span>, <span class="tok-null">null</span>, .{}),
    );
    {
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
            <span class="tok-type">i66</span>,
            gpa,
            <span class="tok-str">&quot;36893488147419103232&quot;</span>,
            &amp;status,
            .{},
        ));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:1: error: type 'i66' cannot represent value\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }
    {
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
            <span class="tok-type">i66</span>,
            gpa,
            <span class="tok-str">&quot;-36893488147419103233&quot;</span>,
            &amp;status,
            .{},
        ));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:1: error: type 'i66' cannot represent value\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Test parsing whole number floats as integers
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, -<span class="tok-number">1</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i8</span>, gpa, <span class="tok-str">&quot;-1.0&quot;</span>, <span class="tok-null">null</span>, .{}));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, <span class="tok-number">123</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i8</span>, gpa, <span class="tok-str">&quot;123.0&quot;</span>, <span class="tok-null">null</span>, .{}));<span class="tok-comment">

    // Test non-decimal integers
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i16</span>, <span class="tok-number">0xff</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i16</span>, gpa, <span class="tok-str">&quot;0xff&quot;</span>, <span class="tok-null">null</span>, .{}));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i16</span>, -<span class="tok-number">0xff</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i16</span>, gpa, <span class="tok-str">&quot;-0xff&quot;</span>, <span class="tok-null">null</span>, .{}));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i16</span>, <span class="tok-number">0o77</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i16</span>, gpa, <span class="tok-str">&quot;0o77&quot;</span>, <span class="tok-null">null</span>, .{}));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i16</span>, -<span class="tok-number">0o77</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i16</span>, gpa, <span class="tok-str">&quot;-0o77&quot;</span>, <span class="tok-null">null</span>, .{}));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i16</span>, <span class="tok-number">0b11</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i16</span>, gpa, <span class="tok-str">&quot;0b11&quot;</span>, <span class="tok-null">null</span>, .{}));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i16</span>, -<span class="tok-number">0b11</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i16</span>, gpa, <span class="tok-str">&quot;-0b11&quot;</span>, <span class="tok-null">null</span>, .{}));<span class="tok-comment">

    // Test non-decimal big integers
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u65</span>, <span class="tok-number">0x1ffffffffffffffff</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
        <span class="tok-type">u65</span>,
        gpa,
        <span class="tok-str">&quot;0x1ffffffffffffffff&quot;</span>,
        <span class="tok-null">null</span>,
        .{},
    ));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i66</span>, <span class="tok-number">0x1ffffffffffffffff</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
        <span class="tok-type">i66</span>,
        gpa,
        <span class="tok-str">&quot;0x1ffffffffffffffff&quot;</span>,
        <span class="tok-null">null</span>,
        .{},
    ));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i66</span>, -<span class="tok-number">0x1ffffffffffffffff</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
        <span class="tok-type">i66</span>,
        gpa,
        <span class="tok-str">&quot;-0x1ffffffffffffffff&quot;</span>,
        <span class="tok-null">null</span>,
        .{},
    ));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u65</span>, <span class="tok-number">0x1ffffffffffffffff</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
        <span class="tok-type">u65</span>,
        gpa,
        <span class="tok-str">&quot;0o3777777777777777777777&quot;</span>,
        <span class="tok-null">null</span>,
        .{},
    ));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i66</span>, <span class="tok-number">0x1ffffffffffffffff</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
        <span class="tok-type">i66</span>,
        gpa,
        <span class="tok-str">&quot;0o3777777777777777777777&quot;</span>,
        <span class="tok-null">null</span>,
        .{},
    ));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i66</span>, -<span class="tok-number">0x1ffffffffffffffff</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
        <span class="tok-type">i66</span>,
        gpa,
        <span class="tok-str">&quot;-0o3777777777777777777777&quot;</span>,
        <span class="tok-null">null</span>,
        .{},
    ));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u65</span>, <span class="tok-number">0x1ffffffffffffffff</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
        <span class="tok-type">u65</span>,
        gpa,
        <span class="tok-str">&quot;0b11111111111111111111111111111111111111111111111111111111111111111&quot;</span>,
        <span class="tok-null">null</span>,
        .{},
    ));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i66</span>, <span class="tok-number">0x1ffffffffffffffff</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
        <span class="tok-type">i66</span>,
        gpa,
        <span class="tok-str">&quot;0b11111111111111111111111111111111111111111111111111111111111111111&quot;</span>,
        <span class="tok-null">null</span>,
        .{},
    ));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i66</span>, -<span class="tok-number">0x1ffffffffffffffff</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
        <span class="tok-type">i66</span>,
        gpa,
        <span class="tok-str">&quot;-0b11111111111111111111111111111111111111111111111111111111111111111&quot;</span>,
        <span class="tok-null">null</span>,
        .{},
    ));<span class="tok-comment">

    // Number with invalid character in the middle
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;32a32&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:3: error: invalid digit 'a' for decimal base\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Failing to parse as int
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;true&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected type 'u8'\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // Failing because an int is out of range
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;256&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:1: error: type 'u8' cannot represent value\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Failing because a negative int is out of range
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i8</span>, gpa, <span class="tok-str">&quot;-129&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:1: error: type 'i8' cannot represent value\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Failing because an unsigned int is negative
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;-1&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:1: error: type 'u8' cannot represent value\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Failing because a float is non-whole
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;1.5&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:1: error: type 'u8' cannot represent value\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Failing because a float is negative
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;-1.0&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:1: error: type 'u8' cannot represent value\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Negative integer zero
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i8</span>, gpa, <span class="tok-str">&quot;-0&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">\\1:2: error: integer literal '-0' is ambiguous</span>
            <span class="tok-str">\\1:2: note: use '0' for an integer zero</span>
            <span class="tok-str">\\1:2: note: use '-0.0' for a floating-point signed zero</span>
            <span class="tok-str">\\</span>
        , <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // Negative integer zero casted to float
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;-0&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">\\1:2: error: integer literal '-0' is ambiguous</span>
            <span class="tok-str">\\1:2: note: use '0' for an integer zero</span>
            <span class="tok-str">\\1:2: note: use '-0.0' for a floating-point signed zero</span>
            <span class="tok-str">\\</span>
        , <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // Negative float 0 is allowed
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(
        <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.iszero.html#std.math.iszero.isNegativeZero">isNegativeZero</a>(<span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;-0.0&quot;</span>, <span class="tok-null">null</span>, .{})),
    );
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.iszero.html#std.math.iszero.isPositiveZero">isPositiveZero</a>(<span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;0.0&quot;</span>, <span class="tok-null">null</span>, .{})));<span class="tok-comment">

    // Double negation is not allowed
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i8</span>, gpa, <span class="tok-str">&quot;--2&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:1: error: expected number or 'inf' after '-'\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }

    {
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;--2.0&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:1: error: expected number or 'inf' after '-'\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Invalid int literal
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;0xg&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:3: error: invalid digit 'g' for hex base\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // Notes on invalid int literal
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;0123&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">\\1:1: error: number '0123' has leading zero</span>
            <span class="tok-str">\\1:1: note: use '0o' prefix for octal literals</span>
            <span class="tok-str">\\</span>
        , <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon negative char&quot;</span> {
    <span class="tok-kw">const</span> gpa = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;

    {
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;-'a'&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:1: error: expected number or 'inf' after '-'\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }
    {
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i16</span>, gpa, <span class="tok-str">&quot;-'a'&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:1: error: expected number or 'inf' after '-'\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon parse float&quot;</span> {
    <span class="tok-kw">const</span> gpa = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;<span class="tok-comment">

    // Test decimals
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">f16</span>, <span class="tok-number">0.5</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f16</span>, gpa, <span class="tok-str">&quot;0.5&quot;</span>, <span class="tok-null">null</span>, .{}));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-number">123.456</span>),
        <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;123.456&quot;</span>, <span class="tok-null">null</span>, .{}),
    );
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, -<span class="tok-number">123.456</span>),
        <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f64</span>, gpa, <span class="tok-str">&quot;-123.456&quot;</span>, <span class="tok-null">null</span>, .{}),
    );
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">f128</span>, <span class="tok-number">42.5</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f128</span>, gpa, <span class="tok-str">&quot;42.5&quot;</span>, <span class="tok-null">null</span>, .{}));<span class="tok-comment">

    // Test whole numbers with and without decimals
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">f16</span>, <span class="tok-number">5.0</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f16</span>, gpa, <span class="tok-str">&quot;5.0&quot;</span>, <span class="tok-null">null</span>, .{}));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">f16</span>, <span class="tok-number">5.0</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f16</span>, gpa, <span class="tok-str">&quot;5&quot;</span>, <span class="tok-null">null</span>, .{}));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, -<span class="tok-number">102</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;-102.0&quot;</span>, <span class="tok-null">null</span>, .{}));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, -<span class="tok-number">102</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;-102&quot;</span>, <span class="tok-null">null</span>, .{}));<span class="tok-comment">

    // Test characters and negated characters
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-str">'a'</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;'a'&quot;</span>, <span class="tok-null">null</span>, .{}));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-str">'z'</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;'z'&quot;</span>, <span class="tok-null">null</span>, .{}));<span class="tok-comment">

    // Test big integers
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-number">36893488147419103231</span>),
        <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;36893488147419103231&quot;</span>, <span class="tok-null">null</span>, .{}),
    );
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, -<span class="tok-number">36893488147419103231</span>),
        <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;-36893488147419103231&quot;</span>, <span class="tok-null">null</span>, .{}),
    );
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">f128</span>, <span class="tok-number">0x1ffffffffffffffff</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
        <span class="tok-type">f128</span>,
        gpa,
        <span class="tok-str">&quot;0x1ffffffffffffffff&quot;</span>,
        <span class="tok-null">null</span>,
        .{},
    ));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-number">0x1ffffffffffffffff</span>), <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
        <span class="tok-type">f32</span>,
        gpa,
        <span class="tok-str">&quot;0x1ffffffffffffffff&quot;</span>,
        <span class="tok-null">null</span>,
        .{},
    ));<span class="tok-comment">

    // Exponents, underscores
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-number">123.0E+77</span>),
        <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;12_3.0E+77&quot;</span>, <span class="tok-null">null</span>, .{}),
    );<span class="tok-comment">

    // Hexadecimal
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-number">0x103.70p-5</span>),
        <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;0x103.70p-5&quot;</span>, <span class="tok-null">null</span>, .{}),
    );
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, -<span class="tok-number">0x103.70</span>),
        <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;-0x103.70&quot;</span>, <span class="tok-null">null</span>, .{}),
    );
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-number">0x1234_5678.9ABC_CDEFp-10</span>),
        <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;0x1234_5678.9ABC_CDEFp-10&quot;</span>, <span class="tok-null">null</span>, .{}),
    );<span class="tok-comment">

    // inf, nan
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.isinf.html#std.math.isinf.isPositiveInf">isPositiveInf</a>(<span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;inf&quot;</span>, <span class="tok-null">null</span>, .{})));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.isinf.html#std.math.isinf.isNegativeInf">isNegativeInf</a>(<span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;-inf&quot;</span>, <span class="tok-null">null</span>, .{})));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.isnan.html#std.math.isnan.isNan">isNan</a>(<span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;nan&quot;</span>, <span class="tok-null">null</span>, .{})));<span class="tok-comment">

    // Negative nan not allowed
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;-nan&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:1: error: expected number or 'inf' after '-'\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // nan as int not allowed
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i8</span>, gpa, <span class="tok-str">&quot;nan&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected type 'i8'\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // nan as int not allowed
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i8</span>, gpa, <span class="tok-str">&quot;nan&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected type 'i8'\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // inf as int not allowed
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i8</span>, gpa, <span class="tok-str">&quot;inf&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected type 'i8'\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // -inf as int not allowed
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">i8</span>, gpa, <span class="tok-str">&quot;-inf&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected type 'i8'\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // Bad identifier as float
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;foo&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">\\1:1: error: invalid expression</span>
            <span class="tok-str">\\1:1: note: ZON allows identifiers 'true', 'false', 'null', 'inf', and 'nan'</span>
            <span class="tok-str">\\1:1: note: precede identifier with '.' for an enum literal</span>
            <span class="tok-str">\\</span>
        , <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }

    {
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;-foo&quot;</span>, &amp;status, .{}));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:1: error: expected number or 'inf' after '-'\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Non float as float
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;\&quot;foo\&quot;&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected type 'f32'\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon free on error&quot;</span> {<span class="tok-comment">
    // Test freeing partially allocated structs
    </span>{
        <span class="tok-kw">const</span> Struct = <span class="tok-kw">struct</span> {
            x: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            y: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            z: <span class="tok-type">bool</span>,
        };
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Struct, <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>,
            <span class="tok-str">\\.{</span>
            <span class="tok-str">\\    .x = &quot;hello&quot;,</span>
            <span class="tok-str">\\    .y = &quot;world&quot;,</span>
            <span class="tok-str">\\    .z = &quot;fail&quot;,</span>
            <span class="tok-str">\\}</span>
        , <span class="tok-null">null</span>, .{}));
    }<span class="tok-comment">

    // Test freeing partially allocated tuples
    </span>{
        <span class="tok-kw">const</span> Struct = <span class="tok-kw">struct</span> {
            []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            <span class="tok-type">bool</span>,
        };
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Struct, <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>,
            <span class="tok-str">\\.{</span>
            <span class="tok-str">\\    &quot;hello&quot;,</span>
            <span class="tok-str">\\    &quot;world&quot;,</span>
            <span class="tok-str">\\    &quot;fail&quot;,</span>
            <span class="tok-str">\\}</span>
        , <span class="tok-null">null</span>, .{}));
    }<span class="tok-comment">

    // Test freeing structs with missing fields
    </span>{
        <span class="tok-kw">const</span> Struct = <span class="tok-kw">struct</span> {
            x: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            y: <span class="tok-type">bool</span>,
        };
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(Struct, <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>,
            <span class="tok-str">\\.{</span>
            <span class="tok-str">\\    .x = &quot;hello&quot;,</span>
            <span class="tok-str">\\}</span>
        , <span class="tok-null">null</span>, .{}));
    }<span class="tok-comment">

    // Test freeing partially allocated arrays
    </span>{
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
            [<span class="tok-number">3</span>][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>,
            <span class="tok-str">\\.{</span>
            <span class="tok-str">\\    &quot;hello&quot;,</span>
            <span class="tok-str">\\    false,</span>
            <span class="tok-str">\\    false,</span>
            <span class="tok-str">\\}</span>
        ,
            <span class="tok-null">null</span>,
            .{},
        ));
    }<span class="tok-comment">

    // Test freeing partially allocated slices
    </span>{
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.ParseZon, <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
            [][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>,
            <span class="tok-str">\\.{</span>
            <span class="tok-str">\\    &quot;hello&quot;,</span>
            <span class="tok-str">\\    &quot;world&quot;,</span>
            <span class="tok-str">\\    false,</span>
            <span class="tok-str">\\}</span>
        ,
            <span class="tok-null">null</span>,
            .{},
        ));
    }<span class="tok-comment">

    // We can parse types that can't be freed, as long as they contain no allocations, e.g. untagged
    // unions.
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-number">1.5</span>),
        (<span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-kw">union</span> { x: <span class="tok-type">f32</span> }, <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;.{ .x = 1.5 }&quot;</span>, <span class="tok-null">null</span>, .{})).x,
    );<span class="tok-comment">

    // We can also parse types that can't be freed if it's impossible for an error to occur after
    // the allocation, as is the case here.
    </span>{
        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
            <span class="tok-kw">union</span> { x: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> },
            <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>,
            <span class="tok-str">&quot;.{ .x = \&quot;foo\&quot; }&quot;</span>,
            <span class="tok-null">null</span>,
            .{},
        );
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, result.x);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;foo&quot;</span>, result.x);
    }<span class="tok-comment">

    // However, if it's possible we could get an error requiring we free the value, but the value
    // cannot be freed (e.g. untagged unions) then we need to turn off `free_on_error` for it to
    // compile.
    </span>{
        <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
            <span class="tok-kw">union</span> { x: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> },
            <span class="tok-type">bool</span>,
        };
        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
            S,
            <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>,
            <span class="tok-str">&quot;.{ .{ .x = \&quot;foo\&quot; }, true }&quot;</span>,
            <span class="tok-null">null</span>,
            .{ .free_on_error = <span class="tok-null">false</span> },
        );
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, result[<span class="tok-number">0</span>].x);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;foo&quot;</span>, result[<span class="tok-number">0</span>].x);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(result[<span class="tok-number">1</span>]);
    }<span class="tok-comment">

    // Again but for structs.
    </span>{
        <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
            a: <span class="tok-kw">union</span> { x: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> },
            b: <span class="tok-type">bool</span>,
        };
        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
            S,
            <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>,
            <span class="tok-str">&quot;.{ .a = .{ .x = \&quot;foo\&quot; }, .b = true }&quot;</span>,
            <span class="tok-null">null</span>,
            .{
                .free_on_error = <span class="tok-null">false</span>,
            },
        );
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, result.a.x);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;foo&quot;</span>, result.a.x);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(result.b);
    }<span class="tok-comment">

    // Again but for arrays.
    </span>{
        <span class="tok-kw">const</span> S = [<span class="tok-number">2</span>]<span class="tok-kw">union</span> { x: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> };
        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
            S,
            <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>,
            <span class="tok-str">&quot;.{ .{ .x = \&quot;foo\&quot; }, .{ .x = \&quot;bar\&quot; } }&quot;</span>,
            <span class="tok-null">null</span>,
            .{
                .free_on_error = <span class="tok-null">false</span>,
            },
        );
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, result[<span class="tok-number">0</span>].x);
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, result[<span class="tok-number">1</span>].x);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;foo&quot;</span>, result[<span class="tok-number">0</span>].x);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;bar&quot;</span>, result[<span class="tok-number">1</span>].x);
    }<span class="tok-comment">

    // Again but for slices.
    </span>{
        <span class="tok-kw">const</span> S = []<span class="tok-kw">union</span> { x: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> };
        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(
            S,
            <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>,
            <span class="tok-str">&quot;.{ .{ .x = \&quot;foo\&quot; }, .{ .x = \&quot;bar\&quot; } }&quot;</span>,
            <span class="tok-null">null</span>,
            .{
                .free_on_error = <span class="tok-null">false</span>,
            },
        );
        <span class="tok-kw">defer</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(result);
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, result[<span class="tok-number">0</span>].x);
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, result[<span class="tok-number">1</span>].x);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;foo&quot;</span>, result[<span class="tok-number">0</span>].x);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;bar&quot;</span>, result[<span class="tok-number">1</span>].x);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon vector&quot;</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_c) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;<span class="tok-comment"> // https://github.com/ziglang/zig/issues/15330
    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_x86_64) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;<span class="tok-comment"> // https://github.com/ziglang/zig/issues/15329

    </span><span class="tok-kw">const</span> gpa = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;<span class="tok-comment">

    // Passing cases
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@Vector</span>(<span class="tok-number">0</span>, <span class="tok-type">bool</span>){},
        <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">0</span>, <span class="tok-type">bool</span>), gpa, <span class="tok-str">&quot;.{}&quot;</span>, <span class="tok-null">null</span>, .{}),
    );
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">bool</span>){ <span class="tok-null">true</span>, <span class="tok-null">false</span>, <span class="tok-null">true</span> },
        <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">bool</span>), gpa, <span class="tok-str">&quot;.{true, false, true}&quot;</span>, <span class="tok-null">null</span>, .{}),
    );

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@Vector</span>(<span class="tok-number">0</span>, <span class="tok-type">f32</span>){},
        <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">0</span>, <span class="tok-type">f32</span>), gpa, <span class="tok-str">&quot;.{}&quot;</span>, <span class="tok-null">null</span>, .{}),
    );
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">f32</span>){ <span class="tok-number">1.5</span>, <span class="tok-number">2.5</span>, <span class="tok-number">3.5</span> },
        <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">f32</span>), gpa, <span class="tok-str">&quot;.{1.5, 2.5, 3.5}&quot;</span>, <span class="tok-null">null</span>, .{}),
    );

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@Vector</span>(<span class="tok-number">0</span>, <span class="tok-type">u8</span>){},
        <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">0</span>, <span class="tok-type">u8</span>), gpa, <span class="tok-str">&quot;.{}&quot;</span>, <span class="tok-null">null</span>, .{}),
    );
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">u8</span>){ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">6</span> },
        <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">u8</span>), gpa, <span class="tok-str">&quot;.{2, 4, 6}&quot;</span>, <span class="tok-null">null</span>, .{}),
    );

    {
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
            <span class="tok-builtin">@Vector</span>(<span class="tok-number">0</span>, *<span class="tok-kw">const</span> <span class="tok-type">u8</span>){},
            <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">0</span>, *<span class="tok-kw">const</span> <span class="tok-type">u8</span>), gpa, <span class="tok-str">&quot;.{}&quot;</span>, <span class="tok-null">null</span>, .{}),
        );
        <span class="tok-kw">const</span> pointers = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, *<span class="tok-kw">const</span> <span class="tok-type">u8</span>), gpa, <span class="tok-str">&quot;.{2, 4, 6}&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, pointers);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualDeep">expectEqualDeep</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, *<span class="tok-kw">const</span> <span class="tok-type">u8</span>){ &amp;<span class="tok-number">2</span>, &amp;<span class="tok-number">4</span>, &amp;<span class="tok-number">6</span> }, pointers);
    }

    {
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
            <span class="tok-builtin">@Vector</span>(<span class="tok-number">0</span>, ?*<span class="tok-kw">const</span> <span class="tok-type">u8</span>){},
            <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">0</span>, ?*<span class="tok-kw">const</span> <span class="tok-type">u8</span>), gpa, <span class="tok-str">&quot;.{}&quot;</span>, <span class="tok-null">null</span>, .{}),
        );
        <span class="tok-kw">const</span> pointers = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, ?*<span class="tok-kw">const</span> <span class="tok-type">u8</span>), gpa, <span class="tok-str">&quot;.{2, null, 6}&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, pointers);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualDeep">expectEqualDeep</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, ?*<span class="tok-kw">const</span> <span class="tok-type">u8</span>){ &amp;<span class="tok-number">2</span>, <span class="tok-null">null</span>, &amp;<span class="tok-number">6</span> }, pointers);
    }<span class="tok-comment">

    // Too few fields
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">f32</span>), gpa, <span class="tok-str">&quot;.{0.5}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:2: error: expected 2 vector elements; found 1\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Too many fields
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">f32</span>), gpa, <span class="tok-str">&quot;.{0.5, 1.5, 2.5}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:2: error: expected 2 vector elements; found 3\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Wrong type fields
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">f32</span>), gpa, <span class="tok-str">&quot;.{0.5, true, 2.5}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(
            <span class="tok-str">&quot;1:8: error: expected type 'f32'\n&quot;</span>,
            <span class="tok-str">&quot;{}&quot;</span>,
            .{status},
        );
    }<span class="tok-comment">

    // Wrong type
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">u8</span>), gpa, <span class="tok-str">&quot;true&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected type '@Vector(3, u8)'\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }<span class="tok-comment">

    // Elements should get freed on error
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, *<span class="tok-type">u8</span>), gpa, <span class="tok-str">&quot;.{1, true, 3}&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:6: error: expected type 'u8'\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.zon add pointers&quot;</span> {
    <span class="tok-kw">const</span> gpa = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;<span class="tok-comment">

    // Primitive with varying levels of pointers
    </span>{
        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(*<span class="tok-type">u32</span>, gpa, <span class="tok-str">&quot;10&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, result);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">10</span>), result.*);
    }

    {
        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(**<span class="tok-type">u32</span>, gpa, <span class="tok-str">&quot;10&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, result);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">10</span>), result.*.*);
    }

    {
        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(***<span class="tok-type">u32</span>, gpa, <span class="tok-str">&quot;10&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, result);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">10</span>), result.*.*.*);
    }<span class="tok-comment">

    // Primitive optional with varying levels of pointers
    </span>{
        <span class="tok-kw">const</span> some = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(?*<span class="tok-type">u32</span>, gpa, <span class="tok-str">&quot;10&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, some);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">10</span>), some.?.*);

        <span class="tok-kw">const</span> none = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(?*<span class="tok-type">u32</span>, gpa, <span class="tok-str">&quot;null&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, none);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, none);
    }

    {
        <span class="tok-kw">const</span> some = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(*?<span class="tok-type">u32</span>, gpa, <span class="tok-str">&quot;10&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, some);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">10</span>), some.*.?);

        <span class="tok-kw">const</span> none = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(*?<span class="tok-type">u32</span>, gpa, <span class="tok-str">&quot;null&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, none);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, none.*);
    }

    {
        <span class="tok-kw">const</span> some = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(?**<span class="tok-type">u32</span>, gpa, <span class="tok-str">&quot;10&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, some);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">10</span>), some.?.*.*);

        <span class="tok-kw">const</span> none = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(?**<span class="tok-type">u32</span>, gpa, <span class="tok-str">&quot;null&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, none);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, none);
    }

    {
        <span class="tok-kw">const</span> some = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(*?*<span class="tok-type">u32</span>, gpa, <span class="tok-str">&quot;10&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, some);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">10</span>), some.*.?.*);

        <span class="tok-kw">const</span> none = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(*?*<span class="tok-type">u32</span>, gpa, <span class="tok-str">&quot;null&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, none);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, none.*);
    }

    {
        <span class="tok-kw">const</span> some = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(**?<span class="tok-type">u32</span>, gpa, <span class="tok-str">&quot;10&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, some);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">10</span>), some.*.*.?);

        <span class="tok-kw">const</span> none = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(**?<span class="tok-type">u32</span>, gpa, <span class="tok-str">&quot;null&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, none);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, none.*.*);
    }<span class="tok-comment">

    // Pointer to an array
    </span>{
        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(*[<span class="tok-number">3</span>]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;.{ 1, 2, 3 }&quot;</span>, <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, result);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>([<span class="tok-number">3</span>]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> }, result.*);
    }<span class="tok-comment">

    // A complicated type with nested internal pointers and string allocations
    </span>{
        <span class="tok-kw">const</span> Inner = <span class="tok-kw">struct</span> {
            f1: *<span class="tok-kw">const</span> ?*<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            f2: *<span class="tok-kw">const</span> ?*<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        };
        <span class="tok-kw">const</span> Outer = <span class="tok-kw">struct</span> {
            f1: *<span class="tok-kw">const</span> ?*<span class="tok-kw">const</span> Inner,
            f2: *<span class="tok-kw">const</span> ?*<span class="tok-kw">const</span> Inner,
        };
        <span class="tok-kw">const</span> expected: Outer = .{
            .f1 = &amp;&amp;.{
                .f1 = &amp;<span class="tok-null">null</span>,
                .f2 = &amp;&amp;<span class="tok-str">&quot;foo&quot;</span>,
            },
            .f2 = &amp;<span class="tok-null">null</span>,
        };

        <span class="tok-kw">const</span> found = <span class="tok-kw">try</span> <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(?*Outer, gpa,
            <span class="tok-str">\\.{</span>
            <span class="tok-str">\\    .f1 = .{</span>
            <span class="tok-str">\\        .f1 = null,</span>
            <span class="tok-str">\\        .f2 = &quot;foo&quot;,</span>
            <span class="tok-str">\\    },</span>
            <span class="tok-str">\\    .f2 = null,</span>
            <span class="tok-str">\\}</span>
        , <span class="tok-null">null</span>, .{});
        <span class="tok-kw">defer</span> <a href="std.zon.parse.html#std.zon.parse.free">free</a>(gpa, found);

        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualDeep">expectEqualDeep</a>(expected, found.?.*);
    }<span class="tok-comment">

    // Test that optional types are flattened correctly in errors
    </span>{
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(*<span class="tok-kw">const</span> ?*<span class="tok-kw">const</span> <span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;true&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected type '?u8'\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }

    {
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(*<span class="tok-kw">const</span> ?*<span class="tok-kw">const</span> <span class="tok-type">f32</span>, gpa, <span class="tok-str">&quot;true&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected type '?f32'\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }

    {
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(*<span class="tok-kw">const</span> ?*<span class="tok-kw">const</span> <span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">u8</span>), gpa, <span class="tok-str">&quot;true&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected type '?@Vector(3, u8)'\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }

    {
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(*<span class="tok-kw">const</span> ?*<span class="tok-kw">const</span> <span class="tok-type">bool</span>, gpa, <span class="tok-str">&quot;10&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected type '?bool'\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }

    {
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(*<span class="tok-kw">const</span> ?*<span class="tok-kw">const</span> <span class="tok-kw">struct</span> { a: <span class="tok-type">i32</span> }, gpa, <span class="tok-str">&quot;true&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected optional struct\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }

    {
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(*<span class="tok-kw">const</span> ?*<span class="tok-kw">const</span> <span class="tok-kw">struct</span> { <span class="tok-type">i32</span> }, gpa, <span class="tok-str">&quot;true&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected optional tuple\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }

    {
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(*<span class="tok-kw">const</span> ?*<span class="tok-kw">const</span> <span class="tok-kw">union</span> { x: <span class="tok-type">void</span> }, gpa, <span class="tok-str">&quot;true&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected optional union\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }

    {
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(*<span class="tok-kw">const</span> ?*<span class="tok-kw">const</span> [<span class="tok-number">3</span>]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;true&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected optional array\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }

    {
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(?[<span class="tok-number">3</span>]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;true&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected optional array\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }

    {
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(*<span class="tok-kw">const</span> ?*<span class="tok-kw">const</span> []<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;true&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected optional array\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }

    {
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(?[]<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;true&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected optional array\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }

    {
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(*<span class="tok-kw">const</span> ?*<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;true&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected optional string\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }

    {
        <span class="tok-kw">var</span> status: <a href="std.zon.parse.Status.html">Status</a> = .{};
        <span class="tok-kw">defer</span> status.deinit(gpa);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
            <span class="tok-kw">error</span>.ParseZon,
            <a href="std.zon.parse.html#std.zon.parse.fromSlice">fromSlice</a>(*<span class="tok-kw">const</span> ?*<span class="tok-kw">const</span> <span class="tok-kw">enum</span> { foo }, gpa, <span class="tok-str">&quot;true&quot;</span>, &amp;status, .{}),
        );
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>(<span class="tok-str">&quot;1:1: error: expected optional enum literal\n&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{status});
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
