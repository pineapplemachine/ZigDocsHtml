<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">valgrind</a></li><li><a href="std.valgrind.memcheck.html" class="active">memcheck</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.valgrind.memcheck" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.valgrind.memcheck</span><a href="#src.zig-std.valgrind.memcheck">[src]</a></h1><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.valgrind.memcheck.ClientRequest.html">std.valgrind.memcheck.ClientRequest</a></li></ul></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.valgrind.memcheck.MemCheckClientRequest" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">MemCheckClientRequest</span><a href="#src.zig-std.valgrind.memcheck.MemCheckClientRequest">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.valgrind.memcheck.MemCheckClientRequest">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MemCheckClientRequest = <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.valgrind.memcheck.MemCheckClientRequest renamed to std.valgrind.memcheck.ClientRequest&quot;</span>)</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.valgrind.memcheck.makeMemNoAccess" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">makeMemNoAccess</span><a href="#src.zig-std.valgrind.memcheck.makeMemNoAccess">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeMemNoAccess</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Mark memory at qzz.ptr as unaddressable for qzz.len bytes.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.valgrind.memcheck.makeMemNoAccess">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeMemNoAccess</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    _ = <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>,<span class="tok-comment"> // default return
        </span>.MakeMemNoAccess, <span class="tok-builtin">@intFromPtr</span>(qzz.ptr), qzz.len, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.valgrind.memcheck.makeMemUndefined" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">makeMemUndefined</span><a href="#src.zig-std.valgrind.memcheck.makeMemUndefined">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeMemUndefined</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Mark memory at qzz.ptr as addressable but undefined for qzz.len bytes.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.valgrind.memcheck.makeMemUndefined">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeMemUndefined</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    _ = <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>,<span class="tok-comment"> // default return
        </span>.MakeMemUndefined, <span class="tok-builtin">@intFromPtr</span>(qzz.ptr), qzz.len, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.valgrind.memcheck.makeMemDefined" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">makeMemDefined</span><a href="#src.zig-std.valgrind.memcheck.makeMemDefined">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeMemDefined</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Mark memory at qzz.ptr as addressable and defined or qzz.len bytes.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.valgrind.memcheck.makeMemDefined">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeMemDefined</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    _ = <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>,<span class="tok-comment"> // default return
        </span>.MakeMemDefined, <span class="tok-builtin">@intFromPtr</span>(qzz.ptr), qzz.len, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.valgrind.memcheck.makeMemDefinedIfAddressable" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">makeMemDefinedIfAddressable</span><a href="#src.zig-std.valgrind.memcheck.makeMemDefinedIfAddressable">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeMemDefinedIfAddressable</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Similar to makeMemDefined except that addressability is
not altered: bytes which are addressable are marked as defined,
but those which are not addressable are left unchanged.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.valgrind.memcheck.makeMemDefinedIfAddressable">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeMemDefinedIfAddressable</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    _ = <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>,<span class="tok-comment"> // default return
        </span>.MakeMemDefinedIfAddressable, <span class="tok-builtin">@intFromPtr</span>(qzz.ptr), qzz.len, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.valgrind.memcheck.createBlock" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">createBlock</span><a href="#src.zig-std.valgrind.memcheck.createBlock">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createBlock</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, desc: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Create a block-description handle.  The description is an ascii
string which is included in any messages pertaining to addresses
within the specified memory range.  Has no other effect on the
properties of the memory range.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>desc: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.valgrind.memcheck.createBlock">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createBlock</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, desc: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>,<span class="tok-comment"> // default return
        </span>.CreateBlock, <span class="tok-builtin">@intFromPtr</span>(qzz.ptr), qzz.len, <span class="tok-builtin">@intFromPtr</span>(desc), <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.valgrind.memcheck.discard" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">discard</span><a href="#src.zig-std.valgrind.memcheck.discard">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">discard</span>(blkindex: <span class="tok-type">usize</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Discard a block-description-handle. Returns 1 for an
invalid handle, 0 for a valid handle.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>blkindex: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.valgrind.memcheck.discard">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">discard</span>(blkindex: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>,<span class="tok-comment"> // default return
        </span>.Discard, <span class="tok-number">0</span>, blkindex, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>) != <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.valgrind.memcheck.checkMemIsAddressable" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkMemIsAddressable</span><a href="#src.zig-std.valgrind.memcheck.checkMemIsAddressable">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkMemIsAddressable</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Check that memory at qzz.ptr is addressable for qzz.len bytes.
If suitable addressability is not established, Valgrind prints an
error message and returns the address of the first offending byte.
Otherwise it returns zero.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.valgrind.memcheck.checkMemIsAddressable">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkMemIsAddressable</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>, .CheckMemIsAddressable, <span class="tok-builtin">@intFromPtr</span>(qzz.ptr), qzz.len, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.valgrind.memcheck.checkMemIsDefined" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkMemIsDefined</span><a href="#src.zig-std.valgrind.memcheck.checkMemIsDefined">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkMemIsDefined</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Check that memory at qzz.ptr is addressable and defined for
qzz.len bytes.  If suitable addressability and definedness are not
established, Valgrind prints an error message and returns the
address of the first offending byte.  Otherwise it returns zero.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.valgrind.memcheck.checkMemIsDefined">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkMemIsDefined</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>, .CheckMemIsDefined, <span class="tok-builtin">@intFromPtr</span>(qzz.ptr), qzz.len, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.valgrind.memcheck.doLeakCheck" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">doLeakCheck</span><a href="#src.zig-std.valgrind.memcheck.doLeakCheck">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doLeakCheck</span>() <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Do a full memory leak check (like --leak-check=full) mid-execution.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.valgrind.memcheck.doLeakCheck">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doLeakCheck</span>() <span class="tok-type">void</span> {
    <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestStmt">doClientRequestStmt</a>(.DoLeakCheck, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.valgrind.memcheck.doAddedLeakCheck" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">doAddedLeakCheck</span><a href="#src.zig-std.valgrind.memcheck.doAddedLeakCheck">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doAddedLeakCheck</span>() <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as doLeakCheck() but only showing the entries for
which there was an increase in leaked bytes or leaked nr of blocks
since the previous leak search.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.valgrind.memcheck.doAddedLeakCheck">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doAddedLeakCheck</span>() <span class="tok-type">void</span> {
    <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestStmt">doClientRequestStmt</a>(.DoLeakCheck, <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.valgrind.memcheck.doChangedLeakCheck" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">doChangedLeakCheck</span><a href="#src.zig-std.valgrind.memcheck.doChangedLeakCheck">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doChangedLeakCheck</span>() <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as doAddedLeakCheck() but showing entries with
increased or decreased leaked bytes/blocks since previous leak
search.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.valgrind.memcheck.doChangedLeakCheck">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doChangedLeakCheck</span>() <span class="tok-type">void</span> {
    <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestStmt">doClientRequestStmt</a>(.DoLeakCheck, <span class="tok-number">0</span>, <span class="tok-number">2</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.valgrind.memcheck.doQuickLeakCheck" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">doQuickLeakCheck</span><a href="#src.zig-std.valgrind.memcheck.doQuickLeakCheck">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doQuickLeakCheck</span>() <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Do a summary memory leak check (like --leak-check=summary) mid-execution.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.valgrind.memcheck.doQuickLeakCheck">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doQuickLeakCheck</span>() <span class="tok-type">void</span> {
    <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestStmt">doClientRequestStmt</a>(.DoLeakCheck, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.valgrind.memcheck.countLeaks" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">countLeaks</span><a href="#src.zig-std.valgrind.memcheck.countLeaks">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">countLeaks</span>() <a href="std.valgrind.memcheck.CountResult.html">CountResult</a></code></pre></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> countLeaks {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@as</span>(<a href="std.valgrind.memcheck.CountResult.html">CountResult</a>, .{
            .leaked = <span class="tok-number">0</span>,
            .dubious = <span class="tok-number">0</span>,
            .reachable = <span class="tok-number">0</span>,
            .suppressed = <span class="tok-number">0</span>,
        }),
        <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.countLeaks">countLeaks</a>(),
    );
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.valgrind.memcheck.countLeaks">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">countLeaks</span>() <a href="std.valgrind.memcheck.CountResult.html">CountResult</a> {
    <span class="tok-kw">var</span> res: <a href="std.valgrind.memcheck.CountResult.html">CountResult</a> = .{
        .leaked = <span class="tok-number">0</span>,
        .dubious = <span class="tok-number">0</span>,
        .reachable = <span class="tok-number">0</span>,
        .suppressed = <span class="tok-number">0</span>,
    };
    <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestStmt">doClientRequestStmt</a>(
        .CountLeaks,
        <span class="tok-builtin">@intFromPtr</span>(&amp;res.leaked),
        <span class="tok-builtin">@intFromPtr</span>(&amp;res.dubious),
        <span class="tok-builtin">@intFromPtr</span>(&amp;res.reachable),
        <span class="tok-builtin">@intFromPtr</span>(&amp;res.suppressed),
        <span class="tok-number">0</span>,
    );
    <span class="tok-kw">return</span> res;
}</code></pre></details></div></div><div class="decl"><h2 id="std.valgrind.memcheck.countLeakBlocks" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">countLeakBlocks</span><a href="#src.zig-std.valgrind.memcheck.countLeakBlocks">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">countLeakBlocks</span>() <a href="std.valgrind.memcheck.CountResult.html">CountResult</a></code></pre></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> countLeakBlocks {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@as</span>(<a href="std.valgrind.memcheck.CountResult.html">CountResult</a>, .{
            .leaked = <span class="tok-number">0</span>,
            .dubious = <span class="tok-number">0</span>,
            .reachable = <span class="tok-number">0</span>,
            .suppressed = <span class="tok-number">0</span>,
        }),
        <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.countLeakBlocks">countLeakBlocks</a>(),
    );
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.valgrind.memcheck.countLeakBlocks">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">countLeakBlocks</span>() <a href="std.valgrind.memcheck.CountResult.html">CountResult</a> {
    <span class="tok-kw">var</span> res: <a href="std.valgrind.memcheck.CountResult.html">CountResult</a> = .{
        .leaked = <span class="tok-number">0</span>,
        .dubious = <span class="tok-number">0</span>,
        .reachable = <span class="tok-number">0</span>,
        .suppressed = <span class="tok-number">0</span>,
    };
    <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestStmt">doClientRequestStmt</a>(
        .CountLeakBlocks,
        <span class="tok-builtin">@intFromPtr</span>(&amp;res.leaked),
        <span class="tok-builtin">@intFromPtr</span>(&amp;res.dubious),
        <span class="tok-builtin">@intFromPtr</span>(&amp;res.reachable),
        <span class="tok-builtin">@intFromPtr</span>(&amp;res.suppressed),
        <span class="tok-number">0</span>,
    );
    <span class="tok-kw">return</span> res;
}</code></pre></details></div></div><div class="decl"><h2 id="std.valgrind.memcheck.getVbits" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getVbits</span><a href="#src.zig-std.valgrind.memcheck.getVbits">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getVbits</span>(zza: []<span class="tok-type">u8</span>, zzvbits: []<span class="tok-type">u8</span>) <span class="tok-type">u2</span></code></pre></div><div class="tldDocs"><p>Get the validity data for addresses zza and copy it
into the provided zzvbits array.  Return values:
0   if not running on valgrind
1   success
2   [previously indicated unaligned arrays;  these are now allowed]
3   if any parts of zzsrc/zzvbits are not addressable.
The metadata is not copied in cases 0, 2 or 3 so it should be
impossible to segfault your system by using this call.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>zza: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>zzvbits: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.valgrind.memcheck.getVbits">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getVbits</span>(zza: []<span class="tok-type">u8</span>, zzvbits: []<span class="tok-type">u8</span>) <span class="tok-type">u2</span> {
    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>(zzvbits.len &gt;= zza.len / <span class="tok-number">8</span>);
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u2</span>, <span class="tok-builtin">@intCast</span>(<a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>, .GetVbits, <span class="tok-builtin">@intFromPtr</span>(zza.ptr), <span class="tok-builtin">@intFromPtr</span>(zzvbits.ptr), zza.len, <span class="tok-number">0</span>, <span class="tok-number">0</span>)));
}</code></pre></details></div></div><div class="decl"><h2 id="std.valgrind.memcheck.setVbits" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setVbits</span><a href="#src.zig-std.valgrind.memcheck.setVbits">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setVbits</span>(zzvbits: []<span class="tok-type">u8</span>, zza: []<span class="tok-type">u8</span>) <span class="tok-type">u2</span></code></pre></div><div class="tldDocs"><p>Set the validity data for addresses zza, copying it
from the provided zzvbits array.  Return values:
0   if not running on valgrind
1   success
2   [previously indicated unaligned arrays;  these are now allowed]
3   if any parts of zza/zzvbits are not addressable.
The metadata is not copied in cases 0, 2 or 3 so it should be
impossible to segfault your system by using this call.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>zzvbits: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>zza: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.valgrind.memcheck.setVbits">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setVbits</span>(zzvbits: []<span class="tok-type">u8</span>, zza: []<span class="tok-type">u8</span>) <span class="tok-type">u2</span> {
    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>(zzvbits.len &gt;= zza.len / <span class="tok-number">8</span>);
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u2</span>, <span class="tok-builtin">@intCast</span>(<a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>, .SetVbits, <span class="tok-builtin">@intFromPtr</span>(zza.ptr), <span class="tok-builtin">@intFromPtr</span>(zzvbits.ptr), zza.len, <span class="tok-number">0</span>, <span class="tok-number">0</span>)));
}</code></pre></details></div></div><div class="decl"><h2 id="std.valgrind.memcheck.disableAddrErrorReportingInRange" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">disableAddrErrorReportingInRange</span><a href="#src.zig-std.valgrind.memcheck.disableAddrErrorReportingInRange">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">disableAddrErrorReportingInRange</span>(qzz: []<span class="tok-type">u8</span>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Disable and re-enable reporting of addressing errors in the
specified address range.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>qzz: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.valgrind.memcheck.disableAddrErrorReportingInRange">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">disableAddrErrorReportingInRange</span>(qzz: []<span class="tok-type">u8</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>,<span class="tok-comment"> // default return
        </span>.DisableAddrErrorReportingInRange, <span class="tok-builtin">@intFromPtr</span>(qzz.ptr), qzz.len, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.valgrind.memcheck.enableAddrErrorReportingInRange" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">enableAddrErrorReportingInRange</span><a href="#src.zig-std.valgrind.memcheck.enableAddrErrorReportingInRange">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">enableAddrErrorReportingInRange</span>(qzz: []<span class="tok-type">u8</span>) <span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>qzz: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.valgrind.memcheck.enableAddrErrorReportingInRange">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">enableAddrErrorReportingInRange</span>(qzz: []<span class="tok-type">u8</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>,<span class="tok-comment"> // default return
        </span>.EnableAddrErrorReportingInRange, <span class="tok-builtin">@intFromPtr</span>(qzz.ptr), qzz.len, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.valgrind.memcheck">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../std.zig&quot;</span>);
<span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;
<span class="tok-kw">const</span> valgrind = <a href="std.html">std</a>.<a href="std.valgrind.html">valgrind</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ClientRequest = <span class="tok-kw">enum</span>(<span class="tok-type">usize</span>) {
    MakeMemNoAccess = <a href="std.valgrind.html">valgrind</a>.<a href="std.valgrind.html#std.valgrind.ToolBase">ToolBase</a>(<span class="tok-str">&quot;MC&quot;</span>.*),
    MakeMemUndefined,
    MakeMemDefined,
    Discard,
    CheckMemIsAddressable,
    CheckMemIsDefined,
    DoLeakCheck,
    CountLeaks,
    GetVbits,
    SetVbits,
    CreateBlock,
    MakeMemDefinedIfAddressable,
    CountLeakBlocks,
    EnableAddrErrorReportingInRange,
    DisableAddrErrorReportingInRange,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MemCheckClientRequest = <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.valgrind.memcheck.MemCheckClientRequest renamed to std.valgrind.memcheck.ClientRequest&quot;</span>);

<span class="tok-kw">fn</span> <span class="tok-fn">doClientRequestExpr</span>(default: <span class="tok-type">usize</span>, request: <a href="std.valgrind.memcheck.ClientRequest.html">ClientRequest</a>, a1: <span class="tok-type">usize</span>, a2: <span class="tok-type">usize</span>, a3: <span class="tok-type">usize</span>, a4: <span class="tok-type">usize</span>, a5: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.valgrind.html">valgrind</a>.<a href="std.valgrind.html#std.valgrind.doClientRequest">doClientRequest</a>(default, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(request))), a1, a2, a3, a4, a5);
}

<span class="tok-kw">fn</span> <span class="tok-fn">doClientRequestStmt</span>(request: <a href="std.valgrind.memcheck.ClientRequest.html">ClientRequest</a>, a1: <span class="tok-type">usize</span>, a2: <span class="tok-type">usize</span>, a3: <span class="tok-type">usize</span>, a4: <span class="tok-type">usize</span>, a5: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    _ = <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>, request, a1, a2, a3, a4, a5);
}

<span class="tok-comment">/// Mark memory at qzz.ptr as unaddressable for qzz.len bytes.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeMemNoAccess</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    _ = <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>,<span class="tok-comment"> // default return
        </span>.MakeMemNoAccess, <span class="tok-builtin">@intFromPtr</span>(qzz.ptr), qzz.len, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}

<span class="tok-comment">/// Mark memory at qzz.ptr as addressable but undefined for qzz.len bytes.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeMemUndefined</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    _ = <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>,<span class="tok-comment"> // default return
        </span>.MakeMemUndefined, <span class="tok-builtin">@intFromPtr</span>(qzz.ptr), qzz.len, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}

<span class="tok-comment">/// Mark memory at qzz.ptr as addressable and defined or qzz.len bytes.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeMemDefined</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    _ = <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>,<span class="tok-comment"> // default return
        </span>.MakeMemDefined, <span class="tok-builtin">@intFromPtr</span>(qzz.ptr), qzz.len, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}

<span class="tok-comment">/// Similar to makeMemDefined except that addressability is</span>
<span class="tok-comment">/// not altered: bytes which are addressable are marked as defined,</span>
<span class="tok-comment">/// but those which are not addressable are left unchanged.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeMemDefinedIfAddressable</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    _ = <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>,<span class="tok-comment"> // default return
        </span>.MakeMemDefinedIfAddressable, <span class="tok-builtin">@intFromPtr</span>(qzz.ptr), qzz.len, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}

<span class="tok-comment">/// Create a block-description handle.  The description is an ascii</span>
<span class="tok-comment">/// string which is included in any messages pertaining to addresses</span>
<span class="tok-comment">/// within the specified memory range.  Has no other effect on the</span>
<span class="tok-comment">/// properties of the memory range.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createBlock</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, desc: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>,<span class="tok-comment"> // default return
        </span>.CreateBlock, <span class="tok-builtin">@intFromPtr</span>(qzz.ptr), qzz.len, <span class="tok-builtin">@intFromPtr</span>(desc), <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}

<span class="tok-comment">/// Discard a block-description-handle. Returns 1 for an</span>
<span class="tok-comment">/// invalid handle, 0 for a valid handle.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">discard</span>(blkindex: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>,<span class="tok-comment"> // default return
        </span>.Discard, <span class="tok-number">0</span>, blkindex, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>) != <span class="tok-number">0</span>;
}

<span class="tok-comment">/// Check that memory at qzz.ptr is addressable for qzz.len bytes.</span>
<span class="tok-comment">/// If suitable addressability is not established, Valgrind prints an</span>
<span class="tok-comment">/// error message and returns the address of the first offending byte.</span>
<span class="tok-comment">/// Otherwise it returns zero.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkMemIsAddressable</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>, .CheckMemIsAddressable, <span class="tok-builtin">@intFromPtr</span>(qzz.ptr), qzz.len, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}

<span class="tok-comment">/// Check that memory at qzz.ptr is addressable and defined for</span>
<span class="tok-comment">/// qzz.len bytes.  If suitable addressability and definedness are not</span>
<span class="tok-comment">/// established, Valgrind prints an error message and returns the</span>
<span class="tok-comment">/// address of the first offending byte.  Otherwise it returns zero.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkMemIsDefined</span>(qzz: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>, .CheckMemIsDefined, <span class="tok-builtin">@intFromPtr</span>(qzz.ptr), qzz.len, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}

<span class="tok-comment">/// Do a full memory leak check (like --leak-check=full) mid-execution.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doLeakCheck</span>() <span class="tok-type">void</span> {
    <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestStmt">doClientRequestStmt</a>(.DoLeakCheck, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}

<span class="tok-comment">/// Same as doLeakCheck() but only showing the entries for</span>
<span class="tok-comment">/// which there was an increase in leaked bytes or leaked nr of blocks</span>
<span class="tok-comment">/// since the previous leak search.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doAddedLeakCheck</span>() <span class="tok-type">void</span> {
    <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestStmt">doClientRequestStmt</a>(.DoLeakCheck, <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}

<span class="tok-comment">/// Same as doAddedLeakCheck() but showing entries with</span>
<span class="tok-comment">/// increased or decreased leaked bytes/blocks since previous leak</span>
<span class="tok-comment">/// search.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doChangedLeakCheck</span>() <span class="tok-type">void</span> {
    <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestStmt">doClientRequestStmt</a>(.DoLeakCheck, <span class="tok-number">0</span>, <span class="tok-number">2</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}

<span class="tok-comment">/// Do a summary memory leak check (like --leak-check=summary) mid-execution.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doQuickLeakCheck</span>() <span class="tok-type">void</span> {
    <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestStmt">doClientRequestStmt</a>(.DoLeakCheck, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}

<span class="tok-comment">/// Return number of leaked, dubious, reachable and suppressed bytes found by</span>
<span class="tok-comment">/// all previous leak checks.</span>
<span class="tok-kw">const</span> CountResult = <span class="tok-kw">struct</span> {
    leaked: <span class="tok-type">usize</span>,
    dubious: <span class="tok-type">usize</span>,
    reachable: <span class="tok-type">usize</span>,
    suppressed: <span class="tok-type">usize</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">countLeaks</span>() <a href="std.valgrind.memcheck.CountResult.html">CountResult</a> {
    <span class="tok-kw">var</span> res: <a href="std.valgrind.memcheck.CountResult.html">CountResult</a> = .{
        .leaked = <span class="tok-number">0</span>,
        .dubious = <span class="tok-number">0</span>,
        .reachable = <span class="tok-number">0</span>,
        .suppressed = <span class="tok-number">0</span>,
    };
    <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestStmt">doClientRequestStmt</a>(
        .CountLeaks,
        <span class="tok-builtin">@intFromPtr</span>(&amp;res.leaked),
        <span class="tok-builtin">@intFromPtr</span>(&amp;res.dubious),
        <span class="tok-builtin">@intFromPtr</span>(&amp;res.reachable),
        <span class="tok-builtin">@intFromPtr</span>(&amp;res.suppressed),
        <span class="tok-number">0</span>,
    );
    <span class="tok-kw">return</span> res;
}

<span class="tok-kw">test</span> countLeaks {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@as</span>(<a href="std.valgrind.memcheck.CountResult.html">CountResult</a>, .{
            .leaked = <span class="tok-number">0</span>,
            .dubious = <span class="tok-number">0</span>,
            .reachable = <span class="tok-number">0</span>,
            .suppressed = <span class="tok-number">0</span>,
        }),
        <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.countLeaks">countLeaks</a>(),
    );
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">countLeakBlocks</span>() <a href="std.valgrind.memcheck.CountResult.html">CountResult</a> {
    <span class="tok-kw">var</span> res: <a href="std.valgrind.memcheck.CountResult.html">CountResult</a> = .{
        .leaked = <span class="tok-number">0</span>,
        .dubious = <span class="tok-number">0</span>,
        .reachable = <span class="tok-number">0</span>,
        .suppressed = <span class="tok-number">0</span>,
    };
    <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestStmt">doClientRequestStmt</a>(
        .CountLeakBlocks,
        <span class="tok-builtin">@intFromPtr</span>(&amp;res.leaked),
        <span class="tok-builtin">@intFromPtr</span>(&amp;res.dubious),
        <span class="tok-builtin">@intFromPtr</span>(&amp;res.reachable),
        <span class="tok-builtin">@intFromPtr</span>(&amp;res.suppressed),
        <span class="tok-number">0</span>,
    );
    <span class="tok-kw">return</span> res;
}

<span class="tok-kw">test</span> countLeakBlocks {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(
        <span class="tok-builtin">@as</span>(<a href="std.valgrind.memcheck.CountResult.html">CountResult</a>, .{
            .leaked = <span class="tok-number">0</span>,
            .dubious = <span class="tok-number">0</span>,
            .reachable = <span class="tok-number">0</span>,
            .suppressed = <span class="tok-number">0</span>,
        }),
        <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.countLeakBlocks">countLeakBlocks</a>(),
    );
}

<span class="tok-comment">/// Get the validity data for addresses zza and copy it</span>
<span class="tok-comment">/// into the provided zzvbits array.  Return values:</span>
<span class="tok-comment">///    0   if not running on valgrind</span>
<span class="tok-comment">///    1   success</span>
<span class="tok-comment">///    2   [previously indicated unaligned arrays;  these are now allowed]</span>
<span class="tok-comment">///    3   if any parts of zzsrc/zzvbits are not addressable.</span>
<span class="tok-comment">/// The metadata is not copied in cases 0, 2 or 3 so it should be</span>
<span class="tok-comment">/// impossible to segfault your system by using this call.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getVbits</span>(zza: []<span class="tok-type">u8</span>, zzvbits: []<span class="tok-type">u8</span>) <span class="tok-type">u2</span> {
    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>(zzvbits.len &gt;= zza.len / <span class="tok-number">8</span>);
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u2</span>, <span class="tok-builtin">@intCast</span>(<a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>, .GetVbits, <span class="tok-builtin">@intFromPtr</span>(zza.ptr), <span class="tok-builtin">@intFromPtr</span>(zzvbits.ptr), zza.len, <span class="tok-number">0</span>, <span class="tok-number">0</span>)));
}

<span class="tok-comment">/// Set the validity data for addresses zza, copying it</span>
<span class="tok-comment">/// from the provided zzvbits array.  Return values:</span>
<span class="tok-comment">///    0   if not running on valgrind</span>
<span class="tok-comment">///    1   success</span>
<span class="tok-comment">///    2   [previously indicated unaligned arrays;  these are now allowed]</span>
<span class="tok-comment">///    3   if any parts of zza/zzvbits are not addressable.</span>
<span class="tok-comment">/// The metadata is not copied in cases 0, 2 or 3 so it should be</span>
<span class="tok-comment">/// impossible to segfault your system by using this call.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setVbits</span>(zzvbits: []<span class="tok-type">u8</span>, zza: []<span class="tok-type">u8</span>) <span class="tok-type">u2</span> {
    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>(zzvbits.len &gt;= zza.len / <span class="tok-number">8</span>);
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u2</span>, <span class="tok-builtin">@intCast</span>(<a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>, .SetVbits, <span class="tok-builtin">@intFromPtr</span>(zza.ptr), <span class="tok-builtin">@intFromPtr</span>(zzvbits.ptr), zza.len, <span class="tok-number">0</span>, <span class="tok-number">0</span>)));
}

<span class="tok-comment">/// Disable and re-enable reporting of addressing errors in the</span>
<span class="tok-comment">/// specified address range.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">disableAddrErrorReportingInRange</span>(qzz: []<span class="tok-type">u8</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>,<span class="tok-comment"> // default return
        </span>.DisableAddrErrorReportingInRange, <span class="tok-builtin">@intFromPtr</span>(qzz.ptr), qzz.len, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">enableAddrErrorReportingInRange</span>(qzz: []<span class="tok-type">u8</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.valgrind.memcheck.html#std.valgrind.memcheck.doClientRequestExpr">doClientRequestExpr</a>(<span class="tok-number">0</span>,<span class="tok-comment"> // default return
        </span>.EnableAddrErrorReportingInRange, <span class="tok-builtin">@intFromPtr</span>(qzz.ptr), qzz.len, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
