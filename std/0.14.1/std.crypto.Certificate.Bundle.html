<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">crypto</a></li><li><a href="std.crypto.html" class="">Certificate</a></li><li><a href="std.crypto.Certificate.Bundle.html" class="active">Bundle</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.crypto.Certificate.Bundle" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.crypto.Certificate.Bundle</span><a href="#src.zig-std.crypto.Certificate.Bundle">[src]</a></h1><div class="tldDocs"><p>A set of certificates. Typically pre-installed on every operating system,
these are &quot;Certificate Authorities&quot; used to validate SSL certificates.
This data structure stores certificates in DER-encoded form, all of them
concatenated together in the <code>bytes</code> array. The <code>map</code> field contains an
index from the DER-encoded subject name to the index of the containing
certificate within <code>bytes</code>.
The key is the contents slice of the subject.</p>
</div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>map: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(<a href="std.crypto.Certificate.der.html">der</a>.<a href="std.crypto.Certificate.der.Element.html">Element</a>.<a href="std.crypto.Certificate.der.Element.Slice.html">Slice</a>, <span class="tok-type">u32</span>, <a href="std.crypto.Certificate.Bundle.MapContext.html">MapContext</a>, <a href="std.html">std</a>.<a href="std.hash_map.html">hash_map</a>.<a href="std.hash_map.html#std.hash_map.default_max_load_percentage">default_max_load_percentage</a>) = .empty</code></pre><div class="fieldDocs"><p>The key is the contents slice of the subject.</p>
</div></div><div><pre><code>bytes: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>) = .empty</code></pre></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.crypto.Certificate.Bundle.VerifyError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">VerifyError</span><a href="#src.zig-std.crypto.Certificate.Bundle.VerifyError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>CertificateExpired <a href="std.crypto.Certificate.Parsed.html#std.crypto.Certificate.Parsed.VerifyError">VerifyError</a></dt></div><div><dt>CertificateFieldHasInvalidLength <a href="std.crypto.Certificate.Parsed.html#std.crypto.Certificate.Parsed.VerifyError">VerifyError</a></dt></div><div><dt>CertificateFieldHasWrongDataType <a href="std.crypto.Certificate.Parsed.html#std.crypto.Certificate.Parsed.VerifyError">VerifyError</a></dt></div><div><dt>CertificateIssuerMismatch <a href="std.crypto.Certificate.Parsed.html#std.crypto.Certificate.Parsed.VerifyError">VerifyError</a></dt></div><div><dt>CertificateIssuerNotFound</dt></div><div><dt>CertificateNotYetValid <a href="std.crypto.Certificate.Parsed.html#std.crypto.Certificate.Parsed.VerifyError">VerifyError</a></dt></div><div><dt>CertificatePublicKeyInvalid <a href="std.crypto.Certificate.Parsed.html#std.crypto.Certificate.Parsed.VerifyError">VerifyError</a></dt></div><div><dt>CertificateSignatureAlgorithmMismatch <a href="std.crypto.Certificate.Parsed.html#std.crypto.Certificate.Parsed.VerifyError">VerifyError</a></dt></div><div><dt>CertificateSignatureAlgorithmUnsupported <a href="std.crypto.Certificate.Parsed.html#std.crypto.Certificate.Parsed.VerifyError">VerifyError</a></dt></div><div><dt>CertificateSignatureInvalid <a href="std.crypto.Certificate.Parsed.html#std.crypto.Certificate.Parsed.VerifyError">VerifyError</a></dt></div><div><dt>CertificateSignatureInvalidLength <a href="std.crypto.Certificate.Parsed.html#std.crypto.Certificate.Parsed.VerifyError">VerifyError</a></dt></div><div><dt>CertificateSignatureNamedCurveUnsupported <a href="std.crypto.Certificate.Parsed.html#std.crypto.Certificate.Parsed.VerifyError">VerifyError</a></dt></div><div><dt>CertificateSignatureUnsupportedBitCount <a href="std.crypto.Certificate.Parsed.html#std.crypto.Certificate.Parsed.VerifyError">VerifyError</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle.VerifyError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> VerifyError = <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.Parsed.html">Parsed</a>.<a href="std.crypto.Certificate.Parsed.html#std.crypto.Certificate.Parsed.VerifyError">VerifyError</a> || <span class="tok-kw">error</span>{
    CertificateIssuerNotFound,
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.Certificate.Bundle.RescanError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">RescanError</span><a href="#src.zig-std.crypto.Certificate.Bundle.RescanError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to open a new resource relative to it.</p>
</dd></div><div><dt>AntivirusInterference <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, antivirus software is enabled by default. It can be
disabled, but Windows Update sometimes ignores the user's preference
and re-enables it. When enabled, antivirus software on Windows
intercepts file system operations and makes them significantly slower
in addition to possibly failing with this error code.</p>
</dd></div><div><dt>BadPathName <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, file paths cannot contain these characters:
'/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</p>
</dd></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>Canceled <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>reading a timerfd with CANCEL_ON_SET will lead to this error
when the clock goes through a discontinuous change</p>
</dd></div><div><dt>CertificateAuthorityBundleTooBig <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFileError">AddCertsFromFileError</a></dt></div><div><dt>CertificateFieldHasInvalidLength <a href="std.crypto.Certificate.der.Element.html#std.crypto.Certificate.der.Element.ParseError">ParseError</a></dt></div><div><dt>CertificateFieldHasWrongDataType <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseTimeError">ParseTimeError</a></dt></div><div><dt>CertificateHasInvalidBitString <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseBitStringError">ParseBitStringError</a></dt></div><div><dt>CertificateHasUnrecognizedObjectId <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseEnumError">ParseEnumError</a></dt></div><div><dt>CertificateTimeInvalid <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseTimeError">ParseTimeError</a></dt></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>ConnectionTimedOut <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>DeviceBusy <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>EndOfStream <a href="std.crypto.Certificate.Bundle.macos.html#std.crypto.Certificate.Bundle.macos.RescanMacError">RescanMacError</a></dt></div><div><dt>FileBusy <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>One of these three things:</p>
<ul>
<li>pathname  refers to an executable image which is currently being
executed and write access was requested.</li>
<li>pathname refers to a file that is currently in  use  as  a  swap
file, and the O_TRUNC flag was specified.</li>
<li>pathname  refers  to  a file that is currently being read by the
kernel (e.g., for module/firmware loading), and write access was
requested.</li>
</ul>
</dd></div><div><dt>FileLocksNotSupported <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The underlying filesystem does not support file locks</p>
</dd></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Either:</p>
<ul>
<li>One of the path components does not exist.</li>
<li>Cwd was used, but cwd has been deleted.</li>
<li>The path associated with the open directory handle has been deleted.</li>
<li>On macOS, multiple processes or threads raced to create the same file
with <code>O.EXCL</code> set to <code>false</code>.</li>
</ul>
</dd></div><div><dt>FileTooBig <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The file is too large to be opened. This error is unreachable
for 64-bit targets, as well as when opening directories.</p>
</dd></div><div><dt>InputOutput <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>InvalidCharacter <a href="std.base64.html#std.base64.Error">Error</a></dt></div><div><dt>InvalidPadding <a href="std.base64.html#std.base64.Error">Error</a></dt></div><div><dt>InvalidUtf8 <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8 <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path refers to directory but the <code>DIRECTORY</code> flag was not provided.</p>
</dd></div><div><dt>LockViolation <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>Unable to read file due to lock.</p>
</dd></div><div><dt>MissingEndCertificateMarker <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFileError">AddCertsFromFileError</a></dt></div><div><dt>NameTooLong <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path exceeded <code><a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a></code> bytes.</p>
</dd></div><div><dt>NetworkNotFound <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NoDevice <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>NoSpaceLeft <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>A new path cannot be created because the device has no room for the new file.
This error is only reachable when the <code>CREAT</code> flag is provided.</p>
</dd></div><div><dt>NotDir <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>A component used as a directory in the path was not, in fact, a directory, or
<code>DIRECTORY</code> was specified and the path was not a directory.</p>
</dd></div><div><dt>NotOpenForReading <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>OperationAborted <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>PathAlreadyExists <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path already exists and the <code>CREAT</code> and <code>EXCL</code> flags were provided.</p>
</dd></div><div><dt>PipeBusy <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>ProcessFdQuotaExceeded <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs in Linux if the process to be read from
no longer exists.</p>
</dd></div><div><dt>SharingViolation <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>SocketNotConnected <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>SymLinkLoop <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SystemFdQuotaExceeded <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Insufficient kernel memory was available, or
the named file is a FIFO and per-user hard limit on
memory allocation for pipes has been reached.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>Unseekable <a href="std.posix.html#std.posix.SeekError">SeekError</a></dt></div><div><dt>UnsupportedCertificateVersion <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseVersionError">ParseVersionError</a></dt></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle.RescanError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RescanError = <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.RescanLinuxError">RescanLinuxError</a> || <a href="std.crypto.Certificate.Bundle.macos.html#std.crypto.Certificate.Bundle.macos.RescanMacError">RescanMacError</a> || <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFilePathError">RescanBSDError</a> || <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.RescanWindowsError">RescanWindowsError</a></code></pre></details></div></div><div class="decl"><h2 id="std.crypto.Certificate.Bundle.AddCertsFromDirPathError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">AddCertsFromDirPathError</span><a href="#src.zig-std.crypto.Certificate.Bundle.AddCertsFromDirPathError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to open a new resource relative to it.</p>
</dd></div><div><dt>AntivirusInterference <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, antivirus software is enabled by default. It can be
disabled, but Windows Update sometimes ignores the user's preference
and re-enables it. When enabled, antivirus software on Windows
intercepts file system operations and makes them significantly slower
in addition to possibly failing with this error code.</p>
</dd></div><div><dt>BadPathName <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, file paths cannot contain these characters:
'/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</p>
</dd></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>Canceled <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>reading a timerfd with CANCEL_ON_SET will lead to this error
when the clock goes through a discontinuous change</p>
</dd></div><div><dt>CertificateAuthorityBundleTooBig <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFileError">AddCertsFromFileError</a></dt></div><div><dt>CertificateFieldHasInvalidLength <a href="std.crypto.Certificate.der.Element.html#std.crypto.Certificate.der.Element.ParseError">ParseError</a></dt></div><div><dt>CertificateFieldHasWrongDataType <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseTimeError">ParseTimeError</a></dt></div><div><dt>CertificateHasInvalidBitString <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseBitStringError">ParseBitStringError</a></dt></div><div><dt>CertificateHasUnrecognizedObjectId <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseEnumError">ParseEnumError</a></dt></div><div><dt>CertificateTimeInvalid <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseTimeError">ParseTimeError</a></dt></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>ConnectionTimedOut <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>DeviceBusy <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>FileBusy <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>One of these three things:</p>
<ul>
<li>pathname  refers to an executable image which is currently being
executed and write access was requested.</li>
<li>pathname refers to a file that is currently in  use  as  a  swap
file, and the O_TRUNC flag was specified.</li>
<li>pathname  refers  to  a file that is currently being read by the
kernel (e.g., for module/firmware loading), and write access was
requested.</li>
</ul>
</dd></div><div><dt>FileLocksNotSupported <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The underlying filesystem does not support file locks</p>
</dd></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Either:</p>
<ul>
<li>One of the path components does not exist.</li>
<li>Cwd was used, but cwd has been deleted.</li>
<li>The path associated with the open directory handle has been deleted.</li>
<li>On macOS, multiple processes or threads raced to create the same file
with <code>O.EXCL</code> set to <code>false</code>.</li>
</ul>
</dd></div><div><dt>FileTooBig <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The file is too large to be opened. This error is unreachable
for 64-bit targets, as well as when opening directories.</p>
</dd></div><div><dt>InputOutput <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>InvalidCharacter <a href="std.base64.html#std.base64.Error">Error</a></dt></div><div><dt>InvalidPadding <a href="std.base64.html#std.base64.Error">Error</a></dt></div><div><dt>InvalidUtf8 <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8 <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path refers to directory but the <code>DIRECTORY</code> flag was not provided.</p>
</dd></div><div><dt>LockViolation <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>Unable to read file due to lock.</p>
</dd></div><div><dt>MissingEndCertificateMarker <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFileError">AddCertsFromFileError</a></dt></div><div><dt>NameTooLong <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path exceeded <code><a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a></code> bytes.</p>
</dd></div><div><dt>NetworkNotFound <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NoDevice <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>NoSpaceLeft <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>A new path cannot be created because the device has no room for the new file.
This error is only reachable when the <code>CREAT</code> flag is provided.</p>
</dd></div><div><dt>NotDir <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>A component used as a directory in the path was not, in fact, a directory, or
<code>DIRECTORY</code> was specified and the path was not a directory.</p>
</dd></div><div><dt>NotOpenForReading <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>OperationAborted <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>PathAlreadyExists <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path already exists and the <code>CREAT</code> and <code>EXCL</code> flags were provided.</p>
</dd></div><div><dt>PipeBusy <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>ProcessFdQuotaExceeded <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs in Linux if the process to be read from
no longer exists.</p>
</dd></div><div><dt>SharingViolation <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>SocketNotConnected <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>SymLinkLoop <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SystemFdQuotaExceeded <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Insufficient kernel memory was available, or
the named file is a FIFO and per-user hard limit on
memory allocation for pipes has been reached.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>Unseekable <a href="std.posix.html#std.posix.SeekError">SeekError</a></dt></div><div><dt>UnsupportedCertificateVersion <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseVersionError">ParseVersionError</a></dt></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle.AddCertsFromDirPathError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AddCertsFromDirPathError = <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a> || <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFilePathError">AddCertsFromDirError</a></code></pre></details></div></div><div class="decl"><h2 id="std.crypto.Certificate.Bundle.AddCertsFromFilePathError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">AddCertsFromFilePathError</span><a href="#src.zig-std.crypto.Certificate.Bundle.AddCertsFromFilePathError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to open a new resource relative to it.</p>
</dd></div><div><dt>AntivirusInterference <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, antivirus software is enabled by default. It can be
disabled, but Windows Update sometimes ignores the user's preference
and re-enables it. When enabled, antivirus software on Windows
intercepts file system operations and makes them significantly slower
in addition to possibly failing with this error code.</p>
</dd></div><div><dt>BadPathName <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, file paths cannot contain these characters:
'/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</p>
</dd></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>Canceled <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>reading a timerfd with CANCEL_ON_SET will lead to this error
when the clock goes through a discontinuous change</p>
</dd></div><div><dt>CertificateAuthorityBundleTooBig <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFileError">AddCertsFromFileError</a></dt></div><div><dt>CertificateFieldHasInvalidLength <a href="std.crypto.Certificate.der.Element.html#std.crypto.Certificate.der.Element.ParseError">ParseError</a></dt></div><div><dt>CertificateFieldHasWrongDataType <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseTimeError">ParseTimeError</a></dt></div><div><dt>CertificateHasInvalidBitString <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseBitStringError">ParseBitStringError</a></dt></div><div><dt>CertificateHasUnrecognizedObjectId <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseEnumError">ParseEnumError</a></dt></div><div><dt>CertificateTimeInvalid <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseTimeError">ParseTimeError</a></dt></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>ConnectionTimedOut <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>DeviceBusy <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>FileBusy <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>One of these three things:</p>
<ul>
<li>pathname  refers to an executable image which is currently being
executed and write access was requested.</li>
<li>pathname refers to a file that is currently in  use  as  a  swap
file, and the O_TRUNC flag was specified.</li>
<li>pathname  refers  to  a file that is currently being read by the
kernel (e.g., for module/firmware loading), and write access was
requested.</li>
</ul>
</dd></div><div><dt>FileLocksNotSupported <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The underlying filesystem does not support file locks</p>
</dd></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Either:</p>
<ul>
<li>One of the path components does not exist.</li>
<li>Cwd was used, but cwd has been deleted.</li>
<li>The path associated with the open directory handle has been deleted.</li>
<li>On macOS, multiple processes or threads raced to create the same file
with <code>O.EXCL</code> set to <code>false</code>.</li>
</ul>
</dd></div><div><dt>FileTooBig <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The file is too large to be opened. This error is unreachable
for 64-bit targets, as well as when opening directories.</p>
</dd></div><div><dt>InputOutput <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>InvalidCharacter <a href="std.base64.html#std.base64.Error">Error</a></dt></div><div><dt>InvalidPadding <a href="std.base64.html#std.base64.Error">Error</a></dt></div><div><dt>InvalidUtf8 <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8 <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path refers to directory but the <code>DIRECTORY</code> flag was not provided.</p>
</dd></div><div><dt>LockViolation <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>Unable to read file due to lock.</p>
</dd></div><div><dt>MissingEndCertificateMarker <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFileError">AddCertsFromFileError</a></dt></div><div><dt>NameTooLong <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path exceeded <code><a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a></code> bytes.</p>
</dd></div><div><dt>NetworkNotFound <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NoDevice <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>NoSpaceLeft <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>A new path cannot be created because the device has no room for the new file.
This error is only reachable when the <code>CREAT</code> flag is provided.</p>
</dd></div><div><dt>NotDir <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>A component used as a directory in the path was not, in fact, a directory, or
<code>DIRECTORY</code> was specified and the path was not a directory.</p>
</dd></div><div><dt>NotOpenForReading <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>OperationAborted <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>PathAlreadyExists <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path already exists and the <code>CREAT</code> and <code>EXCL</code> flags were provided.</p>
</dd></div><div><dt>PipeBusy <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>ProcessFdQuotaExceeded <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs in Linux if the process to be read from
no longer exists.</p>
</dd></div><div><dt>SharingViolation <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>SocketNotConnected <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>SymLinkLoop <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SystemFdQuotaExceeded <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Insufficient kernel memory was available, or
the named file is a FIFO and per-user hard limit on
memory allocation for pipes has been reached.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>Unseekable <a href="std.posix.html#std.posix.SeekError">SeekError</a></dt></div><div><dt>UnsupportedCertificateVersion <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseVersionError">ParseVersionError</a></dt></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle.AddCertsFromFilePathError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AddCertsFromFilePathError = <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a> || <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFileError">AddCertsFromFileError</a></code></pre></details></div></div><div class="decl"><h2 id="std.crypto.Certificate.Bundle.AddCertsFromFilePathError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">AddCertsFromFilePathError</span><a href="#src.zig-std.crypto.Certificate.Bundle.AddCertsFromFilePathError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to open a new resource relative to it.</p>
</dd></div><div><dt>AntivirusInterference <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, antivirus software is enabled by default. It can be
disabled, but Windows Update sometimes ignores the user's preference
and re-enables it. When enabled, antivirus software on Windows
intercepts file system operations and makes them significantly slower
in addition to possibly failing with this error code.</p>
</dd></div><div><dt>BadPathName <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, file paths cannot contain these characters:
'/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</p>
</dd></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>Canceled <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>reading a timerfd with CANCEL_ON_SET will lead to this error
when the clock goes through a discontinuous change</p>
</dd></div><div><dt>CertificateAuthorityBundleTooBig <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFileError">AddCertsFromFileError</a></dt></div><div><dt>CertificateFieldHasInvalidLength <a href="std.crypto.Certificate.der.Element.html#std.crypto.Certificate.der.Element.ParseError">ParseError</a></dt></div><div><dt>CertificateFieldHasWrongDataType <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseTimeError">ParseTimeError</a></dt></div><div><dt>CertificateHasInvalidBitString <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseBitStringError">ParseBitStringError</a></dt></div><div><dt>CertificateHasUnrecognizedObjectId <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseEnumError">ParseEnumError</a></dt></div><div><dt>CertificateTimeInvalid <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseTimeError">ParseTimeError</a></dt></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>ConnectionTimedOut <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>DeviceBusy <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>FileBusy <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>One of these three things:</p>
<ul>
<li>pathname  refers to an executable image which is currently being
executed and write access was requested.</li>
<li>pathname refers to a file that is currently in  use  as  a  swap
file, and the O_TRUNC flag was specified.</li>
<li>pathname  refers  to  a file that is currently being read by the
kernel (e.g., for module/firmware loading), and write access was
requested.</li>
</ul>
</dd></div><div><dt>FileLocksNotSupported <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The underlying filesystem does not support file locks</p>
</dd></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Either:</p>
<ul>
<li>One of the path components does not exist.</li>
<li>Cwd was used, but cwd has been deleted.</li>
<li>The path associated with the open directory handle has been deleted.</li>
<li>On macOS, multiple processes or threads raced to create the same file
with <code>O.EXCL</code> set to <code>false</code>.</li>
</ul>
</dd></div><div><dt>FileTooBig <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The file is too large to be opened. This error is unreachable
for 64-bit targets, as well as when opening directories.</p>
</dd></div><div><dt>InputOutput <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>InvalidCharacter <a href="std.base64.html#std.base64.Error">Error</a></dt></div><div><dt>InvalidPadding <a href="std.base64.html#std.base64.Error">Error</a></dt></div><div><dt>InvalidUtf8 <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8 <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path refers to directory but the <code>DIRECTORY</code> flag was not provided.</p>
</dd></div><div><dt>LockViolation <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>Unable to read file due to lock.</p>
</dd></div><div><dt>MissingEndCertificateMarker <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFileError">AddCertsFromFileError</a></dt></div><div><dt>NameTooLong <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path exceeded <code><a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a></code> bytes.</p>
</dd></div><div><dt>NetworkNotFound <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NoDevice <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>NoSpaceLeft <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>A new path cannot be created because the device has no room for the new file.
This error is only reachable when the <code>CREAT</code> flag is provided.</p>
</dd></div><div><dt>NotDir <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>A component used as a directory in the path was not, in fact, a directory, or
<code>DIRECTORY</code> was specified and the path was not a directory.</p>
</dd></div><div><dt>NotOpenForReading <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>OperationAborted <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>PathAlreadyExists <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path already exists and the <code>CREAT</code> and <code>EXCL</code> flags were provided.</p>
</dd></div><div><dt>PipeBusy <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>ProcessFdQuotaExceeded <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs in Linux if the process to be read from
no longer exists.</p>
</dd></div><div><dt>SharingViolation <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>SocketNotConnected <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>SymLinkLoop <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SystemFdQuotaExceeded <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Insufficient kernel memory was available, or
the named file is a FIFO and per-user hard limit on
memory allocation for pipes has been reached.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>Unseekable <a href="std.posix.html#std.posix.SeekError">SeekError</a></dt></div><div><dt>UnsupportedCertificateVersion <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseVersionError">ParseVersionError</a></dt></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle.AddCertsFromFilePathError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AddCertsFromFilePathError = <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a> || <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFileError">AddCertsFromFileError</a></code></pre></details></div></div><div class="decl"><h2 id="std.crypto.Certificate.Bundle.AddCertsFromFileError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">AddCertsFromFileError</span><a href="#src.zig-std.crypto.Certificate.Bundle.AddCertsFromFileError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.SeekError">SeekError</a></dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to seek on it.</p>
</dd></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>Canceled <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>reading a timerfd with CANCEL_ON_SET will lead to this error
when the clock goes through a discontinuous change</p>
</dd></div><div><dt>CertificateAuthorityBundleTooBig</dt></div><div><dt>CertificateFieldHasInvalidLength <a href="std.crypto.Certificate.der.Element.html#std.crypto.Certificate.der.Element.ParseError">ParseError</a></dt></div><div><dt>CertificateFieldHasWrongDataType <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseTimeError">ParseTimeError</a></dt></div><div><dt>CertificateHasInvalidBitString <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseBitStringError">ParseBitStringError</a></dt></div><div><dt>CertificateHasUnrecognizedObjectId <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseEnumError">ParseEnumError</a></dt></div><div><dt>CertificateTimeInvalid <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseTimeError">ParseTimeError</a></dt></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>ConnectionTimedOut <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>InputOutput <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>InvalidCharacter <a href="std.base64.html#std.base64.Error">Error</a></dt></div><div><dt>InvalidPadding <a href="std.base64.html#std.base64.Error">Error</a></dt></div><div><dt>IsDir <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>LockViolation <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>Unable to read file due to lock.</p>
</dd></div><div><dt>MissingEndCertificateMarker</dt></div><div><dt>NoSpaceLeft <a href="std.base64.html#std.base64.Error">Error</a></dt></div><div><dt>NotOpenForReading <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>OperationAborted <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs in Linux if the process to be read from
no longer exists.</p>
</dd></div><div><dt>SocketNotConnected <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.FStatError">FStatError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>Unseekable <a href="std.posix.html#std.posix.SeekError">SeekError</a></dt></div><div><dt>UnsupportedCertificateVersion <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseVersionError">ParseVersionError</a></dt></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle.AddCertsFromFileError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AddCertsFromFileError = <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> ||
    <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.GetSeekPosError">GetSeekPosError</a> ||
    <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.ReadError">ReadError</a> ||
    <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.ParseCertError">ParseCertError</a> ||
    <a href="std.html">std</a>.<a href="std.base64.html">base64</a>.<a href="std.base64.html#std.base64.Error">Error</a> ||
    <span class="tok-kw">error</span>{ CertificateAuthorityBundleTooBig, MissingEndCertificateMarker }</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.Certificate.Bundle.ParseCertError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ParseCertError</span><a href="#src.zig-std.crypto.Certificate.Bundle.ParseCertError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>CertificateFieldHasInvalidLength <a href="std.crypto.Certificate.der.Element.html#std.crypto.Certificate.der.Element.ParseError">ParseError</a></dt></div><div><dt>CertificateFieldHasWrongDataType <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseTimeError">ParseTimeError</a></dt></div><div><dt>CertificateHasInvalidBitString <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseBitStringError">ParseBitStringError</a></dt></div><div><dt>CertificateHasUnrecognizedObjectId <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseEnumError">ParseEnumError</a></dt></div><div><dt>CertificateTimeInvalid <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseTimeError">ParseTimeError</a></dt></div><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>UnsupportedCertificateVersion <a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseVersionError">ParseVersionError</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle.ParseCertError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ParseCertError = <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseError">ParseError</a></code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.crypto.Certificate.Bundle.verify" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">verify</span><a href="#src.zig-std.crypto.Certificate.Bundle.verify">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">verify</span>(cb: <a href="std.crypto.Certificate.Bundle.html">Bundle</a>, subject: <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.Parsed.html">Parsed</a>, now_sec: <span class="tok-type">i64</span>) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.VerifyError">VerifyError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cb: <a href="std.crypto.Certificate.Bundle.html">Bundle</a></code></pre></div><div><pre><code>subject: <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.Parsed.html">Parsed</a></code></pre></div><div><pre><code>now_sec: <span class="tok-type">i64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle.verify">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">verify</span>(cb: <a href="std.crypto.Certificate.Bundle.html">Bundle</a>, subject: <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.Parsed.html">Parsed</a>, now_sec: <span class="tok-type">i64</span>) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.VerifyError">VerifyError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> bytes_index = cb.find(subject.issuer()) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateIssuerNotFound;
    <span class="tok-kw">const</span> issuer_cert: <a href="std.crypto.Certificate.html">Certificate</a> = .{
        .buffer = cb.bytes.items,
        .index = bytes_index,
    };<span class="tok-comment">
    // Every certificate in the bundle is pre-parsed before adding it, ensuring
    // that parsing will succeed here.
    </span><span class="tok-kw">const</span> issuer = issuer_cert.parse() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">try</span> subject.verify(issuer, now_sec);
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.Certificate.Bundle.find" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">find</span><a href="#src.zig-std.crypto.Certificate.Bundle.find">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">find</span>(cb: <a href="std.crypto.Certificate.Bundle.html">Bundle</a>, subject_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<span class="tok-type">u32</span></code></pre></div><div class="tldDocs"><p>The returned bytes become invalid after calling any of the rescan functions
or add functions.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cb: <a href="std.crypto.Certificate.Bundle.html">Bundle</a></code></pre></div><div><pre><code>subject_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.crypto.Certificate.Bundle.find.hash" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">hash</span><a href="#src.zig-std.crypto.Certificate.Bundle.find.hash">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(ctx: <span class="tok-builtin">@This</span>(), k: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u64</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>ctx: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>k: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle.find.hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(ctx: <span class="tok-builtin">@This</span>(), k: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u64</span> {
    _ = ctx;
    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.hash_map.html">hash_map</a>.<a href="std.hash_map.html#std.hash_map.hashString">hashString</a>(k);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.Certificate.Bundle.find.eql" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">eql</span><a href="#src.zig-std.crypto.Certificate.Bundle.find.eql">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b_key: <a href="std.crypto.Certificate.der.html">der</a>.<a href="std.crypto.Certificate.der.Element.html">Element</a>.<a href="std.crypto.Certificate.der.Element.Slice.html">Slice</a>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>ctx: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>b_key: <a href="std.crypto.Certificate.der.html">der</a>.<a href="std.crypto.Certificate.der.Element.html">Element</a>.<a href="std.crypto.Certificate.der.Element.Slice.html">Slice</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle.find.eql">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b_key: <a href="std.crypto.Certificate.der.html">der</a>.<a href="std.crypto.Certificate.der.Element.html">Element</a>.<a href="std.crypto.Certificate.der.Element.Slice.html">Slice</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> b = ctx.cb.bytes.items[b_key.start..b_key.end];
    <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, a, b);
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle.find">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">find</span>(cb: <a href="std.crypto.Certificate.Bundle.html">Bundle</a>, subject_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        cb: <a href="std.crypto.Certificate.Bundle.html">Bundle</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(ctx: <span class="tok-builtin">@This</span>(), k: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u64</span> {
            _ = ctx;
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.hash_map.html">hash_map</a>.<a href="std.hash_map.html#std.hash_map.hashString">hashString</a>(k);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b_key: <a href="std.crypto.Certificate.der.html">der</a>.<a href="std.crypto.Certificate.der.Element.html">Element</a>.<a href="std.crypto.Certificate.der.Element.Slice.html">Slice</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> b = ctx.cb.bytes.items[b_key.start..b_key.end];
            <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, a, b);
        }
    };
    <span class="tok-kw">return</span> cb.map.getAdapted(subject_name, Adapter{ .cb = cb });
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.Certificate.Bundle.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.crypto.Certificate.Bundle.deinit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle.deinit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    cb.map.deinit(gpa);
    cb.bytes.deinit(gpa);
    cb.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.Certificate.Bundle.rescan" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rescan</span><a href="#src.zig-std.crypto.Certificate.Bundle.rescan">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rescan</span>(cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.RescanError">RescanError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clears the set of certificates and then scans the host operating system
file system standard locations for certificates.
For operating systems that do not have standard CA installations to be
found, this function clears the set of certificates.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle.rescan">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rescan</span>(cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.RescanError">RescanError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
        .linux =&gt; <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.rescanLinux">rescanLinux</a>(cb, gpa),
        .macos =&gt; <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.macos.html#std.crypto.Certificate.Bundle.macos.rescanMac">rescanMac</a>(cb, gpa),
        .freebsd, .openbsd =&gt; <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.rescanBSD">rescanBSD</a>(cb, gpa, <span class="tok-str">&quot;/etc/ssl/cert.pem&quot;</span>),
        .netbsd =&gt; <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.rescanBSD">rescanBSD</a>(cb, gpa, <span class="tok-str">&quot;/etc/openssl/certs/ca-certificates.crt&quot;</span>),
        .dragonfly =&gt; <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.rescanBSD">rescanBSD</a>(cb, gpa, <span class="tok-str">&quot;/usr/local/etc/ssl/cert.pem&quot;</span>),
        .solaris, .illumos =&gt; <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.rescanBSD">rescanBSD</a>(cb, gpa, <span class="tok-str">&quot;/etc/ssl/cacert.pem&quot;</span>),
        .windows =&gt; <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.rescanWindows">rescanWindows</a>(cb, gpa),
        <span class="tok-kw">else</span> =&gt; {},
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.Certificate.Bundle.addCertsFromDirPath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addCertsFromDirPath</span><a href="#src.zig-std.crypto.Certificate.Bundle.addCertsFromDirPath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCertsFromDirPath</span>( cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, sub_dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromDirPathError">AddCertsFromDirPathError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle.addCertsFromDirPath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCertsFromDirPath</span>(
    cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>,
    sub_dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromDirPathError">AddCertsFromDirPathError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> iterable_dir = <span class="tok-kw">try</span> dir.openDir(sub_dir_path, .{ .iterate = <span class="tok-null">true</span> });
    <span class="tok-kw">defer</span> iterable_dir.close();
    <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.addCertsFromDir">addCertsFromDir</a>(cb, gpa, iterable_dir);
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.Certificate.Bundle.addCertsFromDirPathAbsolute" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addCertsFromDirPathAbsolute</span><a href="#src.zig-std.crypto.Certificate.Bundle.addCertsFromDirPathAbsolute">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCertsFromDirPathAbsolute</span>( cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, abs_dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromDirPathError">AddCertsFromDirPathError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>abs_dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle.addCertsFromDirPathAbsolute">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCertsFromDirPathAbsolute</span>(
    cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    abs_dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromDirPathError">AddCertsFromDirPathError</a>!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(abs_dir_path));
    <span class="tok-kw">var</span> iterable_dir = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.openDirAbsolute">openDirAbsolute</a>(abs_dir_path, .{ .iterate = <span class="tok-null">true</span> });
    <span class="tok-kw">defer</span> iterable_dir.close();
    <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.addCertsFromDir">addCertsFromDir</a>(cb, gpa, iterable_dir);
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.Certificate.Bundle.addCertsFromDir" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addCertsFromDir</span><a href="#src.zig-std.crypto.Certificate.Bundle.addCertsFromDir">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCertsFromDir</span>(cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, iterable_dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFilePathError">AddCertsFromDirError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>iterable_dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle.addCertsFromDir">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCertsFromDir</span>(cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, iterable_dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFilePathError">AddCertsFromDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> it = iterable_dir.iterate();
    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> it.next()) |entry| {
        <span class="tok-kw">switch</span> (entry.kind) {
            .file, .sym_link =&gt; {},
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,
        }

        <span class="tok-kw">try</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.addCertsFromFilePath">addCertsFromFilePath</a>(cb, gpa, iterable_dir, entry.name);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.Certificate.Bundle.addCertsFromFilePathAbsolute" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addCertsFromFilePathAbsolute</span><a href="#src.zig-std.crypto.Certificate.Bundle.addCertsFromFilePathAbsolute">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCertsFromFilePathAbsolute</span>( cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, abs_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFilePathError">AddCertsFromFilePathError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>abs_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle.addCertsFromFilePathAbsolute">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCertsFromFilePathAbsolute</span>(
    cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    abs_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFilePathError">AddCertsFromFilePathError</a>!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(abs_file_path));
    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.openFileAbsolute">openFileAbsolute</a>(abs_file_path, .{});
    <span class="tok-kw">defer</span> file.close();
    <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.addCertsFromFile">addCertsFromFile</a>(cb, gpa, file);
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.Certificate.Bundle.addCertsFromFilePath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addCertsFromFilePath</span><a href="#src.zig-std.crypto.Certificate.Bundle.addCertsFromFilePath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCertsFromFilePath</span>( cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, sub_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFilePathError">AddCertsFromFilePathError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle.addCertsFromFilePath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCertsFromFilePath</span>(
    cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>,
    sub_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFilePathError">AddCertsFromFilePathError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> dir.openFile(sub_file_path, .{});
    <span class="tok-kw">defer</span> file.close();
    <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.addCertsFromFile">addCertsFromFile</a>(cb, gpa, file);
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.Certificate.Bundle.addCertsFromFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addCertsFromFile</span><a href="#src.zig-std.crypto.Certificate.Bundle.addCertsFromFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCertsFromFile</span>(cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, file: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFileError">AddCertsFromFileError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>file: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle.addCertsFromFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCertsFromFile</span>(cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, file: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFileError">AddCertsFromFileError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> file.getEndPos();<span class="tok-comment">

    // We borrow `bytes` as a temporary buffer for the base64-encoded data.
    // This is possible by computing the decoded length and reserving the space
    // for the decoded bytes first.
    </span><span class="tok-kw">const</span> decoded_size_upper_bound = size / <span class="tok-number">4</span> * <span class="tok-number">3</span>;
    <span class="tok-kw">const</span> needed_capacity = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u32</span>, decoded_size_upper_bound + size) <span class="tok-kw">orelse</span>
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateAuthorityBundleTooBig;
    <span class="tok-kw">try</span> cb.bytes.ensureUnusedCapacity(gpa, needed_capacity);
    <span class="tok-kw">const</span> end_reserved: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(cb.bytes.items.len + decoded_size_upper_bound);
    <span class="tok-kw">const</span> buffer = cb.bytes.allocatedSlice()[end_reserved..];
    <span class="tok-kw">const</span> end_index = <span class="tok-kw">try</span> file.readAll(buffer);
    <span class="tok-kw">const</span> encoded_bytes = buffer[<span class="tok-number">0</span>..end_index];

    <span class="tok-kw">const</span> begin_marker = <span class="tok-str">&quot;-----BEGIN CERTIFICATE-----&quot;</span>;
    <span class="tok-kw">const</span> end_marker = <span class="tok-str">&quot;-----END CERTIFICATE-----&quot;</span>;

    <span class="tok-kw">const</span> now_sec = <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.timestamp">timestamp</a>();

    <span class="tok-kw">var</span> start_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a>(<span class="tok-type">u8</span>, encoded_bytes, start_index, begin_marker)) |begin_marker_start| {
        <span class="tok-kw">const</span> cert_start = begin_marker_start + begin_marker.len;
        <span class="tok-kw">const</span> cert_end = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a>(<span class="tok-type">u8</span>, encoded_bytes, cert_start, end_marker) <span class="tok-kw">orelse</span>
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingEndCertificateMarker;
        start_index = cert_end + end_marker.len;
        <span class="tok-kw">const</span> encoded_cert = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, encoded_bytes[cert_start..cert_end], <span class="tok-str">&quot; \t\r\n&quot;</span>);
        <span class="tok-kw">const</span> decoded_start: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(cb.bytes.items.len);
        <span class="tok-kw">const</span> dest_buf = cb.bytes.allocatedSlice()[decoded_start..];
        cb.bytes.items.len += <span class="tok-kw">try</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.base64">base64</a>.<a href="#">decode</a>(dest_buf, encoded_cert);
        <span class="tok-kw">try</span> cb.parseCert(gpa, decoded_start, now_sec);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.Certificate.Bundle.parseCert" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">parseCert</span><a href="#src.zig-std.crypto.Certificate.Bundle.parseCert">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseCert</span>(cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, decoded_start: <span class="tok-type">u32</span>, now_sec: <span class="tok-type">i64</span>) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.ParseCertError">ParseCertError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>decoded_start: <span class="tok-type">u32</span></code></pre></div><div><pre><code>now_sec: <span class="tok-type">i64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle.parseCert">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseCert</span>(cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, decoded_start: <span class="tok-type">u32</span>, now_sec: <span class="tok-type">i64</span>) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.ParseCertError">ParseCertError</a>!<span class="tok-type">void</span> {<span class="tok-comment">
    // Even though we could only partially parse the certificate to find
    // the subject name, we pre-parse all of them to make sure and only
    // include in the bundle ones that we know will parse. This way we can
    // use `catch unreachable` later.
    </span><span class="tok-kw">const</span> parsed_cert = <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.html#std.crypto.Certificate.parse">parse</a>(.{
        .buffer = cb.bytes.items,
        .index = decoded_start,
    }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.CertificateHasUnrecognizedObjectId =&gt; {
            cb.bytes.items.len = decoded_start;
            <span class="tok-kw">return</span>;
        },
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
    <span class="tok-kw">if</span> (now_sec &gt; parsed_cert.validity.not_after) {<span class="tok-comment">
        // Ignore expired cert.
        </span>cb.bytes.items.len = decoded_start;
        <span class="tok-kw">return</span>;
    }
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> cb.map.getOrPutContext(gpa, parsed_cert.subject_slice, .{ .cb = cb });
    <span class="tok-kw">if</span> (gop.found_existing) {
        cb.bytes.items.len = decoded_start;
    } <span class="tok-kw">else</span> {
        gop.value_ptr.* = decoded_start;
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.crypto.Certificate.Bundle">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! A set of certificates. Typically pre-installed on every operating system,</span>
<span class="tok-comment">//! these are &quot;Certificate Authorities&quot; used to validate SSL certificates.</span>
<span class="tok-comment">//! This data structure stores certificates in DER-encoded form, all of them</span>
<span class="tok-comment">//! concatenated together in the `bytes` array. The `map` field contains an</span>
<span class="tok-comment">//! index from the DER-encoded subject name to the index of the containing</span>
<span class="tok-comment">//! certificate within `bytes`.</span>

<span class="tok-comment">/// The key is the contents slice of the subject.</span>
map: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(<a href="std.crypto.Certificate.der.html">der</a>.<a href="std.crypto.Certificate.der.Element.html">Element</a>.<a href="std.crypto.Certificate.der.Element.Slice.html">Slice</a>, <span class="tok-type">u32</span>, <a href="std.crypto.Certificate.Bundle.MapContext.html">MapContext</a>, <a href="std.html">std</a>.<a href="std.hash_map.html">hash_map</a>.<a href="std.hash_map.html#std.hash_map.default_max_load_percentage">default_max_load_percentage</a>) = .empty,
bytes: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>) = .empty,

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> VerifyError = <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.Parsed.html">Parsed</a>.<a href="std.crypto.Certificate.Parsed.html#std.crypto.Certificate.Parsed.VerifyError">VerifyError</a> || <span class="tok-kw">error</span>{
    CertificateIssuerNotFound,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">verify</span>(cb: <a href="std.crypto.Certificate.Bundle.html">Bundle</a>, subject: <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.Parsed.html">Parsed</a>, now_sec: <span class="tok-type">i64</span>) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.VerifyError">VerifyError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> bytes_index = cb.find(subject.issuer()) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateIssuerNotFound;
    <span class="tok-kw">const</span> issuer_cert: <a href="std.crypto.Certificate.html">Certificate</a> = .{
        .buffer = cb.bytes.items,
        .index = bytes_index,
    };<span class="tok-comment">
    // Every certificate in the bundle is pre-parsed before adding it, ensuring
    // that parsing will succeed here.
    </span><span class="tok-kw">const</span> issuer = issuer_cert.parse() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">try</span> subject.verify(issuer, now_sec);
}

<span class="tok-comment">/// The returned bytes become invalid after calling any of the rescan functions</span>
<span class="tok-comment">/// or add functions.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">find</span>(cb: <a href="std.crypto.Certificate.Bundle.html">Bundle</a>, subject_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        cb: <a href="std.crypto.Certificate.Bundle.html">Bundle</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(ctx: <span class="tok-builtin">@This</span>(), k: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u64</span> {
            _ = ctx;
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.hash_map.html">hash_map</a>.<a href="std.hash_map.html#std.hash_map.hashString">hashString</a>(k);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b_key: <a href="std.crypto.Certificate.der.html">der</a>.<a href="std.crypto.Certificate.der.Element.html">Element</a>.<a href="std.crypto.Certificate.der.Element.Slice.html">Slice</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> b = ctx.cb.bytes.items[b_key.start..b_key.end];
            <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, a, b);
        }
    };
    <span class="tok-kw">return</span> cb.map.getAdapted(subject_name, Adapter{ .cb = cb });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    cb.map.deinit(gpa);
    cb.bytes.deinit(gpa);
    cb.* = <span class="tok-null">undefined</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RescanError = <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.RescanLinuxError">RescanLinuxError</a> || <a href="std.crypto.Certificate.Bundle.macos.html#std.crypto.Certificate.Bundle.macos.RescanMacError">RescanMacError</a> || <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFilePathError">RescanBSDError</a> || <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.RescanWindowsError">RescanWindowsError</a>;

<span class="tok-comment">/// Clears the set of certificates and then scans the host operating system</span>
<span class="tok-comment">/// file system standard locations for certificates.</span>
<span class="tok-comment">/// For operating systems that do not have standard CA installations to be</span>
<span class="tok-comment">/// found, this function clears the set of certificates.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rescan</span>(cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.RescanError">RescanError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
        .linux =&gt; <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.rescanLinux">rescanLinux</a>(cb, gpa),
        .macos =&gt; <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.macos.html#std.crypto.Certificate.Bundle.macos.rescanMac">rescanMac</a>(cb, gpa),
        .freebsd, .openbsd =&gt; <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.rescanBSD">rescanBSD</a>(cb, gpa, <span class="tok-str">&quot;/etc/ssl/cert.pem&quot;</span>),
        .netbsd =&gt; <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.rescanBSD">rescanBSD</a>(cb, gpa, <span class="tok-str">&quot;/etc/openssl/certs/ca-certificates.crt&quot;</span>),
        .dragonfly =&gt; <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.rescanBSD">rescanBSD</a>(cb, gpa, <span class="tok-str">&quot;/usr/local/etc/ssl/cert.pem&quot;</span>),
        .solaris, .illumos =&gt; <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.rescanBSD">rescanBSD</a>(cb, gpa, <span class="tok-str">&quot;/etc/ssl/cacert.pem&quot;</span>),
        .windows =&gt; <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.rescanWindows">rescanWindows</a>(cb, gpa),
        <span class="tok-kw">else</span> =&gt; {},
    }
}

<span class="tok-kw">const</span> rescanMac = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Bundle/macos.zig&quot;</span>).rescanMac;
<span class="tok-kw">const</span> RescanMacError = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Bundle/macos.zig&quot;</span>).RescanMacError;

<span class="tok-kw">const</span> RescanLinuxError = <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFilePathError">AddCertsFromFilePathError</a> || <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromDirPathError">AddCertsFromDirPathError</a>;

<span class="tok-kw">fn</span> <span class="tok-fn">rescanLinux</span>(cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.RescanLinuxError">RescanLinuxError</a>!<span class="tok-type">void</span> {<span class="tok-comment">
    // Possible certificate files; stop after finding one.
    </span><span class="tok-kw">const</span> cert_file_paths = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{
        <span class="tok-str">&quot;/etc/ssl/certs/ca-certificates.crt&quot;</span>,<span class="tok-comment"> // Debian/Ubuntu/Gentoo etc.
        </span><span class="tok-str">&quot;/etc/pki/tls/certs/ca-bundle.crt&quot;</span>,<span class="tok-comment"> // Fedora/RHEL 6
        </span><span class="tok-str">&quot;/etc/ssl/ca-bundle.pem&quot;</span>,<span class="tok-comment"> // OpenSUSE
        </span><span class="tok-str">&quot;/etc/pki/tls/cacert.pem&quot;</span>,<span class="tok-comment"> // OpenELEC
        </span><span class="tok-str">&quot;/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem&quot;</span>,<span class="tok-comment"> // CentOS/RHEL 7
        </span><span class="tok-str">&quot;/etc/ssl/cert.pem&quot;</span>,<span class="tok-comment"> // Alpine Linux
    </span>};<span class="tok-comment">

    // Possible directories with certificate files; all will be read.
    </span><span class="tok-kw">const</span> cert_dir_paths = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{
        <span class="tok-str">&quot;/etc/ssl/certs&quot;</span>,<span class="tok-comment"> // SLES10/SLES11
        </span><span class="tok-str">&quot;/etc/pki/tls/certs&quot;</span>,<span class="tok-comment"> // Fedora/RHEL
        </span><span class="tok-str">&quot;/system/etc/security/cacerts&quot;</span>,<span class="tok-comment"> // Android
    </span>};

    cb.bytes.clearRetainingCapacity();
    cb.map.clearRetainingCapacity();

    scan: {
        <span class="tok-kw">for</span> (cert_file_paths) |cert_file_path| {
            <span class="tok-kw">if</span> (<a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.addCertsFromFilePathAbsolute">addCertsFromFilePathAbsolute</a>(cb, gpa, cert_file_path)) |_| {
                <span class="tok-kw">break</span> :scan;
            } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">continue</span>,
                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            }
        }

        <span class="tok-kw">for</span> (cert_dir_paths) |cert_dir_path| {
            <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.addCertsFromDirPathAbsolute">addCertsFromDirPathAbsolute</a>(cb, gpa, cert_dir_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">continue</span>,
                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };
        }
    }

    cb.bytes.shrinkAndFree(gpa, cb.bytes.items.len);
}

<span class="tok-kw">const</span> RescanBSDError = <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFilePathError">AddCertsFromFilePathError</a>;

<span class="tok-kw">fn</span> <span class="tok-fn">rescanBSD</span>(cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, cert_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFilePathError">RescanBSDError</a>!<span class="tok-type">void</span> {
    cb.bytes.clearRetainingCapacity();
    cb.map.clearRetainingCapacity();
    <span class="tok-kw">try</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.addCertsFromFilePathAbsolute">addCertsFromFilePathAbsolute</a>(cb, gpa, cert_file_path);
    cb.bytes.shrinkAndFree(gpa, cb.bytes.items.len);
}

<span class="tok-kw">const</span> RescanWindowsError = <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.ParseCertError">ParseCertError</a> || <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a> || <span class="tok-kw">error</span>{FileNotFound};

<span class="tok-kw">fn</span> <span class="tok-fn">rescanWindows</span>(cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.RescanWindowsError">RescanWindowsError</a>!<span class="tok-type">void</span> {
    cb.bytes.clearRetainingCapacity();
    cb.map.clearRetainingCapacity();

    <span class="tok-kw">const</span> w = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>;
    <span class="tok-kw">const</span> GetLastError = w.GetLastError;
    <span class="tok-kw">const</span> root = [<span class="tok-number">4</span>:<span class="tok-number">0</span>]<span class="tok-type">u16</span>{ <span class="tok-str">'R'</span>, <span class="tok-str">'O'</span>, <span class="tok-str">'O'</span>, <span class="tok-str">'T'</span> };
    <span class="tok-kw">const</span> store = w.crypt32.CertOpenSystemStoreW(<span class="tok-null">null</span>, &amp;root) <span class="tok-kw">orelse</span> <span class="tok-kw">switch</span> (GetLastError()) {
        .FILE_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> w.unexpectedError(err),
    };
    <span class="tok-kw">defer</span> _ = w.crypt32.CertCloseStore(store, <span class="tok-number">0</span>);

    <span class="tok-kw">const</span> now_sec = <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.timestamp">timestamp</a>();

    <span class="tok-kw">var</span> ctx = w.crypt32.CertEnumCertificatesInStore(store, <span class="tok-null">null</span>);
    <span class="tok-kw">while</span> (ctx) |context| : (ctx = w.crypt32.CertEnumCertificatesInStore(store, ctx)) {
        <span class="tok-kw">const</span> decoded_start = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(cb.bytes.items.len));
        <span class="tok-kw">const</span> encoded_cert = context.pbCertEncoded[<span class="tok-number">0</span>..context.cbCertEncoded];
        <span class="tok-kw">try</span> cb.bytes.appendSlice(gpa, encoded_cert);
        <span class="tok-kw">try</span> cb.parseCert(gpa, decoded_start, now_sec);
    }
    cb.bytes.shrinkAndFree(gpa, cb.bytes.items.len);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AddCertsFromDirPathError = <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a> || <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFilePathError">AddCertsFromDirError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCertsFromDirPath</span>(
    cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>,
    sub_dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromDirPathError">AddCertsFromDirPathError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> iterable_dir = <span class="tok-kw">try</span> dir.openDir(sub_dir_path, .{ .iterate = <span class="tok-null">true</span> });
    <span class="tok-kw">defer</span> iterable_dir.close();
    <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.addCertsFromDir">addCertsFromDir</a>(cb, gpa, iterable_dir);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCertsFromDirPathAbsolute</span>(
    cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    abs_dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromDirPathError">AddCertsFromDirPathError</a>!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(abs_dir_path));
    <span class="tok-kw">var</span> iterable_dir = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.openDirAbsolute">openDirAbsolute</a>(abs_dir_path, .{ .iterate = <span class="tok-null">true</span> });
    <span class="tok-kw">defer</span> iterable_dir.close();
    <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.addCertsFromDir">addCertsFromDir</a>(cb, gpa, iterable_dir);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AddCertsFromDirError = <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFilePathError">AddCertsFromFilePathError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCertsFromDir</span>(cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, iterable_dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFilePathError">AddCertsFromDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> it = iterable_dir.iterate();
    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> it.next()) |entry| {
        <span class="tok-kw">switch</span> (entry.kind) {
            .file, .sym_link =&gt; {},
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,
        }

        <span class="tok-kw">try</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.addCertsFromFilePath">addCertsFromFilePath</a>(cb, gpa, iterable_dir, entry.name);
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AddCertsFromFilePathError = <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a> || <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFileError">AddCertsFromFileError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCertsFromFilePathAbsolute</span>(
    cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    abs_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFilePathError">AddCertsFromFilePathError</a>!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(abs_file_path));
    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.openFileAbsolute">openFileAbsolute</a>(abs_file_path, .{});
    <span class="tok-kw">defer</span> file.close();
    <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.addCertsFromFile">addCertsFromFile</a>(cb, gpa, file);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCertsFromFilePath</span>(
    cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>,
    sub_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFilePathError">AddCertsFromFilePathError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> dir.openFile(sub_file_path, .{});
    <span class="tok-kw">defer</span> file.close();
    <span class="tok-kw">return</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.addCertsFromFile">addCertsFromFile</a>(cb, gpa, file);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AddCertsFromFileError = <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> ||
    <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.GetSeekPosError">GetSeekPosError</a> ||
    <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.ReadError">ReadError</a> ||
    <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.ParseCertError">ParseCertError</a> ||
    <a href="std.html">std</a>.<a href="std.base64.html">base64</a>.<a href="std.base64.html#std.base64.Error">Error</a> ||
    <span class="tok-kw">error</span>{ CertificateAuthorityBundleTooBig, MissingEndCertificateMarker };

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCertsFromFile</span>(cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, file: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.AddCertsFromFileError">AddCertsFromFileError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> file.getEndPos();<span class="tok-comment">

    // We borrow `bytes` as a temporary buffer for the base64-encoded data.
    // This is possible by computing the decoded length and reserving the space
    // for the decoded bytes first.
    </span><span class="tok-kw">const</span> decoded_size_upper_bound = size / <span class="tok-number">4</span> * <span class="tok-number">3</span>;
    <span class="tok-kw">const</span> needed_capacity = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u32</span>, decoded_size_upper_bound + size) <span class="tok-kw">orelse</span>
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateAuthorityBundleTooBig;
    <span class="tok-kw">try</span> cb.bytes.ensureUnusedCapacity(gpa, needed_capacity);
    <span class="tok-kw">const</span> end_reserved: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(cb.bytes.items.len + decoded_size_upper_bound);
    <span class="tok-kw">const</span> buffer = cb.bytes.allocatedSlice()[end_reserved..];
    <span class="tok-kw">const</span> end_index = <span class="tok-kw">try</span> file.readAll(buffer);
    <span class="tok-kw">const</span> encoded_bytes = buffer[<span class="tok-number">0</span>..end_index];

    <span class="tok-kw">const</span> begin_marker = <span class="tok-str">&quot;-----BEGIN CERTIFICATE-----&quot;</span>;
    <span class="tok-kw">const</span> end_marker = <span class="tok-str">&quot;-----END CERTIFICATE-----&quot;</span>;

    <span class="tok-kw">const</span> now_sec = <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.timestamp">timestamp</a>();

    <span class="tok-kw">var</span> start_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a>(<span class="tok-type">u8</span>, encoded_bytes, start_index, begin_marker)) |begin_marker_start| {
        <span class="tok-kw">const</span> cert_start = begin_marker_start + begin_marker.len;
        <span class="tok-kw">const</span> cert_end = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a>(<span class="tok-type">u8</span>, encoded_bytes, cert_start, end_marker) <span class="tok-kw">orelse</span>
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingEndCertificateMarker;
        start_index = cert_end + end_marker.len;
        <span class="tok-kw">const</span> encoded_cert = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, encoded_bytes[cert_start..cert_end], <span class="tok-str">&quot; \t\r\n&quot;</span>);
        <span class="tok-kw">const</span> decoded_start: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(cb.bytes.items.len);
        <span class="tok-kw">const</span> dest_buf = cb.bytes.allocatedSlice()[decoded_start..];
        cb.bytes.items.len += <span class="tok-kw">try</span> <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.base64">base64</a>.<a href="#">decode</a>(dest_buf, encoded_cert);
        <span class="tok-kw">try</span> cb.parseCert(gpa, decoded_start, now_sec);
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ParseCertError = <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.html#std.crypto.Certificate.ParseError">ParseError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseCert</span>(cb: *<a href="std.crypto.Certificate.Bundle.html">Bundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, decoded_start: <span class="tok-type">u32</span>, now_sec: <span class="tok-type">i64</span>) <a href="std.crypto.Certificate.Bundle.html#std.crypto.Certificate.Bundle.ParseCertError">ParseCertError</a>!<span class="tok-type">void</span> {<span class="tok-comment">
    // Even though we could only partially parse the certificate to find
    // the subject name, we pre-parse all of them to make sure and only
    // include in the bundle ones that we know will parse. This way we can
    // use `catch unreachable` later.
    </span><span class="tok-kw">const</span> parsed_cert = <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.html#std.crypto.Certificate.parse">parse</a>(.{
        .buffer = cb.bytes.items,
        .index = decoded_start,
    }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.CertificateHasUnrecognizedObjectId =&gt; {
            cb.bytes.items.len = decoded_start;
            <span class="tok-kw">return</span>;
        },
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
    <span class="tok-kw">if</span> (now_sec &gt; parsed_cert.validity.not_after) {<span class="tok-comment">
        // Ignore expired cert.
        </span>cb.bytes.items.len = decoded_start;
        <span class="tok-kw">return</span>;
    }
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> cb.map.getOrPutContext(gpa, parsed_cert.subject_slice, .{ .cb = cb });
    <span class="tok-kw">if</span> (gop.found_existing) {
        cb.bytes.items.len = decoded_start;
    } <span class="tok-kw">else</span> {
        gop.value_ptr.* = decoded_start;
    }
}

<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../../std.zig&quot;</span>);
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> fs = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> crypto = <a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>;
<span class="tok-kw">const</span> Allocator = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> Certificate = <a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>.<a href="std.crypto.Certificate.html">Certificate</a>;
<span class="tok-kw">const</span> der = <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.der.html">der</a>;
<span class="tok-kw">const</span> Bundle = <span class="tok-builtin">@This</span>();

<span class="tok-kw">const</span> base64 = <a href="std.html">std</a>.<a href="std.base64.html">base64</a>.<a href="std.base64.html#std.base64.standard">standard</a>.<a href="#">decoderWithIgnore</a>(<span class="tok-str">&quot; \t\r\n&quot;</span>);

<span class="tok-kw">const</span> MapContext = <span class="tok-kw">struct</span> {
    cb: *<span class="tok-kw">const</span> <a href="std.crypto.Certificate.Bundle.html">Bundle</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(ctx: <a href="std.crypto.Certificate.Bundle.MapContext.html">MapContext</a>, k: <a href="std.crypto.Certificate.der.html">der</a>.<a href="std.crypto.Certificate.der.Element.html">Element</a>.<a href="std.crypto.Certificate.der.Element.Slice.html">Slice</a>) <span class="tok-type">u64</span> {
        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.hash_map.html">hash_map</a>.<a href="std.hash_map.html#std.hash_map.hashString">hashString</a>(ctx.cb.bytes.items[k.start..k.end]);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <a href="std.crypto.Certificate.Bundle.MapContext.html">MapContext</a>, a: <a href="std.crypto.Certificate.der.html">der</a>.<a href="std.crypto.Certificate.der.Element.html">Element</a>.<a href="std.crypto.Certificate.der.Element.Slice.html">Slice</a>, b: <a href="std.crypto.Certificate.der.html">der</a>.<a href="std.crypto.Certificate.der.Element.html">Element</a>.<a href="std.crypto.Certificate.der.Element.Slice.html">Slice</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">const</span> bytes = ctx.cb.bytes.items;
        <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(
            <span class="tok-type">u8</span>,
            bytes[a.start..a.end],
            bytes[b.start..b.end],
        );
    }
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;scan for OS-provided certificates&quot;</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .wasi) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> bundle: <a href="std.crypto.Certificate.Bundle.html">Bundle</a> = .{};
    <span class="tok-kw">defer</span> bundle.deinit(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);

    <span class="tok-kw">try</span> bundle.rescan(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
