<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">math</a></li><li><a href="std.math.html" class="">big</a></li><li><a href="std.math.big.int.html" class="">int</a></li><li><a href="std.math.big.int.Managed.html" class="active">Managed</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.math.big.int.Managed" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.math.big.int.Managed</span><a href="#src.zig-std.math.big.int.Managed">[src]</a></h1><div class="tldDocs"><p>An arbitrary-precision big integer along with an allocator which manages the memory.</p>
<p>Memory is allocated as needed to ensure operations never overflow. The range
is bounded only by available memory.</p>
</div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre><div class="fieldDocs"><p>Allocator used by the Managed when requesting memory.</p>
</div></div><div><pre><code>limbs: []<a href="std.math.big.html#std.math.big.Limb">Limb</a></code></pre><div class="fieldDocs"><p>Raw digits. These are:</p>
<ul>
<li>Little-endian ordered</li>
<li>limbs.len &gt;= 1</li>
<li>Zero is represent as Managed.len() == 1 with limbs[0] == 0.</li>
</ul>
<p>Accessing limbs directly should be avoided.</p>
</div></div><div><pre><code>metadata: <span class="tok-type">usize</span></code></pre><div class="fieldDocs"><p>High bit is the sign bit. If set, Managed is negative, else Managed is positive.
The remaining bits represent the number of limbs used by Managed.</p>
</div></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.math.big.int.Managed.sign_bit" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">sign_bit</span><a href="#src.zig-std.math.big.int.Managed.sign_bit">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.sign_bit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> sign_bit: <span class="tok-type">usize</span> = <span class="tok-number">1</span> &lt;&lt; (<span class="tok-builtin">@typeInfo</span>(<span class="tok-type">usize</span>).int.bits - <span class="tok-number">1</span>)</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.default_capacity" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">default_capacity</span><a href="#src.zig-std.math.big.int.Managed.default_capacity">[src]</a></h2><div class="tldDocs"><p>Default number of limbs to allocate on creation of a <code>Managed</code>.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.default_capacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_capacity = <span class="tok-number">4</span></code></pre></details></div></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.math.big.int.Const.ConvertError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ConvertError</span><a href="#src.zig-std.math.big.int.Const.ConvertError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>NegativeIntoUnsigned</dt></div><div><dt>TargetTooSmall</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Const.ConvertError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ConvertError = <span class="tok-kw">error</span>{
    NegativeIntoUnsigned,
    TargetTooSmall,
}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.math.big.int.Managed.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.math.big.int.Managed.init">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div class="tldDocs"><p>Creates a new <code>Managed</code>. <code>default_capacity</code> limbs will be allocated immediately.
The integer value after initializing is <code>0</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.init">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.math.big.int.Managed.html">Managed</a> {
    <span class="tok-kw">return</span> <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.initCapacity">initCapacity</a>(allocator, <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.default_capacity">default_capacity</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.toMutable" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toMutable</span><a href="#src.zig-std.math.big.int.Managed.toMutable">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toMutable</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.toMutable">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toMutable</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <a href="std.math.big.int.Mutable.html">Mutable</a> {
    <span class="tok-kw">return</span> .{
        .limbs = self.limbs,
        .positive = self.isPositive(),
        .len = self.len(),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.toConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toConst</span><a href="#src.zig-std.math.big.int.Managed.toConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toConst</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.toConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toConst</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <a href="std.math.big.int.Const.html">Const</a> {
    <span class="tok-kw">return</span> .{
        .limbs = self.limbs[<span class="tok-number">0</span>..self.len()],
        .positive = self.isPositive(),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.initSet" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initSet</span><a href="#src.zig-std.math.big.int.Managed.initSet">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initSet</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, value: <span class="tok-kw">anytype</span>) !<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div class="tldDocs"><p>Creates a new <code>Managed</code> with value <code>value</code>.</p>
<p>This is identical to an <code>init</code>, followed by a <code>set</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.initSet">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initSet</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, value: <span class="tok-kw">anytype</span>) !<a href="std.math.big.int.Managed.html">Managed</a> {
    <span class="tok-kw">var</span> s = <span class="tok-kw">try</span> <a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.init">init</a>(allocator);
    <span class="tok-kw">errdefer</span> s.deinit();
    <span class="tok-kw">try</span> s.set(value);
    <span class="tok-kw">return</span> s;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.initCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initCapacity</span><a href="#src.zig-std.math.big.int.Managed.initCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initCapacity</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, capacity: <span class="tok-type">usize</span>) !<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div class="tldDocs"><p>Creates a new Managed with a specific capacity. If capacity &lt; default_capacity then the
default capacity will be used instead.
The integer value after initializing is <code>0</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.initCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initCapacity</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, capacity: <span class="tok-type">usize</span>) !<a href="std.math.big.int.Managed.html">Managed</a> {
    <span class="tok-kw">return</span> <a href="std.math.big.int.Managed.html">Managed</a>{
        .allocator = allocator,
        .metadata = <span class="tok-number">1</span>,
        .limbs = block: {
            <span class="tok-kw">const</span> limbs = <span class="tok-kw">try</span> allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@max</span>(<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.default_capacity">default_capacity</a>, capacity));
            limbs[<span class="tok-number">0</span>] = <span class="tok-number">0</span>;
            <span class="tok-kw">break</span> :block limbs;
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.len" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">len</span><a href="#src.zig-std.math.big.int.Managed.len">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">len</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of limbs currently in use.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.len">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">len</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.metadata &amp; ~<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.isPositive" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isPositive</span><a href="#src.zig-std.math.big.int.Managed.isPositive">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isPositive</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns whether an Managed is positive.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.isPositive">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isPositive</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.metadata &amp; <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a> == <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.setSign" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setSign</span><a href="#src.zig-std.math.big.int.Managed.setSign">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setSign</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, positive: <span class="tok-type">bool</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sets the sign of an Managed.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>positive: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.setSign">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setSign</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, positive: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (positive) {
        self.metadata &amp;= ~<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
    } <span class="tok-kw">else</span> {
        self.metadata |= <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.setLen" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setLen</span><a href="#src.zig-std.math.big.int.Managed.setLen">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setLen</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sets the length of an Managed.</p>
<p>If setLen is used, then the Managed must be normalized to suit.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.setLen">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setLen</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    self.metadata &amp;= <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
    self.metadata |= new_len;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.setMetadata" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setMetadata</span><a href="#src.zig-std.math.big.int.Managed.setMetadata">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setMetadata</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, positive: <span class="tok-type">bool</span>, length: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>positive: <span class="tok-type">bool</span></code></pre></div><div><pre><code>length: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.setMetadata">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setMetadata</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, positive: <span class="tok-type">bool</span>, length: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    self.metadata = <span class="tok-kw">if</span> (positive) length &amp; ~<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a> <span class="tok-kw">else</span> length | <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.ensureCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureCapacity</span><a href="#src.zig-std.math.big.int.Managed.ensureCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureCapacity</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Ensures an Managed has enough space allocated for capacity limbs. If the Managed does not have
sufficient capacity, the exact amount will be allocated. This occurs even if the requested
capacity is only greater than the current capacity by one limb.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.ensureCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureCapacity</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (capacity &lt;= self.limbs.len) {
        <span class="tok-kw">return</span>;
    }
    self.limbs = <span class="tok-kw">try</span> self.allocator.realloc(self.limbs, capacity);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.math.big.int.Managed.deinit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Frees all associated memory.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.deinit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">void</span> {
    self.allocator.free(self.limbs);
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.math.big.int.Managed.clone">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(other: <a href="std.math.big.int.Managed.html">Managed</a>) !<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div class="tldDocs"><p>Returns a <code>Managed</code> with the same value. The returned <code>Managed</code> is a deep copy and
can be modified separately from the original, and its resources are managed
separately from the original.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>other: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.clone">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(other: <a href="std.math.big.int.Managed.html">Managed</a>) !<a href="std.math.big.int.Managed.html">Managed</a> {
    <span class="tok-kw">return</span> other.cloneWithDifferentAllocator(other.allocator);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.cloneWithDifferentAllocator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithDifferentAllocator</span><a href="#src.zig-std.math.big.int.Managed.cloneWithDifferentAllocator">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithDifferentAllocator</span>(other: <a href="std.math.big.int.Managed.html">Managed</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>other: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.cloneWithDifferentAllocator">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithDifferentAllocator</span>(other: <a href="std.math.big.int.Managed.html">Managed</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.math.big.int.Managed.html">Managed</a> {
    <span class="tok-kw">return</span> <a href="std.math.big.int.Managed.html">Managed</a>{
        .allocator = allocator,
        .metadata = other.metadata,
        .limbs = block: {
            <span class="tok-kw">const</span> limbs = <span class="tok-kw">try</span> allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, other.len());
            <span class="tok-builtin">@memcpy</span>(limbs, other.limbs[<span class="tok-number">0</span>..other.len()]);
            <span class="tok-kw">break</span> :block limbs;
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.copy" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">copy</span><a href="#src.zig-std.math.big.int.Managed.copy">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copy</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, other: <a href="std.math.big.int.Const.html">Const</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Copies the value of the integer to an existing <code>Managed</code> so that they both have the same value.
Extra memory will be allocated if the receiver does not have enough capacity.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>other: <a href="std.math.big.int.Const.html">Const</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.copy">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copy</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, other: <a href="std.math.big.int.Const.html">Const</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (self.limbs.ptr == other.limbs.ptr) <span class="tok-kw">return</span>;

    <span class="tok-kw">try</span> self.ensureCapacity(other.limbs.len);
    <span class="tok-builtin">@memcpy</span>(self.limbs[<span class="tok-number">0</span>..other.limbs.len], other.limbs[<span class="tok-number">0</span>..other.limbs.len]);
    self.setMetadata(other.positive, other.limbs.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.swap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swap</span><a href="#src.zig-std.math.big.int.Managed.swap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, other: *<a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Efficiently swap a <code>Managed</code> with another. This swaps the limb pointers and a full copy is not
performed. The address of the limbs field will not be the same after this function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>other: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.swap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, other: *<a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">void</span> {
    <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(<a href="std.math.big.int.Managed.html">Managed</a>, self, other);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.dump" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dump</span><a href="#src.zig-std.math.big.int.Managed.dump">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Debugging tool: prints the state to stderr.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.dump">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">for</span> (self.limbs[<span class="tok-number">0</span>..self.len()]) |limb| {
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;{x} &quot;</span>, .{limb});
    }
    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;capacity={} positive={}\n&quot;</span>, .{ self.limbs.len, self.isPositive() });
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.negate" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">negate</span><a href="#src.zig-std.math.big.int.Managed.negate">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">negate</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Negate the sign.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.negate">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">negate</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">void</span> {
    self.metadata ^= <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.abs" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">abs</span><a href="#src.zig-std.math.big.int.Managed.abs">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">abs</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Make positive.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.abs">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">abs</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">void</span> {
    self.metadata &amp;= ~<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.isOdd" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isOdd</span><a href="#src.zig-std.math.big.int.Managed.isOdd">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isOdd</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.isOdd">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isOdd</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.limbs[<span class="tok-number">0</span>] &amp; <span class="tok-number">1</span> != <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.isEven" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isEven</span><a href="#src.zig-std.math.big.int.Managed.isEven">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isEven</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.isEven">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isEven</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> !self.isOdd();
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.bitCountAbs" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bitCountAbs</span><a href="#src.zig-std.math.big.int.Managed.bitCountAbs">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitCountAbs</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of bits required to represent the absolute value of an integer.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.bitCountAbs">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitCountAbs</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.toConst().bitCountAbs();
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.bitCountTwosComp" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bitCountTwosComp</span><a href="#src.zig-std.math.big.int.Managed.bitCountTwosComp">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitCountTwosComp</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of bits required to represent the integer in twos-complement form.</p>
<p>If the integer is negative the value returned is the number of bits needed by a signed
integer to represent the value. If positive the value is the number of bits for an
unsigned integer. Any unsigned integer will fit in the signed integer with bitcount
one greater than the returned value.</p>
<p>e.g. -127 returns 8 as it will fit in an i8. 127 returns 7 since it fits in a u7.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.bitCountTwosComp">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitCountTwosComp</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.toConst().bitCountTwosComp();
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.fitsInTwosComp" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fitsInTwosComp</span><a href="#src.zig-std.math.big.int.Managed.fitsInTwosComp">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fitsInTwosComp</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.fitsInTwosComp">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fitsInTwosComp</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.toConst().fitsInTwosComp(signedness, bit_count);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.fits" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fits</span><a href="#src.zig-std.math.big.int.Managed.fits">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fits</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns whether self can fit into an integer of the requested type.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.fits">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fits</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.toConst().fits(T);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.sizeInBaseUpperBound" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sizeInBaseUpperBound</span><a href="#src.zig-std.math.big.int.Managed.sizeInBaseUpperBound">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sizeInBaseUpperBound</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, base: <span class="tok-type">usize</span>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the approximate size of the integer in the given base. Negative values accommodate for
the minus sign. This is used for determining the number of characters needed to print the
value. It is inexact and may exceed the given value by ~1-2 bytes.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>base: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.sizeInBaseUpperBound">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sizeInBaseUpperBound</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, base: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.toConst().sizeInBaseUpperBound(base);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.set" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">set</span><a href="#src.zig-std.math.big.int.Managed.set">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, value: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sets an Managed to value. Value must be an primitive integer type.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.set">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, value: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcLimbLen">calcLimbLen</a>(value));
    <span class="tok-kw">var</span> m = self.toMutable();
    m.set(value);
    self.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.toInt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toInt</span><a href="#src.zig-std.math.big.int.Managed.toInt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toInt</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <a href="std.math.big.int.Const.html#std.math.big.int.Const.ConvertError">ConvertError</a>!T</code></pre></div><div class="tldDocs"><p>Convert self to integer type T.</p>
<p>Returns an error if self cannot be narrowed into the requested type without truncation.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.toInt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toInt</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <a href="std.math.big.int.Const.html#std.math.big.int.Const.ConvertError">ConvertError</a>!T {
    <span class="tok-kw">return</span> self.toConst().toInt(T);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.toInt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toInt</span><a href="#src.zig-std.math.big.int.Managed.toInt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toInt</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <a href="std.math.big.int.Const.html#std.math.big.int.Const.ConvertError">ConvertError</a>!T</code></pre></div><div class="tldDocs"><p>Convert self to integer type T.</p>
<p>Returns an error if self cannot be narrowed into the requested type without truncation.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.toInt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toInt</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <a href="std.math.big.int.Const.html#std.math.big.int.Const.ConvertError">ConvertError</a>!T {
    <span class="tok-kw">return</span> self.toConst().toInt(T);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.toFloat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toFloat</span><a href="#src.zig-std.math.big.int.Managed.toFloat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toFloat</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T</code></pre></div><div class="tldDocs"><p>Convert self to float type T.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.toFloat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toFloat</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T {
    <span class="tok-kw">return</span> self.toConst().toFloat(T);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.setString" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setString</span><a href="#src.zig-std.math.big.int.Managed.setString">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setString</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, base: <span class="tok-type">u8</span>, value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Set self from the string representation <code>value</code>.</p>
<p><code>value</code> must contain only digits &lt;= <code>base</code> and is case insensitive.  Base prefixes are
not allowed (e.g. 0x43 should simply be 43).  Underscores in the input string are
ignored and can be used as digit separators.</p>
<p>Returns an error if memory could not be allocated or <code>value</code> has invalid digits for the
requested base.</p>
<p>self's allocator is used for temporary storage to boost multiplication performance.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>base: <span class="tok-type">u8</span></code></pre></div><div><pre><code>value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.setString">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setString</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, base: <span class="tok-type">u8</span>, value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (base &lt; <span class="tok-number">2</span> <span class="tok-kw">or</span> base &gt; <span class="tok-number">36</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidBase;
    <span class="tok-kw">try</span> self.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcSetStringLimbCount">calcSetStringLimbCount</a>(base, value.len));
    <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> self.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <a href="std.math.big.int.html#std.math.big.int.calcSetStringLimbsBufferLen">calcSetStringLimbsBufferLen</a>(base, value.len));
    <span class="tok-kw">defer</span> self.allocator.free(limbs_buffer);
    <span class="tok-kw">var</span> m = self.toMutable();
    <span class="tok-kw">try</span> m.setString(base, value, limbs_buffer, self.allocator);
    self.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.setTwosCompIntLimit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setTwosCompIntLimit</span><a href="#src.zig-std.math.big.int.Managed.setTwosCompIntLimit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setTwosCompIntLimit</span>( r: *<a href="std.math.big.int.Managed.html">Managed</a>, limit: <a href="std.math.big.int.TwosCompIntLimit.html">TwosCompIntLimit</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>, ) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Set self to either bound of a 2s-complement integer.
Note: The result is still sign-magnitude, not twos complement! In order to convert the
result to twos complement, it is sufficient to take the absolute value.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>limit: <a href="std.math.big.int.TwosCompIntLimit.html">TwosCompIntLimit</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.setTwosCompIntLimit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setTwosCompIntLimit</span>(
    r: *<a href="std.math.big.int.Managed.html">Managed</a>,
    limit: <a href="std.math.big.int.TwosCompIntLimit.html">TwosCompIntLimit</a>,
    signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
    bit_count: <span class="tok-type">usize</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> r.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count));
    <span class="tok-kw">var</span> m = r.toMutable();
    m.setTwosCompIntLimit(limit, signedness, bit_count);
    r.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.toString" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toString</span><a href="#src.zig-std.math.big.int.Managed.toString">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toString</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, base: <span class="tok-type">u8</span>, case: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.Case.html">Case</a>) ![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Converts self to a string in the requested base. Memory is allocated from the provided
allocator and not the one present in self.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>base: <span class="tok-type">u8</span></code></pre></div><div><pre><code>case: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.Case.html">Case</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.toString">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toString</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, base: <span class="tok-type">u8</span>, case: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.Case.html">Case</a>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (base &lt; <span class="tok-number">2</span> <span class="tok-kw">or</span> base &gt; <span class="tok-number">36</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidBase;
    <span class="tok-kw">return</span> self.toConst().toStringAlloc(allocator, base, case);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.format" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">format</span><a href="#src.zig-std.math.big.int.Managed.format">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>( self: <a href="std.math.big.int.Managed.html">Managed</a>, <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>, out_stream: <span class="tok-kw">anytype</span>, ) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>To allow <code>std.fmt.format</code> to work with <code>Managed</code>.
If the absolute value of integer is greater than or equal to <code>pow(2, 64 * @sizeOf(usize) * 8)</code>,
this function will fail to print the string, printing &quot;(BigInt)&quot; instead of a number.
This is because the rendering algorithm requires reversing a string, which requires O(N) memory.
See <code>toString</code> and <code>toStringAlloc</code> for a way to print big integers without failure.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.format">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
    self: <a href="std.math.big.int.Managed.html">Managed</a>,
    <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
    out_stream: <span class="tok-kw">anytype</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.toConst().format(fmt, options, out_stream);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.orderAbs" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderAbs</span><a href="#src.zig-std.math.big.int.Managed.orderAbs">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderAbs</span>(a: <a href="std.math.big.int.Managed.html">Managed</a>, b: <a href="std.math.big.int.Managed.html">Managed</a>) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a></code></pre></div><div class="tldDocs"><p>Returns math.Order.lt, math.Order.eq, math.Order.gt if |a| &lt; |b|, |a| ==
|b| or |a| &gt; |b| respectively.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.orderAbs">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderAbs</span>(a: <a href="std.math.big.int.Managed.html">Managed</a>, b: <a href="std.math.big.int.Managed.html">Managed</a>) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
    <span class="tok-kw">return</span> a.toConst().orderAbs(b.toConst());
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.order" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">order</span><a href="#src.zig-std.math.big.int.Managed.order">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">order</span>(a: <a href="std.math.big.int.Managed.html">Managed</a>, b: <a href="std.math.big.int.Managed.html">Managed</a>) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a></code></pre></div><div class="tldDocs"><p>Returns math.Order.lt, math.Order.eq, math.Order.gt if a &lt; b, a == b or a &gt; b
respectively.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.order">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">order</span>(a: <a href="std.math.big.int.Managed.html">Managed</a>, b: <a href="std.math.big.int.Managed.html">Managed</a>) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
    <span class="tok-kw">return</span> a.toConst().order(b.toConst());
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.eqlZero" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">eqlZero</span><a href="#src.zig-std.math.big.int.Managed.eqlZero">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlZero</span>(a: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true if a == 0.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.eqlZero">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlZero</span>(a: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> a.toConst().eqlZero();
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.eqlAbs" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">eqlAbs</span><a href="#src.zig-std.math.big.int.Managed.eqlAbs">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlAbs</span>(a: <a href="std.math.big.int.Managed.html">Managed</a>, b: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true if |a| == |b|.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.eqlAbs">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlAbs</span>(a: <a href="std.math.big.int.Managed.html">Managed</a>, b: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> a.toConst().eqlAbs(b.toConst());
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.eql" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">eql</span><a href="#src.zig-std.math.big.int.Managed.eql">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(a: <a href="std.math.big.int.Managed.html">Managed</a>, b: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true if a == b.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.eql">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(a: <a href="std.math.big.int.Managed.html">Managed</a>, b: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> a.toConst().eql(b.toConst());
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.normalize" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">normalize</span><a href="#src.zig-std.math.big.int.Managed.normalize">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">normalize</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, length: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Normalize a possible sequence of leading zeros.</p>
<p>[1, 2, 3, 4, 0] -&gt; [1, 2, 3, 4]
[1, 2, 0, 0, 0] -&gt; [1, 2]
[0, 0, 0, 0, 0] -&gt; [0]</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>length: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.normalize">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">normalize</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, length: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(length &gt; <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(length &lt;= r.limbs.len);

    <span class="tok-kw">var</span> j = length;
    <span class="tok-kw">while</span> (j &gt; <span class="tok-number">0</span>) : (j -= <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (r.limbs[j - <span class="tok-number">1</span>] != <span class="tok-number">0</span>) {
            <span class="tok-kw">break</span>;
        }
    }<span class="tok-comment">

    // Handle zero
    </span>r.setLen(<span class="tok-kw">if</span> (j != <span class="tok-number">0</span>) j <span class="tok-kw">else</span> <span class="tok-number">1</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.addScalar" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addScalar</span><a href="#src.zig-std.math.big.int.Managed.addScalar">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addScalar</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, scalar: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a + scalar</p>
<p>r and a may be aliases.</p>
<p>Returns an error if memory could not be allocated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.addScalar">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addScalar</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, scalar: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> r.ensureAddScalarCapacity(a.toConst(), scalar);
    <span class="tok-kw">var</span> m = r.toMutable();
    m.addScalar(a.toConst(), scalar);
    r.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.add" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">add</span><a href="#src.zig-std.math.big.int.Managed.add">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a + b</p>
<p>r, a and b may be aliases.</p>
<p>Returns an error if memory could not be allocated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.add">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> r.ensureAddCapacity(a.toConst(), b.toConst());
    <span class="tok-kw">var</span> m = r.toMutable();
    m.add(a.toConst(), b.toConst());
    r.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.addWrap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addWrap</span><a href="#src.zig-std.math.big.int.Managed.addWrap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWrap</span>( r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>r = a + b with 2s-complement wrapping semantics. Returns whether any overflow occurred.</p>
<p>r, a and b may be aliases.</p>
<p>Returns an error if memory could not be allocated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.addWrap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWrap</span>(
    r: *<a href="std.math.big.int.Managed.html">Managed</a>,
    a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
    b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
    signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
    bit_count: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">bool</span> {
    <span class="tok-kw">try</span> r.ensureTwosCompCapacity(bit_count);
    <span class="tok-kw">var</span> m = r.toMutable();
    <span class="tok-kw">const</span> wrapped = m.addWrap(a.toConst(), b.toConst(), signedness, bit_count);
    r.setMetadata(m.positive, m.len);
    <span class="tok-kw">return</span> wrapped;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.addSat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addSat</span><a href="#src.zig-std.math.big.int.Managed.addSat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSat</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a + b with 2s-complement saturating semantics.</p>
<p>r, a and b may be aliases.</p>
<p>Returns an error if memory could not be allocated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.addSat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSat</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> r.ensureTwosCompCapacity(bit_count);
    <span class="tok-kw">var</span> m = r.toMutable();
    m.addSat(a.toConst(), b.toConst(), signedness, bit_count);
    r.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.sub" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sub</span><a href="#src.zig-std.math.big.int.Managed.sub">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a - b</p>
<p>r, a and b may be aliases.</p>
<p>Returns an error if memory could not be allocated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.sub">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> r.ensureCapacity(<span class="tok-builtin">@max</span>(a.len(), b.len()) + <span class="tok-number">1</span>);
    <span class="tok-kw">var</span> m = r.toMutable();
    m.sub(a.toConst(), b.toConst());
    r.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.subWrap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">subWrap</span><a href="#src.zig-std.math.big.int.Managed.subWrap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subWrap</span>( r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>r = a - b with 2s-complement wrapping semantics. Returns whether any overflow occurred.</p>
<p>r, a and b may be aliases.</p>
<p>Returns an error if memory could not be allocated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.subWrap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subWrap</span>(
    r: *<a href="std.math.big.int.Managed.html">Managed</a>,
    a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
    b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
    signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
    bit_count: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">bool</span> {
    <span class="tok-kw">try</span> r.ensureTwosCompCapacity(bit_count);
    <span class="tok-kw">var</span> m = r.toMutable();
    <span class="tok-kw">const</span> wrapped = m.subWrap(a.toConst(), b.toConst(), signedness, bit_count);
    r.setMetadata(m.positive, m.len);
    <span class="tok-kw">return</span> wrapped;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.subSat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">subSat</span><a href="#src.zig-std.math.big.int.Managed.subSat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subSat</span>( r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a - b with 2s-complement saturating semantics.</p>
<p>r, a and b may be aliases.</p>
<p>Returns an error if memory could not be allocated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.subSat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subSat</span>(
    r: *<a href="std.math.big.int.Managed.html">Managed</a>,
    a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
    b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
    signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
    bit_count: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> r.ensureTwosCompCapacity(bit_count);
    <span class="tok-kw">var</span> m = r.toMutable();
    m.subSat(a.toConst(), b.toConst(), signedness, bit_count);
    r.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.mul" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mul</span><a href="#src.zig-std.math.big.int.Managed.mul">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mul</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>rma = a * b</p>
<p>rma, a and b may be aliases. However, it is more efficient if rma does not alias a or b.</p>
<p>Returns an error if memory could not be allocated.</p>
<p>rma's allocator is used for temporary storage to speed up the multiplication.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>rma: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.mul">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mul</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> alias_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (rma.limbs.ptr == a.limbs.ptr)
        alias_count += <span class="tok-number">1</span>;
    <span class="tok-kw">if</span> (rma.limbs.ptr == b.limbs.ptr)
        alias_count += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> rma.ensureMulCapacity(a.toConst(), b.toConst());
    <span class="tok-kw">var</span> m = rma.toMutable();
    <span class="tok-kw">if</span> (alias_count == <span class="tok-number">0</span>) {
        m.mulNoAlias(a.toConst(), b.toConst(), rma.allocator);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> limb_count = <a href="std.math.big.int.html#std.math.big.int.calcMulLimbsBufferLen">calcMulLimbsBufferLen</a>(a.len(), b.len(), alias_count);
        <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> rma.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, limb_count);
        <span class="tok-kw">defer</span> rma.allocator.free(limbs_buffer);
        m.mul(a.toConst(), b.toConst(), limbs_buffer, rma.allocator);
    }
    rma.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.mulWrap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mulWrap</span><a href="#src.zig-std.math.big.int.Managed.mulWrap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulWrap</span>( rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>, ) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>rma = a * b with 2s-complement wrapping semantics.</p>
<p>rma, a and b may be aliases. However, it is more efficient if rma does not alias a or b.</p>
<p>Returns an error if memory could not be allocated.</p>
<p>rma's allocator is used for temporary storage to speed up the multiplication.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>rma: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.mulWrap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulWrap</span>(
    rma: *<a href="std.math.big.int.Managed.html">Managed</a>,
    a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
    b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
    signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
    bit_count: <span class="tok-type">usize</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> alias_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (rma.limbs.ptr == a.limbs.ptr)
        alias_count += <span class="tok-number">1</span>;
    <span class="tok-kw">if</span> (rma.limbs.ptr == b.limbs.ptr)
        alias_count += <span class="tok-number">1</span>;

    <span class="tok-kw">try</span> rma.ensureTwosCompCapacity(bit_count);
    <span class="tok-kw">var</span> m = rma.toMutable();
    <span class="tok-kw">if</span> (alias_count == <span class="tok-number">0</span>) {
        m.mulWrapNoAlias(a.toConst(), b.toConst(), signedness, bit_count, rma.allocator);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> limb_count = <a href="std.math.big.int.html#std.math.big.int.calcMulWrapLimbsBufferLen">calcMulWrapLimbsBufferLen</a>(bit_count, a.len(), b.len(), alias_count);
        <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> rma.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, limb_count);
        <span class="tok-kw">defer</span> rma.allocator.free(limbs_buffer);
        m.mulWrap(a.toConst(), b.toConst(), signedness, bit_count, limbs_buffer, rma.allocator);
    }
    rma.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.ensureTwosCompCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTwosCompCapacity</span><a href="#src.zig-std.math.big.int.Managed.ensureTwosCompCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTwosCompCapacity</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.ensureTwosCompCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTwosCompCapacity</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> r.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count));
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.ensureAddScalarCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureAddScalarCapacity</span><a href="#src.zig-std.math.big.int.Managed.ensureAddScalarCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureAddScalarCapacity</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: <a href="std.math.big.int.Const.html">Const</a>, scalar: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.ensureAddScalarCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureAddScalarCapacity</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: <a href="std.math.big.int.Const.html">Const</a>, scalar: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> r.ensureCapacity(<span class="tok-builtin">@max</span>(a.limbs.len, <a href="std.math.big.int.html#std.math.big.int.calcLimbLen">calcLimbLen</a>(scalar)) + <span class="tok-number">1</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.ensureAddCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureAddCapacity</span><a href="#src.zig-std.math.big.int.Managed.ensureAddCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureAddCapacity</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Const.html">Const</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.ensureAddCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureAddCapacity</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> r.ensureCapacity(<span class="tok-builtin">@max</span>(a.limbs.len, b.limbs.len) + <span class="tok-number">1</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.ensureMulCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureMulCapacity</span><a href="#src.zig-std.math.big.int.Managed.ensureMulCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureMulCapacity</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>rma: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Const.html">Const</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.ensureMulCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureMulCapacity</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> rma.ensureCapacity(a.limbs.len + b.limbs.len + <span class="tok-number">1</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.divFloor" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">divFloor</span><a href="#src.zig-std.math.big.int.Managed.divFloor">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">divFloor</span>(q: *<a href="std.math.big.int.Managed.html">Managed</a>, r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>q = a / b (rem r)</p>
<p>a / b are floored (rounded towards 0).</p>
<p>Returns an error if memory could not be allocated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>q: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.divFloor">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">divFloor</span>(q: *<a href="std.math.big.int.Managed.html">Managed</a>, r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> q.ensureCapacity(a.len());
    <span class="tok-kw">try</span> r.ensureCapacity(b.len());
    <span class="tok-kw">var</span> mq = q.toMutable();
    <span class="tok-kw">var</span> mr = r.toMutable();
    <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> q.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <a href="std.math.big.int.html#std.math.big.int.calcDivLimbsBufferLen">calcDivLimbsBufferLen</a>(a.len(), b.len()));
    <span class="tok-kw">defer</span> q.allocator.free(limbs_buffer);
    mq.divFloor(&amp;mr, a.toConst(), b.toConst(), limbs_buffer);
    q.setMetadata(mq.positive, mq.len);
    r.setMetadata(mr.positive, mr.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.divTrunc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">divTrunc</span><a href="#src.zig-std.math.big.int.Managed.divTrunc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">divTrunc</span>(q: *<a href="std.math.big.int.Managed.html">Managed</a>, r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>q = a / b (rem r)</p>
<p>a / b are truncated (rounded towards -inf).</p>
<p>Returns an error if memory could not be allocated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>q: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.divTrunc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">divTrunc</span>(q: *<a href="std.math.big.int.Managed.html">Managed</a>, r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> q.ensureCapacity(a.len());
    <span class="tok-kw">try</span> r.ensureCapacity(b.len());
    <span class="tok-kw">var</span> mq = q.toMutable();
    <span class="tok-kw">var</span> mr = r.toMutable();
    <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> q.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <a href="std.math.big.int.html#std.math.big.int.calcDivLimbsBufferLen">calcDivLimbsBufferLen</a>(a.len(), b.len()));
    <span class="tok-kw">defer</span> q.allocator.free(limbs_buffer);
    mq.divTrunc(&amp;mr, a.toConst(), b.toConst(), limbs_buffer);
    q.setMetadata(mq.positive, mq.len);
    r.setMetadata(mr.positive, mr.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.shiftLeft" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shiftLeft</span><a href="#src.zig-std.math.big.int.Managed.shiftLeft">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftLeft</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, shift: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a &lt;&lt; shift, in other words, r = a * 2^shift
r and a may alias.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>shift: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.shiftLeft">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftLeft</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, shift: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> r.ensureCapacity(a.len() + (shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) + <span class="tok-number">1</span>);
    <span class="tok-kw">var</span> m = r.toMutable();
    m.shiftLeft(a.toConst(), shift);
    r.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.shiftLeftSat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shiftLeftSat</span><a href="#src.zig-std.math.big.int.Managed.shiftLeftSat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftLeftSat</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, shift: <span class="tok-type">usize</span>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a &lt;&lt;| shift with 2s-complement saturating semantics.
r and a may alias.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>shift: <span class="tok-type">usize</span></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.shiftLeftSat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftLeftSat</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, shift: <span class="tok-type">usize</span>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> r.ensureTwosCompCapacity(bit_count);
    <span class="tok-kw">var</span> m = r.toMutable();
    m.shiftLeftSat(a.toConst(), shift, signedness, bit_count);
    r.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.shiftRight" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shiftRight</span><a href="#src.zig-std.math.big.int.Managed.shiftRight">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftRight</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, shift: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a &gt;&gt; shift
r and a may alias.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>shift: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.shiftRight">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftRight</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, shift: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (a.len() &lt;= shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) {<span class="tok-comment">
        // Shifting negative numbers converges to -1 instead of 0
        </span><span class="tok-kw">if</span> (a.isPositive()) {
            r.metadata = <span class="tok-number">1</span>;
            r.limbs[<span class="tok-number">0</span>] = <span class="tok-number">0</span>;
        } <span class="tok-kw">else</span> {
            r.metadata = <span class="tok-number">1</span>;
            r.setSign(<span class="tok-null">false</span>);
            r.limbs[<span class="tok-number">0</span>] = <span class="tok-number">1</span>;
        }
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">try</span> r.ensureCapacity(a.len() - (shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>));
    <span class="tok-kw">var</span> m = r.toMutable();
    m.shiftRight(a.toConst(), shift);
    r.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.bitNotWrap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bitNotWrap</span><a href="#src.zig-std.math.big.int.Managed.bitNotWrap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitNotWrap</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = ~a under 2s-complement wrapping semantics.
r and a may alias.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.bitNotWrap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitNotWrap</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> r.ensureTwosCompCapacity(bit_count);
    <span class="tok-kw">var</span> m = r.toMutable();
    m.bitNotWrap(a.toConst(), signedness, bit_count);
    r.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.bitOr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bitOr</span><a href="#src.zig-std.math.big.int.Managed.bitOr">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitOr</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a | b</p>
<p>a and b are zero-extended to the longer of a or b.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.bitOr">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitOr</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> r.ensureCapacity(<span class="tok-builtin">@max</span>(a.len(), b.len()));
    <span class="tok-kw">var</span> m = r.toMutable();
    m.bitOr(a.toConst(), b.toConst());
    r.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.bitAnd" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bitAnd</span><a href="#src.zig-std.math.big.int.Managed.bitAnd">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitAnd</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a &amp; b</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.bitAnd">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitAnd</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> cap = <span class="tok-kw">if</span> (a.len() &gt;= b.len())
        <span class="tok-kw">if</span> (b.isPositive()) b.len() <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.isPositive()) a.len() <span class="tok-kw">else</span> a.len() + <span class="tok-number">1</span>
    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.isPositive()) a.len() <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.isPositive()) b.len() <span class="tok-kw">else</span> b.len() + <span class="tok-number">1</span>;

    <span class="tok-kw">try</span> r.ensureCapacity(cap);
    <span class="tok-kw">var</span> m = r.toMutable();
    m.bitAnd(a.toConst(), b.toConst());
    r.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.bitXor" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bitXor</span><a href="#src.zig-std.math.big.int.Managed.bitXor">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitXor</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a ^ b</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.bitXor">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitXor</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> cap = <span class="tok-builtin">@max</span>(a.len(), b.len()) + <span class="tok-builtin">@intFromBool</span>(a.isPositive() != b.isPositive());
    <span class="tok-kw">try</span> r.ensureCapacity(cap);

    <span class="tok-kw">var</span> m = r.toMutable();
    m.bitXor(a.toConst(), b.toConst());
    r.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.gcd" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">gcd</span><a href="#src.zig-std.math.big.int.Managed.gcd">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gcd</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, x: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, y: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>rma may alias x or y.
x and y may alias each other.</p>
<p>rma's allocator is used for temporary storage to boost multiplication performance.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>rma: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>x: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>y: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.gcd">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gcd</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, x: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, y: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> rma.ensureCapacity(<span class="tok-builtin">@min</span>(x.len(), y.len()));
    <span class="tok-kw">var</span> m = rma.toMutable();
    <span class="tok-kw">var</span> limbs_buffer = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>).init(rma.allocator);
    <span class="tok-kw">defer</span> limbs_buffer.deinit();
    <span class="tok-kw">try</span> m.gcd(x.toConst(), y.toConst(), &amp;limbs_buffer);
    rma.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.sqr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sqr</span><a href="#src.zig-std.math.big.int.Managed.sqr">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sqr</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a * a</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>rma: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.sqr">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sqr</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> needed_limbs = <span class="tok-number">2</span> * a.len() + <span class="tok-number">1</span>;

    <span class="tok-kw">if</span> (rma.limbs.ptr == a.limbs.ptr) {
        <span class="tok-kw">var</span> m = <span class="tok-kw">try</span> <a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.initCapacity">initCapacity</a>(rma.allocator, needed_limbs);
        <span class="tok-kw">errdefer</span> m.deinit();
        <span class="tok-kw">var</span> m_mut = m.toMutable();
        m_mut.sqrNoAlias(a.toConst(), rma.allocator);
        m.setMetadata(m_mut.positive, m_mut.len);

        rma.deinit();
        rma.swap(&amp;m);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> rma.ensureCapacity(needed_limbs);
        <span class="tok-kw">var</span> rma_mut = rma.toMutable();
        rma_mut.sqrNoAlias(a.toConst(), rma.allocator);
        rma.setMetadata(rma_mut.positive, rma_mut.len);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.pow" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pow</span><a href="#src.zig-std.math.big.int.Managed.pow">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pow</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: <span class="tok-type">u32</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>rma: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>b: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.pow">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pow</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: <span class="tok-type">u32</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> needed_limbs = <a href="std.math.big.int.html#std.math.big.int.calcPowLimbsBufferLen">calcPowLimbsBufferLen</a>(a.bitCountAbs(), b);

    <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> rma.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, needed_limbs);
    <span class="tok-kw">defer</span> rma.allocator.free(limbs_buffer);

    <span class="tok-kw">if</span> (rma.limbs.ptr == a.limbs.ptr) {
        <span class="tok-kw">var</span> m = <span class="tok-kw">try</span> <a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.initCapacity">initCapacity</a>(rma.allocator, needed_limbs);
        <span class="tok-kw">errdefer</span> m.deinit();
        <span class="tok-kw">var</span> m_mut = m.toMutable();
        m_mut.pow(a.toConst(), b, limbs_buffer);
        m.setMetadata(m_mut.positive, m_mut.len);

        rma.deinit();
        rma.swap(&amp;m);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> rma.ensureCapacity(needed_limbs);
        <span class="tok-kw">var</span> rma_mut = rma.toMutable();
        rma_mut.pow(a.toConst(), b, limbs_buffer);
        rma.setMetadata(rma_mut.positive, rma_mut.len);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.sqrt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sqrt</span><a href="#src.zig-std.math.big.int.Managed.sqrt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sqrt</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = ⌊√a⌋</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>rma: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.sqrt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sqrt</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> bit_count = a.bitCountAbs();

    <span class="tok-kw">if</span> (bit_count == <span class="tok-number">0</span>) {
        <span class="tok-kw">try</span> rma.set(<span class="tok-number">0</span>);
        rma.setMetadata(a.isPositive(), rma.len());
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">if</span> (!a.isPositive()) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SqrtOfNegativeNumber;
    }

    <span class="tok-kw">const</span> needed_limbs = <a href="std.math.big.int.html#std.math.big.int.calcSqrtLimbsBufferLen">calcSqrtLimbsBufferLen</a>(bit_count);
    <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> rma.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, needed_limbs);
    <span class="tok-kw">defer</span> rma.allocator.free(limbs_buffer);

    <span class="tok-kw">try</span> rma.ensureCapacity((a.len() - <span class="tok-number">1</span>) / <span class="tok-number">2</span> + <span class="tok-number">1</span>);
    <span class="tok-kw">var</span> m = rma.toMutable();
    m.sqrt(a.toConst(), limbs_buffer);
    rma.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.truncate" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">truncate</span><a href="#src.zig-std.math.big.int.Managed.truncate">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">truncate</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = truncate(Int(signedness, bit_count), a)</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.truncate">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">truncate</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> r.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count));
    <span class="tok-kw">var</span> m = r.toMutable();
    m.truncate(a.toConst(), signedness, bit_count);
    r.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.saturate" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">saturate</span><a href="#src.zig-std.math.big.int.Managed.saturate">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">saturate</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = saturate(Int(signedness, bit_count), a)</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.saturate">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">saturate</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> r.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count));
    <span class="tok-kw">var</span> m = r.toMutable();
    m.saturate(a.toConst(), signedness, bit_count);
    r.setMetadata(m.positive, m.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Managed.popCount" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">popCount</span><a href="#src.zig-std.math.big.int.Managed.popCount">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popCount</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = @popCount(a) with 2s-complement semantics.
r and a may be aliases.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Managed.popCount">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popCount</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> r.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count));
    <span class="tok-kw">var</span> m = r.toMutable();
    m.popCount(a.toConst(), bit_count);
    r.setMetadata(m.positive, m.len);
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.math.big.int.Managed">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Managed = <span class="tok-kw">struct</span> {
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> sign_bit: <span class="tok-type">usize</span> = <span class="tok-number">1</span> &lt;&lt; (<span class="tok-builtin">@typeInfo</span>(<span class="tok-type">usize</span>).int.bits - <span class="tok-number">1</span>);

    <span class="tok-comment">/// Default number of limbs to allocate on creation of a `Managed`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_capacity = <span class="tok-number">4</span>;

    <span class="tok-comment">/// Allocator used by the Managed when requesting memory.</span>
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,

    <span class="tok-comment">/// Raw digits. These are:</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// * Little-endian ordered</span>
    <span class="tok-comment">/// * limbs.len &gt;= 1</span>
    <span class="tok-comment">/// * Zero is represent as Managed.len() == 1 with limbs[0] == 0.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Accessing limbs directly should be avoided.</span>
    limbs: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>,

    <span class="tok-comment">/// High bit is the sign bit. If set, Managed is negative, else Managed is positive.</span>
    <span class="tok-comment">/// The remaining bits represent the number of limbs used by Managed.</span>
    metadata: <span class="tok-type">usize</span>,

    <span class="tok-comment">/// Creates a new `Managed`. `default_capacity` limbs will be allocated immediately.</span>
    <span class="tok-comment">/// The integer value after initializing is `0`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.math.big.int.Managed.html">Managed</a> {
        <span class="tok-kw">return</span> <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.initCapacity">initCapacity</a>(allocator, <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.default_capacity">default_capacity</a>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toMutable</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <a href="std.math.big.int.Mutable.html">Mutable</a> {
        <span class="tok-kw">return</span> .{
            .limbs = self.limbs,
            .positive = self.isPositive(),
            .len = self.len(),
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toConst</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <a href="std.math.big.int.Const.html">Const</a> {
        <span class="tok-kw">return</span> .{
            .limbs = self.limbs[<span class="tok-number">0</span>..self.len()],
            .positive = self.isPositive(),
        };
    }

    <span class="tok-comment">/// Creates a new `Managed` with value `value`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// This is identical to an `init`, followed by a `set`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initSet</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, value: <span class="tok-kw">anytype</span>) !<a href="std.math.big.int.Managed.html">Managed</a> {
        <span class="tok-kw">var</span> s = <span class="tok-kw">try</span> <a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.init">init</a>(allocator);
        <span class="tok-kw">errdefer</span> s.deinit();
        <span class="tok-kw">try</span> s.set(value);
        <span class="tok-kw">return</span> s;
    }

    <span class="tok-comment">/// Creates a new Managed with a specific capacity. If capacity &lt; default_capacity then the</span>
    <span class="tok-comment">/// default capacity will be used instead.</span>
    <span class="tok-comment">/// The integer value after initializing is `0`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initCapacity</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, capacity: <span class="tok-type">usize</span>) !<a href="std.math.big.int.Managed.html">Managed</a> {
        <span class="tok-kw">return</span> <a href="std.math.big.int.Managed.html">Managed</a>{
            .allocator = allocator,
            .metadata = <span class="tok-number">1</span>,
            .limbs = block: {
                <span class="tok-kw">const</span> limbs = <span class="tok-kw">try</span> allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@max</span>(<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.default_capacity">default_capacity</a>, capacity));
                limbs[<span class="tok-number">0</span>] = <span class="tok-number">0</span>;
                <span class="tok-kw">break</span> :block limbs;
            },
        };
    }

    <span class="tok-comment">/// Returns the number of limbs currently in use.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">len</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> self.metadata &amp; ~<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
    }

    <span class="tok-comment">/// Returns whether an Managed is positive.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isPositive</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self.metadata &amp; <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a> == <span class="tok-number">0</span>;
    }

    <span class="tok-comment">/// Sets the sign of an Managed.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setSign</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, positive: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (positive) {
            self.metadata &amp;= ~<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
        } <span class="tok-kw">else</span> {
            self.metadata |= <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
        }
    }

    <span class="tok-comment">/// Sets the length of an Managed.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If setLen is used, then the Managed must be normalized to suit.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setLen</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        self.metadata &amp;= <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
        self.metadata |= new_len;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setMetadata</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, positive: <span class="tok-type">bool</span>, length: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        self.metadata = <span class="tok-kw">if</span> (positive) length &amp; ~<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a> <span class="tok-kw">else</span> length | <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
    }

    <span class="tok-comment">/// Ensures an Managed has enough space allocated for capacity limbs. If the Managed does not have</span>
    <span class="tok-comment">/// sufficient capacity, the exact amount will be allocated. This occurs even if the requested</span>
    <span class="tok-comment">/// capacity is only greater than the current capacity by one limb.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureCapacity</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (capacity &lt;= self.limbs.len) {
            <span class="tok-kw">return</span>;
        }
        self.limbs = <span class="tok-kw">try</span> self.allocator.realloc(self.limbs, capacity);
    }

    <span class="tok-comment">/// Frees all associated memory.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">void</span> {
        self.allocator.free(self.limbs);
        self.* = <span class="tok-null">undefined</span>;
    }

    <span class="tok-comment">/// Returns a `Managed` with the same value. The returned `Managed` is a deep copy and</span>
    <span class="tok-comment">/// can be modified separately from the original, and its resources are managed</span>
    <span class="tok-comment">/// separately from the original.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(other: <a href="std.math.big.int.Managed.html">Managed</a>) !<a href="std.math.big.int.Managed.html">Managed</a> {
        <span class="tok-kw">return</span> other.cloneWithDifferentAllocator(other.allocator);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithDifferentAllocator</span>(other: <a href="std.math.big.int.Managed.html">Managed</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.math.big.int.Managed.html">Managed</a> {
        <span class="tok-kw">return</span> <a href="std.math.big.int.Managed.html">Managed</a>{
            .allocator = allocator,
            .metadata = other.metadata,
            .limbs = block: {
                <span class="tok-kw">const</span> limbs = <span class="tok-kw">try</span> allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, other.len());
                <span class="tok-builtin">@memcpy</span>(limbs, other.limbs[<span class="tok-number">0</span>..other.len()]);
                <span class="tok-kw">break</span> :block limbs;
            },
        };
    }

    <span class="tok-comment">/// Copies the value of the integer to an existing `Managed` so that they both have the same value.</span>
    <span class="tok-comment">/// Extra memory will be allocated if the receiver does not have enough capacity.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copy</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, other: <a href="std.math.big.int.Const.html">Const</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (self.limbs.ptr == other.limbs.ptr) <span class="tok-kw">return</span>;

        <span class="tok-kw">try</span> self.ensureCapacity(other.limbs.len);
        <span class="tok-builtin">@memcpy</span>(self.limbs[<span class="tok-number">0</span>..other.limbs.len], other.limbs[<span class="tok-number">0</span>..other.limbs.len]);
        self.setMetadata(other.positive, other.limbs.len);
    }

    <span class="tok-comment">/// Efficiently swap a `Managed` with another. This swaps the limb pointers and a full copy is not</span>
    <span class="tok-comment">/// performed. The address of the limbs field will not be the same after this function.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, other: *<a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">void</span> {
        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(<a href="std.math.big.int.Managed.html">Managed</a>, self, other);
    }

    <span class="tok-comment">/// Debugging tool: prints the state to stderr.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">for</span> (self.limbs[<span class="tok-number">0</span>..self.len()]) |limb| {
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;{x} &quot;</span>, .{limb});
        }
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;capacity={} positive={}\n&quot;</span>, .{ self.limbs.len, self.isPositive() });
    }

    <span class="tok-comment">/// Negate the sign.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">negate</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">void</span> {
        self.metadata ^= <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
    }

    <span class="tok-comment">/// Make positive.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">abs</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">void</span> {
        self.metadata &amp;= ~<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isOdd</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self.limbs[<span class="tok-number">0</span>] &amp; <span class="tok-number">1</span> != <span class="tok-number">0</span>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isEven</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> !self.isOdd();
    }

    <span class="tok-comment">/// Returns the number of bits required to represent the absolute value of an integer.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitCountAbs</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> self.toConst().bitCountAbs();
    }

    <span class="tok-comment">/// Returns the number of bits required to represent the integer in twos-complement form.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If the integer is negative the value returned is the number of bits needed by a signed</span>
    <span class="tok-comment">/// integer to represent the value. If positive the value is the number of bits for an</span>
    <span class="tok-comment">/// unsigned integer. Any unsigned integer will fit in the signed integer with bitcount</span>
    <span class="tok-comment">/// one greater than the returned value.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// e.g. -127 returns 8 as it will fit in an i8. 127 returns 7 since it fits in a u7.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitCountTwosComp</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> self.toConst().bitCountTwosComp();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fitsInTwosComp</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self.toConst().fitsInTwosComp(signedness, bit_count);
    }

    <span class="tok-comment">/// Returns whether self can fit into an integer of the requested type.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fits</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self.toConst().fits(T);
    }

    <span class="tok-comment">/// Returns the approximate size of the integer in the given base. Negative values accommodate for</span>
    <span class="tok-comment">/// the minus sign. This is used for determining the number of characters needed to print the</span>
    <span class="tok-comment">/// value. It is inexact and may exceed the given value by ~1-2 bytes.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sizeInBaseUpperBound</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, base: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> self.toConst().sizeInBaseUpperBound(base);
    }

    <span class="tok-comment">/// Sets an Managed to value. Value must be an primitive integer type.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, value: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> self.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcLimbLen">calcLimbLen</a>(value));
        <span class="tok-kw">var</span> m = self.toMutable();
        m.set(value);
        self.setMetadata(m.positive, m.len);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ConvertError = <a href="std.math.big.int.Const.html">Const</a>.<a href="std.math.big.int.Const.html#std.math.big.int.Const.ConvertError">ConvertError</a>;

    <span class="tok-comment">/// Deprecated; use `toInt`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> to = <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.toInt">toInt</a>;

    <span class="tok-comment">/// Convert self to integer type T.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if self cannot be narrowed into the requested type without truncation.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toInt</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <a href="std.math.big.int.Const.html#std.math.big.int.Const.ConvertError">ConvertError</a>!T {
        <span class="tok-kw">return</span> self.toConst().toInt(T);
    }

    <span class="tok-comment">/// Convert self to float type T.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toFloat</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T {
        <span class="tok-kw">return</span> self.toConst().toFloat(T);
    }

    <span class="tok-comment">/// Set self from the string representation `value`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `value` must contain only digits &lt;= `base` and is case insensitive.  Base prefixes are</span>
    <span class="tok-comment">/// not allowed (e.g. 0x43 should simply be 43).  Underscores in the input string are</span>
    <span class="tok-comment">/// ignored and can be used as digit separators.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated or `value` has invalid digits for the</span>
    <span class="tok-comment">/// requested base.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// self's allocator is used for temporary storage to boost multiplication performance.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setString</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, base: <span class="tok-type">u8</span>, value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (base &lt; <span class="tok-number">2</span> <span class="tok-kw">or</span> base &gt; <span class="tok-number">36</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidBase;
        <span class="tok-kw">try</span> self.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcSetStringLimbCount">calcSetStringLimbCount</a>(base, value.len));
        <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> self.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <a href="std.math.big.int.html#std.math.big.int.calcSetStringLimbsBufferLen">calcSetStringLimbsBufferLen</a>(base, value.len));
        <span class="tok-kw">defer</span> self.allocator.free(limbs_buffer);
        <span class="tok-kw">var</span> m = self.toMutable();
        <span class="tok-kw">try</span> m.setString(base, value, limbs_buffer, self.allocator);
        self.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// Set self to either bound of a 2s-complement integer.</span>
    <span class="tok-comment">/// Note: The result is still sign-magnitude, not twos complement! In order to convert the</span>
    <span class="tok-comment">/// result to twos complement, it is sufficient to take the absolute value.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setTwosCompIntLimit</span>(
        r: *<a href="std.math.big.int.Managed.html">Managed</a>,
        limit: <a href="std.math.big.int.TwosCompIntLimit.html">TwosCompIntLimit</a>,
        signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
        bit_count: <span class="tok-type">usize</span>,
    ) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count));
        <span class="tok-kw">var</span> m = r.toMutable();
        m.setTwosCompIntLimit(limit, signedness, bit_count);
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// Converts self to a string in the requested base. Memory is allocated from the provided</span>
    <span class="tok-comment">/// allocator and not the one present in self.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toString</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, base: <span class="tok-type">u8</span>, case: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.Case.html">Case</a>) ![]<span class="tok-type">u8</span> {
        <span class="tok-kw">if</span> (base &lt; <span class="tok-number">2</span> <span class="tok-kw">or</span> base &gt; <span class="tok-number">36</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidBase;
        <span class="tok-kw">return</span> self.toConst().toStringAlloc(allocator, base, case);
    }

    <span class="tok-comment">/// To allow `std.fmt.format` to work with `Managed`.</span>
    <span class="tok-comment">/// If the absolute value of integer is greater than or equal to `pow(2, 64 * @sizeOf(usize) * 8)`,</span>
    <span class="tok-comment">/// this function will fail to print the string, printing &quot;(BigInt)&quot; instead of a number.</span>
    <span class="tok-comment">/// This is because the rendering algorithm requires reversing a string, which requires O(N) memory.</span>
    <span class="tok-comment">/// See `toString` and `toStringAlloc` for a way to print big integers without failure.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        self: <a href="std.math.big.int.Managed.html">Managed</a>,
        <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        out_stream: <span class="tok-kw">anytype</span>,
    ) !<span class="tok-type">void</span> {
        <span class="tok-kw">return</span> self.toConst().format(fmt, options, out_stream);
    }

    <span class="tok-comment">/// Returns math.Order.lt, math.Order.eq, math.Order.gt if |a| &lt; |b|, |a| ==</span>
    <span class="tok-comment">/// |b| or |a| &gt; |b| respectively.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderAbs</span>(a: <a href="std.math.big.int.Managed.html">Managed</a>, b: <a href="std.math.big.int.Managed.html">Managed</a>) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
        <span class="tok-kw">return</span> a.toConst().orderAbs(b.toConst());
    }

    <span class="tok-comment">/// Returns math.Order.lt, math.Order.eq, math.Order.gt if a &lt; b, a == b or a &gt; b</span>
    <span class="tok-comment">/// respectively.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">order</span>(a: <a href="std.math.big.int.Managed.html">Managed</a>, b: <a href="std.math.big.int.Managed.html">Managed</a>) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
        <span class="tok-kw">return</span> a.toConst().order(b.toConst());
    }

    <span class="tok-comment">/// Returns true if a == 0.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlZero</span>(a: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> a.toConst().eqlZero();
    }

    <span class="tok-comment">/// Returns true if |a| == |b|.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlAbs</span>(a: <a href="std.math.big.int.Managed.html">Managed</a>, b: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> a.toConst().eqlAbs(b.toConst());
    }

    <span class="tok-comment">/// Returns true if a == b.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(a: <a href="std.math.big.int.Managed.html">Managed</a>, b: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> a.toConst().eql(b.toConst());
    }

    <span class="tok-comment">/// Normalize a possible sequence of leading zeros.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// [1, 2, 3, 4, 0] -&gt; [1, 2, 3, 4]</span>
    <span class="tok-comment">/// [1, 2, 0, 0, 0] -&gt; [1, 2]</span>
    <span class="tok-comment">/// [0, 0, 0, 0, 0] -&gt; [0]</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">normalize</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, length: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(length &gt; <span class="tok-number">0</span>);
        <a href="std.debug.html#std.debug.assert">assert</a>(length &lt;= r.limbs.len);

        <span class="tok-kw">var</span> j = length;
        <span class="tok-kw">while</span> (j &gt; <span class="tok-number">0</span>) : (j -= <span class="tok-number">1</span>) {
            <span class="tok-kw">if</span> (r.limbs[j - <span class="tok-number">1</span>] != <span class="tok-number">0</span>) {
                <span class="tok-kw">break</span>;
            }
        }<span class="tok-comment">

        // Handle zero
        </span>r.setLen(<span class="tok-kw">if</span> (j != <span class="tok-number">0</span>) j <span class="tok-kw">else</span> <span class="tok-number">1</span>);
    }

    <span class="tok-comment">/// r = a + scalar</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r and a may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addScalar</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, scalar: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureAddScalarCapacity(a.toConst(), scalar);
        <span class="tok-kw">var</span> m = r.toMutable();
        m.addScalar(a.toConst(), scalar);
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = a + b</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureAddCapacity(a.toConst(), b.toConst());
        <span class="tok-kw">var</span> m = r.toMutable();
        m.add(a.toConst(), b.toConst());
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = a + b with 2s-complement wrapping semantics. Returns whether any overflow occurred.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWrap</span>(
        r: *<a href="std.math.big.int.Managed.html">Managed</a>,
        a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
        b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
        signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
        bit_count: <span class="tok-type">usize</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">bool</span> {
        <span class="tok-kw">try</span> r.ensureTwosCompCapacity(bit_count);
        <span class="tok-kw">var</span> m = r.toMutable();
        <span class="tok-kw">const</span> wrapped = m.addWrap(a.toConst(), b.toConst(), signedness, bit_count);
        r.setMetadata(m.positive, m.len);
        <span class="tok-kw">return</span> wrapped;
    }

    <span class="tok-comment">/// r = a + b with 2s-complement saturating semantics.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSat</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureTwosCompCapacity(bit_count);
        <span class="tok-kw">var</span> m = r.toMutable();
        m.addSat(a.toConst(), b.toConst(), signedness, bit_count);
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = a - b</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureCapacity(<span class="tok-builtin">@max</span>(a.len(), b.len()) + <span class="tok-number">1</span>);
        <span class="tok-kw">var</span> m = r.toMutable();
        m.sub(a.toConst(), b.toConst());
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = a - b with 2s-complement wrapping semantics. Returns whether any overflow occurred.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subWrap</span>(
        r: *<a href="std.math.big.int.Managed.html">Managed</a>,
        a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
        b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
        signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
        bit_count: <span class="tok-type">usize</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">bool</span> {
        <span class="tok-kw">try</span> r.ensureTwosCompCapacity(bit_count);
        <span class="tok-kw">var</span> m = r.toMutable();
        <span class="tok-kw">const</span> wrapped = m.subWrap(a.toConst(), b.toConst(), signedness, bit_count);
        r.setMetadata(m.positive, m.len);
        <span class="tok-kw">return</span> wrapped;
    }

    <span class="tok-comment">/// r = a - b with 2s-complement saturating semantics.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subSat</span>(
        r: *<a href="std.math.big.int.Managed.html">Managed</a>,
        a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
        b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
        signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
        bit_count: <span class="tok-type">usize</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureTwosCompCapacity(bit_count);
        <span class="tok-kw">var</span> m = r.toMutable();
        m.subSat(a.toConst(), b.toConst(), signedness, bit_count);
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// rma = a * b</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// rma, a and b may be aliases. However, it is more efficient if rma does not alias a or b.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// rma's allocator is used for temporary storage to speed up the multiplication.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mul</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">var</span> alias_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">if</span> (rma.limbs.ptr == a.limbs.ptr)
            alias_count += <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (rma.limbs.ptr == b.limbs.ptr)
            alias_count += <span class="tok-number">1</span>;
        <span class="tok-kw">try</span> rma.ensureMulCapacity(a.toConst(), b.toConst());
        <span class="tok-kw">var</span> m = rma.toMutable();
        <span class="tok-kw">if</span> (alias_count == <span class="tok-number">0</span>) {
            m.mulNoAlias(a.toConst(), b.toConst(), rma.allocator);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">const</span> limb_count = <a href="std.math.big.int.html#std.math.big.int.calcMulLimbsBufferLen">calcMulLimbsBufferLen</a>(a.len(), b.len(), alias_count);
            <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> rma.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, limb_count);
            <span class="tok-kw">defer</span> rma.allocator.free(limbs_buffer);
            m.mul(a.toConst(), b.toConst(), limbs_buffer, rma.allocator);
        }
        rma.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// rma = a * b with 2s-complement wrapping semantics.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// rma, a and b may be aliases. However, it is more efficient if rma does not alias a or b.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// rma's allocator is used for temporary storage to speed up the multiplication.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulWrap</span>(
        rma: *<a href="std.math.big.int.Managed.html">Managed</a>,
        a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
        b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
        signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
        bit_count: <span class="tok-type">usize</span>,
    ) !<span class="tok-type">void</span> {
        <span class="tok-kw">var</span> alias_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">if</span> (rma.limbs.ptr == a.limbs.ptr)
            alias_count += <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (rma.limbs.ptr == b.limbs.ptr)
            alias_count += <span class="tok-number">1</span>;

        <span class="tok-kw">try</span> rma.ensureTwosCompCapacity(bit_count);
        <span class="tok-kw">var</span> m = rma.toMutable();
        <span class="tok-kw">if</span> (alias_count == <span class="tok-number">0</span>) {
            m.mulWrapNoAlias(a.toConst(), b.toConst(), signedness, bit_count, rma.allocator);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">const</span> limb_count = <a href="std.math.big.int.html#std.math.big.int.calcMulWrapLimbsBufferLen">calcMulWrapLimbsBufferLen</a>(bit_count, a.len(), b.len(), alias_count);
            <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> rma.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, limb_count);
            <span class="tok-kw">defer</span> rma.allocator.free(limbs_buffer);
            m.mulWrap(a.toConst(), b.toConst(), signedness, bit_count, limbs_buffer, rma.allocator);
        }
        rma.setMetadata(m.positive, m.len);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTwosCompCapacity</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count));
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureAddScalarCapacity</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: <a href="std.math.big.int.Const.html">Const</a>, scalar: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureCapacity(<span class="tok-builtin">@max</span>(a.limbs.len, <a href="std.math.big.int.html#std.math.big.int.calcLimbLen">calcLimbLen</a>(scalar)) + <span class="tok-number">1</span>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureAddCapacity</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureCapacity(<span class="tok-builtin">@max</span>(a.limbs.len, b.limbs.len) + <span class="tok-number">1</span>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureMulCapacity</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> rma.ensureCapacity(a.limbs.len + b.limbs.len + <span class="tok-number">1</span>);
    }

    <span class="tok-comment">/// q = a / b (rem r)</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// a / b are floored (rounded towards 0).</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">divFloor</span>(q: *<a href="std.math.big.int.Managed.html">Managed</a>, r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> q.ensureCapacity(a.len());
        <span class="tok-kw">try</span> r.ensureCapacity(b.len());
        <span class="tok-kw">var</span> mq = q.toMutable();
        <span class="tok-kw">var</span> mr = r.toMutable();
        <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> q.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <a href="std.math.big.int.html#std.math.big.int.calcDivLimbsBufferLen">calcDivLimbsBufferLen</a>(a.len(), b.len()));
        <span class="tok-kw">defer</span> q.allocator.free(limbs_buffer);
        mq.divFloor(&amp;mr, a.toConst(), b.toConst(), limbs_buffer);
        q.setMetadata(mq.positive, mq.len);
        r.setMetadata(mr.positive, mr.len);
    }

    <span class="tok-comment">/// q = a / b (rem r)</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// a / b are truncated (rounded towards -inf).</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">divTrunc</span>(q: *<a href="std.math.big.int.Managed.html">Managed</a>, r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> q.ensureCapacity(a.len());
        <span class="tok-kw">try</span> r.ensureCapacity(b.len());
        <span class="tok-kw">var</span> mq = q.toMutable();
        <span class="tok-kw">var</span> mr = r.toMutable();
        <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> q.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <a href="std.math.big.int.html#std.math.big.int.calcDivLimbsBufferLen">calcDivLimbsBufferLen</a>(a.len(), b.len()));
        <span class="tok-kw">defer</span> q.allocator.free(limbs_buffer);
        mq.divTrunc(&amp;mr, a.toConst(), b.toConst(), limbs_buffer);
        q.setMetadata(mq.positive, mq.len);
        r.setMetadata(mr.positive, mr.len);
    }

    <span class="tok-comment">/// r = a &lt;&lt; shift, in other words, r = a * 2^shift</span>
    <span class="tok-comment">/// r and a may alias.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftLeft</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, shift: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureCapacity(a.len() + (shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) + <span class="tok-number">1</span>);
        <span class="tok-kw">var</span> m = r.toMutable();
        m.shiftLeft(a.toConst(), shift);
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = a &lt;&lt;| shift with 2s-complement saturating semantics.</span>
    <span class="tok-comment">/// r and a may alias.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftLeftSat</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, shift: <span class="tok-type">usize</span>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureTwosCompCapacity(bit_count);
        <span class="tok-kw">var</span> m = r.toMutable();
        m.shiftLeftSat(a.toConst(), shift, signedness, bit_count);
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = a &gt;&gt; shift</span>
    <span class="tok-comment">/// r and a may alias.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftRight</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, shift: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (a.len() &lt;= shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) {<span class="tok-comment">
            // Shifting negative numbers converges to -1 instead of 0
            </span><span class="tok-kw">if</span> (a.isPositive()) {
                r.metadata = <span class="tok-number">1</span>;
                r.limbs[<span class="tok-number">0</span>] = <span class="tok-number">0</span>;
            } <span class="tok-kw">else</span> {
                r.metadata = <span class="tok-number">1</span>;
                r.setSign(<span class="tok-null">false</span>);
                r.limbs[<span class="tok-number">0</span>] = <span class="tok-number">1</span>;
            }
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">try</span> r.ensureCapacity(a.len() - (shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>));
        <span class="tok-kw">var</span> m = r.toMutable();
        m.shiftRight(a.toConst(), shift);
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = ~a under 2s-complement wrapping semantics.</span>
    <span class="tok-comment">/// r and a may alias.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitNotWrap</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureTwosCompCapacity(bit_count);
        <span class="tok-kw">var</span> m = r.toMutable();
        m.bitNotWrap(a.toConst(), signedness, bit_count);
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = a | b</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// a and b are zero-extended to the longer of a or b.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitOr</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureCapacity(<span class="tok-builtin">@max</span>(a.len(), b.len()));
        <span class="tok-kw">var</span> m = r.toMutable();
        m.bitOr(a.toConst(), b.toConst());
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = a &amp; b</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitAnd</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> cap = <span class="tok-kw">if</span> (a.len() &gt;= b.len())
            <span class="tok-kw">if</span> (b.isPositive()) b.len() <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.isPositive()) a.len() <span class="tok-kw">else</span> a.len() + <span class="tok-number">1</span>
        <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.isPositive()) a.len() <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.isPositive()) b.len() <span class="tok-kw">else</span> b.len() + <span class="tok-number">1</span>;

        <span class="tok-kw">try</span> r.ensureCapacity(cap);
        <span class="tok-kw">var</span> m = r.toMutable();
        m.bitAnd(a.toConst(), b.toConst());
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = a ^ b</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitXor</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> cap = <span class="tok-builtin">@max</span>(a.len(), b.len()) + <span class="tok-builtin">@intFromBool</span>(a.isPositive() != b.isPositive());
        <span class="tok-kw">try</span> r.ensureCapacity(cap);

        <span class="tok-kw">var</span> m = r.toMutable();
        m.bitXor(a.toConst(), b.toConst());
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// rma may alias x or y.</span>
    <span class="tok-comment">/// x and y may alias each other.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// rma's allocator is used for temporary storage to boost multiplication performance.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gcd</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, x: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, y: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> rma.ensureCapacity(<span class="tok-builtin">@min</span>(x.len(), y.len()));
        <span class="tok-kw">var</span> m = rma.toMutable();
        <span class="tok-kw">var</span> limbs_buffer = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>).init(rma.allocator);
        <span class="tok-kw">defer</span> limbs_buffer.deinit();
        <span class="tok-kw">try</span> m.gcd(x.toConst(), y.toConst(), &amp;limbs_buffer);
        rma.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = a * a</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sqr</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> needed_limbs = <span class="tok-number">2</span> * a.len() + <span class="tok-number">1</span>;

        <span class="tok-kw">if</span> (rma.limbs.ptr == a.limbs.ptr) {
            <span class="tok-kw">var</span> m = <span class="tok-kw">try</span> <a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.initCapacity">initCapacity</a>(rma.allocator, needed_limbs);
            <span class="tok-kw">errdefer</span> m.deinit();
            <span class="tok-kw">var</span> m_mut = m.toMutable();
            m_mut.sqrNoAlias(a.toConst(), rma.allocator);
            m.setMetadata(m_mut.positive, m_mut.len);

            rma.deinit();
            rma.swap(&amp;m);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> rma.ensureCapacity(needed_limbs);
            <span class="tok-kw">var</span> rma_mut = rma.toMutable();
            rma_mut.sqrNoAlias(a.toConst(), rma.allocator);
            rma.setMetadata(rma_mut.positive, rma_mut.len);
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pow</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: <span class="tok-type">u32</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> needed_limbs = <a href="std.math.big.int.html#std.math.big.int.calcPowLimbsBufferLen">calcPowLimbsBufferLen</a>(a.bitCountAbs(), b);

        <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> rma.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, needed_limbs);
        <span class="tok-kw">defer</span> rma.allocator.free(limbs_buffer);

        <span class="tok-kw">if</span> (rma.limbs.ptr == a.limbs.ptr) {
            <span class="tok-kw">var</span> m = <span class="tok-kw">try</span> <a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.initCapacity">initCapacity</a>(rma.allocator, needed_limbs);
            <span class="tok-kw">errdefer</span> m.deinit();
            <span class="tok-kw">var</span> m_mut = m.toMutable();
            m_mut.pow(a.toConst(), b, limbs_buffer);
            m.setMetadata(m_mut.positive, m_mut.len);

            rma.deinit();
            rma.swap(&amp;m);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> rma.ensureCapacity(needed_limbs);
            <span class="tok-kw">var</span> rma_mut = rma.toMutable();
            rma_mut.pow(a.toConst(), b, limbs_buffer);
            rma.setMetadata(rma_mut.positive, rma_mut.len);
        }
    }

    <span class="tok-comment">/// r = ⌊√a⌋</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sqrt</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> bit_count = a.bitCountAbs();

        <span class="tok-kw">if</span> (bit_count == <span class="tok-number">0</span>) {
            <span class="tok-kw">try</span> rma.set(<span class="tok-number">0</span>);
            rma.setMetadata(a.isPositive(), rma.len());
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">if</span> (!a.isPositive()) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SqrtOfNegativeNumber;
        }

        <span class="tok-kw">const</span> needed_limbs = <a href="std.math.big.int.html#std.math.big.int.calcSqrtLimbsBufferLen">calcSqrtLimbsBufferLen</a>(bit_count);
        <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> rma.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, needed_limbs);
        <span class="tok-kw">defer</span> rma.allocator.free(limbs_buffer);

        <span class="tok-kw">try</span> rma.ensureCapacity((a.len() - <span class="tok-number">1</span>) / <span class="tok-number">2</span> + <span class="tok-number">1</span>);
        <span class="tok-kw">var</span> m = rma.toMutable();
        m.sqrt(a.toConst(), limbs_buffer);
        rma.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = truncate(Int(signedness, bit_count), a)</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">truncate</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count));
        <span class="tok-kw">var</span> m = r.toMutable();
        m.truncate(a.toConst(), signedness, bit_count);
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = saturate(Int(signedness, bit_count), a)</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">saturate</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count));
        <span class="tok-kw">var</span> m = r.toMutable();
        m.saturate(a.toConst(), signedness, bit_count);
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = @popCount(a) with 2s-complement semantics.</span>
    <span class="tok-comment">/// r and a may be aliases.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popCount</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count));
        <span class="tok-kw">var</span> m = r.toMutable();
        m.popCount(a.toConst(), bit_count);
        r.setMetadata(m.positive, m.len);
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
