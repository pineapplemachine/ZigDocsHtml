<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.posix.html" class="active">posix</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.posix" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.posix</span><a href="#src.zig-std.posix">[src]</a></h1><div class="tldDocs"><p>POSIX API layer.</p>
<p>This is more cross platform than using OS-specific APIs, however, it is
lower-level and less portable than other namespaces such as <code><a href="std.fs.html">std.fs</a></code> and
<code><a href="std.process.html">std.process</a></code>.</p>
<p>These APIs are generally lowered to libc function calls if and only if libc
is linked. Most operating systems other than Windows, Linux, and WASI
require always linking libc because they use it as the stable syscall ABI.</p>
<p>Operating systems that are not POSIX-compliant are sometimes supported by
this API layer; sometimes not. Generally, an implementation will be
provided only if such implementation is straightforward on that operating
system. Otherwise, programmers are expected to use OS-specific logic to
deal with the exception.</p>
</div><div class="sectNamespaces"><h2 class="sectionHeader">Namespaces</h2><ul class="listNamespaces columns"><li><a href="std.posix.LOCK.html">std.posix.LOCK</a></li><li><a href="std.posix.LOG.html">std.posix.LOG</a></li></ul></div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.posix.iovec.html">std.posix.iovec</a></li><li><a href="std.posix.iovec_const.html">std.posix.iovec_const</a></li><li><a href="std.posix.ACCMODE.html">std.posix.ACCMODE</a></li><li><a href="std.posix.TCSA.html">std.posix.TCSA</a></li><li><a href="std.posix.winsize.html">std.posix.winsize</a></li><li><a href="std.posix.Arg0Expand.html">std.posix.Arg0Expand</a></li><li><a href="std.posix.ShutdownHow.html">std.posix.ShutdownHow</a></li><li><a href="std.posix.WaitPidResult.html">std.posix.WaitPidResult</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.posix.system" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">system</span><a href="#src.zig-std.posix.system">[src]</a></h2><div class="tldDocs"><p>A libc-compatible API layer.</p>
</div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.posix.system.ucontext_t" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">ucontext_t</span><a href="#src.zig-std.posix.system.ucontext_t">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.posix.system.ucontext_t">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ucontext_t = <span class="tok-type">void</span></code></pre></details></div></div><div class="decl"><h3 id="std.posix.system.pid_t" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">pid_t</span><a href="#src.zig-std.posix.system.pid_t">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.posix.system.pid_t">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> pid_t = <span class="tok-type">void</span></code></pre></details></div></div><div class="decl"><h3 id="std.posix.system.pollfd" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">pollfd</span><a href="#src.zig-std.posix.system.pollfd">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.posix.system.pollfd">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> pollfd = <span class="tok-type">void</span></code></pre></details></div></div><div class="decl"><h3 id="std.posix.system.fd_t" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">fd_t</span><a href="#src.zig-std.posix.system.fd_t">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.posix.system.fd_t">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> fd_t = <span class="tok-type">void</span></code></pre></details></div></div><div class="decl"><h3 id="std.posix.system.uid_t" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">uid_t</span><a href="#src.zig-std.posix.system.uid_t">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.posix.system.uid_t">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> uid_t = <span class="tok-type">void</span></code></pre></details></div></div><div class="decl"><h3 id="std.posix.system.gid_t" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">gid_t</span><a href="#src.zig-std.posix.system.gid_t">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.posix.system.gid_t">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> gid_t = <span class="tok-type">void</span></code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.system">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> system = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.use_libc">use_libc</a>)
    <a href="std.html">std</a>.<a href="std.c.html">c</a>
<span class="tok-kw">else</span> <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
    .linux =&gt; <a href="std.os.linux.html">linux</a>,
    .plan9 =&gt; <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.plan9.html">plan9</a>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ucontext_t = <span class="tok-type">void</span>;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> pid_t = <span class="tok-type">void</span>;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> pollfd = <span class="tok-type">void</span>;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> fd_t = <span class="tok-type">void</span>;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> uid_t = <span class="tok-type">void</span>;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> gid_t = <span class="tok-type">void</span>;
    },
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.socket_t" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">socket_t</span><a href="#src.zig-std.posix.socket_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.socket_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> socket_t = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET">SOCKET</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.RebootCommand" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">RebootCommand</span><a href="#src.zig-std.posix.RebootCommand">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.RebootCommand">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RebootCommand = <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
    .linux =&gt; <span class="tok-kw">union</span>(linux.LINUX_REBOOT.CMD) {
        RESTART: <span class="tok-type">void</span>,
        HALT: <span class="tok-type">void</span>,
        CAD_ON: <span class="tok-type">void</span>,
        CAD_OFF: <span class="tok-type">void</span>,
        POWER_OFF: <span class="tok-type">void</span>,
        RESTART2: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        SW_SUSPEND: <span class="tok-type">void</span>,
        KEXEC: <span class="tok-type">void</span>,
    },
    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported OS&quot;</span>),
}</code></pre></details></div></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.posix.AF" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">AF</span><a href="#src.zig-std.posix.AF">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.AF">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AF = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">AF</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.AF_SUN" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">AF_SUN</span><a href="#src.zig-std.posix.AF_SUN">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.AF_SUN">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AF_SUN = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">AF_SUN</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.AI" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">AI</span><a href="#src.zig-std.posix.AI">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.AI">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AI = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">AI</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.ARCH" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">ARCH</span><a href="#src.zig-std.posix.ARCH">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.ARCH">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ARCH = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">ARCH</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.AT" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">AT</span><a href="#src.zig-std.posix.AT">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.AT">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AT = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">AT</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.AT_SUN" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">AT_SUN</span><a href="#src.zig-std.posix.AT_SUN">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.AT_SUN">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AT_SUN = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">AT_SUN</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.CLOCK" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">CLOCK</span><a href="#src.zig-std.posix.CLOCK">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.CLOCK">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CLOCK = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">CLOCK</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.CPU_COUNT" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">CPU_COUNT</span><a href="#src.zig-std.posix.CPU_COUNT">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.CPU_COUNT">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CPU_COUNT = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">CPU_COUNT</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.CTL" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">CTL</span><a href="#src.zig-std.posix.CTL">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.CTL">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CTL = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">CTL</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.DT" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">DT</span><a href="#src.zig-std.posix.DT">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.DT">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DT = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">DT</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.E" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">E</span><a href="#src.zig-std.posix.E">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.E">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> E = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">E</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.Elf_Symndx" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Elf_Symndx</span><a href="#src.zig-std.posix.Elf_Symndx">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.Elf_Symndx">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Elf_Symndx = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">Elf_Symndx</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.F" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">F</span><a href="#src.zig-std.posix.F">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.F">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> F = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">F</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FD_CLOEXEC" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">FD_CLOEXEC</span><a href="#src.zig-std.posix.FD_CLOEXEC">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FD_CLOEXEC">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FD_CLOEXEC = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">FD_CLOEXEC</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.Flock" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Flock</span><a href="#src.zig-std.posix.Flock">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.Flock">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Flock = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">Flock</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.HOST_NAME_MAX" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">HOST_NAME_MAX</span><a href="#src.zig-std.posix.HOST_NAME_MAX">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.HOST_NAME_MAX">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> HOST_NAME_MAX = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">HOST_NAME_MAX</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.HW" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">HW</span><a href="#src.zig-std.posix.HW">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.HW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> HW = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">HW</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.IFNAMESIZE" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">IFNAMESIZE</span><a href="#src.zig-std.posix.IFNAMESIZE">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.IFNAMESIZE">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> IFNAMESIZE = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">IFNAMESIZE</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.IOV_MAX" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">IOV_MAX</span><a href="#src.zig-std.posix.IOV_MAX">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.IOV_MAX">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> IOV_MAX = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">IOV_MAX</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.IPPROTO" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">IPPROTO</span><a href="#src.zig-std.posix.IPPROTO">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.IPPROTO">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> IPPROTO = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">IPPROTO</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.KERN" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">KERN</span><a href="#src.zig-std.posix.KERN">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.KERN">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KERN = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">KERN</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.Kevent" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Kevent</span><a href="#src.zig-std.posix.Kevent">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.Kevent">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Kevent = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">Kevent</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.MADV" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">MADV</span><a href="#src.zig-std.posix.MADV">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.MADV">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MADV = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MADV</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.MAP" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">MAP</span><a href="#src.zig-std.posix.MAP">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.MAP">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MAP = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MAP</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.MAX_ADDR_LEN" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">MAX_ADDR_LEN</span><a href="#src.zig-std.posix.MAX_ADDR_LEN">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.MAX_ADDR_LEN">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MAX_ADDR_LEN = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MAX_ADDR_LEN</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.MFD" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">MFD</span><a href="#src.zig-std.posix.MFD">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.MFD">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MFD = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MFD</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.MMAP2_UNIT" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">MMAP2_UNIT</span><a href="#src.zig-std.posix.MMAP2_UNIT">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.MMAP2_UNIT">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MMAP2_UNIT = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MMAP2_UNIT</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.MREMAP" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">MREMAP</span><a href="#src.zig-std.posix.MREMAP">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.MREMAP">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MREMAP = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MREMAP</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.MSF" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">MSF</span><a href="#src.zig-std.posix.MSF">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.MSF">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MSF = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MSF</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.MSG" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">MSG</span><a href="#src.zig-std.posix.MSG">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.MSG">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MSG = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MSG</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.NAME_MAX" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">NAME_MAX</span><a href="#src.zig-std.posix.NAME_MAX">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.NAME_MAX">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> NAME_MAX = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">NAME_MAX</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.O" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">O</span><a href="#src.zig-std.posix.O">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.O">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> O = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">O</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.PATH_MAX" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">PATH_MAX</span><a href="#src.zig-std.posix.PATH_MAX">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.PATH_MAX">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PATH_MAX = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">PATH_MAX</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.POLL" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">POLL</span><a href="#src.zig-std.posix.POLL">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.POLL">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> POLL = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">POLL</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.POSIX_FADV" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">POSIX_FADV</span><a href="#src.zig-std.posix.POSIX_FADV">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.POSIX_FADV">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> POSIX_FADV = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">POSIX_FADV</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.PR" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">PR</span><a href="#src.zig-std.posix.PR">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.PR">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PR = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">PR</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.PROT" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">PROT</span><a href="#src.zig-std.posix.PROT">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.PROT">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PROT = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">PROT</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.REG" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">REG</span><a href="#src.zig-std.posix.REG">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.REG">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> REG = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">REG</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.RLIM" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">RLIM</span><a href="#src.zig-std.posix.RLIM">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.RLIM">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RLIM = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">RLIM</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.RR" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">RR</span><a href="#src.zig-std.posix.RR">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.RR">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RR = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">RR</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.S" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">S</span><a href="#src.zig-std.posix.S">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.S">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> S = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">S</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SA" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">SA</span><a href="#src.zig-std.posix.SA">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SA">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SA = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">SA</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SC" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">SC</span><a href="#src.zig-std.posix.SC">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SC">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SC = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">SC</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SEEK" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">SEEK</span><a href="#src.zig-std.posix.SEEK">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SEEK">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SEEK = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">SEEK</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SHUT" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">SHUT</span><a href="#src.zig-std.posix.SHUT">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SHUT">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SHUT = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">SHUT</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SIG" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">SIG</span><a href="#src.zig-std.posix.SIG">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SIG">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SIG = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">SIG</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SIOCGIFINDEX" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">SIOCGIFINDEX</span><a href="#src.zig-std.posix.SIOCGIFINDEX">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SIOCGIFINDEX">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SIOCGIFINDEX = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">SIOCGIFINDEX</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SO" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">SO</span><a href="#src.zig-std.posix.SO">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SO">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SO = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">SO</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SOCK" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">SOCK</span><a href="#src.zig-std.posix.SOCK">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SOCK">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SOCK = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">SOCK</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SOL" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">SOL</span><a href="#src.zig-std.posix.SOL">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SOL">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SOL = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">SOL</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.IFF" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">IFF</span><a href="#src.zig-std.posix.IFF">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.IFF">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> IFF = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">IFF</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.STDERR_FILENO" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">STDERR_FILENO</span><a href="#src.zig-std.posix.STDERR_FILENO">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.STDERR_FILENO">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> STDERR_FILENO = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">STDERR_FILENO</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.STDIN_FILENO" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">STDIN_FILENO</span><a href="#src.zig-std.posix.STDIN_FILENO">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.STDIN_FILENO">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> STDIN_FILENO = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">STDIN_FILENO</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.STDOUT_FILENO" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">STDOUT_FILENO</span><a href="#src.zig-std.posix.STDOUT_FILENO">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.STDOUT_FILENO">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> STDOUT_FILENO = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">STDOUT_FILENO</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SYS" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">SYS</span><a href="#src.zig-std.posix.SYS">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SYS">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SYS = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">SYS</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.Sigaction" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Sigaction</span><a href="#src.zig-std.posix.Sigaction">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.Sigaction">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Sigaction = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">Sigaction</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.Stat" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Stat</span><a href="#src.zig-std.posix.Stat">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.Stat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Stat = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">Stat</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.T" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">T</span><a href="#src.zig-std.posix.T">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.T">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> T = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">T</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.TCP" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">TCP</span><a href="#src.zig-std.posix.TCP">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.TCP">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TCP = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">TCP</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.VDSO" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">VDSO</span><a href="#src.zig-std.posix.VDSO">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.VDSO">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> VDSO = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">VDSO</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.W" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">W</span><a href="#src.zig-std.posix.W">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.W">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> W = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">W</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix._SC" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">_SC</span><a href="#src.zig-std.posix._SC">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix._SC">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> _SC = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">_SC</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.addrinfo" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">addrinfo</span><a href="#src.zig-std.posix.addrinfo">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.addrinfo">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> addrinfo = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">addrinfo</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.blkcnt_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">blkcnt_t</span><a href="#src.zig-std.posix.blkcnt_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.blkcnt_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> blkcnt_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">blkcnt_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.blksize_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">blksize_t</span><a href="#src.zig-std.posix.blksize_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.blksize_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> blksize_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">blksize_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.clock_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">clock_t</span><a href="#src.zig-std.posix.clock_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.clock_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> clock_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">clock_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.clockid_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">clockid_t</span><a href="#src.zig-std.posix.clockid_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.clockid_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> clockid_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">clockid_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.timerfd_clockid_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">timerfd_clockid_t</span><a href="#src.zig-std.posix.timerfd_clockid_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.timerfd_clockid_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> timerfd_clockid_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">timerfd_clockid_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.cpu_set_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">cpu_set_t</span><a href="#src.zig-std.posix.cpu_set_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.cpu_set_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> cpu_set_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">cpu_set_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.dev_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">dev_t</span><a href="#src.zig-std.posix.dev_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.dev_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> dev_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">dev_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.dl_phdr_info" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">dl_phdr_info</span><a href="#src.zig-std.posix.dl_phdr_info">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.dl_phdr_info">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> dl_phdr_info = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">dl_phdr_info</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.empty_sigset" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">empty_sigset</span><a href="#src.zig-std.posix.empty_sigset">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.empty_sigset">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty_sigset = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">empty_sigset</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.fd_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">fd_t</span><a href="#src.zig-std.posix.fd_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.fd_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> fd_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="std.posix.html#std.posix.system.fd_t">fd_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.file_obj" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">file_obj</span><a href="#src.zig-std.posix.file_obj">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.file_obj">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> file_obj = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">file_obj</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.filled_sigset" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">filled_sigset</span><a href="#src.zig-std.posix.filled_sigset">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.filled_sigset">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> filled_sigset = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">filled_sigset</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.gid_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">gid_t</span><a href="#src.zig-std.posix.gid_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.gid_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> gid_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="std.posix.html#std.posix.system.gid_t">gid_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.ifreq" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">ifreq</span><a href="#src.zig-std.posix.ifreq">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.ifreq">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ifreq = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">ifreq</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.ino_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">ino_t</span><a href="#src.zig-std.posix.ino_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.ino_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ino_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">ino_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.mcontext_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">mcontext_t</span><a href="#src.zig-std.posix.mcontext_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.mcontext_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> mcontext_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">mcontext_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.mode_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">mode_t</span><a href="#src.zig-std.posix.mode_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.mode_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> mode_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">mode_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.msghdr" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">msghdr</span><a href="#src.zig-std.posix.msghdr">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.msghdr">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> msghdr = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">msghdr</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.msghdr_const" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">msghdr_const</span><a href="#src.zig-std.posix.msghdr_const">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.msghdr_const">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> msghdr_const = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">msghdr_const</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.nfds_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">nfds_t</span><a href="#src.zig-std.posix.nfds_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.nfds_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> nfds_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">nfds_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.nlink_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">nlink_t</span><a href="#src.zig-std.posix.nlink_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.nlink_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> nlink_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">nlink_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.off_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">off_t</span><a href="#src.zig-std.posix.off_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.off_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> off_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">off_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.pid_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">pid_t</span><a href="#src.zig-std.posix.pid_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.pid_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> pid_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="std.posix.html#std.posix.system.pid_t">pid_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.pollfd" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">pollfd</span><a href="#src.zig-std.posix.pollfd">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.pollfd">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> pollfd = <a href="std.posix.html#std.posix.system">system</a>.<a href="std.posix.html#std.posix.system.pollfd">pollfd</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.port_event" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">port_event</span><a href="#src.zig-std.posix.port_event">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.port_event">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> port_event = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">port_event</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.port_notify" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">port_notify</span><a href="#src.zig-std.posix.port_notify">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.port_notify">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> port_notify = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">port_notify</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.port_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">port_t</span><a href="#src.zig-std.posix.port_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.port_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> port_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">port_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.rlim_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">rlim_t</span><a href="#src.zig-std.posix.rlim_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.rlim_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> rlim_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">rlim_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.rlimit" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">rlimit</span><a href="#src.zig-std.posix.rlimit">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.rlimit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> rlimit = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">rlimit</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.rlimit_resource" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">rlimit_resource</span><a href="#src.zig-std.posix.rlimit_resource">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.rlimit_resource">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> rlimit_resource = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">rlimit_resource</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.rusage" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">rusage</span><a href="#src.zig-std.posix.rusage">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.rusage">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> rusage = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">rusage</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.sa_family_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">sa_family_t</span><a href="#src.zig-std.posix.sa_family_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.sa_family_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> sa_family_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">sa_family_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.siginfo_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">siginfo_t</span><a href="#src.zig-std.posix.siginfo_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.siginfo_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> siginfo_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">siginfo_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.sigset_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">sigset_t</span><a href="#src.zig-std.posix.sigset_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.sigset_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> sigset_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">sigset_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.sockaddr" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">sockaddr</span><a href="#src.zig-std.posix.sockaddr">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.sockaddr">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> sockaddr = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">sockaddr</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.socklen_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">socklen_t</span><a href="#src.zig-std.posix.socklen_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.socklen_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> socklen_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">socklen_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.stack_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">stack_t</span><a href="#src.zig-std.posix.stack_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.stack_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> stack_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">stack_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.time_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">time_t</span><a href="#src.zig-std.posix.time_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.time_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> time_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">time_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.timespec" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">timespec</span><a href="#src.zig-std.posix.timespec">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.timespec">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> timespec = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">timespec</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.timestamp_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">timestamp_t</span><a href="#src.zig-std.posix.timestamp_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.timestamp_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> timestamp_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">timestamp_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.timeval" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">timeval</span><a href="#src.zig-std.posix.timeval">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.timeval">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> timeval = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">timeval</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.timezone" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">timezone</span><a href="#src.zig-std.posix.timezone">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.timezone">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> timezone = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">timezone</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.ucontext_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">ucontext_t</span><a href="#src.zig-std.posix.ucontext_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.ucontext_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ucontext_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="std.posix.html#std.posix.system.ucontext_t">ucontext_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.uid_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">uid_t</span><a href="#src.zig-std.posix.uid_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.uid_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> uid_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="std.posix.html#std.posix.system.uid_t">uid_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.user_desc" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">user_desc</span><a href="#src.zig-std.posix.user_desc">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.user_desc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> user_desc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">user_desc</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.utsname" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">utsname</span><a href="#src.zig-std.posix.utsname">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.utsname">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> utsname = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">utsname</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.termios" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">termios</span><a href="#src.zig-std.posix.termios">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.termios">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> termios = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">termios</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.CSIZE" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">CSIZE</span><a href="#src.zig-std.posix.CSIZE">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.CSIZE">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CSIZE = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">CSIZE</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.NCCS" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">NCCS</span><a href="#src.zig-std.posix.NCCS">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.NCCS">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> NCCS = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">NCCS</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.cc_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">cc_t</span><a href="#src.zig-std.posix.cc_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.cc_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> cc_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">cc_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.V" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">V</span><a href="#src.zig-std.posix.V">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.V">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> V = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">V</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.speed_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">speed_t</span><a href="#src.zig-std.posix.speed_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.speed_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> speed_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">speed_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.tc_iflag_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">tc_iflag_t</span><a href="#src.zig-std.posix.tc_iflag_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.tc_iflag_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> tc_iflag_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">tc_iflag_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.tc_oflag_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">tc_oflag_t</span><a href="#src.zig-std.posix.tc_oflag_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.tc_oflag_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> tc_oflag_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">tc_oflag_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.tc_cflag_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">tc_cflag_t</span><a href="#src.zig-std.posix.tc_cflag_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.tc_cflag_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> tc_cflag_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">tc_cflag_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.tc_lflag_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">tc_lflag_t</span><a href="#src.zig-std.posix.tc_lflag_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.tc_lflag_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> tc_lflag_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">tc_lflag_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.F_OK" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">F_OK</span><a href="#src.zig-std.posix.F_OK">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.F_OK">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> F_OK = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">F_OK</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.R_OK" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">R_OK</span><a href="#src.zig-std.posix.R_OK">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.R_OK">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> R_OK = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">R_OK</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.W_OK" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">W_OK</span><a href="#src.zig-std.posix.W_OK">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.W_OK">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> W_OK = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">W_OK</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.X_OK" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">X_OK</span><a href="#src.zig-std.posix.X_OK">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.X_OK">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> X_OK = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">X_OK</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.unexpected_error_tracing" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">unexpected_error_tracing</span><a href="#src.zig-std.posix.unexpected_error_tracing">[src]</a></h2><div class="tldDocs"><p>Whether or not <code>error.Unexpected</code> will print its value and a stack trace.</p>
<p>If this happens the fix is to add the error code to the corresponding
switch expression, possibly introduce a new error in the error set, and
send a patch to Zig.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.unexpected_error_tracing">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> unexpected_error_tracing = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_llvm <span class="tok-kw">and</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.mode">mode</a> == .Debug</code></pre></details></div></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.posix.FChmodError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FChmodError</span><a href="#src.zig-std.posix.FChmodError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>FileNotFound</dt></div><div><dt>InputOutput</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FChmodError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FChmodError = <span class="tok-kw">error</span>{
    AccessDenied,
    InputOutput,
    SymLinkLoop,
    FileNotFound,
    SystemResources,
    ReadOnlyFileSystem,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FChmodAtError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FChmodAtError</span><a href="#src.zig-std.posix.FChmodAtError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.FChmodError">FChmodError</a></dt></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.FChmodError">FChmodError</a></dt></div><div><dt>InputOutput <a href="std.posix.html#std.posix.FChmodError">FChmodError</a></dt></div><div><dt>NameTooLong</dt><dd><p>A component of <code>path</code> exceeded <code><a href="std.posix.html#std.posix.NAME_MAX">NAME_MAX</a></code>, or the entire path exceeded
<code><a href="std.posix.html#std.posix.PATH_MAX">PATH_MAX</a></code>.</p>
</dd></div><div><dt>OperationNotSupported</dt><dd><p><code>path</code> resolves to a symbolic link, and <code>AT.SYMLINK_NOFOLLOW</code> was set
in <code>flags</code>. This error only occurs on Linux, where changing the mode of
a symbolic link has no meaning and can cause undefined behaviour on
certain filesystems.</p>
<p>The procfs fallback was used but procfs was not mounted.</p>
</dd></div><div><dt>ProcessFdQuotaExceeded</dt><dd><p>The procfs fallback was used but the process exceeded its open file
limit.</p>
</dd></div><div><dt>ReadOnlyFileSystem <a href="std.posix.html#std.posix.FChmodError">FChmodError</a></dt></div><div><dt>SymLinkLoop <a href="std.posix.html#std.posix.FChmodError">FChmodError</a></dt></div><div><dt>SystemFdQuotaExceeded</dt><dd><p>The procfs fallback was used but the system exceeded it open file limit.</p>
</dd></div><div><dt>SystemResources <a href="std.posix.html#std.posix.FChmodError">FChmodError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FChmodAtError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FChmodAtError = <a href="std.posix.html#std.posix.FChmodError">FChmodError</a> || <span class="tok-kw">error</span>{
    <span class="tok-comment">/// A component of `path` exceeded `NAME_MAX`, or the entire path exceeded</span>
    <span class="tok-comment">/// `PATH_MAX`.</span>
    NameTooLong,
    <span class="tok-comment">/// `path` resolves to a symbolic link, and `AT.SYMLINK_NOFOLLOW` was set</span>
    <span class="tok-comment">/// in `flags`. This error only occurs on Linux, where changing the mode of</span>
    <span class="tok-comment">/// a symbolic link has no meaning and can cause undefined behaviour on</span>
    <span class="tok-comment">/// certain filesystems.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The procfs fallback was used but procfs was not mounted.</span>
    OperationNotSupported,
    <span class="tok-comment">/// The procfs fallback was used but the process exceeded its open file</span>
    <span class="tok-comment">/// limit.</span>
    ProcessFdQuotaExceeded,
    <span class="tok-comment">/// The procfs fallback was used but the system exceeded it open file limit.</span>
    SystemFdQuotaExceeded,
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.FChownError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FChownError</span><a href="#src.zig-std.posix.FChownError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>FileNotFound</dt></div><div><dt>InputOutput</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FChownError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FChownError = <span class="tok-kw">error</span>{
    AccessDenied,
    InputOutput,
    SymLinkLoop,
    FileNotFound,
    SystemResources,
    ReadOnlyFileSystem,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.RebootError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">RebootError</span><a href="#src.zig-std.posix.RebootError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>PermissionDenied</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.RebootError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RebootError = <span class="tok-kw">error</span>{
    PermissionDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.OpenError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">OpenError</span><a href="#src.zig-std.posix.OpenError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to open a new resource relative to it.</p>
</dd></div><div><dt>BadPathName</dt><dd><p>Path contains characters that are disallowed by the underlying filesystem.</p>
</dd></div><div><dt>DeviceBusy</dt></div><div><dt>FileBusy</dt><dd><p>One of these three things:</p>
<ul>
<li>pathname  refers to an executable image which is currently being
executed and write access was requested.</li>
<li>pathname refers to a file that is currently in  use  as  a  swap
file, and the O_TRUNC flag was specified.</li>
<li>pathname  refers  to  a file that is currently being read by the
kernel (e.g., for module/firmware loading), and write access was
requested.</li>
</ul>
</dd></div><div><dt>FileLocksNotSupported</dt><dd><p>The underlying filesystem does not support file locks</p>
</dd></div><div><dt>FileNotFound</dt><dd><p>Either:</p>
<ul>
<li>One of the path components does not exist.</li>
<li>Cwd was used, but cwd has been deleted.</li>
<li>The path associated with the open directory handle has been deleted.</li>
<li>On macOS, multiple processes or threads raced to create the same file
with <code>O.EXCL</code> set to <code>false</code>.</li>
</ul>
</dd></div><div><dt>FileTooBig</dt><dd><p>The file is too large to be opened. This error is unreachable
for 64-bit targets, as well as when opening directories.</p>
</dd></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir</dt><dd><p>The path refers to directory but the <code>DIRECTORY</code> flag was not provided.</p>
</dd></div><div><dt>NameTooLong</dt><dd><p>The path exceeded <code><a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a></code> bytes.</p>
</dd></div><div><dt>NetworkNotFound</dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NoDevice</dt></div><div><dt>NoSpaceLeft</dt><dd><p>A new path cannot be created because the device has no room for the new file.
This error is only reachable when the <code>CREAT</code> flag is provided.</p>
</dd></div><div><dt>NotDir</dt><dd><p>A component used as a directory in the path was not, in fact, a directory, or
<code>DIRECTORY</code> was specified and the path was not a directory.</p>
</dd></div><div><dt>PathAlreadyExists</dt><dd><p>The path already exists and the <code>CREAT</code> and <code>EXCL</code> flags were provided.</p>
</dd></div><div><dt>ProcessFdQuotaExceeded</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemFdQuotaExceeded</dt></div><div><dt>SystemResources</dt><dd><p>Insufficient kernel memory was available, or
the named file is a FIFO and per-user hard limit on
memory allocation for pipes has been reached.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WouldBlock</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.OpenError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to open a new resource relative to it.</span>
    AccessDenied,
    SymLinkLoop,
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    NoDevice,
    <span class="tok-comment">/// Either:</span>
    <span class="tok-comment">/// * One of the path components does not exist.</span>
    <span class="tok-comment">/// * Cwd was used, but cwd has been deleted.</span>
    <span class="tok-comment">/// * The path associated with the open directory handle has been deleted.</span>
    <span class="tok-comment">/// * On macOS, multiple processes or threads raced to create the same file</span>
    <span class="tok-comment">///   with `O.EXCL` set to `false`.</span>
    FileNotFound,

    <span class="tok-comment">/// The path exceeded `max_path_bytes` bytes.</span>
    NameTooLong,

    <span class="tok-comment">/// Insufficient kernel memory was available, or</span>
    <span class="tok-comment">/// the named file is a FIFO and per-user hard limit on</span>
    <span class="tok-comment">/// memory allocation for pipes has been reached.</span>
    SystemResources,

    <span class="tok-comment">/// The file is too large to be opened. This error is unreachable</span>
    <span class="tok-comment">/// for 64-bit targets, as well as when opening directories.</span>
    FileTooBig,

    <span class="tok-comment">/// The path refers to directory but the `DIRECTORY` flag was not provided.</span>
    IsDir,

    <span class="tok-comment">/// A new path cannot be created because the device has no room for the new file.</span>
    <span class="tok-comment">/// This error is only reachable when the `CREAT` flag is provided.</span>
    NoSpaceLeft,

    <span class="tok-comment">/// A component used as a directory in the path was not, in fact, a directory, or</span>
    <span class="tok-comment">/// `DIRECTORY` was specified and the path was not a directory.</span>
    NotDir,

    <span class="tok-comment">/// The path already exists and the `CREAT` and `EXCL` flags were provided.</span>
    PathAlreadyExists,
    DeviceBusy,

    <span class="tok-comment">/// The underlying filesystem does not support file locks</span>
    FileLocksNotSupported,

    <span class="tok-comment">/// Path contains characters that are disallowed by the underlying filesystem.</span>
    BadPathName,

    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,

    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,

    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,

    <span class="tok-comment">/// One of these three things:</span>
    <span class="tok-comment">/// * pathname  refers to an executable image which is currently being</span>
    <span class="tok-comment">///   executed and write access was requested.</span>
    <span class="tok-comment">/// * pathname refers to a file that is currently in  use  as  a  swap</span>
    <span class="tok-comment">///   file, and the O_TRUNC flag was specified.</span>
    <span class="tok-comment">/// * pathname  refers  to  a file that is currently being read by the</span>
    <span class="tok-comment">///   kernel (e.g., for module/firmware loading), and write access was</span>
    <span class="tok-comment">///   requested.</span>
    FileBusy,

    WouldBlock,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.UnexpectedError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">UnexpectedError</span><a href="#src.zig-std.posix.UnexpectedError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>Unexpected</dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.UnexpectedError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnexpectedError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The Operating System returned an undocumented error code.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// This error is in theory not possible, but it would be better</span>
    <span class="tok-comment">/// to handle this error than to invoke undefined behavior.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// When this error code is observed, it usually means the Zig Standard</span>
    <span class="tok-comment">/// Library needs a small patch to add the error code to the error set for</span>
    <span class="tok-comment">/// the respective function.</span>
    Unexpected,
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.KillError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">KillError</span><a href="#src.zig-std.posix.KillError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>PermissionDenied</dt></div><div><dt>ProcessNotFound</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.KillError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KillError = <span class="tok-kw">error</span>{ ProcessNotFound, PermissionDenied } || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.ReadError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ReadError</span><a href="#src.zig-std.posix.ReadError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error occurs when the file descriptor does
not hold the required rights to read from it.</p>
</dd></div><div><dt>BrokenPipe</dt></div><div><dt>Canceled</dt><dd><p>reading a timerfd with CANCEL_ON_SET will lead to this error
when the clock goes through a discontinuous change</p>
</dd></div><div><dt>ConnectionResetByPeer</dt></div><div><dt>ConnectionTimedOut</dt></div><div><dt>InputOutput</dt></div><div><dt>IsDir</dt></div><div><dt>LockViolation</dt><dd><p>Unable to read file due to lock.</p>
</dd></div><div><dt>NotOpenForReading</dt></div><div><dt>OperationAborted</dt></div><div><dt>ProcessNotFound</dt><dd><p>This error occurs in Linux if the process to be read from
no longer exists.</p>
</dd></div><div><dt>SocketNotConnected</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WouldBlock</dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.ReadError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadError = <span class="tok-kw">error</span>{
    InputOutput,
    SystemResources,
    IsDir,
    OperationAborted,
    BrokenPipe,
    ConnectionResetByPeer,
    ConnectionTimedOut,
    NotOpenForReading,
    SocketNotConnected,

    <span class="tok-comment">/// This error occurs when no global event loop is configured,</span>
    <span class="tok-comment">/// and reading from the file descriptor would block.</span>
    WouldBlock,

    <span class="tok-comment">/// reading a timerfd with CANCEL_ON_SET will lead to this error</span>
    <span class="tok-comment">/// when the clock goes through a discontinuous change</span>
    Canceled,

    <span class="tok-comment">/// In WASI, this error occurs when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to read from it.</span>
    AccessDenied,

    <span class="tok-comment">/// This error occurs in Linux if the process to be read from</span>
    <span class="tok-comment">/// no longer exists.</span>
    ProcessNotFound,

    <span class="tok-comment">/// Unable to read file due to lock.</span>
    LockViolation,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.PReadError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">PReadError</span><a href="#src.zig-std.posix.PReadError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>In WASI, this error occurs when the file descriptor does
not hold the required rights to read from it.</p>
</dd></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>Canceled <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>reading a timerfd with CANCEL_ON_SET will lead to this error
when the clock goes through a discontinuous change</p>
</dd></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>ConnectionTimedOut <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>InputOutput <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>IsDir <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>LockViolation <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>Unable to read file due to lock.</p>
</dd></div><div><dt>NotOpenForReading <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>OperationAborted <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs in Linux if the process to be read from
no longer exists.</p>
</dd></div><div><dt>SocketNotConnected <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>Unseekable</dt></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.PReadError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PReadError = <a href="std.posix.html#std.posix.ReadError">ReadError</a> || <span class="tok-kw">error</span>{Unseekable}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.TruncateError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">TruncateError</span><a href="#src.zig-std.posix.TruncateError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error occurs when the file descriptor does
not hold the required rights to call <code><a href="std.posix.html#std.posix.ftruncate">ftruncate</a></code> on it.</p>
</dd></div><div><dt>FileBusy</dt></div><div><dt>FileTooBig</dt></div><div><dt>InputOutput</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.TruncateError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TruncateError = <span class="tok-kw">error</span>{
    FileTooBig,
    InputOutput,
    FileBusy,

    <span class="tok-comment">/// In WASI, this error occurs when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to call `ftruncate` on it.</span>
    AccessDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.WriteError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">WriteError</span><a href="#src.zig-std.posix.WriteError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>File descriptor does not hold the required rights to write to it.</p>
</dd></div><div><dt>BrokenPipe</dt></div><div><dt>ConnectionResetByPeer</dt><dd><p>Connection reset by peer.</p>
</dd></div><div><dt>DeviceBusy</dt></div><div><dt>DiskQuota</dt></div><div><dt>FileTooBig</dt></div><div><dt>InputOutput</dt></div><div><dt>InvalidArgument</dt></div><div><dt>LockViolation</dt><dd><p>The process cannot access the file because another process has locked
a portion of the file. Windows-only.</p>
</dd></div><div><dt>NoDevice</dt><dd><p>This error occurs when a device gets disconnected before or mid-flush
while it's being written to - errno(6): No such device or address.</p>
</dd></div><div><dt>NoSpaceLeft</dt></div><div><dt>NotOpenForWriting</dt></div><div><dt>OperationAborted</dt></div><div><dt>ProcessNotFound</dt><dd><p>This error occurs in Linux if the process being written to
no longer exists.</p>
</dd></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WouldBlock</dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.WriteError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteError = <span class="tok-kw">error</span>{
    DiskQuota,
    FileTooBig,
    InputOutput,
    NoSpaceLeft,
    DeviceBusy,
    InvalidArgument,

    <span class="tok-comment">/// File descriptor does not hold the required rights to write to it.</span>
    AccessDenied,
    BrokenPipe,
    SystemResources,
    OperationAborted,
    NotOpenForWriting,

    <span class="tok-comment">/// The process cannot access the file because another process has locked</span>
    <span class="tok-comment">/// a portion of the file. Windows-only.</span>
    LockViolation,

    <span class="tok-comment">/// This error occurs when no global event loop is configured,</span>
    <span class="tok-comment">/// and reading from the file descriptor would block.</span>
    WouldBlock,

    <span class="tok-comment">/// Connection reset by peer.</span>
    ConnectionResetByPeer,

    <span class="tok-comment">/// This error occurs in Linux if the process being written to</span>
    <span class="tok-comment">/// no longer exists.</span>
    ProcessNotFound,
    <span class="tok-comment">/// This error occurs when a device gets disconnected before or mid-flush</span>
    <span class="tok-comment">/// while it's being written to - errno(6): No such device or address.</span>
    NoDevice,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.PWriteError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">PWriteError</span><a href="#src.zig-std.posix.PWriteError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>File descriptor does not hold the required rights to write to it.</p>
</dd></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>Connection reset by peer.</p>
</dd></div><div><dt>DeviceBusy <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>DiskQuota <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>FileTooBig <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>InputOutput <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>InvalidArgument <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>LockViolation <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>The process cannot access the file because another process has locked
a portion of the file. Windows-only.</p>
</dd></div><div><dt>NoDevice <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>This error occurs when a device gets disconnected before or mid-flush
while it's being written to - errno(6): No such device or address.</p>
</dd></div><div><dt>NoSpaceLeft <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>NotOpenForWriting <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>OperationAborted <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>This error occurs in Linux if the process being written to
no longer exists.</p>
</dd></div><div><dt>SystemResources <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>Unseekable</dt></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.PWriteError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PWriteError = <a href="std.posix.html#std.posix.WriteError">WriteError</a> || <span class="tok-kw">error</span>{Unseekable}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.OpenError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">OpenError</span><a href="#src.zig-std.posix.OpenError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to open a new resource relative to it.</p>
</dd></div><div><dt>BadPathName</dt><dd><p>Path contains characters that are disallowed by the underlying filesystem.</p>
</dd></div><div><dt>DeviceBusy</dt></div><div><dt>FileBusy</dt><dd><p>One of these three things:</p>
<ul>
<li>pathname  refers to an executable image which is currently being
executed and write access was requested.</li>
<li>pathname refers to a file that is currently in  use  as  a  swap
file, and the O_TRUNC flag was specified.</li>
<li>pathname  refers  to  a file that is currently being read by the
kernel (e.g., for module/firmware loading), and write access was
requested.</li>
</ul>
</dd></div><div><dt>FileLocksNotSupported</dt><dd><p>The underlying filesystem does not support file locks</p>
</dd></div><div><dt>FileNotFound</dt><dd><p>Either:</p>
<ul>
<li>One of the path components does not exist.</li>
<li>Cwd was used, but cwd has been deleted.</li>
<li>The path associated with the open directory handle has been deleted.</li>
<li>On macOS, multiple processes or threads raced to create the same file
with <code>O.EXCL</code> set to <code>false</code>.</li>
</ul>
</dd></div><div><dt>FileTooBig</dt><dd><p>The file is too large to be opened. This error is unreachable
for 64-bit targets, as well as when opening directories.</p>
</dd></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir</dt><dd><p>The path refers to directory but the <code>DIRECTORY</code> flag was not provided.</p>
</dd></div><div><dt>NameTooLong</dt><dd><p>The path exceeded <code><a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a></code> bytes.</p>
</dd></div><div><dt>NetworkNotFound</dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NoDevice</dt></div><div><dt>NoSpaceLeft</dt><dd><p>A new path cannot be created because the device has no room for the new file.
This error is only reachable when the <code>CREAT</code> flag is provided.</p>
</dd></div><div><dt>NotDir</dt><dd><p>A component used as a directory in the path was not, in fact, a directory, or
<code>DIRECTORY</code> was specified and the path was not a directory.</p>
</dd></div><div><dt>PathAlreadyExists</dt><dd><p>The path already exists and the <code>CREAT</code> and <code>EXCL</code> flags were provided.</p>
</dd></div><div><dt>ProcessFdQuotaExceeded</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemFdQuotaExceeded</dt></div><div><dt>SystemResources</dt><dd><p>Insufficient kernel memory was available, or
the named file is a FIFO and per-user hard limit on
memory allocation for pipes has been reached.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WouldBlock</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.OpenError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to open a new resource relative to it.</span>
    AccessDenied,
    SymLinkLoop,
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    NoDevice,
    <span class="tok-comment">/// Either:</span>
    <span class="tok-comment">/// * One of the path components does not exist.</span>
    <span class="tok-comment">/// * Cwd was used, but cwd has been deleted.</span>
    <span class="tok-comment">/// * The path associated with the open directory handle has been deleted.</span>
    <span class="tok-comment">/// * On macOS, multiple processes or threads raced to create the same file</span>
    <span class="tok-comment">///   with `O.EXCL` set to `false`.</span>
    FileNotFound,

    <span class="tok-comment">/// The path exceeded `max_path_bytes` bytes.</span>
    NameTooLong,

    <span class="tok-comment">/// Insufficient kernel memory was available, or</span>
    <span class="tok-comment">/// the named file is a FIFO and per-user hard limit on</span>
    <span class="tok-comment">/// memory allocation for pipes has been reached.</span>
    SystemResources,

    <span class="tok-comment">/// The file is too large to be opened. This error is unreachable</span>
    <span class="tok-comment">/// for 64-bit targets, as well as when opening directories.</span>
    FileTooBig,

    <span class="tok-comment">/// The path refers to directory but the `DIRECTORY` flag was not provided.</span>
    IsDir,

    <span class="tok-comment">/// A new path cannot be created because the device has no room for the new file.</span>
    <span class="tok-comment">/// This error is only reachable when the `CREAT` flag is provided.</span>
    NoSpaceLeft,

    <span class="tok-comment">/// A component used as a directory in the path was not, in fact, a directory, or</span>
    <span class="tok-comment">/// `DIRECTORY` was specified and the path was not a directory.</span>
    NotDir,

    <span class="tok-comment">/// The path already exists and the `CREAT` and `EXCL` flags were provided.</span>
    PathAlreadyExists,
    DeviceBusy,

    <span class="tok-comment">/// The underlying filesystem does not support file locks</span>
    FileLocksNotSupported,

    <span class="tok-comment">/// Path contains characters that are disallowed by the underlying filesystem.</span>
    BadPathName,

    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,

    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,

    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,

    <span class="tok-comment">/// One of these three things:</span>
    <span class="tok-comment">/// * pathname  refers to an executable image which is currently being</span>
    <span class="tok-comment">///   executed and write access was requested.</span>
    <span class="tok-comment">/// * pathname refers to a file that is currently in  use  as  a  swap</span>
    <span class="tok-comment">///   file, and the O_TRUNC flag was specified.</span>
    <span class="tok-comment">/// * pathname  refers  to  a file that is currently being read by the</span>
    <span class="tok-comment">///   kernel (e.g., for module/firmware loading), and write access was</span>
    <span class="tok-comment">///   requested.</span>
    FileBusy,

    WouldBlock,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.ExecveError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ExecveError</span><a href="#src.zig-std.posix.ExecveError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>FileBusy</dt></div><div><dt>FileNotFound</dt></div><div><dt>FileSystem</dt></div><div><dt>InvalidExe</dt></div><div><dt>IsDir</dt></div><div><dt>NameTooLong</dt></div><div><dt>NotDir</dt></div><div><dt>ProcessFdQuotaExceeded</dt></div><div><dt>SystemFdQuotaExceeded</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.ExecveError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExecveError = <span class="tok-kw">error</span>{
    SystemResources,
    AccessDenied,
    InvalidExe,
    FileSystem,
    IsDir,
    FileNotFound,
    NotDir,
    FileBusy,
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    NameTooLong,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.GetCwdError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">GetCwdError</span><a href="#src.zig-std.posix.GetCwdError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>CurrentWorkingDirectoryUnlinked</dt></div><div><dt>NameTooLong</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.GetCwdError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetCwdError = <span class="tok-kw">error</span>{
    NameTooLong,
    CurrentWorkingDirectoryUnlinked,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SymLinkError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SymLinkError</span><a href="#src.zig-std.posix.SymLinkError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to create a new symbolic link relative to it.</p>
</dd></div><div><dt>BadPathName</dt></div><div><dt>DiskQuota</dt></div><div><dt>FileNotFound</dt></div><div><dt>FileSystem</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>NameTooLong</dt></div><div><dt>NoSpaceLeft</dt></div><div><dt>NotDir</dt></div><div><dt>PathAlreadyExists</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SymLinkError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SymLinkError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to create a new symbolic link relative to it.</span>
    AccessDenied,
    DiskQuota,
    PathAlreadyExists,
    FileSystem,
    SymLinkLoop,
    FileNotFound,
    SystemResources,
    NoSpaceLeft,
    ReadOnlyFileSystem,
    NotDir,
    NameTooLong,

    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,

    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,

    BadPathName,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.LinkError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">LinkError</span><a href="#src.zig-std.posix.LinkError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>DiskQuota</dt></div><div><dt>FileNotFound</dt></div><div><dt>FileSystem</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>LinkQuotaExceeded</dt></div><div><dt>NameTooLong</dt></div><div><dt>NoSpaceLeft</dt></div><div><dt>NotSameFileSystem</dt></div><div><dt>PathAlreadyExists</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.LinkError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> LinkError = <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a> || <span class="tok-kw">error</span>{
    AccessDenied,
    DiskQuota,
    PathAlreadyExists,
    FileSystem,
    SymLinkLoop,
    LinkQuotaExceeded,
    NameTooLong,
    FileNotFound,
    SystemResources,
    NoSpaceLeft,
    ReadOnlyFileSystem,
    NotSameFileSystem,

    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.LinkatError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">LinkatError</span><a href="#src.zig-std.posix.LinkatError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.LinkError">LinkError</a></dt></div><div><dt>DiskQuota <a href="std.posix.html#std.posix.LinkError">LinkError</a></dt></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.LinkError">LinkError</a></dt></div><div><dt>FileSystem <a href="std.posix.html#std.posix.LinkError">LinkError</a></dt></div><div><dt>InvalidUtf8 <a href="std.posix.html#std.posix.LinkError">LinkError</a></dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>LinkQuotaExceeded <a href="std.posix.html#std.posix.LinkError">LinkError</a></dt></div><div><dt>NameTooLong <a href="std.posix.html#std.posix.LinkError">LinkError</a></dt></div><div><dt>NoSpaceLeft <a href="std.posix.html#std.posix.LinkError">LinkError</a></dt></div><div><dt>NotDir</dt></div><div><dt>NotSameFileSystem <a href="std.posix.html#std.posix.LinkError">LinkError</a></dt></div><div><dt>PathAlreadyExists <a href="std.posix.html#std.posix.LinkError">LinkError</a></dt></div><div><dt>ReadOnlyFileSystem <a href="std.posix.html#std.posix.LinkError">LinkError</a></dt></div><div><dt>SymLinkLoop <a href="std.posix.html#std.posix.LinkError">LinkError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.LinkError">LinkError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.LinkatError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> LinkatError = <a href="std.posix.html#std.posix.LinkError">LinkError</a> || <span class="tok-kw">error</span>{NotDir}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.UnlinkError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">UnlinkError</span><a href="#src.zig-std.posix.UnlinkError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to unlink a resource by path relative to it.</p>
</dd></div><div><dt>BadPathName</dt><dd><p>On Windows, file paths cannot contain these characters:
'/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</p>
</dd></div><div><dt>FileBusy</dt></div><div><dt>FileNotFound</dt></div><div><dt>FileSystem</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir</dt></div><div><dt>NameTooLong</dt></div><div><dt>NetworkNotFound</dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NotDir</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.UnlinkError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnlinkError = <span class="tok-kw">error</span>{
    FileNotFound,

    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to unlink a resource by path relative to it.</span>
    AccessDenied,
    FileBusy,
    FileSystem,
    IsDir,
    SymLinkLoop,
    NameTooLong,
    NotDir,
    SystemResources,
    ReadOnlyFileSystem,

    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,

    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,

    <span class="tok-comment">/// On Windows, file paths cannot contain these characters:</span>
    <span class="tok-comment">/// '/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</span>
    BadPathName,

    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.UnlinkatError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">UnlinkatError</span><a href="#src.zig-std.posix.UnlinkatError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a></dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to unlink a resource by path relative to it.</p>
</dd></div><div><dt>BadPathName <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a></dt><dd><p>On Windows, file paths cannot contain these characters:
'/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</p>
</dd></div><div><dt>DirNotEmpty</dt><dd><p>When passing <code>AT.REMOVEDIR</code>, this error occurs when the named directory is not empty.</p>
</dd></div><div><dt>FileBusy <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a></dt></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a></dt></div><div><dt>FileSystem <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a></dt></div><div><dt>InvalidUtf8 <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a></dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8 <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a></dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a></dt></div><div><dt>NameTooLong <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a></dt></div><div><dt>NetworkNotFound <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a></dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NotDir <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a></dt></div><div><dt>ReadOnlyFileSystem <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a></dt></div><div><dt>SymLinkLoop <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.UnlinkatError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnlinkatError = <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a> || <span class="tok-kw">error</span>{
    <span class="tok-comment">/// When passing `AT.REMOVEDIR`, this error occurs when the named directory is not empty.</span>
    DirNotEmpty,
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.RenameError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">RenameError</span><a href="#src.zig-std.posix.RenameError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to rename a resource by path relative to it.</p>
<p>On Windows, this error may be returned instead of PathAlreadyExists when
renaming a directory over an existing directory.</p>
</dd></div><div><dt>AntivirusInterference</dt><dd><p>On Windows, antivirus software is enabled by default. It can be
disabled, but Windows Update sometimes ignores the user's preference
and re-enables it. When enabled, antivirus software on Windows
intercepts file system operations and makes them significantly slower
in addition to possibly failing with this error code.</p>
</dd></div><div><dt>BadPathName</dt></div><div><dt>DiskQuota</dt></div><div><dt>FileBusy</dt></div><div><dt>FileNotFound</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir</dt></div><div><dt>LinkQuotaExceeded</dt></div><div><dt>NameTooLong</dt></div><div><dt>NetworkNotFound</dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NoDevice</dt></div><div><dt>NoSpaceLeft</dt></div><div><dt>NotDir</dt></div><div><dt>PathAlreadyExists</dt></div><div><dt>PipeBusy</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>RenameAcrossMountPoints</dt></div><div><dt>SharingViolation</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.RenameError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RenameError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to rename a resource by path relative to it.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// On Windows, this error may be returned instead of PathAlreadyExists when</span>
    <span class="tok-comment">/// renaming a directory over an existing directory.</span>
    AccessDenied,
    FileBusy,
    DiskQuota,
    IsDir,
    SymLinkLoop,
    LinkQuotaExceeded,
    NameTooLong,
    FileNotFound,
    NotDir,
    SystemResources,
    NoSpaceLeft,
    PathAlreadyExists,
    ReadOnlyFileSystem,
    RenameAcrossMountPoints,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
    BadPathName,
    NoDevice,
    SharingViolation,
    PipeBusy,
    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
    <span class="tok-comment">/// On Windows, antivirus software is enabled by default. It can be</span>
    <span class="tok-comment">/// disabled, but Windows Update sometimes ignores the user's preference</span>
    <span class="tok-comment">/// and re-enables it. When enabled, antivirus software on Windows</span>
    <span class="tok-comment">/// intercepts file system operations and makes them significantly slower</span>
    <span class="tok-comment">/// in addition to possibly failing with this error code.</span>
    AntivirusInterference,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.MakeDirError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">MakeDirError</span><a href="#src.zig-std.posix.MakeDirError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to create a new directory relative to it.</p>
</dd></div><div><dt>BadPathName</dt></div><div><dt>DiskQuota</dt></div><div><dt>FileNotFound</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>LinkQuotaExceeded</dt></div><div><dt>NameTooLong</dt></div><div><dt>NetworkNotFound</dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NoDevice</dt></div><div><dt>NoSpaceLeft</dt></div><div><dt>NotDir</dt></div><div><dt>PathAlreadyExists</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.MakeDirError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MakeDirError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to create a new directory relative to it.</span>
    AccessDenied,
    DiskQuota,
    PathAlreadyExists,
    SymLinkLoop,
    LinkQuotaExceeded,
    NameTooLong,
    FileNotFound,
    SystemResources,
    NoSpaceLeft,
    NotDir,
    ReadOnlyFileSystem,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
    BadPathName,
    NoDevice,
    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.DeleteDirError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">DeleteDirError</span><a href="#src.zig-std.posix.DeleteDirError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>BadPathName</dt></div><div><dt>DirNotEmpty</dt></div><div><dt>FileBusy</dt></div><div><dt>FileNotFound</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>NameTooLong</dt></div><div><dt>NetworkNotFound</dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NotDir</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.DeleteDirError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeleteDirError = <span class="tok-kw">error</span>{
    AccessDenied,
    FileBusy,
    SymLinkLoop,
    NameTooLong,
    FileNotFound,
    SystemResources,
    NotDir,
    DirNotEmpty,
    ReadOnlyFileSystem,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
    BadPathName,
    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.ChangeCurDirError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ChangeCurDirError</span><a href="#src.zig-std.posix.ChangeCurDirError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>BadPathName</dt></div><div><dt>FileNotFound</dt></div><div><dt>FileSystem</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>NameTooLong</dt></div><div><dt>NotDir</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.ChangeCurDirError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ChangeCurDirError = <span class="tok-kw">error</span>{
    AccessDenied,
    FileSystem,
    SymLinkLoop,
    NameTooLong,
    FileNotFound,
    SystemResources,
    NotDir,
    BadPathName,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FchdirError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FchdirError</span><a href="#src.zig-std.posix.FchdirError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>FileSystem</dt></div><div><dt>NotDir</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FchdirError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FchdirError = <span class="tok-kw">error</span>{
    AccessDenied,
    NotDir,
    FileSystem,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.ReadLinkError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ReadLinkError</span><a href="#src.zig-std.posix.ReadLinkError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to read value of a symbolic link relative to it.</p>
</dd></div><div><dt>BadPathName</dt></div><div><dt>FileNotFound</dt></div><div><dt>FileSystem</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>NameTooLong</dt></div><div><dt>NetworkNotFound</dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NotDir</dt></div><div><dt>NotLink</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>UnsupportedReparsePointType</dt><dd><p>Windows-only. This error may occur if the opened reparse point is
of unsupported type.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.ReadLinkError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadLinkError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to read value of a symbolic link relative to it.</span>
    AccessDenied,
    FileSystem,
    SymLinkLoop,
    NameTooLong,
    FileNotFound,
    SystemResources,
    NotLink,
    NotDir,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
    BadPathName,
    <span class="tok-comment">/// Windows-only. This error may occur if the opened reparse point is</span>
    <span class="tok-comment">/// of unsupported type.</span>
    UnsupportedReparsePointType,
    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SetEidError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SetEidError</span><a href="#src.zig-std.posix.SetEidError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>InvalidUserId</dt></div><div><dt>PermissionDenied</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SetEidError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SetEidError = <span class="tok-kw">error</span>{
    InvalidUserId,
    PermissionDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SetIdError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SetIdError</span><a href="#src.zig-std.posix.SetIdError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>InvalidUserId <a href="std.posix.html#std.posix.SetEidError">SetEidError</a></dt></div><div><dt>PermissionDenied <a href="std.posix.html#std.posix.SetEidError">SetEidError</a></dt></div><div><dt>ResourceLimitReached</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SetIdError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SetIdError = <span class="tok-kw">error</span>{ResourceLimitReached} || <a href="std.posix.html#std.posix.SetEidError">SetEidError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SetPgidError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SetPgidError</span><a href="#src.zig-std.posix.SetPgidError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>InvalidProcessGroupId</dt></div><div><dt>PermissionDenied</dt></div><div><dt>ProcessAlreadyExec</dt></div><div><dt>ProcessNotFound</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SetPgidError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SetPgidError = <span class="tok-kw">error</span>{
    ProcessAlreadyExec,
    InvalidProcessGroupId,
    PermissionDenied,
    ProcessNotFound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SocketError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SocketError</span><a href="#src.zig-std.posix.SocketError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AddressFamilyNotSupported</dt><dd><p>The implementation does not support the specified address family.</p>
</dd></div><div><dt>PermissionDenied</dt><dd><p>Permission to create a socket of the specified type and/or
pro‐tocol is denied.</p>
</dd></div><div><dt>ProcessFdQuotaExceeded</dt><dd><p>The per-process limit on the number of open file descriptors has been reached.</p>
</dd></div><div><dt>ProtocolFamilyNotAvailable</dt><dd><p>Unknown protocol, or protocol family not available.</p>
</dd></div><div><dt>ProtocolNotSupported</dt><dd><p>The protocol type or the specified protocol is not supported within this domain.</p>
</dd></div><div><dt>SocketTypeNotSupported</dt><dd><p>The socket type is not supported by the protocol.</p>
</dd></div><div><dt>SystemFdQuotaExceeded</dt><dd><p>The system-wide limit on the total number of open files has been reached.</p>
</dd></div><div><dt>SystemResources</dt><dd><p>Insufficient memory is available. The socket cannot be created until sufficient
resources are freed.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SocketError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SocketError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// Permission to create a socket of the specified type and/or</span>
    <span class="tok-comment">/// pro‐tocol is denied.</span>
    PermissionDenied,

    <span class="tok-comment">/// The implementation does not support the specified address family.</span>
    AddressFamilyNotSupported,

    <span class="tok-comment">/// Unknown protocol, or protocol family not available.</span>
    ProtocolFamilyNotAvailable,

    <span class="tok-comment">/// The per-process limit on the number of open file descriptors has been reached.</span>
    ProcessFdQuotaExceeded,

    <span class="tok-comment">/// The system-wide limit on the total number of open files has been reached.</span>
    SystemFdQuotaExceeded,

    <span class="tok-comment">/// Insufficient memory is available. The socket cannot be created until sufficient</span>
    <span class="tok-comment">/// resources are freed.</span>
    SystemResources,

    <span class="tok-comment">/// The protocol type or the specified protocol is not supported within this domain.</span>
    ProtocolNotSupported,

    <span class="tok-comment">/// The socket type is not supported by the protocol.</span>
    SocketTypeNotSupported,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.ShutdownError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ShutdownError</span><a href="#src.zig-std.posix.ShutdownError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>BlockingOperationInProgress</dt></div><div><dt>ConnectionAborted</dt></div><div><dt>ConnectionResetByPeer</dt><dd><p>Connection was reset by peer, application should close socket as it is no longer usable.</p>
</dd></div><div><dt>NetworkSubsystemFailed</dt><dd><p>The network subsystem has failed.</p>
</dd></div><div><dt>SocketNotConnected</dt><dd><p>The socket is not connected (connection-oriented sockets only).</p>
</dd></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.ShutdownError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ShutdownError = <span class="tok-kw">error</span>{
    ConnectionAborted,

    <span class="tok-comment">/// Connection was reset by peer, application should close socket as it is no longer usable.</span>
    ConnectionResetByPeer,
    BlockingOperationInProgress,

    <span class="tok-comment">/// The network subsystem has failed.</span>
    NetworkSubsystemFailed,

    <span class="tok-comment">/// The socket is not connected (connection-oriented sockets only).</span>
    SocketNotConnected,
    SystemResources,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.BindError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">BindError</span><a href="#src.zig-std.posix.BindError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>The address is protected, and the user is not the superuser.
For UNIX domain sockets: Search permission is denied on  a  component
of  the  path  prefix.</p>
</dd></div><div><dt>AddressFamilyNotSupported</dt><dd><p>The address is not valid for the address family of socket.</p>
</dd></div><div><dt>AddressInUse</dt><dd><p>The given address is already in use, or in the case of Internet domain sockets,
The  port number was specified as zero in the socket
address structure, but, upon attempting to bind to  an  ephemeral  port,  it  was
determined  that  all  port  numbers in the ephemeral port range are currently in
use.  See the discussion of /proc/sys/net/ipv4/ip_local_port_range ip(7).</p>
</dd></div><div><dt>AddressNotAvailable</dt><dd><p>A nonexistent interface was requested or the requested address was not local.</p>
</dd></div><div><dt>AlreadyBound</dt></div><div><dt>FileDescriptorNotASocket</dt></div><div><dt>FileNotFound</dt><dd><p>A component in the directory prefix of the socket pathname does not exist.</p>
</dd></div><div><dt>NameTooLong</dt><dd><p>addr is too long.</p>
</dd></div><div><dt>NetworkSubsystemFailed</dt><dd><p>The network subsystem has failed.</p>
</dd></div><div><dt>NotDir</dt><dd><p>A component of the path prefix is not a directory.</p>
</dd></div><div><dt>ReadOnlyFileSystem</dt><dd><p>The socket inode would reside on a read-only filesystem.</p>
</dd></div><div><dt>SymLinkLoop</dt><dd><p>Too many symbolic links were encountered in resolving addr.</p>
</dd></div><div><dt>SystemResources</dt><dd><p>Insufficient kernel memory was available.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.BindError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> BindError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The address is protected, and the user is not the superuser.</span>
    <span class="tok-comment">/// For UNIX domain sockets: Search permission is denied on  a  component</span>
    <span class="tok-comment">/// of  the  path  prefix.</span>
    AccessDenied,

    <span class="tok-comment">/// The given address is already in use, or in the case of Internet domain sockets,</span>
    <span class="tok-comment">/// The  port number was specified as zero in the socket</span>
    <span class="tok-comment">/// address structure, but, upon attempting to bind to  an  ephemeral  port,  it  was</span>
    <span class="tok-comment">/// determined  that  all  port  numbers in the ephemeral port range are currently in</span>
    <span class="tok-comment">/// use.  See the discussion of /proc/sys/net/ipv4/ip_local_port_range ip(7).</span>
    AddressInUse,

    <span class="tok-comment">/// A nonexistent interface was requested or the requested address was not local.</span>
    AddressNotAvailable,

    <span class="tok-comment">/// The address is not valid for the address family of socket.</span>
    AddressFamilyNotSupported,

    <span class="tok-comment">/// Too many symbolic links were encountered in resolving addr.</span>
    SymLinkLoop,

    <span class="tok-comment">/// addr is too long.</span>
    NameTooLong,

    <span class="tok-comment">/// A component in the directory prefix of the socket pathname does not exist.</span>
    FileNotFound,

    <span class="tok-comment">/// Insufficient kernel memory was available.</span>
    SystemResources,

    <span class="tok-comment">/// A component of the path prefix is not a directory.</span>
    NotDir,

    <span class="tok-comment">/// The socket inode would reside on a read-only filesystem.</span>
    ReadOnlyFileSystem,

    <span class="tok-comment">/// The network subsystem has failed.</span>
    NetworkSubsystemFailed,

    FileDescriptorNotASocket,

    AlreadyBound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.ListenError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ListenError</span><a href="#src.zig-std.posix.ListenError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AddressInUse</dt><dd><p>Another socket is already listening on the same port.
For Internet domain sockets, the  socket referred to by sockfd had not previously
been bound to an address and, upon attempting to bind it to an ephemeral port, it
was determined that all port numbers in the ephemeral port range are currently in
use.  See the discussion of /proc/sys/net/ipv4/ip_local_port_range in ip(7).</p>
</dd></div><div><dt>AlreadyConnected</dt><dd><p>Already connected</p>
</dd></div><div><dt>FileDescriptorNotASocket</dt><dd><p>The file descriptor sockfd does not refer to a socket.</p>
</dd></div><div><dt>NetworkSubsystemFailed</dt><dd><p>The network subsystem has failed.</p>
</dd></div><div><dt>OperationNotSupported</dt><dd><p>The socket is not of a type that supports the listen() operation.</p>
</dd></div><div><dt>SocketNotBound</dt><dd><p>Socket has not been bound yet</p>
</dd></div><div><dt>SystemResources</dt><dd><p>Ran out of system resources
On Windows it can either run out of socket descriptors or buffer space</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.ListenError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ListenError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// Another socket is already listening on the same port.</span>
    <span class="tok-comment">/// For Internet domain sockets, the  socket referred to by sockfd had not previously</span>
    <span class="tok-comment">/// been bound to an address and, upon attempting to bind it to an ephemeral port, it</span>
    <span class="tok-comment">/// was determined that all port numbers in the ephemeral port range are currently in</span>
    <span class="tok-comment">/// use.  See the discussion of /proc/sys/net/ipv4/ip_local_port_range in ip(7).</span>
    AddressInUse,

    <span class="tok-comment">/// The file descriptor sockfd does not refer to a socket.</span>
    FileDescriptorNotASocket,

    <span class="tok-comment">/// The socket is not of a type that supports the listen() operation.</span>
    OperationNotSupported,

    <span class="tok-comment">/// The network subsystem has failed.</span>
    NetworkSubsystemFailed,

    <span class="tok-comment">/// Ran out of system resources</span>
    <span class="tok-comment">/// On Windows it can either run out of socket descriptors or buffer space</span>
    SystemResources,

    <span class="tok-comment">/// Already connected</span>
    AlreadyConnected,

    <span class="tok-comment">/// Socket has not been bound yet</span>
    SocketNotBound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.AcceptError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">AcceptError</span><a href="#src.zig-std.posix.AcceptError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>BlockedByFirewall</dt><dd><p>Firewall rules forbid connection.</p>
</dd></div><div><dt>ConnectionAborted</dt></div><div><dt>ConnectionResetByPeer</dt><dd><p>An incoming connection was indicated, but was subsequently terminated by the
remote peer prior to accepting the call.</p>
</dd></div><div><dt>FileDescriptorNotASocket</dt><dd><p>The file descriptor sockfd does not refer to a socket.</p>
</dd></div><div><dt>NetworkSubsystemFailed</dt><dd><p>The network subsystem has failed.</p>
</dd></div><div><dt>OperationNotSupported</dt><dd><p>The referenced socket is not a type that supports connection-oriented service.</p>
</dd></div><div><dt>ProcessFdQuotaExceeded</dt><dd><p>The per-process limit on the number of open file descriptors has been reached.</p>
</dd></div><div><dt>ProtocolFailure</dt></div><div><dt>SocketNotListening</dt><dd><p>Socket is not listening for new connections.</p>
</dd></div><div><dt>SystemFdQuotaExceeded</dt><dd><p>The system-wide limit on the total number of open files has been reached.</p>
</dd></div><div><dt>SystemResources</dt><dd><p>Not enough free memory.  This often means that the memory allocation  is  limited
by the socket buffer limits, not by the system memory.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WouldBlock</dt><dd><p>This error occurs when no global event loop is configured,
and accepting from the socket would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.AcceptError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AcceptError = <span class="tok-kw">error</span>{
    ConnectionAborted,

    <span class="tok-comment">/// The file descriptor sockfd does not refer to a socket.</span>
    FileDescriptorNotASocket,

    <span class="tok-comment">/// The per-process limit on the number of open file descriptors has been reached.</span>
    ProcessFdQuotaExceeded,

    <span class="tok-comment">/// The system-wide limit on the total number of open files has been reached.</span>
    SystemFdQuotaExceeded,

    <span class="tok-comment">/// Not enough free memory.  This often means that the memory allocation  is  limited</span>
    <span class="tok-comment">/// by the socket buffer limits, not by the system memory.</span>
    SystemResources,

    <span class="tok-comment">/// Socket is not listening for new connections.</span>
    SocketNotListening,

    ProtocolFailure,

    <span class="tok-comment">/// Firewall rules forbid connection.</span>
    BlockedByFirewall,

    <span class="tok-comment">/// This error occurs when no global event loop is configured,</span>
    <span class="tok-comment">/// and accepting from the socket would block.</span>
    WouldBlock,

    <span class="tok-comment">/// An incoming connection was indicated, but was subsequently terminated by the</span>
    <span class="tok-comment">/// remote peer prior to accepting the call.</span>
    ConnectionResetByPeer,

    <span class="tok-comment">/// The network subsystem has failed.</span>
    NetworkSubsystemFailed,

    <span class="tok-comment">/// The referenced socket is not a type that supports connection-oriented service.</span>
    OperationNotSupported,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.EpollCreateError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">EpollCreateError</span><a href="#src.zig-std.posix.EpollCreateError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>ProcessFdQuotaExceeded</dt><dd><p>The  per-user   limit   on   the   number   of   epoll   instances   imposed   by
/proc/sys/fs/epoll/max_user_instances  was encountered.  See epoll(7) for further
details.
Or, The per-process limit on the number of open file descriptors has been reached.</p>
</dd></div><div><dt>SystemFdQuotaExceeded</dt><dd><p>The system-wide limit on the total number of open files has been reached.</p>
</dd></div><div><dt>SystemResources</dt><dd><p>There was insufficient memory to create the kernel object.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.EpollCreateError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> EpollCreateError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The  per-user   limit   on   the   number   of   epoll   instances   imposed   by</span>
    <span class="tok-comment">/// /proc/sys/fs/epoll/max_user_instances  was encountered.  See epoll(7) for further</span>
    <span class="tok-comment">/// details.</span>
    <span class="tok-comment">/// Or, The per-process limit on the number of open file descriptors has been reached.</span>
    ProcessFdQuotaExceeded,

    <span class="tok-comment">/// The system-wide limit on the total number of open files has been reached.</span>
    SystemFdQuotaExceeded,

    <span class="tok-comment">/// There was insufficient memory to create the kernel object.</span>
    SystemResources,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.EpollCtlError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">EpollCtlError</span><a href="#src.zig-std.posix.EpollCtlError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>FileDescriptorAlreadyPresentInSet</dt><dd><p>op was EPOLL_CTL_ADD, and the supplied file descriptor fd is  already  registered
with this epoll instance.</p>
</dd></div><div><dt>FileDescriptorIncompatibleWithEpoll</dt><dd><p>The target file fd does not support epoll.  This error can occur if fd refers to,
for example, a regular file or a directory.</p>
</dd></div><div><dt>FileDescriptorNotRegistered</dt><dd><p>op was EPOLL_CTL_MOD or EPOLL_CTL_DEL, and fd is not registered with  this  epoll
instance.</p>
</dd></div><div><dt>OperationCausesCircularLoop</dt><dd><p>fd refers to an epoll instance and this EPOLL_CTL_ADD operation would result in a
circular loop of epoll instances monitoring one another.</p>
</dd></div><div><dt>SystemResources</dt><dd><p>There was insufficient memory to handle the requested op control operation.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>UserResourceLimitReached</dt><dd><p>The  limit  imposed  by /proc/sys/fs/epoll/max_user_watches was encountered while
trying to register (EPOLL_CTL_ADD) a new file descriptor on  an  epoll  instance.
See epoll(7) for further details.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.EpollCtlError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> EpollCtlError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// op was EPOLL_CTL_ADD, and the supplied file descriptor fd is  already  registered</span>
    <span class="tok-comment">/// with this epoll instance.</span>
    FileDescriptorAlreadyPresentInSet,

    <span class="tok-comment">/// fd refers to an epoll instance and this EPOLL_CTL_ADD operation would result in a</span>
    <span class="tok-comment">/// circular loop of epoll instances monitoring one another.</span>
    OperationCausesCircularLoop,

    <span class="tok-comment">/// op was EPOLL_CTL_MOD or EPOLL_CTL_DEL, and fd is not registered with  this  epoll</span>
    <span class="tok-comment">/// instance.</span>
    FileDescriptorNotRegistered,

    <span class="tok-comment">/// There was insufficient memory to handle the requested op control operation.</span>
    SystemResources,

    <span class="tok-comment">/// The  limit  imposed  by /proc/sys/fs/epoll/max_user_watches was encountered while</span>
    <span class="tok-comment">/// trying to register (EPOLL_CTL_ADD) a new file descriptor on  an  epoll  instance.</span>
    <span class="tok-comment">/// See epoll(7) for further details.</span>
    UserResourceLimitReached,

    <span class="tok-comment">/// The target file fd does not support epoll.  This error can occur if fd refers to,</span>
    <span class="tok-comment">/// for example, a regular file or a directory.</span>
    FileDescriptorIncompatibleWithEpoll,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.EventFdError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">EventFdError</span><a href="#src.zig-std.posix.EventFdError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>ProcessFdQuotaExceeded</dt></div><div><dt>SystemFdQuotaExceeded</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.EventFdError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> EventFdError = <span class="tok-kw">error</span>{
    SystemResources,
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.GetSockNameError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">GetSockNameError</span><a href="#src.zig-std.posix.GetSockNameError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>FileDescriptorNotASocket</dt></div><div><dt>NetworkSubsystemFailed</dt><dd><p>The network subsystem has failed.</p>
</dd></div><div><dt>SocketNotBound</dt><dd><p>Socket hasn't been bound yet</p>
</dd></div><div><dt>SystemResources</dt><dd><p>Insufficient resources were available in the system to perform the operation.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.GetSockNameError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetSockNameError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// Insufficient resources were available in the system to perform the operation.</span>
    SystemResources,

    <span class="tok-comment">/// The network subsystem has failed.</span>
    NetworkSubsystemFailed,

    <span class="tok-comment">/// Socket hasn't been bound yet</span>
    SocketNotBound,

    FileDescriptorNotASocket,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.ConnectError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ConnectError</span><a href="#src.zig-std.posix.ConnectError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AddressFamilyNotSupported</dt><dd><p>The passed address didn't have the correct address family in its sa_family field.</p>
</dd></div><div><dt>AddressInUse</dt><dd><p>Local address is already in use.</p>
</dd></div><div><dt>AddressNotAvailable</dt><dd><p>(Internet  domain  sockets)  The  socket  referred  to  by sockfd had not previously been bound to an
address and, upon attempting to bind it to an ephemeral port, it was determined that all port numbers
in    the    ephemeral    port    range    are   currently   in   use.    See   the   discussion   of
/proc/sys/net/ipv4/ip_local_port_range in ip(7).</p>
</dd></div><div><dt>ConnectionPending</dt><dd><p>Socket is non-blocking and already has a pending connection in progress.</p>
</dd></div><div><dt>ConnectionRefused</dt><dd><p>A connect() on a stream socket found no one listening on the remote address.</p>
</dd></div><div><dt>ConnectionResetByPeer</dt><dd><p>Connection was reset by peer before connect could complete.</p>
</dd></div><div><dt>ConnectionTimedOut</dt><dd><p>Timeout  while  attempting  connection.   The server may be too busy to accept new connections.  Note
that for IP sockets the timeout may be very long when syncookies are enabled on the server.</p>
</dd></div><div><dt>FileNotFound</dt><dd><p>The given path for the unix socket does not exist.</p>
</dd></div><div><dt>NetworkUnreachable</dt><dd><p>Network is unreachable.</p>
</dd></div><div><dt>PermissionDenied</dt><dd><p>For UNIX domain sockets, which are identified by pathname: Write permission is denied on  the  socket
file,  or  search  permission  is  denied  for  one of the directories in the path prefix.
or
The user tried to connect to a broadcast address without having the socket broadcast flag enabled  or
the connection request failed because of a local firewall rule.</p>
</dd></div><div><dt>SystemResources</dt><dd><p>Insufficient entries in the routing cache.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WouldBlock</dt><dd><p>This error occurs when no global event loop is configured,
and connecting to the socket would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.ConnectError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ConnectError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// For UNIX domain sockets, which are identified by pathname: Write permission is denied on  the  socket</span>
    <span class="tok-comment">/// file,  or  search  permission  is  denied  for  one of the directories in the path prefix.</span>
    <span class="tok-comment">/// or</span>
    <span class="tok-comment">/// The user tried to connect to a broadcast address without having the socket broadcast flag enabled  or</span>
    <span class="tok-comment">/// the connection request failed because of a local firewall rule.</span>
    PermissionDenied,

    <span class="tok-comment">/// Local address is already in use.</span>
    AddressInUse,

    <span class="tok-comment">/// (Internet  domain  sockets)  The  socket  referred  to  by sockfd had not previously been bound to an</span>
    <span class="tok-comment">/// address and, upon attempting to bind it to an ephemeral port, it was determined that all port numbers</span>
    <span class="tok-comment">/// in    the    ephemeral    port    range    are   currently   in   use.    See   the   discussion   of</span>
    <span class="tok-comment">/// /proc/sys/net/ipv4/ip_local_port_range in ip(7).</span>
    AddressNotAvailable,

    <span class="tok-comment">/// The passed address didn't have the correct address family in its sa_family field.</span>
    AddressFamilyNotSupported,

    <span class="tok-comment">/// Insufficient entries in the routing cache.</span>
    SystemResources,

    <span class="tok-comment">/// A connect() on a stream socket found no one listening on the remote address.</span>
    ConnectionRefused,

    <span class="tok-comment">/// Network is unreachable.</span>
    NetworkUnreachable,

    <span class="tok-comment">/// Timeout  while  attempting  connection.   The server may be too busy to accept new connections.  Note</span>
    <span class="tok-comment">/// that for IP sockets the timeout may be very long when syncookies are enabled on the server.</span>
    ConnectionTimedOut,

    <span class="tok-comment">/// This error occurs when no global event loop is configured,</span>
    <span class="tok-comment">/// and connecting to the socket would block.</span>
    WouldBlock,

    <span class="tok-comment">/// The given path for the unix socket does not exist.</span>
    FileNotFound,

    <span class="tok-comment">/// Connection was reset by peer before connect could complete.</span>
    ConnectionResetByPeer,

    <span class="tok-comment">/// Socket is non-blocking and already has a pending connection in progress.</span>
    ConnectionPending,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.GetSockOptError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">GetSockOptError</span><a href="#src.zig-std.posix.GetSockOptError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>The calling process does not have the appropriate privileges.</p>
</dd></div><div><dt>InvalidProtocolOption</dt><dd><p>The option is not supported by the protocol.</p>
</dd></div><div><dt>SystemResources</dt><dd><p>Insufficient resources are available in the system to complete the call.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.GetSockOptError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetSockOptError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The calling process does not have the appropriate privileges.</span>
    AccessDenied,

    <span class="tok-comment">/// The option is not supported by the protocol.</span>
    InvalidProtocolOption,

    <span class="tok-comment">/// Insufficient resources are available in the system to complete the call.</span>
    SystemResources,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FStatError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FStatError</span><a href="#src.zig-std.posix.FStatError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to get its filestat information.</p>
</dd></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FStatError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FStatError = <span class="tok-kw">error</span>{
    SystemResources,

    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to get its filestat information.</span>
    AccessDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FStatAtError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FStatAtError</span><a href="#src.zig-std.posix.FStatAtError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.FStatError">FStatError</a></dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to get its filestat information.</p>
</dd></div><div><dt>FileNotFound</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>NameTooLong</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.FStatError">FStatError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FStatAtError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FStatAtError = <a href="std.posix.html#std.posix.FStatError">FStatError</a> || <span class="tok-kw">error</span>{
    NameTooLong,
    FileNotFound,
    SymLinkLoop,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.KQueueError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">KQueueError</span><a href="#src.zig-std.posix.KQueueError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>ProcessFdQuotaExceeded</dt><dd><p>The per-process limit on the number of open file descriptors has been reached.</p>
</dd></div><div><dt>SystemFdQuotaExceeded</dt><dd><p>The system-wide limit on the total number of open files has been reached.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.KQueueError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KQueueError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The per-process limit on the number of open file descriptors has been reached.</span>
    ProcessFdQuotaExceeded,

    <span class="tok-comment">/// The system-wide limit on the total number of open files has been reached.</span>
    SystemFdQuotaExceeded,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.KEventError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">KEventError</span><a href="#src.zig-std.posix.KEventError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>The process does not have permission to register a filter.</p>
</dd></div><div><dt>EventNotFound</dt><dd><p>The event could not be found to be modified or deleted.</p>
</dd></div><div><dt>Overflow</dt><dd><p>changelist or eventlist had too many items on it.
TODO remove this possibility</p>
</dd></div><div><dt>ProcessNotFound</dt><dd><p>The specified process to attach to does not exist.</p>
</dd></div><div><dt>SystemResources</dt><dd><p>No memory was available to register the event.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.KEventError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KEventError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The process does not have permission to register a filter.</span>
    AccessDenied,

    <span class="tok-comment">/// The event could not be found to be modified or deleted.</span>
    EventNotFound,

    <span class="tok-comment">/// No memory was available to register the event.</span>
    SystemResources,

    <span class="tok-comment">/// The specified process to attach to does not exist.</span>
    ProcessNotFound,

    <span class="tok-comment">/// changelist or eventlist had too many items on it.</span>
    <span class="tok-comment">/// TODO remove this possibility</span>
    Overflow,
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.INotifyInitError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">INotifyInitError</span><a href="#src.zig-std.posix.INotifyInitError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>ProcessFdQuotaExceeded</dt></div><div><dt>SystemFdQuotaExceeded</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.INotifyInitError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> INotifyInitError = <span class="tok-kw">error</span>{
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    SystemResources,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.INotifyAddWatchError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">INotifyAddWatchError</span><a href="#src.zig-std.posix.INotifyAddWatchError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>FileNotFound</dt></div><div><dt>NameTooLong</dt></div><div><dt>NotDir</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>UserResourceLimitReached</dt></div><div><dt>WatchAlreadyExists</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.INotifyAddWatchError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> INotifyAddWatchError = <span class="tok-kw">error</span>{
    AccessDenied,
    NameTooLong,
    FileNotFound,
    SystemResources,
    UserResourceLimitReached,
    NotDir,
    WatchAlreadyExists,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FanotifyInitError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FanotifyInitError</span><a href="#src.zig-std.posix.FanotifyInitError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>PermissionDenied</dt></div><div><dt>ProcessFdQuotaExceeded</dt></div><div><dt>SystemFdQuotaExceeded</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>UnsupportedFlags</dt><dd><p>The kernel does not recognize the flags passed, likely because it is an
older version.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FanotifyInitError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FanotifyInitError = <span class="tok-kw">error</span>{
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    SystemResources,
    PermissionDenied,
    <span class="tok-comment">/// The kernel does not recognize the flags passed, likely because it is an</span>
    <span class="tok-comment">/// older version.</span>
    UnsupportedFlags,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FanotifyMarkError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FanotifyMarkError</span><a href="#src.zig-std.posix.FanotifyMarkError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>FileNotFound</dt></div><div><dt>IsDir</dt></div><div><dt>MarkAlreadyExists</dt></div><div><dt>NameTooLong</dt></div><div><dt>NotAssociatedWithFileSystem</dt></div><div><dt>NotDir</dt></div><div><dt>NotSameFileSystem</dt></div><div><dt>OperationNotSupported</dt></div><div><dt>PermissionDenied</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>UserMarkQuotaExceeded</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FanotifyMarkError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FanotifyMarkError = <span class="tok-kw">error</span>{
    MarkAlreadyExists,
    IsDir,
    NotAssociatedWithFileSystem,
    FileNotFound,
    SystemResources,
    UserMarkQuotaExceeded,
    NotDir,
    OperationNotSupported,
    PermissionDenied,
    NotSameFileSystem,
    NameTooLong,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.MProtectError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">MProtectError</span><a href="#src.zig-std.posix.MProtectError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>The memory cannot be given the specified access.  This can happen, for example, if you
mmap(2)  a  file  to  which  you have read-only access, then ask mprotect() to mark it
PROT_WRITE.</p>
</dd></div><div><dt>OutOfMemory</dt><dd><p>Changing  the  protection  of a memory region would result in the total number of map‐
pings with distinct attributes (e.g., read versus read/write protection) exceeding the
allowed maximum.  (For example, making the protection of a range PROT_READ in the mid‐
dle of a region currently protected as PROT_READ|PROT_WRITE would result in three map‐
pings: two read/write mappings at each end and a read-only mapping in the middle.)</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.MProtectError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MProtectError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The memory cannot be given the specified access.  This can happen, for example, if you</span>
    <span class="tok-comment">/// mmap(2)  a  file  to  which  you have read-only access, then ask mprotect() to mark it</span>
    <span class="tok-comment">/// PROT_WRITE.</span>
    AccessDenied,

    <span class="tok-comment">/// Changing  the  protection  of a memory region would result in the total number of map‐</span>
    <span class="tok-comment">/// pings with distinct attributes (e.g., read versus read/write protection) exceeding the</span>
    <span class="tok-comment">/// allowed maximum.  (For example, making the protection of a range PROT_READ in the mid‐</span>
    <span class="tok-comment">/// dle of a region currently protected as PROT_READ|PROT_WRITE would result in three map‐</span>
    <span class="tok-comment">/// pings: two read/write mappings at each end and a read-only mapping in the middle.)</span>
    OutOfMemory,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.ForkError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ForkError</span><a href="#src.zig-std.posix.ForkError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.ForkError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ForkError = <span class="tok-kw">error</span>{SystemResources} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.MMapError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">MMapError</span><a href="#src.zig-std.posix.MMapError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>A file descriptor refers to a non-regular file. Or a file mapping was requested,
but the file descriptor is not open for reading. Or <code>MAP.SHARED</code> was requested
and <code>PROT_WRITE</code> is set, but the file descriptor is not open in <code>RDWR</code> mode.
Or <code>PROT_WRITE</code> is set, but the file is append-only.</p>
</dd></div><div><dt>LockedMemoryLimitExceeded</dt></div><div><dt>MappingAlreadyExists</dt><dd><p>Using FIXED_NOREPLACE flag and the process has already mapped memory at the given address</p>
</dd></div><div><dt>MemoryMappingNotSupported</dt><dd><p>The underlying filesystem of the specified file does not support memory mapping.</p>
</dd></div><div><dt>OutOfMemory</dt></div><div><dt>PermissionDenied</dt><dd><p>The <code>prot</code> argument asks for <code>PROT_EXEC</code> but the mapped area belongs to a file on
a filesystem that was mounted no-exec.</p>
</dd></div><div><dt>ProcessFdQuotaExceeded</dt></div><div><dt>SystemFdQuotaExceeded</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.MMapError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MMapError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The underlying filesystem of the specified file does not support memory mapping.</span>
    MemoryMappingNotSupported,

    <span class="tok-comment">/// A file descriptor refers to a non-regular file. Or a file mapping was requested,</span>
    <span class="tok-comment">/// but the file descriptor is not open for reading. Or `MAP.SHARED` was requested</span>
    <span class="tok-comment">/// and `PROT_WRITE` is set, but the file descriptor is not open in `RDWR` mode.</span>
    <span class="tok-comment">/// Or `PROT_WRITE` is set, but the file is append-only.</span>
    AccessDenied,

    <span class="tok-comment">/// The `prot` argument asks for `PROT_EXEC` but the mapped area belongs to a file on</span>
    <span class="tok-comment">/// a filesystem that was mounted no-exec.</span>
    PermissionDenied,
    LockedMemoryLimitExceeded,
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    OutOfMemory,

    <span class="tok-comment">/// Using FIXED_NOREPLACE flag and the process has already mapped memory at the given address</span>
    MappingAlreadyExists,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.MRemapError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">MRemapError</span><a href="#src.zig-std.posix.MRemapError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>InvalidSyscallParameters</dt><dd><p>Either a bug in the calling code, or the operating system abused the
EINVAL error code.</p>
</dd></div><div><dt>LockedMemoryLimitExceeded</dt></div><div><dt>OutOfMemory</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.MRemapError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MRemapError = <span class="tok-kw">error</span>{
    LockedMemoryLimitExceeded,
    <span class="tok-comment">/// Either a bug in the calling code, or the operating system abused the</span>
    <span class="tok-comment">/// EINVAL error code.</span>
    InvalidSyscallParameters,
    OutOfMemory,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.MSyncError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">MSyncError</span><a href="#src.zig-std.posix.MSyncError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>PermissionDenied</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>UnmappedMemory</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.MSyncError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MSyncError = <span class="tok-kw">error</span>{
    UnmappedMemory,
    PermissionDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.AccessError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">AccessError</span><a href="#src.zig-std.posix.AccessError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>BadPathName</dt></div><div><dt>FileBusy</dt></div><div><dt>FileNotFound</dt></div><div><dt>InputOutput</dt></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>NameTooLong</dt></div><div><dt>PermissionDenied</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.AccessError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AccessError = <span class="tok-kw">error</span>{
    PermissionDenied,
    FileNotFound,
    NameTooLong,
    InputOutput,
    SystemResources,
    BadPathName,
    FileBusy,
    SymLinkLoop,
    ReadOnlyFileSystem,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.PipeError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">PipeError</span><a href="#src.zig-std.posix.PipeError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>ProcessFdQuotaExceeded</dt></div><div><dt>SystemFdQuotaExceeded</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.PipeError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PipeError = <span class="tok-kw">error</span>{
    SystemFdQuotaExceeded,
    ProcessFdQuotaExceeded,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SysCtlError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SysCtlError</span><a href="#src.zig-std.posix.SysCtlError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>NameTooLong</dt></div><div><dt>PermissionDenied</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>UnknownName</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SysCtlError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SysCtlError = <span class="tok-kw">error</span>{
    PermissionDenied,
    SystemResources,
    NameTooLong,
    UnknownName,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SeekError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SeekError</span><a href="#src.zig-std.posix.SeekError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to seek on it.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>Unseekable</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SeekError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SeekError = <span class="tok-kw">error</span>{
    Unseekable,

    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to seek on it.</span>
    AccessDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FcntlError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FcntlError</span><a href="#src.zig-std.posix.FcntlError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>DeadLock</dt></div><div><dt>FileBusy</dt></div><div><dt>Locked</dt></div><div><dt>LockedRegionLimitExceeded</dt></div><div><dt>PermissionDenied</dt></div><div><dt>ProcessFdQuotaExceeded</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FcntlError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FcntlError = <span class="tok-kw">error</span>{
    PermissionDenied,
    FileBusy,
    ProcessFdQuotaExceeded,
    Locked,
    DeadLock,
    LockedRegionLimitExceeded,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FlockError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FlockError</span><a href="#src.zig-std.posix.FlockError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>FileLocksNotSupported</dt><dd><p>The underlying filesystem does not support file locks</p>
</dd></div><div><dt>SystemResources</dt><dd><p>The kernel ran out of memory for allocating file locks</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WouldBlock</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FlockError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FlockError = <span class="tok-kw">error</span>{
    WouldBlock,

    <span class="tok-comment">/// The kernel ran out of memory for allocating file locks</span>
    SystemResources,

    <span class="tok-comment">/// The underlying filesystem does not support file locks</span>
    FileLocksNotSupported,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.RealPathError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">RealPathError</span><a href="#src.zig-std.posix.RealPathError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>AntivirusInterference</dt><dd><p>On Windows, antivirus software is enabled by default. It can be
disabled, but Windows Update sometimes ignores the user's preference
and re-enables it. When enabled, antivirus software on Windows
intercepts file system operations and makes them significantly slower
in addition to possibly failing with this error code.</p>
</dd></div><div><dt>BadPathName</dt></div><div><dt>DeviceBusy</dt></div><div><dt>FileNotFound</dt></div><div><dt>FileSystem</dt></div><div><dt>FileTooBig</dt></div><div><dt>InputOutput</dt></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir</dt></div><div><dt>NameTooLong</dt></div><div><dt>NetworkNotFound</dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NoDevice</dt></div><div><dt>NoSpaceLeft</dt></div><div><dt>NotDir</dt></div><div><dt>NotSupported</dt></div><div><dt>PathAlreadyExists</dt></div><div><dt>PipeBusy</dt></div><div><dt>ProcessFdQuotaExceeded</dt></div><div><dt>SharingViolation</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemFdQuotaExceeded</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>UnrecognizedVolume</dt><dd><p>On Windows, the volume does not contain a recognized file system. File
system drivers might not be loaded, or the volume may be corrupt.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.RealPathError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RealPathError = <span class="tok-kw">error</span>{
    FileNotFound,
    AccessDenied,
    NameTooLong,
    NotSupported,
    NotDir,
    SymLinkLoop,
    InputOutput,
    FileTooBig,
    IsDir,
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    NoDevice,
    SystemResources,
    NoSpaceLeft,
    FileSystem,
    BadPathName,
    DeviceBusy,

    SharingViolation,
    PipeBusy,

    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,

    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,

    PathAlreadyExists,

    <span class="tok-comment">/// On Windows, antivirus software is enabled by default. It can be</span>
    <span class="tok-comment">/// disabled, but Windows Update sometimes ignores the user's preference</span>
    <span class="tok-comment">/// and re-enables it. When enabled, antivirus software on Windows</span>
    <span class="tok-comment">/// intercepts file system operations and makes them significantly slower</span>
    <span class="tok-comment">/// in addition to possibly failing with this error code.</span>
    AntivirusInterference,

    <span class="tok-comment">/// On Windows, the volume does not contain a recognized file system. File</span>
    <span class="tok-comment">/// system drivers might not be loaded, or the volume may be corrupt.</span>
    UnrecognizedVolume,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.ClockGetTimeError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ClockGetTimeError</span><a href="#src.zig-std.posix.ClockGetTimeError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>UnsupportedClock</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.ClockGetTimeError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ClockGetTimeError = <span class="tok-kw">error</span>{UnsupportedClock} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SchedGetAffinityError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SchedGetAffinityError</span><a href="#src.zig-std.posix.SchedGetAffinityError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>PermissionDenied</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SchedGetAffinityError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SchedGetAffinityError = <span class="tok-kw">error</span>{PermissionDenied} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SigaltstackError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SigaltstackError</span><a href="#src.zig-std.posix.SigaltstackError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>PermissionDenied</dt><dd><p>Attempted to change the signal stack while it was active.</p>
</dd></div><div><dt>SizeTooSmall</dt><dd><p>The supplied stack size was less than MINSIGSTKSZ.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SigaltstackError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SigaltstackError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The supplied stack size was less than MINSIGSTKSZ.</span>
    SizeTooSmall,

    <span class="tok-comment">/// Attempted to change the signal stack while it was active.</span>
    PermissionDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FutimensError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FutimensError</span><a href="#src.zig-std.posix.FutimensError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>times is NULL, or both nsec values are UTIME_NOW, and either:</p>
<ul>
<li>the effective user ID of the caller does not match the  owner
of  the  file,  the  caller does not have write access to the
file, and the caller is not privileged (Linux: does not  have
either  the  CAP_FOWNER  or the CAP_DAC_OVERRIDE capability);
or,</li>
<li>the file is marked immutable (see chattr(1)).</li>
</ul>
</dd></div><div><dt>PermissionDenied</dt><dd><p>The caller attempted to change one or both timestamps to a value
other than the current time, or to change one of the  timestamps
to the current time while leaving the other timestamp unchanged,
(i.e., times is not NULL, neither nsec  field  is  UTIME_NOW,
and neither nsec field is UTIME_OMIT) and either:</p>
<ul>
<li>the  caller's  effective  user ID does not match the owner of
file, and the caller is not privileged (Linux: does not  have
the CAP_FOWNER capability); or,</li>
<li>the file is marked append-only or immutable (see chattr(1)).</li>
</ul>
</dd></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FutimensError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FutimensError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// times is NULL, or both nsec values are UTIME_NOW, and either:</span>
    <span class="tok-comment">/// *  the effective user ID of the caller does not match the  owner</span>
    <span class="tok-comment">///    of  the  file,  the  caller does not have write access to the</span>
    <span class="tok-comment">///    file, and the caller is not privileged (Linux: does not  have</span>
    <span class="tok-comment">///    either  the  CAP_FOWNER  or the CAP_DAC_OVERRIDE capability);</span>
    <span class="tok-comment">///    or,</span>
    <span class="tok-comment">/// *  the file is marked immutable (see chattr(1)).</span>
    AccessDenied,

    <span class="tok-comment">/// The caller attempted to change one or both timestamps to a value</span>
    <span class="tok-comment">/// other than the current time, or to change one of the  timestamps</span>
    <span class="tok-comment">/// to the current time while leaving the other timestamp unchanged,</span>
    <span class="tok-comment">/// (i.e., times is not NULL, neither nsec  field  is  UTIME_NOW,</span>
    <span class="tok-comment">/// and neither nsec field is UTIME_OMIT) and either:</span>
    <span class="tok-comment">/// *  the  caller's  effective  user ID does not match the owner of</span>
    <span class="tok-comment">///    file, and the caller is not privileged (Linux: does not  have</span>
    <span class="tok-comment">///    the CAP_FOWNER capability); or,</span>
    <span class="tok-comment">/// *  the file is marked append-only or immutable (see chattr(1)).</span>
    PermissionDenied,

    ReadOnlyFileSystem,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.GetHostNameError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">GetHostNameError</span><a href="#src.zig-std.posix.GetHostNameError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>PermissionDenied</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.GetHostNameError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetHostNameError = <span class="tok-kw">error</span>{PermissionDenied} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SendError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SendError</span><a href="#src.zig-std.posix.SendError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>(For UNIX domain sockets, which are identified by pathname) Write permission is  denied
on  the destination socket file, or search permission is denied for one of the
directories the path prefix.  (See path_resolution(7).)
(For UDP sockets) An attempt was made to send to a network/broadcast address as  though
it was a unicast address.</p>
</dd></div><div><dt>BrokenPipe</dt><dd><p>The  local  end  has been shut down on a connection oriented socket.  In this case, the
process will also receive a SIGPIPE unless MSG.NOSIGNAL is set.</p>
</dd></div><div><dt>ConnectionResetByPeer</dt><dd><p>Connection reset by peer.</p>
</dd></div><div><dt>FastOpenAlreadyInProgress</dt><dd><p>Another Fast Open is already in progress.</p>
</dd></div><div><dt>FileDescriptorNotASocket</dt></div><div><dt>MessageTooBig</dt><dd><p>The  socket  type requires that message be sent atomically, and the size of the message
to be sent made this impossible. The message is not transmitted.</p>
</dd></div><div><dt>NetworkSubsystemFailed</dt><dd><p>The local network interface used to reach the destination is down.</p>
</dd></div><div><dt>NetworkUnreachable</dt><dd><p>Network is unreachable.</p>
</dd></div><div><dt>SystemResources</dt><dd><p>The output queue for a network interface was full.  This generally indicates  that  the
interface  has  stopped sending, but may be caused by transient congestion.  (Normally,
this does not occur in Linux.  Packets are just silently dropped when  a  device  queue
overflows.)
This is also caused when there is not enough kernel memory available.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WouldBlock</dt><dd><p>The socket is marked nonblocking and the requested operation would block, and
there is no global event loop configured.
It's also possible to get this error under the following condition:
(Internet  domain datagram sockets) The socket referred to by sockfd had not previously
been bound to an address and, upon attempting to bind it to an ephemeral port,  it  was
determined that all port numbers in the ephemeral port range are currently in use.  See
the discussion of /proc/sys/net/ipv4/ip_local_port_range in ip(7).</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SendError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SendError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// (For UNIX domain sockets, which are identified by pathname) Write permission is  denied</span>
    <span class="tok-comment">/// on  the destination socket file, or search permission is denied for one of the</span>
    <span class="tok-comment">/// directories the path prefix.  (See path_resolution(7).)</span>
    <span class="tok-comment">/// (For UDP sockets) An attempt was made to send to a network/broadcast address as  though</span>
    <span class="tok-comment">/// it was a unicast address.</span>
    AccessDenied,

    <span class="tok-comment">/// The socket is marked nonblocking and the requested operation would block, and</span>
    <span class="tok-comment">/// there is no global event loop configured.</span>
    <span class="tok-comment">/// It's also possible to get this error under the following condition:</span>
    <span class="tok-comment">/// (Internet  domain datagram sockets) The socket referred to by sockfd had not previously</span>
    <span class="tok-comment">/// been bound to an address and, upon attempting to bind it to an ephemeral port,  it  was</span>
    <span class="tok-comment">/// determined that all port numbers in the ephemeral port range are currently in use.  See</span>
    <span class="tok-comment">/// the discussion of /proc/sys/net/ipv4/ip_local_port_range in ip(7).</span>
    WouldBlock,

    <span class="tok-comment">/// Another Fast Open is already in progress.</span>
    FastOpenAlreadyInProgress,

    <span class="tok-comment">/// Connection reset by peer.</span>
    ConnectionResetByPeer,

    <span class="tok-comment">/// The  socket  type requires that message be sent atomically, and the size of the message</span>
    <span class="tok-comment">/// to be sent made this impossible. The message is not transmitted.</span>
    MessageTooBig,

    <span class="tok-comment">/// The output queue for a network interface was full.  This generally indicates  that  the</span>
    <span class="tok-comment">/// interface  has  stopped sending, but may be caused by transient congestion.  (Normally,</span>
    <span class="tok-comment">/// this does not occur in Linux.  Packets are just silently dropped when  a  device  queue</span>
    <span class="tok-comment">/// overflows.)</span>
    <span class="tok-comment">/// This is also caused when there is not enough kernel memory available.</span>
    SystemResources,

    <span class="tok-comment">/// The  local  end  has been shut down on a connection oriented socket.  In this case, the</span>
    <span class="tok-comment">/// process will also receive a SIGPIPE unless MSG.NOSIGNAL is set.</span>
    BrokenPipe,

    FileDescriptorNotASocket,

    <span class="tok-comment">/// Network is unreachable.</span>
    NetworkUnreachable,

    <span class="tok-comment">/// The local network interface used to reach the destination is down.</span>
    NetworkSubsystemFailed,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SendMsgError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SendMsgError</span><a href="#src.zig-std.posix.SendMsgError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>(For UNIX domain sockets, which are identified by pathname) Write permission is  denied
on  the destination socket file, or search permission is denied for one of the
directories the path prefix.  (See path_resolution(7).)
(For UDP sockets) An attempt was made to send to a network/broadcast address as  though
it was a unicast address.</p>
</dd></div><div><dt>AddressFamilyNotSupported</dt><dd><p>The passed address didn't have the correct address family in its sa_family field.</p>
</dd></div><div><dt>AddressNotAvailable</dt></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>The  local  end  has been shut down on a connection oriented socket.  In this case, the
process will also receive a SIGPIPE unless MSG.NOSIGNAL is set.</p>
</dd></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>Connection reset by peer.</p>
</dd></div><div><dt>FastOpenAlreadyInProgress <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>Another Fast Open is already in progress.</p>
</dd></div><div><dt>FileDescriptorNotASocket <a href="std.posix.html#std.posix.SendError">SendError</a></dt></div><div><dt>FileNotFound</dt><dd><p>Returned when socket is AF.UNIX and the given path does not point to an existing file.</p>
</dd></div><div><dt>MessageTooBig <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>The  socket  type requires that message be sent atomically, and the size of the message
to be sent made this impossible. The message is not transmitted.</p>
</dd></div><div><dt>NameTooLong</dt><dd><p>Returned when socket is AF.UNIX and the given path length exceeds <code><a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a></code> bytes.</p>
</dd></div><div><dt>NetworkSubsystemFailed <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>The local network interface used to reach the destination is down.</p>
</dd></div><div><dt>NetworkUnreachable <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>Network is unreachable.</p>
</dd></div><div><dt>NotDir</dt></div><div><dt>SocketNotConnected</dt><dd><p>The socket is not connected (connection-oriented sockets only).</p>
</dd></div><div><dt>SymLinkLoop</dt><dd><p>Returned when socket is AF.UNIX and the given path has a symlink loop.</p>
</dd></div><div><dt>SystemResources <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>The output queue for a network interface was full.  This generally indicates  that  the
interface  has  stopped sending, but may be caused by transient congestion.  (Normally,
this does not occur in Linux.  Packets are just silently dropped when  a  device  queue
overflows.)
This is also caused when there is not enough kernel memory available.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>The socket is marked nonblocking and the requested operation would block, and
there is no global event loop configured.
It's also possible to get this error under the following condition:
(Internet  domain datagram sockets) The socket referred to by sockfd had not previously
been bound to an address and, upon attempting to bind it to an ephemeral port,  it  was
determined that all port numbers in the ephemeral port range are currently in use.  See
the discussion of /proc/sys/net/ipv4/ip_local_port_range in ip(7).</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SendMsgError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SendMsgError = <a href="std.posix.html#std.posix.SendError">SendError</a> || <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The passed address didn't have the correct address family in its sa_family field.</span>
    AddressFamilyNotSupported,

    <span class="tok-comment">/// Returned when socket is AF.UNIX and the given path has a symlink loop.</span>
    SymLinkLoop,

    <span class="tok-comment">/// Returned when socket is AF.UNIX and the given path length exceeds `max_path_bytes` bytes.</span>
    NameTooLong,

    <span class="tok-comment">/// Returned when socket is AF.UNIX and the given path does not point to an existing file.</span>
    FileNotFound,
    NotDir,

    <span class="tok-comment">/// The socket is not connected (connection-oriented sockets only).</span>
    SocketNotConnected,
    AddressNotAvailable,
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.SendToError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SendToError</span><a href="#src.zig-std.posix.SendToError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>(For UNIX domain sockets, which are identified by pathname) Write permission is  denied
on  the destination socket file, or search permission is denied for one of the
directories the path prefix.  (See path_resolution(7).)
(For UDP sockets) An attempt was made to send to a network/broadcast address as  though
it was a unicast address.</p>
</dd></div><div><dt>AddressFamilyNotSupported <a href="std.posix.html#std.posix.SendMsgError">SendMsgError</a></dt><dd><p>The passed address didn't have the correct address family in its sa_family field.</p>
</dd></div><div><dt>AddressNotAvailable <a href="std.posix.html#std.posix.SendMsgError">SendMsgError</a></dt></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>The  local  end  has been shut down on a connection oriented socket.  In this case, the
process will also receive a SIGPIPE unless MSG.NOSIGNAL is set.</p>
</dd></div><div><dt>ConnectionRefused</dt><dd><p>The destination address is not listening.</p>
</dd></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>Connection reset by peer.</p>
</dd></div><div><dt>FastOpenAlreadyInProgress <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>Another Fast Open is already in progress.</p>
</dd></div><div><dt>FileDescriptorNotASocket <a href="std.posix.html#std.posix.SendError">SendError</a></dt></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.SendMsgError">SendMsgError</a></dt><dd><p>Returned when socket is AF.UNIX and the given path does not point to an existing file.</p>
</dd></div><div><dt>MessageTooBig <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>The  socket  type requires that message be sent atomically, and the size of the message
to be sent made this impossible. The message is not transmitted.</p>
</dd></div><div><dt>NameTooLong <a href="std.posix.html#std.posix.SendMsgError">SendMsgError</a></dt><dd><p>Returned when socket is AF.UNIX and the given path length exceeds <code><a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a></code> bytes.</p>
</dd></div><div><dt>NetworkSubsystemFailed <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>The local network interface used to reach the destination is down.</p>
</dd></div><div><dt>NetworkUnreachable <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>Network is unreachable.</p>
</dd></div><div><dt>NotDir <a href="std.posix.html#std.posix.SendMsgError">SendMsgError</a></dt></div><div><dt>SocketNotConnected <a href="std.posix.html#std.posix.SendMsgError">SendMsgError</a></dt><dd><p>The socket is not connected (connection-oriented sockets only).</p>
</dd></div><div><dt>SymLinkLoop <a href="std.posix.html#std.posix.SendMsgError">SendMsgError</a></dt><dd><p>Returned when socket is AF.UNIX and the given path has a symlink loop.</p>
</dd></div><div><dt>SystemResources <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>The output queue for a network interface was full.  This generally indicates  that  the
interface  has  stopped sending, but may be caused by transient congestion.  (Normally,
this does not occur in Linux.  Packets are just silently dropped when  a  device  queue
overflows.)
This is also caused when there is not enough kernel memory available.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>UnreachableAddress</dt><dd><p>The destination address is not reachable by the bound address.</p>
</dd></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>The socket is marked nonblocking and the requested operation would block, and
there is no global event loop configured.
It's also possible to get this error under the following condition:
(Internet  domain datagram sockets) The socket referred to by sockfd had not previously
been bound to an address and, upon attempting to bind it to an ephemeral port,  it  was
determined that all port numbers in the ephemeral port range are currently in use.  See
the discussion of /proc/sys/net/ipv4/ip_local_port_range in ip(7).</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SendToError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SendToError = <a href="std.posix.html#std.posix.SendMsgError">SendMsgError</a> || <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The destination address is not reachable by the bound address.</span>
    UnreachableAddress,
    <span class="tok-comment">/// The destination address is not listening.</span>
    ConnectionRefused,
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.SendFileError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SendFileError</span><a href="#src.zig-std.posix.SendFileError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>In WASI, this error occurs when the file descriptor does
not hold the required rights to read from it.</p>
</dd></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>The  local  end  has been shut down on a connection oriented socket.  In this case, the
process will also receive a SIGPIPE unless MSG.NOSIGNAL is set.</p>
</dd></div><div><dt>Canceled <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>reading a timerfd with CANCEL_ON_SET will lead to this error
when the clock goes through a discontinuous change</p>
</dd></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>Connection reset by peer.</p>
</dd></div><div><dt>ConnectionTimedOut <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>DeviceBusy <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>DiskQuota <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>FastOpenAlreadyInProgress <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>Another Fast Open is already in progress.</p>
</dd></div><div><dt>FileDescriptorNotASocket <a href="std.posix.html#std.posix.SendError">SendError</a></dt></div><div><dt>FileTooBig <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>InputOutput <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>InvalidArgument <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>IsDir <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>LockViolation <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>Unable to read file due to lock.</p>
</dd></div><div><dt>MessageTooBig <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>The  socket  type requires that message be sent atomically, and the size of the message
to be sent made this impossible. The message is not transmitted.</p>
</dd></div><div><dt>NetworkSubsystemFailed <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>The local network interface used to reach the destination is down.</p>
</dd></div><div><dt>NetworkUnreachable <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>Network is unreachable.</p>
</dd></div><div><dt>NoDevice <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>This error occurs when a device gets disconnected before or mid-flush
while it's being written to - errno(6): No such device or address.</p>
</dd></div><div><dt>NoSpaceLeft <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>NotOpenForReading <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>NotOpenForWriting <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>OperationAborted <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs in Linux if the process to be read from
no longer exists.</p>
</dd></div><div><dt>SocketNotConnected <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.SendError">SendError</a></dt><dd><p>The output queue for a network interface was full.  This generally indicates  that  the
interface  has  stopped sending, but may be caused by transient congestion.  (Normally,
this does not occur in Linux.  Packets are just silently dropped when  a  device  queue
overflows.)
This is also caused when there is not enough kernel memory available.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>Unseekable <a href="std.posix.html#std.posix.PReadError">PReadError</a></dt></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SendFileError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SendFileError = <a href="std.posix.html#std.posix.PReadError">PReadError</a> || <a href="std.posix.html#std.posix.WriteError">WriteError</a> || <a href="std.posix.html#std.posix.SendError">SendError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.CopyFileRangeError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">CopyFileRangeError</span><a href="#src.zig-std.posix.CopyFileRangeError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>In WASI, this error occurs when the file descriptor does
not hold the required rights to read from it.</p>
</dd></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>Canceled <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>reading a timerfd with CANCEL_ON_SET will lead to this error
when the clock goes through a discontinuous change</p>
</dd></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>Connection reset by peer.</p>
</dd></div><div><dt>ConnectionTimedOut <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>CorruptedData</dt></div><div><dt>DeviceBusy <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>DiskQuota <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>FileTooBig</dt></div><div><dt>FilesOpenedWithWrongFlags</dt><dd><p><code>fd_in</code> is not open for reading; or <code>fd_out</code> is not open  for  writing;
or the  <code>APPEND</code>  flag  is  set  for <code>fd_out</code>.</p>
</dd></div><div><dt>InputOutput</dt></div><div><dt>InvalidArgument <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>IsDir</dt></div><div><dt>LockViolation <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>Unable to read file due to lock.</p>
</dd></div><div><dt>NoDevice <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>This error occurs when a device gets disconnected before or mid-flush
while it's being written to - errno(6): No such device or address.</p>
</dd></div><div><dt>NoSpaceLeft</dt></div><div><dt>NotOpenForReading <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>NotOpenForWriting <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>OperationAborted <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>OutOfMemory</dt></div><div><dt>PermissionDenied</dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs in Linux if the process to be read from
no longer exists.</p>
</dd></div><div><dt>SocketNotConnected <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>SwapFile</dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>Unseekable</dt></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.CopyFileRangeError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CopyFileRangeError = <span class="tok-kw">error</span>{
    FileTooBig,
    InputOutput,
    <span class="tok-comment">/// `fd_in` is not open for reading; or `fd_out` is not open  for  writing;</span>
    <span class="tok-comment">/// or the  `APPEND`  flag  is  set  for `fd_out`.</span>
    FilesOpenedWithWrongFlags,
    IsDir,
    OutOfMemory,
    NoSpaceLeft,
    Unseekable,
    PermissionDenied,
    SwapFile,
    CorruptedData,
} || <a href="std.posix.html#std.posix.PReadError">PReadError</a> || <a href="std.posix.html#std.posix.PWriteError">PWriteError</a> || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.PollError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">PollError</span><a href="#src.zig-std.posix.PollError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>NetworkSubsystemFailed</dt><dd><p>The network subsystem has failed.</p>
</dd></div><div><dt>SystemResources</dt><dd><p>The kernel had no space to allocate file descriptor tables.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.PollError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PollError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The network subsystem has failed.</span>
    NetworkSubsystemFailed,

    <span class="tok-comment">/// The kernel had no space to allocate file descriptor tables.</span>
    SystemResources,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.PPollError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">PPollError</span><a href="#src.zig-std.posix.PPollError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>SignalInterrupt</dt><dd><p>The operation was interrupted by a delivery of a signal before it could complete.</p>
</dd></div><div><dt>SystemResources</dt><dd><p>The kernel had no space to allocate file descriptor tables.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.PPollError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PPollError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The operation was interrupted by a delivery of a signal before it could complete.</span>
    SignalInterrupt,

    <span class="tok-comment">/// The kernel had no space to allocate file descriptor tables.</span>
    SystemResources,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.RecvFromError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">RecvFromError</span><a href="#src.zig-std.posix.RecvFromError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>ConnectionRefused</dt><dd><p>A remote host refused to allow the network connection, typically because it is not
running the requested service.</p>
</dd></div><div><dt>ConnectionResetByPeer</dt></div><div><dt>ConnectionTimedOut</dt></div><div><dt>MessageTooBig</dt><dd><p>The UDP message was too big for the buffer and part of it has been discarded</p>
</dd></div><div><dt>NetworkSubsystemFailed</dt><dd><p>The network subsystem has failed.</p>
</dd></div><div><dt>SocketNotBound</dt><dd><p>The socket has not been bound.</p>
</dd></div><div><dt>SocketNotConnected</dt><dd><p>The socket is not connected (connection-oriented sockets only).</p>
</dd></div><div><dt>SystemResources</dt><dd><p>Could not allocate kernel memory.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WouldBlock</dt><dd><p>The socket is marked nonblocking and the requested operation would block, and
there is no global event loop configured.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.RecvFromError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RecvFromError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The socket is marked nonblocking and the requested operation would block, and</span>
    <span class="tok-comment">/// there is no global event loop configured.</span>
    WouldBlock,

    <span class="tok-comment">/// A remote host refused to allow the network connection, typically because it is not</span>
    <span class="tok-comment">/// running the requested service.</span>
    ConnectionRefused,

    <span class="tok-comment">/// Could not allocate kernel memory.</span>
    SystemResources,

    ConnectionResetByPeer,
    ConnectionTimedOut,

    <span class="tok-comment">/// The socket has not been bound.</span>
    SocketNotBound,

    <span class="tok-comment">/// The UDP message was too big for the buffer and part of it has been discarded</span>
    MessageTooBig,

    <span class="tok-comment">/// The network subsystem has failed.</span>
    NetworkSubsystemFailed,

    <span class="tok-comment">/// The socket is not connected (connection-oriented sockets only).</span>
    SocketNotConnected,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.DnExpandError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">DnExpandError</span><a href="#src.zig-std.posix.DnExpandError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>InvalidDnsPacket</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.DnExpandError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DnExpandError = <span class="tok-kw">error</span>{InvalidDnsPacket}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.SetSockOptError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SetSockOptError</span><a href="#src.zig-std.posix.SetSockOptError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AlreadyConnected</dt><dd><p>The socket is already connected, and a specified option cannot be set while the socket is connected.</p>
</dd></div><div><dt>FileDescriptorNotASocket</dt></div><div><dt>InvalidProtocolOption</dt><dd><p>The option is not supported by the protocol.</p>
</dd></div><div><dt>NetworkSubsystemFailed</dt></div><div><dt>NoDevice</dt></div><div><dt>OperationNotSupported</dt></div><div><dt>PermissionDenied</dt></div><div><dt>SocketNotBound</dt></div><div><dt>SystemResources</dt><dd><p>Insufficient resources are available in the system to complete the call.</p>
</dd></div><div><dt>TimeoutTooBig</dt><dd><p>The send and receive timeout values are too big to fit into the timeout fields in the socket structure.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SetSockOptError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SetSockOptError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The socket is already connected, and a specified option cannot be set while the socket is connected.</span>
    AlreadyConnected,

    <span class="tok-comment">/// The option is not supported by the protocol.</span>
    InvalidProtocolOption,

    <span class="tok-comment">/// The send and receive timeout values are too big to fit into the timeout fields in the socket structure.</span>
    TimeoutTooBig,

    <span class="tok-comment">/// Insufficient resources are available in the system to complete the call.</span>
    SystemResources,<span class="tok-comment">

    // Setting the socket option requires more elevated permissions.
    </span>PermissionDenied,

    OperationNotSupported,
    NetworkSubsystemFailed,
    FileDescriptorNotASocket,
    SocketNotBound,
    NoDevice,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.MemFdCreateError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">MemFdCreateError</span><a href="#src.zig-std.posix.MemFdCreateError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>NameTooLong</dt><dd><p>Either the name provided exceeded <code><a href="std.posix.html#std.posix.NAME_MAX">NAME_MAX</a></code>, or invalid flags were passed.</p>
</dd></div><div><dt>OutOfMemory</dt></div><div><dt>ProcessFdQuotaExceeded</dt></div><div><dt>SystemFdQuotaExceeded</dt></div><div><dt>SystemOutdated</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.MemFdCreateError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MemFdCreateError = <span class="tok-kw">error</span>{
    SystemFdQuotaExceeded,
    ProcessFdQuotaExceeded,
    OutOfMemory,
    <span class="tok-comment">/// Either the name provided exceeded `NAME_MAX`, or invalid flags were passed.</span>
    NameTooLong,
    SystemOutdated,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.TIOCError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">TIOCError</span><a href="#src.zig-std.posix.TIOCError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>NotATerminal</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.TIOCError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TIOCError = <span class="tok-kw">error</span>{NotATerminal}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.TermiosGetError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">TermiosGetError</span><a href="#src.zig-std.posix.TermiosGetError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>NotATerminal <a href="std.posix.html#std.posix.TIOCError">TIOCError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.TermiosGetError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TermiosGetError = <a href="std.posix.html#std.posix.TIOCError">TIOCError</a> || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.TermiosSetError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">TermiosSetError</span><a href="#src.zig-std.posix.TermiosSetError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>NotATerminal <a href="std.posix.html#std.posix.TIOCError">TIOCError</a></dt></div><div><dt>ProcessOrphaned</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.TermiosSetError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TermiosSetError = <a href="std.posix.html#std.posix.TermiosGetError">TermiosGetError</a> || <span class="tok-kw">error</span>{ProcessOrphaned}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.TermioGetPgrpError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">TermioGetPgrpError</span><a href="#src.zig-std.posix.TermioGetPgrpError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>NotATerminal <a href="std.posix.html#std.posix.TIOCError">TIOCError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.TermioGetPgrpError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TermioGetPgrpError = <a href="std.posix.html#std.posix.TIOCError">TIOCError</a> || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.TermioSetPgrpError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">TermioSetPgrpError</span><a href="#src.zig-std.posix.TermioSetPgrpError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>NotAPgrpMember</dt></div><div><dt>NotATerminal <a href="std.posix.html#std.posix.TIOCError">TIOCError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.TermioSetPgrpError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TermioSetPgrpError = <a href="std.posix.html#std.posix.TermioGetPgrpError">TermioGetPgrpError</a> || <span class="tok-kw">error</span>{NotAPgrpMember}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.SyncError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SyncError</span><a href="#src.zig-std.posix.SyncError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>DiskQuota</dt></div><div><dt>InputOutput</dt></div><div><dt>NoSpaceLeft</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SyncError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SyncError = <span class="tok-kw">error</span>{
    InputOutput,
    NoSpaceLeft,
    DiskQuota,
    AccessDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.PrctlError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">PrctlError</span><a href="#src.zig-std.posix.PrctlError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>Can only occur with PR_SET_SECCOMP/SECCOMP_MODE_FILTER or
PR_SET_MM/PR_SET_MM_EXE_FILE</p>
</dd></div><div><dt>InvalidAddress</dt></div><div><dt>InvalidFileDescriptor</dt><dd><p>Can only occur with PR_SET_MM/PR_SET_MM_EXE_FILE</p>
</dd></div><div><dt>OperationNotSupported</dt><dd><p>Can only occur with PR_SET_FP_MODE</p>
</dd></div><div><dt>PermissionDenied</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>UnsupportedFeature</dt><dd><p>Can only occur with PR_SET_SPECULATION_CTRL, PR_MPX_ENABLE_MANAGEMENT,
or PR_MPX_DISABLE_MANAGEMENT</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.PrctlError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PrctlError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// Can only occur with PR_SET_SECCOMP/SECCOMP_MODE_FILTER or</span>
    <span class="tok-comment">/// PR_SET_MM/PR_SET_MM_EXE_FILE</span>
    AccessDenied,
    <span class="tok-comment">/// Can only occur with PR_SET_MM/PR_SET_MM_EXE_FILE</span>
    InvalidFileDescriptor,
    InvalidAddress,
    <span class="tok-comment">/// Can only occur with PR_SET_SPECULATION_CTRL, PR_MPX_ENABLE_MANAGEMENT,</span>
    <span class="tok-comment">/// or PR_MPX_DISABLE_MANAGEMENT</span>
    UnsupportedFeature,
    <span class="tok-comment">/// Can only occur with PR_SET_FP_MODE</span>
    OperationNotSupported,
    PermissionDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.UnexpectedError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">UnexpectedError</span><a href="#src.zig-std.posix.UnexpectedError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>Unexpected</dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.UnexpectedError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnexpectedError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The Operating System returned an undocumented error code.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// This error is in theory not possible, but it would be better</span>
    <span class="tok-comment">/// to handle this error than to invoke undefined behavior.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// When this error code is observed, it usually means the Zig Standard</span>
    <span class="tok-comment">/// Library needs a small patch to add the error code to the error set for</span>
    <span class="tok-comment">/// the respective function.</span>
    Unexpected,
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.SetrlimitError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SetrlimitError</span><a href="#src.zig-std.posix.SetrlimitError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>LimitTooBig</dt></div><div><dt>PermissionDenied</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SetrlimitError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SetrlimitError = <span class="tok-kw">error</span>{ PermissionDenied, LimitTooBig } || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.MincoreError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">MincoreError</span><a href="#src.zig-std.posix.MincoreError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>InvalidAddress</dt><dd><p>vec points to an invalid address.</p>
</dd></div><div><dt>InvalidSyscall</dt><dd><p>addr is not page-aligned.</p>
</dd></div><div><dt>MincoreUnavailable</dt><dd><p>The mincore syscall is not available on this version and configuration
of this UNIX-like kernel.</p>
</dd></div><div><dt>OutOfMemory</dt><dd><p>One of the following:</p>
<ul>
<li>length is greater than user space TASK_SIZE - addr</li>
<li>addr + length contains unmapped memory</li>
</ul>
</dd></div><div><dt>SystemResources</dt><dd><p>A kernel resource was temporarily unavailable.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.MincoreError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MincoreError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// A kernel resource was temporarily unavailable.</span>
    SystemResources,
    <span class="tok-comment">/// vec points to an invalid address.</span>
    InvalidAddress,
    <span class="tok-comment">/// addr is not page-aligned.</span>
    InvalidSyscall,
    <span class="tok-comment">/// One of the following:</span>
    <span class="tok-comment">/// * length is greater than user space TASK_SIZE - addr</span>
    <span class="tok-comment">/// * addr + length contains unmapped memory</span>
    OutOfMemory,
    <span class="tok-comment">/// The mincore syscall is not available on this version and configuration</span>
    <span class="tok-comment">/// of this UNIX-like kernel.</span>
    MincoreUnavailable,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.MadviseError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">MadviseError</span><a href="#src.zig-std.posix.MadviseError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>advice is MADV.REMOVE, but the specified address range is not a shared writable mapping.</p>
</dd></div><div><dt>InvalidSyscall</dt><dd><p>One of the following:</p>
<ul>
<li>addr is not page-aligned or length is negative</li>
<li>advice is not valid</li>
<li>advice is MADV.DONTNEED or MADV.REMOVE and the specified address range
includes locked, Huge TLB pages, or VM_PFNMAP pages.</li>
<li>advice is MADV.MERGEABLE or MADV.UNMERGEABLE, but the kernel was not
configured with CONFIG_KSM.</li>
<li>advice is MADV.FREE or MADV.WIPEONFORK but the specified address range
includes file, Huge TLB, MAP.SHARED, or VM_PFNMAP ranges.</li>
</ul>
</dd></div><div><dt>MadviseUnavailable</dt><dd><p>The madvise syscall is not available on this version and configuration
of the Linux kernel.</p>
</dd></div><div><dt>OutOfMemory</dt><dd><p>One of the following:</p>
<ul>
<li>(for MADV.WILLNEED) Not enough memory: paging in failed.</li>
<li>Addresses in the specified range are not currently mapped, or
are outside the address space of the process.</li>
</ul>
</dd></div><div><dt>PermissionDenied</dt><dd><p>advice is MADV.HWPOISON, but the caller does not have the CAP_SYS_ADMIN capability.</p>
</dd></div><div><dt>SystemResources</dt><dd><p>A kernel resource was temporarily unavailable.</p>
</dd></div><div><dt>Unexpected</dt><dd><p>The operating system returned an undocumented error code.</p>
</dd></div><div><dt>WouldExceedMaximumResidentSetSize</dt><dd><p>(for MADV.WILLNEED) Paging in this area would exceed the process's
maximum resident set size.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.MadviseError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MadviseError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// advice is MADV.REMOVE, but the specified address range is not a shared writable mapping.</span>
    AccessDenied,
    <span class="tok-comment">/// advice is MADV.HWPOISON, but the caller does not have the CAP_SYS_ADMIN capability.</span>
    PermissionDenied,
    <span class="tok-comment">/// A kernel resource was temporarily unavailable.</span>
    SystemResources,
    <span class="tok-comment">/// One of the following:</span>
    <span class="tok-comment">/// * addr is not page-aligned or length is negative</span>
    <span class="tok-comment">/// * advice is not valid</span>
    <span class="tok-comment">/// * advice is MADV.DONTNEED or MADV.REMOVE and the specified address range</span>
    <span class="tok-comment">///   includes locked, Huge TLB pages, or VM_PFNMAP pages.</span>
    <span class="tok-comment">/// * advice is MADV.MERGEABLE or MADV.UNMERGEABLE, but the kernel was not</span>
    <span class="tok-comment">///   configured with CONFIG_KSM.</span>
    <span class="tok-comment">/// * advice is MADV.FREE or MADV.WIPEONFORK but the specified address range</span>
    <span class="tok-comment">///   includes file, Huge TLB, MAP.SHARED, or VM_PFNMAP ranges.</span>
    InvalidSyscall,
    <span class="tok-comment">/// (for MADV.WILLNEED) Paging in this area would exceed the process's</span>
    <span class="tok-comment">/// maximum resident set size.</span>
    WouldExceedMaximumResidentSetSize,
    <span class="tok-comment">/// One of the following:</span>
    <span class="tok-comment">/// * (for MADV.WILLNEED) Not enough memory: paging in failed.</span>
    <span class="tok-comment">/// * Addresses in the specified range are not currently mapped, or</span>
    <span class="tok-comment">///   are outside the address space of the process.</span>
    OutOfMemory,
    <span class="tok-comment">/// The madvise syscall is not available on this version and configuration</span>
    <span class="tok-comment">/// of the Linux kernel.</span>
    MadviseUnavailable,
    <span class="tok-comment">/// The operating system returned an undocumented error code.</span>
    Unexpected,
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.PerfEventOpenError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">PerfEventOpenError</span><a href="#src.zig-std.posix.PerfEventOpenError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>DeviceBusy</dt><dd><p>Returned if another event already has exclusive  access  to  the
PMU.</p>
</dd></div><div><dt>EventNotSupported</dt><dd><p>Returned if an event requiring a specific  hardware  feature  is
requested  but  there is no hardware support.  This includes re‐
questing low-skid events if not supported, branch tracing if  it
is not available, sampling if no PMU interrupt is available, and
branch stacks for software events.</p>
</dd></div><div><dt>EventRequiresUnsupportedCpuFeature</dt></div><div><dt>PermissionDenied</dt><dd><p>Returned when the requested event requires CAP_SYS_ADMIN permis‐
sions  (or a more permissive perf_event paranoid setting).  Some
common cases where an unprivileged process  may  encounter  this
error:  attaching  to a process owned by a different user; moni‐
toring all processes on a given CPU (i.e.,  specifying  the  pid
argument  as  -1); and not setting exclude_kernel when the para‐
noid setting requires it.
Also:
Returned on many (but not all) architectures when an unsupported
exclude_hv,  exclude_idle,  exclude_user, or exclude_kernel set‐
ting is specified.
It can also happen, as with EACCES, when the requested event re‐
quires   CAP_SYS_ADMIN   permissions   (or   a  more  permissive
perf_event paranoid setting).  This includes  setting  a  break‐
point on a kernel address, and (since Linux 3.13) setting a ker‐
nel function-trace tracepoint.</p>
</dd></div><div><dt>ProcessNotFound</dt><dd><p>Returned if attempting to attach to a process that does not  exist.</p>
</dd></div><div><dt>ProcessResources</dt><dd><p>Each  opened  event uses one file descriptor.  If a large number
of events are opened, the per-process limit  on  the  number  of
open file descriptors will be reached, and no more events can be
created.</p>
</dd></div><div><dt>SampleMaxStackOverflow</dt><dd><p>Returned  if  PERF_SAMPLE_CALLCHAIN  is   requested   and   sam‐
ple_max_stack   is   larger   than   the  maximum  specified  in
/proc/sys/kernel/perf_event_max_stack.</p>
</dd></div><div><dt>SampleStackNotSupported</dt><dd><p>Returned  if PERF_SAMPLE_STACK_USER is set in sample_type and it
is not supported by hardware.</p>
</dd></div><div><dt>TooBig</dt><dd><p>Returned if the perf_event_attr size value is too small (smaller
than PERF_ATTR_SIZE_VER0), too big (larger than the page  size),
or  larger  than the kernel supports and the extra bytes are not
zero.  When E2BIG is returned, the perf_event_attr size field is
overwritten by the kernel to be the size of the structure it was
expecting.</p>
</dd></div><div><dt>TooManyBreakpoints</dt><dd><p>Returned if  you  try  to  add  more  breakpoint
events than supported by the hardware.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.PerfEventOpenError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PerfEventOpenError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// Returned if the perf_event_attr size value is too small (smaller</span>
    <span class="tok-comment">/// than PERF_ATTR_SIZE_VER0), too big (larger than the page  size),</span>
    <span class="tok-comment">/// or  larger  than the kernel supports and the extra bytes are not</span>
    <span class="tok-comment">/// zero.  When E2BIG is returned, the perf_event_attr size field is</span>
    <span class="tok-comment">/// overwritten by the kernel to be the size of the structure it was</span>
    <span class="tok-comment">/// expecting.</span>
    TooBig,
    <span class="tok-comment">/// Returned when the requested event requires CAP_SYS_ADMIN permis‐</span>
    <span class="tok-comment">/// sions  (or a more permissive perf_event paranoid setting).  Some</span>
    <span class="tok-comment">/// common cases where an unprivileged process  may  encounter  this</span>
    <span class="tok-comment">/// error:  attaching  to a process owned by a different user; moni‐</span>
    <span class="tok-comment">/// toring all processes on a given CPU (i.e.,  specifying  the  pid</span>
    <span class="tok-comment">/// argument  as  -1); and not setting exclude_kernel when the para‐</span>
    <span class="tok-comment">/// noid setting requires it.</span>
    <span class="tok-comment">/// Also:</span>
    <span class="tok-comment">/// Returned on many (but not all) architectures when an unsupported</span>
    <span class="tok-comment">/// exclude_hv,  exclude_idle,  exclude_user, or exclude_kernel set‐</span>
    <span class="tok-comment">/// ting is specified.</span>
    <span class="tok-comment">/// It can also happen, as with EACCES, when the requested event re‐</span>
    <span class="tok-comment">/// quires   CAP_SYS_ADMIN   permissions   (or   a  more  permissive</span>
    <span class="tok-comment">/// perf_event paranoid setting).  This includes  setting  a  break‐</span>
    <span class="tok-comment">/// point on a kernel address, and (since Linux 3.13) setting a ker‐</span>
    <span class="tok-comment">/// nel function-trace tracepoint.</span>
    PermissionDenied,
    <span class="tok-comment">/// Returned if another event already has exclusive  access  to  the</span>
    <span class="tok-comment">/// PMU.</span>
    DeviceBusy,
    <span class="tok-comment">/// Each  opened  event uses one file descriptor.  If a large number</span>
    <span class="tok-comment">/// of events are opened, the per-process limit  on  the  number  of</span>
    <span class="tok-comment">/// open file descriptors will be reached, and no more events can be</span>
    <span class="tok-comment">/// created.</span>
    ProcessResources,
    EventRequiresUnsupportedCpuFeature,
    <span class="tok-comment">/// Returned if  you  try  to  add  more  breakpoint</span>
    <span class="tok-comment">/// events than supported by the hardware.</span>
    TooManyBreakpoints,
    <span class="tok-comment">/// Returned  if PERF_SAMPLE_STACK_USER is set in sample_type and it</span>
    <span class="tok-comment">/// is not supported by hardware.</span>
    SampleStackNotSupported,
    <span class="tok-comment">/// Returned if an event requiring a specific  hardware  feature  is</span>
    <span class="tok-comment">/// requested  but  there is no hardware support.  This includes re‐</span>
    <span class="tok-comment">/// questing low-skid events if not supported, branch tracing if  it</span>
    <span class="tok-comment">/// is not available, sampling if no PMU interrupt is available, and</span>
    <span class="tok-comment">/// branch stacks for software events.</span>
    EventNotSupported,
    <span class="tok-comment">/// Returned  if  PERF_SAMPLE_CALLCHAIN  is   requested   and   sam‐</span>
    <span class="tok-comment">/// ple_max_stack   is   larger   than   the  maximum  specified  in</span>
    <span class="tok-comment">/// /proc/sys/kernel/perf_event_max_stack.</span>
    SampleMaxStackOverflow,
    <span class="tok-comment">/// Returned if attempting to attach to a process that does not  exist.</span>
    ProcessNotFound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.TimerFdCreateError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">TimerFdCreateError</span><a href="#src.zig-std.posix.TimerFdCreateError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>NoDevice</dt></div><div><dt>ProcessFdQuotaExceeded</dt></div><div><dt>SystemFdQuotaExceeded</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.TimerFdCreateError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TimerFdCreateError = <span class="tok-kw">error</span>{
    AccessDenied,
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    NoDevice,
    SystemResources,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.TimerFdGetError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">TimerFdGetError</span><a href="#src.zig-std.posix.TimerFdGetError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>InvalidHandle</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.TimerFdGetError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TimerFdGetError = <span class="tok-kw">error</span>{InvalidHandle} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.TimerFdSetError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">TimerFdSetError</span><a href="#src.zig-std.posix.TimerFdSetError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>Canceled</dt></div><div><dt>InvalidHandle <a href="std.posix.html#std.posix.TimerFdGetError">TimerFdGetError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.TimerFdSetError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TimerFdSetError = <a href="std.posix.html#std.posix.TimerFdGetError">TimerFdGetError</a> || <span class="tok-kw">error</span>{Canceled}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.PtraceError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">PtraceError</span><a href="#src.zig-std.posix.PtraceError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>DeviceBusy</dt></div><div><dt>InputOutput</dt></div><div><dt>PermissionDenied</dt></div><div><dt>ProcessNotFound</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.PtraceError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PtraceError = <span class="tok-kw">error</span>{
    DeviceBusy,
    InputOutput,
    ProcessNotFound,
    PermissionDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.NameToFileHandleAtError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">NameToFileHandleAtError</span><a href="#src.zig-std.posix.NameToFileHandleAtError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>FileNotFound</dt></div><div><dt>NameTooLong</dt></div><div><dt>NotDir</dt></div><div><dt>OperationNotSupported</dt></div><div><dt>Unexpected</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.NameToFileHandleAtError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> NameToFileHandleAtError = <span class="tok-kw">error</span>{
    FileNotFound,
    NotDir,
    OperationNotSupported,
    NameTooLong,
    Unexpected,
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.IoCtl_SIOCGIFINDEX_Error" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">IoCtl_SIOCGIFINDEX_Error</span><a href="#src.zig-std.posix.IoCtl_SIOCGIFINDEX_Error">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>FileSystem</dt></div><div><dt>InterfaceNotFound</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.IoCtl_SIOCGIFINDEX_Error">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> IoCtl_SIOCGIFINDEX_Error = <span class="tok-kw">error</span>{
    FileSystem,
    InterfaceNotFound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.UnexpectedError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">UnexpectedError</span><a href="#src.zig-std.posix.UnexpectedError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>Unexpected</dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.UnexpectedError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnexpectedError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The Operating System returned an undocumented error code.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// This error is in theory not possible, but it would be better</span>
    <span class="tok-comment">/// to handle this error than to invoke undefined behavior.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// When this error code is observed, it usually means the Zig Standard</span>
    <span class="tok-comment">/// Library needs a small patch to add the error code to the error set for</span>
    <span class="tok-comment">/// the respective function.</span>
    Unexpected,
}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.posix.errno" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">errno</span><a href="#src.zig-std.posix.errno">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">errno</span>(rc: <span class="tok-kw">anytype</span>) <a href="std.posix.html#std.posix.E">E</a></code></pre></div><div class="tldDocs"><p>Obtains errno from the return value of a system function call.</p>
<p>For some systems this will obtain the value directly from the syscall return value;
for others it will use a thread-local errno variable. Therefore, this
function only returns a well-defined value when it is called directly after
the system function call whose errno value is intended to be observed.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.errno">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">errno</span>(rc: <span class="tok-kw">anytype</span>) <a href="std.posix.html#std.posix.E">E</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.use_libc">use_libc</a>) {
        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (rc == -<span class="tok-number">1</span>) <span class="tok-builtin">@enumFromInt</span>(<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c._errno">_errno</a>().*) <span class="tok-kw">else</span> .SUCCESS;
    }
    <span class="tok-kw">const</span> signed: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(rc);
    <span class="tok-kw">const</span> int = <span class="tok-kw">if</span> (signed &gt; -<span class="tok-number">4096</span> <span class="tok-kw">and</span> signed &lt; <span class="tok-number">0</span>) -signed <span class="tok-kw">else</span> <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(int);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.close" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">close</span><a href="#src.zig-std.posix.close">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Closes the file descriptor.</p>
<p>Asserts the file descriptor is open.</p>
<p>This function is not capable of returning any indication of failure. An
application which wants to ensure writes have succeeded before closing must
call <code><a href="std.posix.html#std.posix.fsync">fsync</a></code> before <code><a href="std.posix.html#std.posix.close">close</a></code>.</p>
<p>The Zig standard library does not support POSIX thread cancellation.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.close">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CloseHandle">CloseHandle</a>(fd);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        _ = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_close">fd_close</a>(fd);
        <span class="tok-kw">return</span>;
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">close</a>(fd))) {
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition.
        </span>.INTR =&gt; <span class="tok-kw">return</span>,<span class="tok-comment"> // This is still a success. See https://github.com/ziglang/zig/issues/2425
        </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span>,
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.fchmod" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fchmod</span><a href="#src.zig-std.posix.fchmod">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fchmod</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.FChmodError">FChmodError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Changes the mode of the file referred to by the file descriptor.</p>
<p>The process must have the correct privileges in order to do this
successfully, or must have the effective user ID matching the owner
of the file.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.fchmod">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fchmod</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.FChmodError">FChmodError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.has_executable_bit">has_executable_bit</a>) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;fchmod unsupported by target OS&quot;</span>);

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> res = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fchmod</a>(fd, mode);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(res)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.fchmodat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fchmodat</span><a href="#src.zig-std.posix.fchmodat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">fchmodat</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.FChmodAtError">FChmodAtError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Changes the <code>mode</code> of <code>path</code> relative to the directory referred to by
<code>dirfd</code>. The process must have the correct privileges in order to do this
successfully, or must have the effective user ID matching the owner of the
file.</p>
<p>On Linux the <code><a href="std.posix.html#std.posix.fchmodat2">fchmodat2</a></code> syscall will be used if available, otherwise a
workaround using procfs will be employed. Changing the mode of a symbolic
link with <code>AT.SYMLINK_NOFOLLOW</code> set will also return
<code>OperationNotSupported</code>, as:</p>
<ol>
<li>Permissions on the link are ignored when resolving its target.</li>
<li>This operation has been known to invoke undefined behaviour across
different filesystems[1].</li>
</ol>
<p>[1]: <a href="https://sourceware.org/legacy-ml/libc-alpha/2020-02/msg00467.html">https://sourceware.org/legacy-ml/libc-alpha/2020-02/msg00467.html</a>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.fchmodat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">fchmodat</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.FChmodAtError">FChmodAtError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.has_executable_bit">has_executable_bit</a>) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;fchmodat unsupported by target OS&quot;</span>);<span class="tok-comment">

    // No special handling for linux is needed if we can use the libc fallback
    // or `flags` is empty. Glibc only added the fallback in 2.32.
    </span><span class="tok-kw">const</span> skip_fchmodat_fallback = <a href="std.posix.html#std.posix.native_os">native_os</a> != .linux <span class="tok-kw">or</span>
        <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.versionCheck">versionCheck</a>(.{ .major = <span class="tok-number">2</span>, .minor = <span class="tok-number">32</span>, .patch = <span class="tok-number">0</span> }) <span class="tok-kw">or</span>
        flags == <span class="tok-number">0</span>;<span class="tok-comment">

    // This function is marked inline so that when flags is comptime-known,
    // skip_fchmodat_fallback will be comptime-known true.
    </span><span class="tok-kw">if</span> (skip_fchmodat_fallback)
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.fchmodat1">fchmodat1</a>(dirfd, path, mode, flags);

    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.fchmodat2">fchmodat2</a>(dirfd, path, mode, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.fchown" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fchown</span><a href="#src.zig-std.posix.fchown">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fchown</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, owner: ?<a href="std.posix.html#std.posix.uid_t">uid_t</a>, group: ?<a href="std.posix.html#std.posix.gid_t">gid_t</a>) <a href="std.posix.html#std.posix.FChownError">FChownError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Changes the owner and group of the file referred to by the file descriptor.
The process must have the correct privileges in order to do this
successfully. The group may be changed by the owner of the directory to
any group of which the owner is a member. If the owner or group is
specified as <code>null</code>, the ID is not changed.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>owner: ?<a href="std.posix.html#std.posix.uid_t">uid_t</a></code></pre></div><div><pre><code>group: ?<a href="std.posix.html#std.posix.gid_t">gid_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.fchown">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fchown</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, owner: ?<a href="std.posix.html#std.posix.uid_t">uid_t</a>, group: ?<a href="std.posix.html#std.posix.gid_t">gid_t</a>) <a href="std.posix.html#std.posix.FChownError">FChownError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .windows, .wasi =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported OS&quot;</span>),
        <span class="tok-kw">else</span> =&gt; {},
    }

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> res = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fchown</a>(fd, owner <span class="tok-kw">orelse</span> ~<span class="tok-builtin">@as</span>(<a href="std.posix.html#std.posix.uid_t">uid_t</a>, <span class="tok-number">0</span>), group <span class="tok-kw">orelse</span> ~<span class="tok-builtin">@as</span>(<a href="std.posix.html#std.posix.gid_t">gid_t</a>, <span class="tok-number">0</span>));

        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(res)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Can be reached if the fd refers to a directory opened without `Dir.OpenOptions{ .iterate = true }`

            </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.reboot" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reboot</span><a href="#src.zig-std.posix.reboot">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reboot</span>(cmd: <a href="std.posix.html#std.posix.RebootCommand">RebootCommand</a>) <a href="std.posix.html#std.posix.RebootError">RebootError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cmd: <a href="std.posix.html#std.posix.RebootCommand">RebootCommand</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.reboot">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reboot</span>(cmd: <a href="std.posix.html#std.posix.RebootCommand">RebootCommand</a>) <a href="std.posix.html#std.posix.RebootError">RebootError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .linux =&gt; {
            <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.reboot">reboot</a>(
                .MAGIC1,
                .MAGIC2,
                cmd,
                <span class="tok-kw">switch</span> (cmd) {
                    .RESTART2 =&gt; |s| s,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
                },
            ))) {
                .SUCCESS =&gt; {},
                .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
            <span class="tok-kw">switch</span> (cmd) {
                .CAD_OFF =&gt; {},
                .CAD_ON =&gt; {},
                .SW_SUSPEND =&gt; {},

                .HALT =&gt; <span class="tok-kw">unreachable</span>,
                .KEXEC =&gt; <span class="tok-kw">unreachable</span>,
                .POWER_OFF =&gt; <span class="tok-kw">unreachable</span>,
                .RESTART =&gt; <span class="tok-kw">unreachable</span>,
                .RESTART2 =&gt; <span class="tok-kw">unreachable</span>,
            }
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported OS&quot;</span>),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.getrandom" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getrandom</span><a href="#src.zig-std.posix.getrandom">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getrandom</span>(buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.OpenError">GetRandomError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Obtain a series of random bytes. These bytes can be used to seed user-space
random number generators or for cryptographic purposes.
When linking against libc, this calls the
appropriate OS-specific library call. Otherwise it uses the zig standard
library implementation.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.getrandom">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getrandom</span>(buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.OpenError">GetRandomError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.RtlGenRandom">RtlGenRandom</a>(buffer);
    }
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a> <span class="tok-kw">and</span> <span class="tok-builtin">@TypeOf</span>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">arc4random_buf</a>) != <span class="tok-type">void</span>) {
        <a href="std.posix.html#std.posix.system">system</a>.<a href="#">arc4random_buf</a>(buffer.ptr, buffer.len);
        <span class="tok-kw">return</span>;
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi) <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.random_get">random_get</a>(buffer.ptr, buffer.len)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    };
    <span class="tok-kw">if</span> (<span class="tok-builtin">@TypeOf</span>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">getrandom</a>) != <span class="tok-type">void</span>) {
        <span class="tok-kw">var</span> buf = buffer;
        <span class="tok-kw">const</span> use_c = <a href="std.posix.html#std.posix.native_os">native_os</a> != .linux <span class="tok-kw">or</span>
            <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.versionCheck">versionCheck</a>(<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a>{ .major = <span class="tok-number">2</span>, .minor = <span class="tok-number">25</span>, .patch = <span class="tok-number">0</span> });

        <span class="tok-kw">while</span> (buf.len != <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> num_read: <span class="tok-type">usize</span>, <span class="tok-kw">const</span> err = <span class="tok-kw">if</span> (use_c) res: {
                <span class="tok-kw">const</span> rc = std.c.getrandom(buf.ptr, buf.len, <span class="tok-number">0</span>);
                <span class="tok-kw">break</span> :res .{ <span class="tok-builtin">@bitCast</span>(rc), errno(rc) };
            } <span class="tok-kw">else</span> res: {
                <span class="tok-kw">const</span> rc = linux.getrandom(buf.ptr, buf.len, <span class="tok-number">0</span>);
                <span class="tok-kw">break</span> :res .{ rc, linux.E.init(rc) };
            };

            <span class="tok-kw">switch</span> (err) {
                .SUCCESS =&gt; buf = buf[num_read..],
                .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                .FAULT =&gt; <span class="tok-kw">unreachable</span>,
                .INTR =&gt; <span class="tok-kw">continue</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
        }
        <span class="tok-kw">return</span>;
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .emscripten) {
        <span class="tok-kw">const</span> err = <a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.getentropy">getentropy</a>(buffer.ptr, buffer.len));
        <span class="tok-kw">switch</span> (err) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.getRandomBytesDevURandom">getRandomBytesDevURandom</a>(buffer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.abort" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">abort</span><a href="#src.zig-std.posix.abort">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">abort</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="tldDocs"><p>Causes abnormal process termination.
If linking against libc, this calls the abort() libc function. Otherwise
it raises SIGABRT followed by SIGKILL and finally lo
Invokes the current signal handler for SIGABRT, if any.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.abort">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">abort</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);<span class="tok-comment">
    // MSVCRT abort() sometimes opens a popup window which is undesirable, so
    // even when linking libc on Windows we use our own abort implementation.
    // See https://github.com/ziglang/zig/issues/2071 for more details.
    </span><span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.mode">mode</a> == .Debug) {
            <span class="tok-builtin">@breakpoint</span>();
        }
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.ExitProcess">ExitProcess</a>(<span class="tok-number">3</span>);
    }
    <span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a> <span class="tok-kw">and</span> <a href="std.posix.html#std.posix.native_os">native_os</a> == .linux) {<span class="tok-comment">
        // The Linux man page says that the libc abort() function
        // &quot;first unblocks the SIGABRT signal&quot;, but this is a footgun
        // for user-defined signal handlers that want to restore some state in
        // some program sections and crash in others.
        // So, the user-installed SIGABRT handler is run, if present.
        </span><a href="std.posix.html#std.posix.raise">raise</a>(<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">ABRT</a>) <span class="tok-kw">catch</span> {};<span class="tok-comment">

        // Disable all signal handlers.
        </span><a href="std.posix.html#std.posix.sigprocmask">sigprocmask</a>(<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">BLOCK</a>, &amp;<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.all_mask">all_mask</a>, <span class="tok-null">null</span>);<span class="tok-comment">

        // Only one thread may proceed to the rest of abort().
        </span><span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>) {
            <span class="tok-kw">const</span> global = <span class="tok-kw">struct</span> {
                <span class="tok-kw">var</span> abort_entered: <span class="tok-type">bool</span> = <span class="tok-null">false</span>;
            };
            <span class="tok-kw">while</span> (<span class="tok-builtin">@cmpxchgWeak</span>(<span class="tok-type">bool</span>, &amp;global.abort_entered, <span class="tok-null">false</span>, <span class="tok-null">true</span>, .seq_cst, .seq_cst)) |_| {}
        }<span class="tok-comment">

        // Install default handler so that the tkill below will terminate.
        </span><span class="tok-kw">const</span> sigact = <a href="std.posix.html#std.posix.Sigaction">Sigaction</a>{
            .handler = .{ .handler = <a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">DFL</a> },
            .mask = <a href="std.posix.html#std.posix.empty_sigset">empty_sigset</a>,
            .flags = <span class="tok-number">0</span>,
        };
        <a href="std.posix.html#std.posix.sigaction">sigaction</a>(<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">ABRT</a>, &amp;sigact, <span class="tok-null">null</span>);

        _ = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.tkill">tkill</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.gettid">gettid</a>(), <a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">ABRT</a>);

        <span class="tok-kw">const</span> sigabrtmask: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.sigset_t">sigset_t</a> = [_]<span class="tok-type">u32</span>{<span class="tok-number">0</span>} ** <span class="tok-number">31</span> ++ [_]<span class="tok-type">u32</span>{<span class="tok-number">1</span> &lt;&lt; (<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">ABRT</a> - <span class="tok-number">1</span>)};
        <a href="std.posix.html#std.posix.sigprocmask">sigprocmask</a>(<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">UNBLOCK</a>, &amp;sigabrtmask, <span class="tok-null">null</span>);<span class="tok-comment">

        // Beyond this point should be unreachable.
        </span><span class="tok-builtin">@as</span>(*<span class="tok-kw">allowzero</span> <span class="tok-kw">volatile</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0</span>)).* = <span class="tok-number">0</span>;
        <a href="std.posix.html#std.posix.raise">raise</a>(<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">KILL</a>) <span class="tok-kw">catch</span> {};
        <a href="std.posix.html#std.posix.exit">exit</a>(<span class="tok-number">127</span>);<span class="tok-comment"> // Pid 1 might not be signalled in some containers.
    </span>}
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .uefi, .wasi, .emscripten, .cuda, .amdhsa =&gt; <span class="tok-builtin">@trap</span>(),
        <span class="tok-kw">else</span> =&gt; <a href="std.posix.html#std.posix.system">system</a>.<a href="#">abort</a>(),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.raise" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">raise</span><a href="#src.zig-std.posix.raise">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">raise</span>(sig: <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.UnexpectedError">RaiseError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>sig: <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.raise">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">raise</span>(sig: <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.UnexpectedError">RaiseError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">raise</a>(sig))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .linux) {<span class="tok-comment">
        // https://git.musl-libc.org/cgit/musl/commit/?id=0bed7e0acfd34e3fb63ca0e4d99b7592571355a9
        //
        // Unlike musl, libc-less Zig std does not have any internal signals for implementation purposes, so we
        // need to block all signals on the assumption that any of them could potentially fork() in a handler.
        </span><span class="tok-kw">var</span> set: <a href="std.posix.html#std.posix.sigset_t">sigset_t</a> = <span class="tok-null">undefined</span>;
        <a href="std.posix.html#std.posix.sigprocmask">sigprocmask</a>(<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">BLOCK</a>, &amp;<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.all_mask">all_mask</a>, &amp;set);

        <span class="tok-kw">const</span> tid = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.gettid">gettid</a>();
        <span class="tok-kw">const</span> rc = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.tkill">tkill</a>(tid, sig);<span class="tok-comment">

        // restore signal mask
        </span><a href="std.posix.html#std.posix.sigprocmask">sigprocmask</a>(<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">SETMASK</a>, &amp;set, <span class="tok-null">null</span>);

        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.posix.raise unimplemented for this target&quot;</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.kill" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">kill</span><a href="#src.zig-std.posix.kill">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">kill</span>(pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>, sig: <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.KillError">KillError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a></code></pre></div><div><pre><code>sig: <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.kill">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">kill</span>(pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>, sig: <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.KillError">KillError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">kill</a>(pid, sig))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid signal
        </span>.PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .SRCH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.exit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">exit</span><a href="#src.zig-std.posix.exit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">exit</span>(status: <span class="tok-type">u8</span>) <span class="tok-type">noreturn</span></code></pre></div><div class="tldDocs"><p>Exits all threads of the program with the specified status code.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>status: <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.exit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">exit</span>(status: <span class="tok-type">u8</span>) <span class="tok-type">noreturn</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.exit">exit</a>(status);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.ExitProcess">ExitProcess</a>(status);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi) {
        <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.proc_exit">proc_exit</a>(status);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .linux <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>) {
        <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.exit_group">exit_group</a>(status);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .uefi) {
        <span class="tok-kw">const</span> uefi = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.uefi.html">uefi</a>;<span class="tok-comment">
        // exit() is only available if exitBootServices() has not been called yet.
        // This call to exit should not fail, so we don't care about its return value.
        </span><span class="tok-kw">if</span> (uefi.system_table.boot_services) |bs| {
            _ = bs.exit(uefi.handle, <span class="tok-builtin">@enumFromInt</span>(status), <span class="tok-number">0</span>, <span class="tok-null">null</span>);
        }<span class="tok-comment">
        // If we can't exit, reboot the system instead.
        </span>uefi.system_table.runtime_services.resetSystem(.reset_cold, <span class="tok-builtin">@enumFromInt</span>(status), <span class="tok-number">0</span>, <span class="tok-null">null</span>);
    }
    <a href="std.posix.html#std.posix.system">system</a>.<a href="#">exit</a>(status);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.read" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">read</span><a href="#src.zig-std.posix.read">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, buf: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of bytes that were read, which can be less than
buf.len. If 0 bytes were read, that means EOF.
If <code>fd</code> is opened in non blocking mode, the function will return error.WouldBlock
when EAGAIN is received.</p>
<p>Linux has a limit on how many bytes may be transferred in one <code><a href="std.posix.html#std.posix.read">read</a></code> call, which is <code>0x7ffff000</code>
on both 64-bit and 32-bit systems. This is due to using a signed C int as the return value, as
well as stuffing the errno codes into the last <code>4096</code> values. This is noted on the <code><a href="std.posix.html#std.posix.read">read</a></code> man page.
The limit on Darwin is <code>0x7fffffff</code>, trying to read more than that returns EINVAL.
The corresponding POSIX limit is <code>maxInt(isize)</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>buf: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.read">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, buf: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (buf.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ReadFile">ReadFile</a>(fd, buf, <span class="tok-null">null</span>);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> iovs = [<span class="tok-number">1</span>]<a href="std.posix.iovec.html">iovec</a>{<a href="std.posix.iovec.html">iovec</a>{
            .base = buf.ptr,
            .len = buf.len,
        }};

        <span class="tok-kw">var</span> nread: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_read">fd_read</a>(fd, &amp;iovs, iovs.len, &amp;nread)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> nread,
            .INTR =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .AGAIN =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForReading,<span class="tok-comment"> // Can be a race condition.
            </span>.IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }<span class="tok-comment">

    // Prevents EINVAL.
    </span><span class="tok-kw">const</span> max_count = <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .linux =&gt; <span class="tok-number">0x7ffff000</span>,
        .macos, .ios, .watchos, .tvos, .visionos =&gt; <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">i32</span>),
        <span class="tok-kw">else</span> =&gt; <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">isize</span>),
    };
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">read</a>(fd, buf.ptr, <span class="tok-builtin">@min</span>(buf.len, max_count));
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .CANCELED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Canceled,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForReading,<span class="tok-comment"> // Can be a race condition.
            </span>.IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.readv" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readv</span><a href="#src.zig-std.posix.readv">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readv</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, iov: []<span class="tok-kw">const</span> <a href="std.posix.iovec.html">iovec</a>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Number of bytes read is returned. Upon reading end-of-file, zero is returned.</p>
<p>For POSIX systems, if <code>fd</code> is opened in non blocking mode, the function will
return error.WouldBlock when EAGAIN is received.
On Windows, if the application has a global event loop enabled, I/O Completion Ports are
used to perform the I/O. <code>error.WouldBlock</code> is not possible on Windows.</p>
<p>This operation is non-atomic on the following systems:</p>
<ul>
<li>Windows
On these systems, the read races with concurrent writes to the same file descriptor.</li>
</ul>
<p>This function assumes that all vectors, including zero-length vectors, have
a pointer within the address space of the application.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>iov: []<span class="tok-kw">const</span> <a href="std.posix.iovec.html">iovec</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.readv">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readv</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, iov: []<span class="tok-kw">const</span> <a href="std.posix.iovec.html">iovec</a>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {<span class="tok-comment">
        // TODO improve this to use ReadFileScatter
        </span><span class="tok-kw">if</span> (iov.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> first = iov[<span class="tok-number">0</span>];
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.read">read</a>(fd, first.base[<span class="tok-number">0</span>..first.len]);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> nread: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_read">fd_read</a>(fd, iov.ptr, iov.len, &amp;nread)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> nread,
            .INTR =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .AGAIN =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // currently not support in WASI
            </span>.BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForReading,<span class="tok-comment"> // can be a race condition
            </span>.IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">readv</a>(fd, iov.ptr, <span class="tok-builtin">@min</span>(iov.len, <a href="std.posix.html#std.posix.IOV_MAX">IOV_MAX</a>));
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForReading,<span class="tok-comment"> // can be a race condition
            </span>.IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.pread" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pread</span><a href="#src.zig-std.posix.pread">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pread</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, buf: []<span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PReadError">PReadError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Number of bytes read is returned. Upon reading end-of-file, zero is returned.</p>
<p>Retries when interrupted by a signal.</p>
<p>For POSIX systems, if <code>fd</code> is opened in non blocking mode, the function will
return error.WouldBlock when EAGAIN is received.
On Windows, if the application has a global event loop enabled, I/O Completion Ports are
used to perform the I/O. <code>error.WouldBlock</code> is not possible on Windows.</p>
<p>Linux has a limit on how many bytes may be transferred in one <code><a href="std.posix.html#std.posix.pread">pread</a></code> call, which is <code>0x7ffff000</code>
on both 64-bit and 32-bit systems. This is due to using a signed C int as the return value, as
well as stuffing the errno codes into the last <code>4096</code> values. This is noted on the <code><a href="std.posix.html#std.posix.read">read</a></code> man page.
The limit on Darwin is <code>0x7fffffff</code>, trying to read more than that returns EINVAL.
The corresponding POSIX limit is <code>maxInt(isize)</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>buf: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.pread">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pread</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, buf: []<span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PReadError">PReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (buf.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ReadFile">ReadFile</a>(fd, buf, offset);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> iovs = [<span class="tok-number">1</span>]<a href="std.posix.iovec.html">iovec</a>{<a href="std.posix.iovec.html">iovec</a>{
            .base = buf.ptr,
            .len = buf.len,
        }};

        <span class="tok-kw">var</span> nread: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_pread">fd_pread</a>(fd, &amp;iovs, iovs.len, offset, &amp;nread)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> nread,
            .INTR =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .AGAIN =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForReading,<span class="tok-comment"> // Can be a race condition.
            </span>.IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }<span class="tok-comment">

    // Prevent EINVAL.
    </span><span class="tok-kw">const</span> max_count = <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .linux =&gt; <span class="tok-number">0x7ffff000</span>,
        .macos, .ios, .watchos, .tvos, .visionos =&gt; <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">i32</span>),
        <span class="tok-kw">else</span> =&gt; <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">isize</span>),
    };

    <span class="tok-kw">const</span> pread_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">pread64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">pread</a>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = pread_sym(fd, buf.ptr, <span class="tok-builtin">@min</span>(buf.len, max_count), <span class="tok-builtin">@bitCast</span>(offset));
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForReading,<span class="tok-comment"> // Can be a race condition.
            </span>.IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.ftruncate" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ftruncate</span><a href="#src.zig-std.posix.ftruncate">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ftruncate</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, length: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.TruncateError">TruncateError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>length: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.ftruncate">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ftruncate</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, length: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.TruncateError">TruncateError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> eof_info = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_END_OF_FILE_INFORMATION.html">FILE_END_OF_FILE_INFORMATION</a>{
            .EndOfFile = <span class="tok-builtin">@bitCast</span>(length),
        };

        <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtSetInformationFile">NtSetInformationFile</a>(
            fd,
            &amp;io_status_block,
            &amp;eof_info,
            <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_END_OF_FILE_INFORMATION.html">FILE_END_OF_FILE_INFORMATION</a>),
            .FileEndOfFileInformation,
        );

        <span class="tok-kw">switch</span> (rc) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .INVALID_HANDLE =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handle not open for writing
            </span>.ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .USER_MAPPED_FILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedStatus">unexpectedStatus</a>(rc),
        }
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_filestat_set_size">fd_filestat_set_size</a>(fd, length)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .INTR =&gt; <span class="tok-kw">unreachable</span>,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .TXTBSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handle not open for writing
            </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handle not open for writing
            </span>.NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">const</span> ftruncate_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">ftruncate64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">ftruncate</a>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(ftruncate_sym(fd, <span class="tok-builtin">@bitCast</span>(length)))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .TXTBSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handle not open for writing
            </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handle not open for writing
            </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.preadv" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">preadv</span><a href="#src.zig-std.posix.preadv">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">preadv</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, iov: []<span class="tok-kw">const</span> <a href="std.posix.iovec.html">iovec</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PReadError">PReadError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Number of bytes read is returned. Upon reading end-of-file, zero is returned.</p>
<p>Retries when interrupted by a signal.</p>
<p>For POSIX systems, if <code>fd</code> is opened in non blocking mode, the function will
return error.WouldBlock when EAGAIN is received.
On Windows, if the application has a global event loop enabled, I/O Completion Ports are
used to perform the I/O. <code>error.WouldBlock</code> is not possible on Windows.</p>
<p>This operation is non-atomic on the following systems:</p>
<ul>
<li>Darwin</li>
<li>Windows
On these systems, the read races with concurrent writes to the same file descriptor.</li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>iov: []<span class="tok-kw">const</span> <a href="std.posix.iovec.html">iovec</a></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.preadv">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">preadv</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, iov: []<span class="tok-kw">const</span> <a href="std.posix.iovec.html">iovec</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PReadError">PReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> have_pread_but_not_preadv = <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .windows, .macos, .ios, .watchos, .tvos, .visionos, .haiku =&gt; <span class="tok-null">true</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
    };
    <span class="tok-kw">if</span> (have_pread_but_not_preadv) {<span class="tok-comment">
        // We could loop here; but proper usage of `preadv` must handle partial reads anyway.
        // So we simply read into the first vector only.
        </span><span class="tok-kw">if</span> (iov.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> first = iov[<span class="tok-number">0</span>];
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.pread">pread</a>(fd, first.base[<span class="tok-number">0</span>..first.len], offset);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> nread: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_pread">fd_pread</a>(fd, iov.ptr, iov.len, offset, &amp;nread)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> nread,
            .INTR =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .AGAIN =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForReading,<span class="tok-comment"> // can be a race condition
            </span>.IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">const</span> preadv_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">preadv64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">preadv</a>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = preadv_sym(fd, iov.ptr, <span class="tok-builtin">@min</span>(iov.len, <a href="std.posix.html#std.posix.IOV_MAX">IOV_MAX</a>), <span class="tok-builtin">@bitCast</span>(offset));
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForReading,<span class="tok-comment"> // can be a race condition
            </span>.IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.write" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">write</span><a href="#src.zig-std.posix.write">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Write to a file descriptor.
Retries when interrupted by a signal.
Returns the number of bytes written. If nonzero bytes were supplied, this will be nonzero.</p>
<p>Note that a successful write() may transfer fewer than count bytes.  Such partial  writes  can
occur  for  various reasons; for example, because there was insufficient space on the disk
device to write all of the requested bytes, or because a blocked write() to a socket,  pipe,  or
similar  was  interrupted by a signal handler after it had transferred some, but before it had
transferred all of the requested bytes.  In the event of a partial write, the caller can  make
another  write() call to transfer the remaining bytes.  The subsequent call will either
transfer further bytes or may result in an error (e.g., if the disk is now full).</p>
<p>For POSIX systems, if <code>fd</code> is opened in non blocking mode, the function will
return error.WouldBlock when EAGAIN is received.
On Windows, if the application has a global event loop enabled, I/O Completion Ports are
used to perform the I/O. <code>error.WouldBlock</code> is not possible on Windows.</p>
<p>Linux has a limit on how many bytes may be transferred in one <code><a href="std.posix.html#std.posix.write">write</a></code> call, which is <code>0x7ffff000</code>
on both 64-bit and 32-bit systems. This is due to using a signed C int as the return value, as
well as stuffing the errno codes into the last <code>4096</code> values. This is noted on the <code><a href="std.posix.html#std.posix.write">write</a></code> man page.
The limit on Darwin is <code>0x7fffffff</code>, trying to read more than that returns EINVAL.
The corresponding POSIX limit is <code>maxInt(isize)</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.write">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (bytes.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.WriteFile">WriteFile</a>(fd, bytes, <span class="tok-null">null</span>);
    }

    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> ciovs = [_]<a href="std.posix.iovec_const.html">iovec_const</a>{<a href="std.posix.iovec_const.html">iovec_const</a>{
            .base = bytes.ptr,
            .len = bytes.len,
        }};
        <span class="tok-kw">var</span> nwritten: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_write">fd_write</a>(fd, &amp;ciovs, ciovs.len, &amp;nwritten)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> nwritten,
            .INTR =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .AGAIN =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForWriting,<span class="tok-comment"> // can be a race condition.
            </span>.DESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // `connect` was never called.
            </span>.DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">const</span> max_count = <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .linux =&gt; <span class="tok-number">0x7ffff000</span>,
        .macos, .ios, .watchos, .tvos, .visionos =&gt; <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">i32</span>),
        <span class="tok-kw">else</span> =&gt; <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">isize</span>),
    };
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">write</a>(fd, bytes.ptr, <span class="tok-builtin">@min</span>(bytes.len, max_count));
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidArgument,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForWriting,<span class="tok-comment"> // can be a race condition.
            </span>.DESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // `connect` was never called.
            </span>.DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeviceBusy,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoDevice,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.writev" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writev</span><a href="#src.zig-std.posix.writev">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writev</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, iov: []<span class="tok-kw">const</span> <a href="std.posix.iovec_const.html">iovec_const</a>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Write multiple buffers to a file descriptor.
Retries when interrupted by a signal.
Returns the number of bytes written. If nonzero bytes were supplied, this will be nonzero.</p>
<p>Note that a successful write() may transfer fewer bytes than supplied.  Such partial  writes  can
occur  for  various reasons; for example, because there was insufficient space on the disk
device to write all of the requested bytes, or because a blocked write() to a socket,  pipe,  or
similar  was  interrupted by a signal handler after it had transferred some, but before it had
transferred all of the requested bytes.  In the event of a partial write, the caller can  make
another  write() call to transfer the remaining bytes.  The subsequent call will either
transfer further bytes or may result in an error (e.g., if the disk is now full).</p>
<p>For POSIX systems, if <code>fd</code> is opened in non blocking mode, the function will
return error.WouldBlock when EAGAIN is received.
On Windows, if the application has a global event loop enabled, I/O Completion Ports are
used to perform the I/O. <code>error.WouldBlock</code> is not possible on Windows.</p>
<p>If <code>iov.len</code> is larger than <code><a href="std.posix.html#std.posix.IOV_MAX">IOV_MAX</a></code>, a partial write will occur.</p>
<p>This function assumes that all vectors, including zero-length vectors, have
a pointer within the address space of the application.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>iov: []<span class="tok-kw">const</span> <a href="std.posix.iovec_const.html">iovec_const</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.writev">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writev</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, iov: []<span class="tok-kw">const</span> <a href="std.posix.iovec_const.html">iovec_const</a>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {<span class="tok-comment">
        // TODO improve this to use WriteFileScatter
        </span><span class="tok-kw">if</span> (iov.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> first = iov[<span class="tok-number">0</span>];
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.write">write</a>(fd, first.base[<span class="tok-number">0</span>..first.len]);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> nwritten: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_write">fd_write</a>(fd, iov.ptr, iov.len, &amp;nwritten)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> nwritten,
            .INTR =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .AGAIN =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForWriting,<span class="tok-comment"> // can be a race condition.
            </span>.DESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // `connect` was never called.
            </span>.DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">writev</a>(fd, iov.ptr, <span class="tok-builtin">@min</span>(iov.len, <a href="std.posix.html#std.posix.IOV_MAX">IOV_MAX</a>));
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidArgument,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForWriting,<span class="tok-comment"> // Can be a race condition.
            </span>.DESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // `connect` was never called.
            </span>.DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeviceBusy,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.pwrite" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pwrite</span><a href="#src.zig-std.posix.pwrite">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pwrite</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PWriteError">PWriteError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Write to a file descriptor, with a position offset.
Retries when interrupted by a signal.
Returns the number of bytes written. If nonzero bytes were supplied, this will be nonzero.</p>
<p>Note that a successful write() may transfer fewer bytes than supplied.  Such partial  writes  can
occur  for  various reasons; for example, because there was insufficient space on the disk
device to write all of the requested bytes, or because a blocked write() to a socket,  pipe,  or
similar  was  interrupted by a signal handler after it had transferred some, but before it had
transferred all of the requested bytes.  In the event of a partial write, the caller can  make
another  write() call to transfer the remaining bytes.  The subsequent call will either
transfer further bytes or may result in an error (e.g., if the disk is now full).</p>
<p>For POSIX systems, if <code>fd</code> is opened in non blocking mode, the function will
return error.WouldBlock when EAGAIN is received.
On Windows, if the application has a global event loop enabled, I/O Completion Ports are
used to perform the I/O. <code>error.WouldBlock</code> is not possible on Windows.</p>
<p>Linux has a limit on how many bytes may be transferred in one <code><a href="std.posix.html#std.posix.pwrite">pwrite</a></code> call, which is <code>0x7ffff000</code>
on both 64-bit and 32-bit systems. This is due to using a signed C int as the return value, as
well as stuffing the errno codes into the last <code>4096</code> values. This is noted on the <code><a href="std.posix.html#std.posix.write">write</a></code> man page.
The limit on Darwin is <code>0x7fffffff</code>, trying to write more than that returns EINVAL.
The corresponding POSIX limit is <code>maxInt(isize)</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.pwrite">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pwrite</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PWriteError">PWriteError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (bytes.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.WriteFile">WriteFile</a>(fd, bytes, offset);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> ciovs = [<span class="tok-number">1</span>]<a href="std.posix.iovec_const.html">iovec_const</a>{<a href="std.posix.iovec_const.html">iovec_const</a>{
            .base = bytes.ptr,
            .len = bytes.len,
        }};

        <span class="tok-kw">var</span> nwritten: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_pwrite">fd_pwrite</a>(fd, &amp;ciovs, ciovs.len, offset, &amp;nwritten)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> nwritten,
            .INTR =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .AGAIN =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForWriting,<span class="tok-comment"> // can be a race condition.
            </span>.DESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // `connect` was never called.
            </span>.DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }<span class="tok-comment">

    // Prevent EINVAL.
    </span><span class="tok-kw">const</span> max_count = <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .linux =&gt; <span class="tok-number">0x7ffff000</span>,
        .macos, .ios, .watchos, .tvos, .visionos =&gt; <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">i32</span>),
        <span class="tok-kw">else</span> =&gt; <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">isize</span>),
    };

    <span class="tok-kw">const</span> pwrite_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">pwrite64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">pwrite</a>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = pwrite_sym(fd, bytes.ptr, <span class="tok-builtin">@min</span>(bytes.len, max_count), <span class="tok-builtin">@bitCast</span>(offset));
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidArgument,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForWriting,<span class="tok-comment"> // Can be a race condition.
            </span>.DESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // `connect` was never called.
            </span>.DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeviceBusy,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.pwritev" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pwritev</span><a href="#src.zig-std.posix.pwritev">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pwritev</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, iov: []<span class="tok-kw">const</span> <a href="std.posix.iovec_const.html">iovec_const</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PWriteError">PWriteError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Write multiple buffers to a file descriptor, with a position offset.
Retries when interrupted by a signal.
Returns the number of bytes written. If nonzero bytes were supplied, this will be nonzero.</p>
<p>Note that a successful write() may transfer fewer than count bytes.  Such partial  writes  can
occur  for  various reasons; for example, because there was insufficient space on the disk
device to write all of the requested bytes, or because a blocked write() to a socket,  pipe,  or
similar  was  interrupted by a signal handler after it had transferred some, but before it had
transferred all of the requested bytes.  In the event of a partial write, the caller can  make
another  write() call to transfer the remaining bytes.  The subsequent call will either
transfer further bytes or may result in an error (e.g., if the disk is now full).</p>
<p>If <code>fd</code> is opened in non blocking mode, the function will
return error.WouldBlock when EAGAIN is received.</p>
<p>The following systems do not have this syscall, and will return partial writes if more than one
vector is provided:</p>
<ul>
<li>Darwin</li>
<li>Windows</li>
</ul>
<p>If <code>iov.len</code> is larger than <code><a href="std.posix.html#std.posix.IOV_MAX">IOV_MAX</a></code>, a partial write will occur.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>iov: []<span class="tok-kw">const</span> <a href="std.posix.iovec_const.html">iovec_const</a></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.pwritev">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pwritev</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, iov: []<span class="tok-kw">const</span> <a href="std.posix.iovec_const.html">iovec_const</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PWriteError">PWriteError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> have_pwrite_but_not_pwritev = <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .windows, .macos, .ios, .watchos, .tvos, .visionos, .haiku =&gt; <span class="tok-null">true</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
    };

    <span class="tok-kw">if</span> (have_pwrite_but_not_pwritev) {<span class="tok-comment">
        // We could loop here; but proper usage of `pwritev` must handle partial writes anyway.
        // So we simply write the first vector only.
        </span><span class="tok-kw">if</span> (iov.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> first = iov[<span class="tok-number">0</span>];
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.pwrite">pwrite</a>(fd, first.base[<span class="tok-number">0</span>..first.len], offset);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> nwritten: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_pwrite">fd_pwrite</a>(fd, iov.ptr, iov.len, offset, &amp;nwritten)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> nwritten,
            .INTR =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .AGAIN =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForWriting,<span class="tok-comment"> // Can be a race condition.
            </span>.DESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // `connect` was never called.
            </span>.DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">const</span> pwritev_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">pwritev64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">pwritev</a>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = pwritev_sym(fd, iov.ptr, <span class="tok-builtin">@min</span>(iov.len, <a href="std.posix.html#std.posix.IOV_MAX">IOV_MAX</a>), <span class="tok-builtin">@bitCast</span>(offset));
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidArgument,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForWriting,<span class="tok-comment"> // Can be a race condition.
            </span>.DESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // `connect` was never called.
            </span>.DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeviceBusy,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.open" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">open</span><a href="#src.zig-std.posix.open">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">open</span>(file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.posix.html#std.posix.O">O</a>, perm: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.OpenError">OpenError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div class="tldDocs"><p>Open and possibly create a file. Keeps trying if it gets interrupted.
On Windows, <code>file_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>file_path</code> should be encoded as valid UTF-8.
On other platforms, <code>file_path</code> is an opaque sequence of bytes with no particular encoding.
See also <code><a href="std.posix.html#std.posix.openZ">openZ</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.posix.html#std.posix.O">O</a></code></pre></div><div><pre><code>perm: <a href="std.posix.html#std.posix.mode_t">mode_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.open">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">open</span>(file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.posix.html#std.posix.O">O</a>, perm: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.OpenError">OpenError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Windows does not support POSIX; use Windows-specific API or cross-platform std.fs API&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.openat">openat</a>(<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, file_path, flags, perm);
    }
    <span class="tok-kw">const</span> file_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(file_path);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.openZ">openZ</a>(&amp;file_path_c, flags, perm);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.openZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">openZ</span><a href="#src.zig-std.posix.openZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openZ</span>(file_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.posix.html#std.posix.O">O</a>, perm: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.OpenError">OpenError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div class="tldDocs"><p>Open and possibly create a file. Keeps trying if it gets interrupted.
On Windows, <code>file_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>file_path</code> should be encoded as valid UTF-8.
On other platforms, <code>file_path</code> is an opaque sequence of bytes with no particular encoding.
See also <code><a href="std.posix.html#std.posix.open">open</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>file_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.posix.html#std.posix.O">O</a></code></pre></div><div><pre><code>perm: <a href="std.posix.html#std.posix.mode_t">mode_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.openZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openZ</span>(file_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.posix.html#std.posix.O">O</a>, perm: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.OpenError">OpenError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Windows does not support POSIX; use Windows-specific API or cross-platform std.fs API&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.open">open</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(file_path, <span class="tok-number">0</span>), flags, perm);
    }

    <span class="tok-kw">const</span> open_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">open64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">open</a>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = open_sym(file_path, flags, perm);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,

            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadPathName,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
            .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
            .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
            .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
            .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoDevice,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
            .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeviceBusy,
            .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
            <span class="tok-kw">else</span>
                <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.openat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">openat</span><a href="#src.zig-std.posix.openat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openat</span>(dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.posix.html#std.posix.O">O</a>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.OpenError">OpenError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div class="tldDocs"><p>Open and possibly create a file. Keeps trying if it gets interrupted.
<code>file_path</code> is relative to the open directory handle <code>dir_fd</code>.
On Windows, <code>file_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>file_path</code> should be encoded as valid UTF-8.
On other platforms, <code>file_path</code> is an opaque sequence of bytes with no particular encoding.
See also <code><a href="std.posix.html#std.posix.openatZ">openatZ</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.posix.html#std.posix.O">O</a></code></pre></div><div><pre><code>mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.openat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openat</span>(dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.posix.html#std.posix.O">O</a>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.OpenError">OpenError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Windows does not support POSIX; use Windows-specific API or cross-platform std.fs API&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {<span class="tok-comment">
        // `mode` is ignored on WASI, which does not support unix-style file permissions
        </span><span class="tok-kw">const</span> opts = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.openOptionsFromFlagsWasi">openOptionsFromFlagsWasi</a>(flags);
        <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.openatWasi">openatWasi</a>(
            dir_fd,
            file_path,
            opts.lookup_flags,
            opts.oflags,
            opts.fs_flags,
            opts.fs_rights_base,
            opts.fs_rights_inheriting,
        );
        <span class="tok-kw">errdefer</span> <a href="std.posix.html#std.posix.close">close</a>(fd);

        <span class="tok-kw">if</span> (flags.write) {
            <span class="tok-kw">const</span> info = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.fstat_wasi">fstat_wasi</a>(fd);
            <span class="tok-kw">if</span> (info.filetype == .DIRECTORY)
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir;
        }

        <span class="tok-kw">return</span> fd;
    }
    <span class="tok-kw">const</span> file_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(file_path);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.openatZ">openatZ</a>(dir_fd, &amp;file_path_c, flags, mode);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.openatWasi" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">openatWasi</span><a href="#src.zig-std.posix.openatWasi">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openatWasi</span>( dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, lookup_flags: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.lookupflags_t.html">lookupflags_t</a>, oflags: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.oflags_t.html">oflags_t</a>, fdflags: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.fdflags_t.html">fdflags_t</a>, base: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.rights_t.html">rights_t</a>, inheriting: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.rights_t.html">rights_t</a>, ) <a href="std.posix.html#std.posix.OpenError">OpenError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div class="tldDocs"><p>Open and possibly create a file in WASI.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>lookup_flags: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.lookupflags_t.html">lookupflags_t</a></code></pre></div><div><pre><code>oflags: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.oflags_t.html">oflags_t</a></code></pre></div><div><pre><code>fdflags: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.fdflags_t.html">fdflags_t</a></code></pre></div><div><pre><code>base: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.rights_t.html">rights_t</a></code></pre></div><div><pre><code>inheriting: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.rights_t.html">rights_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.openatWasi">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openatWasi</span>(
    dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    lookup_flags: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.lookupflags_t.html">lookupflags_t</a>,
    oflags: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.oflags_t.html">oflags_t</a>,
    fdflags: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.fdflags_t.html">fdflags_t</a>,
    base: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.rights_t.html">rights_t</a>,
    inheriting: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.rights_t.html">rights_t</a>,
) <a href="std.posix.html#std.posix.OpenError">OpenError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">var</span> fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.path_open">path_open</a>(dir_fd, lookup_flags, file_path.ptr, file_path.len, oflags, base, inheriting, fdflags, &amp;fd)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> fd,
            .INTR =&gt; <span class="tok-kw">continue</span>,

            .FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment">
            // Provides INVAL with a linux host on a bad path name, but NOENT on Windows
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadPathName,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
            .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
            .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
            .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
            .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoDevice,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
            .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeviceBusy,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .ILSEQ =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.openatZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">openatZ</span><a href="#src.zig-std.posix.openatZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openatZ</span>(dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.posix.html#std.posix.O">O</a>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.OpenError">OpenError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div class="tldDocs"><p>Open and possibly create a file. Keeps trying if it gets interrupted.
<code>file_path</code> is relative to the open directory handle <code>dir_fd</code>.
On Windows, <code>file_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>file_path</code> should be encoded as valid UTF-8.
On other platforms, <code>file_path</code> is an opaque sequence of bytes with no particular encoding.
See also <code><a href="std.posix.html#std.posix.openat">openat</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>file_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.posix.html#std.posix.O">O</a></code></pre></div><div><pre><code>mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.openatZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openatZ</span>(dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.posix.html#std.posix.O">O</a>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.OpenError">OpenError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Windows does not support POSIX; use Windows-specific API or cross-platform std.fs API&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.openat">openat</a>(dir_fd, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(file_path, <span class="tok-number">0</span>), flags, mode);
    }

    <span class="tok-kw">const</span> openat_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">openat64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">openat</a>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = openat_sym(dir_fd, file_path, flags, mode);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,

            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadPathName,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
            .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
            .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
            .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
            .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoDevice,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
            .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeviceBusy,
            .OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileLocksNotSupported,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .TXTBSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoDevice,
            .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
            <span class="tok-kw">else</span>
                <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.dup" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dup</span><a href="#src.zig-std.posix.dup">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dup</span>(old_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) !<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>old_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.dup">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dup</span>(old_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) !<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">dup</a>(old_fd);
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        .MFILE =&gt; <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid file descriptor
        </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.dup2" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dup2</span><a href="#src.zig-std.posix.dup2">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dup2</span>(old_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, new_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>old_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>new_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.dup2">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dup2</span>(old_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, new_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">dup2</a>(old_fd, new_fd))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BUSY, .INTR =&gt; <span class="tok-kw">continue</span>,
            .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid parameters passed to dup2
            </span>.BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid file descriptor
            </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.execveZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">execveZ</span><a href="#src.zig-std.posix.execveZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">execveZ</span>( path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, child_argv: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, envp: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></code></pre></div><div class="tldDocs"><p>This function ignores PATH environment variable. See <code><a href="std.posix.html#std.posix.execvpeZ">execvpeZ</a></code> for that.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>child_argv: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>envp: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.execveZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">execveZ</span>(
    path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    child_argv: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    envp: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.posix.html#std.posix.ExecveError">ExecveError</a> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">execve</a>(path, child_argv, envp))) {
        .SUCCESS =&gt; <span class="tok-kw">unreachable</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .@&quot;2BIG&quot; =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExe,
        .NOEXEC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExe,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .TXTBSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
            .macos, .ios, .tvos, .watchos, .visionos =&gt; <span class="tok-kw">switch</span> (err) {
                .BADEXEC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExe,
                .BADARCH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExe,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            },
            .linux =&gt; <span class="tok-kw">switch</span> (err) {
                .LIBBAD =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExe,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        },
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.execvpeZ_expandArg0" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">execvpeZ_expandArg0</span><a href="#src.zig-std.posix.execvpeZ_expandArg0">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">execvpeZ_expandArg0</span>( <span class="tok-kw">comptime</span> arg0_expand: <a href="std.posix.Arg0Expand.html">Arg0Expand</a>, file: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, child_argv: <span class="tok-kw">switch</span> (arg0_expand) { .expand =&gt; [*:<span class="tok-null">null</span>]?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, .no_expand =&gt; [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, }, envp: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></code></pre></div><div class="tldDocs"><p>Like <code><a href="std.posix.html#std.posix.execvpeZ">execvpeZ</a></code> except if <code>arg0_expand</code> is <code>.expand</code>, then <code>argv</code> is mutable,
and <code>argv[0]</code> is expanded to be the same absolute path that is passed to the execve syscall.
If this function returns with an error, <code>argv[0]</code> will be restored to the value it was when it was passed in.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>arg0_expand: <a href="std.posix.Arg0Expand.html">Arg0Expand</a></code></pre></div><div><pre><code>file: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>child_argv: <span class="tok-kw">switch</span> (arg0_expand) {
    .expand =&gt; [*:<span class="tok-null">null</span>]?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    .no_expand =&gt; [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
}</code></pre></div><div><pre><code>envp: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.execvpeZ_expandArg0">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">execvpeZ_expandArg0</span>(
    <span class="tok-kw">comptime</span> arg0_expand: <a href="std.posix.Arg0Expand.html">Arg0Expand</a>,
    file: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    child_argv: <span class="tok-kw">switch</span> (arg0_expand) {
        .expand =&gt; [*:<span class="tok-null">null</span>]?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        .no_expand =&gt; [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    },
    envp: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.posix.html#std.posix.ExecveError">ExecveError</a> {
    <span class="tok-kw">const</span> file_slice = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(file, <span class="tok-number">0</span>);
    <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, file_slice, <span class="tok-str">'/'</span>) != <span class="tok-null">null</span>) <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.execveZ">execveZ</a>(file, child_argv, envp);

    <span class="tok-kw">const</span> PATH = <a href="std.posix.html#std.posix.getenvZ">getenvZ</a>(<span class="tok-str">&quot;PATH&quot;</span>) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;/usr/local/bin:/bin/:/usr/bin&quot;</span>;<span class="tok-comment">
    // Use of PATH_MAX here is valid as the path_buf will be passed
    // directly to the operating system in execveZ.
    </span><span class="tok-kw">var</span> path_buf: [<a href="std.posix.html#std.posix.PATH_MAX">PATH_MAX</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, PATH, <span class="tok-str">':'</span>);
    <span class="tok-kw">var</span> seen_eacces = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> err: <a href="std.posix.html#std.posix.ExecveError">ExecveError</a> = <span class="tok-kw">error</span>.FileNotFound;<span class="tok-comment">

    // In case of expanding arg0 we must put it back if we return with an error.
    </span><span class="tok-kw">const</span> prev_arg0 = child_argv[<span class="tok-number">0</span>];
    <span class="tok-kw">defer</span> <span class="tok-kw">switch</span> (arg0_expand) {
        .expand =&gt; child_argv[<span class="tok-number">0</span>] = prev_arg0,
        .no_expand =&gt; {},
    };

    <span class="tok-kw">while</span> (it.next()) |search_path| {
        <span class="tok-kw">const</span> path_len = search_path.len + file_slice.len + <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (path_buf.len &lt; path_len + <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
        <span class="tok-builtin">@memcpy</span>(path_buf[<span class="tok-number">0</span>..search_path.len], search_path);
        path_buf[search_path.len] = <span class="tok-str">'/'</span>;
        <span class="tok-builtin">@memcpy</span>(path_buf[search_path.len + <span class="tok-number">1</span> ..][<span class="tok-number">0</span>..file_slice.len], file_slice);
        path_buf[path_len] = <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> full_path = path_buf[<span class="tok-number">0</span>..path_len :<span class="tok-number">0</span>].ptr;
        <span class="tok-kw">switch</span> (arg0_expand) {
            .expand =&gt; child_argv[<span class="tok-number">0</span>] = full_path,
            .no_expand =&gt; {},
        }
        err = <a href="std.posix.html#std.posix.execveZ">execveZ</a>(full_path, child_argv, envp);
        <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.AccessDenied =&gt; seen_eacces = <span class="tok-null">true</span>,
            <span class="tok-kw">error</span>.FileNotFound, <span class="tok-kw">error</span>.NotDir =&gt; {},
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        }
    }
    <span class="tok-kw">if</span> (seen_eacces) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied;
    <span class="tok-kw">return</span> err;
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.execvpeZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">execvpeZ</span><a href="#src.zig-std.posix.execvpeZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">execvpeZ</span>( file: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, argv_ptr: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, envp: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></code></pre></div><div class="tldDocs"><p>This function also uses the PATH environment variable to get the full path to the executable.
If <code>file</code> is an absolute path, this is the same as <code><a href="std.posix.html#std.posix.execveZ">execveZ</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>file: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>argv_ptr: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>envp: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.execvpeZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">execvpeZ</span>(
    file: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    argv_ptr: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    envp: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.posix.html#std.posix.ExecveError">ExecveError</a> {
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.execvpeZ_expandArg0">execvpeZ_expandArg0</a>(.no_expand, file, argv_ptr, envp);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.getenv" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getenv</span><a href="#src.zig-std.posix.getenv">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getenv</span>(key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Get an environment variable.
See also <code><a href="std.posix.html#std.posix.getenvZ">getenvZ</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.getenv">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getenv</span>(key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.posix.getenv is unavailable for Windows because environment strings are in WTF-16 format. See std.process.getEnvVarOwned for a cross-platform API or std.process.getenvW for a Windows-specific API.&quot;</span>);
    }
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> ptr = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.environ">environ</a>;
        <span class="tok-kw">while</span> (ptr[<span class="tok-number">0</span>]) |line| : (ptr += <span class="tok-number">1</span>) {
            <span class="tok-kw">var</span> line_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (line[line_i] != <span class="tok-number">0</span> <span class="tok-kw">and</span> line[line_i] != <span class="tok-str">'='</span>) : (line_i += <span class="tok-number">1</span>) {}
            <span class="tok-kw">const</span> this_key = line[<span class="tok-number">0</span>..line_i];

            <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, this_key, key)) <span class="tok-kw">continue</span>;

            <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(line + line_i + <span class="tok-number">1</span>, <span class="tok-number">0</span>);
        }
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.posix.getenv is unavailable for WASI. See std.process.getEnvMap or std.process.getEnvVarOwned for a cross-platform API.&quot;</span>);
    }<span class="tok-comment">
    // The simplified start logic doesn't populate environ.
    </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.start.html">start</a>.<a href="std.start.html#std.start.simplified_logic">simplified_logic</a>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;<span class="tok-comment">
    // TODO see https://github.com/ziglang/zig/issues/4524
    </span><span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.environ">environ</a>) |ptr| {
        <span class="tok-kw">var</span> line_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (ptr[line_i] != <span class="tok-number">0</span> <span class="tok-kw">and</span> ptr[line_i] != <span class="tok-str">'='</span>) : (line_i += <span class="tok-number">1</span>) {}
        <span class="tok-kw">const</span> this_key = ptr[<span class="tok-number">0</span>..line_i];
        <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, key, this_key)) <span class="tok-kw">continue</span>;

        <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(ptr + line_i + <span class="tok-number">1</span>, <span class="tok-number">0</span>);
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.getenvZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getenvZ</span><a href="#src.zig-std.posix.getenvZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getenvZ</span>(key: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Get an environment variable with a null-terminated name.
See also <code><a href="std.posix.html#std.posix.getenv">getenv</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>key: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.getenvZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getenvZ</span>(key: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> value = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">getenv</a>(key) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(value, <span class="tok-number">0</span>);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.posix.getenvZ is unavailable for Windows because environment string is in WTF-16 format. See std.process.getEnvVarOwned for cross-platform API or std.process.getenvW for Windows-specific API.&quot;</span>);
    }
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.getenv">getenv</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(key, <span class="tok-number">0</span>));
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.getcwd" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getcwd</span><a href="#src.zig-std.posix.getcwd">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getcwd</span>(out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.GetCwdError">GetCwdError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>The result is a slice of out_buffer, indexed from 0.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>out_buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.getcwd">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getcwd</span>(out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.GetCwdError">GetCwdError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetCurrentDirectory">GetCurrentDirectory</a>(out_buffer);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> path = <span class="tok-str">&quot;.&quot;</span>;
        <span class="tok-kw">if</span> (out_buffer.len &lt; path.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
        <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..path.len];
        <span class="tok-builtin">@memcpy</span>(result, path);
        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">const</span> err: <a href="std.posix.html#std.posix.E">E</a> = <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) err: {
        <span class="tok-kw">const</span> c_err = <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.getcwd">getcwd</a>(out_buffer.ptr, out_buffer.len)) |_| <span class="tok-number">0</span> <span class="tok-kw">else</span> <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c._errno">_errno</a>().*;
        <span class="tok-kw">break</span> :err <span class="tok-builtin">@enumFromInt</span>(c_err);
    } <span class="tok-kw">else</span> err: {
        <span class="tok-kw">break</span> :err <a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">getcwd</a>(out_buffer.ptr, out_buffer.len));
    };
    <span class="tok-kw">switch</span> (err) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(out_buffer, <span class="tok-number">0</span>),
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CurrentWorkingDirectoryUnlinked,
        .RANGE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.symlink" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">symlink</span><a href="#src.zig-std.posix.symlink">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symlink</span>(target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.SymLinkError">SymLinkError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Creates a symbolic link named <code>sym_link_path</code> which contains the string <code>target_path</code>.
A symbolic link (also known as a soft link) may point to an existing file or to a nonexistent
one; the latter case is known as a dangling link.
On Windows, both paths should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, both paths should be encoded as valid UTF-8.
On other platforms, both paths are an opaque sequence of bytes with no particular encoding.
If <code>sym_link_path</code> exists, it will not be overwritten.
See also <code>symlinkZ.</code></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.symlink">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symlink</span>(target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.SymLinkError">SymLinkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;symlink is not supported on Windows; use std.os.windows.CreateSymbolicLink instead&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.symlinkat">symlinkat</a>(target_path, <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, sym_link_path);
    }
    <span class="tok-kw">const</span> target_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(target_path);
    <span class="tok-kw">const</span> sym_link_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sym_link_path);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.symlinkZ">symlinkZ</a>(&amp;target_path_c, &amp;sym_link_path_c);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.symlinkZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">symlinkZ</span><a href="#src.zig-std.posix.symlinkZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symlinkZ</span>(target_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, sym_link_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.SymLinkError">SymLinkError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>This is the same as <code><a href="std.posix.html#std.posix.symlink">symlink</a></code> except the parameters are null-terminated pointers.
See also <code><a href="std.posix.html#std.posix.symlink">symlink</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>target_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>sym_link_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.symlinkZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symlinkZ</span>(target_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, sym_link_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.SymLinkError">SymLinkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;symlink is not supported on Windows; use std.os.windows.CreateSymbolicLink instead&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.symlinkatZ">symlinkatZ</a>(target_path, <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().fd, sym_link_path);
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">symlink</a>(target_path, sym_link_path))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.symlinkat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">symlinkat</span><a href="#src.zig-std.posix.symlinkat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symlinkat</span>(target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, newdirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.SymLinkError">SymLinkError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Similar to <code><a href="std.posix.html#std.posix.symlink">symlink</a></code>, however, creates a symbolic link named <code>sym_link_path</code> which contains the string
<code>target_path</code> <strong>relative</strong> to <code>newdirfd</code> directory handle.
A symbolic link (also known as a soft link) may point to an existing file or to a nonexistent
one; the latter case is known as a dangling link.
On Windows, both paths should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, both paths should be encoded as valid UTF-8.
On other platforms, both paths are an opaque sequence of bytes with no particular encoding.
If <code>sym_link_path</code> exists, it will not be overwritten.
See also <code><a href="std.posix.html#std.posix.symlinkatWasi">symlinkatWasi</a></code>, <code><a href="std.posix.html#std.posix.symlinkatZ">symlinkatZ</a></code> and <code>symlinkatW</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>newdirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.symlinkat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symlinkat</span>(target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, newdirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.SymLinkError">SymLinkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;symlinkat is not supported on Windows; use std.os.windows.CreateSymbolicLink instead&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.symlinkatWasi">symlinkatWasi</a>(target_path, newdirfd, sym_link_path);
    }
    <span class="tok-kw">const</span> target_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(target_path);
    <span class="tok-kw">const</span> sym_link_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sym_link_path);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.symlinkatZ">symlinkatZ</a>(&amp;target_path_c, newdirfd, &amp;sym_link_path_c);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.symlinkatWasi" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">symlinkatWasi</span><a href="#src.zig-std.posix.symlinkatWasi">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symlinkatWasi</span>(target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, newdirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.SymLinkError">SymLinkError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>WASI-only. The same as <code><a href="std.posix.html#std.posix.symlinkat">symlinkat</a></code> but targeting WASI.
See also <code><a href="std.posix.html#std.posix.symlinkat">symlinkat</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>newdirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.symlinkatWasi">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symlinkatWasi</span>(target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, newdirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.SymLinkError">SymLinkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.path_symlink">path_symlink</a>(target_path.ptr, target_path.len, newdirfd, sym_link_path.ptr, sym_link_path.len)) {
        .SUCCESS =&gt; {},
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .ILSEQ =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.symlinkatZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">symlinkatZ</span><a href="#src.zig-std.posix.symlinkatZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symlinkatZ</span>(target_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, newdirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sym_link_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.SymLinkError">SymLinkError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>The same as <code><a href="std.posix.html#std.posix.symlinkat">symlinkat</a></code> except the parameters are null-terminated pointers.
See also <code><a href="std.posix.html#std.posix.symlinkat">symlinkat</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>target_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>newdirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>sym_link_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.symlinkatZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symlinkatZ</span>(target_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, newdirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sym_link_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.SymLinkError">SymLinkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;symlinkat is not supported on Windows; use std.os.windows.CreateSymbolicLink instead&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.symlinkat">symlinkat</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(target_path, <span class="tok-number">0</span>), newdirfd, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sym_link_path, <span class="tok-number">0</span>));
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">symlinkat</a>(target_path, newdirfd, sym_link_path))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.linkZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">linkZ</span><a href="#src.zig-std.posix.linkZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkZ</span>(oldpath: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, newpath: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.LinkError">LinkError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>On WASI, both paths should be encoded as valid UTF-8.
On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>oldpath: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>newpath: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.linkZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkZ</span>(oldpath: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, newpath: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.LinkError">LinkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.link">link</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(oldpath, <span class="tok-number">0</span>), <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(newpath, <span class="tok-number">0</span>));
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">link</a>(oldpath, newpath))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .MLINK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LinkQuotaExceeded,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .XDEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotSameFileSystem,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.link" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">link</span><a href="#src.zig-std.posix.link">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">link</span>(oldpath: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, newpath: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.LinkError">LinkError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>On WASI, both paths should be encoded as valid UTF-8.
On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>oldpath: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>newpath: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.link">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">link</span>(oldpath: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, newpath: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.LinkError">LinkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.linkat">linkat</a>(<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, oldpath, <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, newpath, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.NotDir =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // link() does not support directories
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    }
    <span class="tok-kw">const</span> old = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(oldpath);
    <span class="tok-kw">const</span> new = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(newpath);
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.linkZ">linkZ</a>(&amp;old, &amp;new);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.linkatZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">linkatZ</span><a href="#src.zig-std.posix.linkatZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkatZ</span>( olddir: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, oldpath: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, newdir: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, newpath: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">i32</span>, ) <a href="std.posix.html#std.posix.LinkatError">LinkatError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>On WASI, both paths should be encoded as valid UTF-8.
On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>olddir: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>oldpath: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>newdir: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>newpath: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <span class="tok-type">i32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.linkatZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkatZ</span>(
    olddir: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    oldpath: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    newdir: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    newpath: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <span class="tok-type">i32</span>,
) <a href="std.posix.html#std.posix.LinkatError">LinkatError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.linkat">linkat</a>(olddir, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(oldpath, <span class="tok-number">0</span>), newdir, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(newpath, <span class="tok-number">0</span>), flags);
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">linkat</a>(olddir, oldpath, newdir, newpath, flags))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .MLINK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LinkQuotaExceeded,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .XDEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotSameFileSystem,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.linkat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">linkat</span><a href="#src.zig-std.posix.linkat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkat</span>( olddir: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, oldpath: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, newdir: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, newpath: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">i32</span>, ) <a href="std.posix.html#std.posix.LinkatError">LinkatError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>On WASI, both paths should be encoded as valid UTF-8.
On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>olddir: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>oldpath: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>newdir: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>newpath: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <span class="tok-type">i32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.linkat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkat</span>(
    olddir: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    oldpath: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    newdir: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    newpath: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <span class="tok-type">i32</span>,
) <a href="std.posix.html#std.posix.LinkatError">LinkatError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> old: <a href="std.posix.RelativePathWasi.html">RelativePathWasi</a> = .{ .dir_fd = olddir, .relative_path = oldpath };
        <span class="tok-kw">const</span> new: <a href="std.posix.RelativePathWasi.html">RelativePathWasi</a> = .{ .dir_fd = newdir, .relative_path = newpath };
        <span class="tok-kw">const</span> old_flags: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.lookupflags_t.html">lookupflags_t</a> = .{
            .SYMLINK_FOLLOW = (flags &amp; <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">SYMLINK_FOLLOW</a>) != <span class="tok-number">0</span>,
        };
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.path_link">path_link</a>(
            old.dir_fd,
            old_flags,
            old.relative_path.ptr,
            old.relative_path.len,
            new.dir_fd,
            new.relative_path.ptr,
            new.relative_path.len,
        )) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
            .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
            .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
            .MLINK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LinkQuotaExceeded,
            .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
            .XDEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotSameFileSystem,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .ILSEQ =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">const</span> old = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(oldpath);
    <span class="tok-kw">const</span> new = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(newpath);
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.linkatZ">linkatZ</a>(olddir, &amp;old, newdir, &amp;new, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.unlink" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlink</span><a href="#src.zig-std.posix.unlink">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlink</span>(file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Delete a name and possibly the file it refers to.
On Windows, <code>file_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>file_path</code> should be encoded as valid UTF-8.
On other platforms, <code>file_path</code> is an opaque sequence of bytes with no particular encoding.
See also <code><a href="std.posix.html#std.posix.unlinkZ">unlinkZ</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.unlink">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlink</span>(file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlinkat">unlinkat</a>(<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, file_path, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // only occurs when targeting directories
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> file_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, file_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlinkW">unlinkW</a>(file_path_w.span());
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> file_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(file_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlinkZ">unlinkZ</a>(&amp;file_path_c);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.unlinkZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlinkZ</span><a href="#src.zig-std.posix.unlinkZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkZ</span>(file_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.unlink">unlink</a></code> except the parameter is null terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>file_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.unlinkZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkZ</span>(file_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> file_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, file_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlinkW">unlinkW</a>(file_path_w.span());
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlink">unlink</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(file_path, <span class="tok-number">0</span>));
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">unlink</a>(file_path))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.unlinkW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlinkW</span><a href="#src.zig-std.posix.unlinkW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkW</span>(file_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Windows-only. Same as <code><a href="std.posix.html#std.posix.unlink">unlink</a></code> except the parameter is null-terminated, WTF16 LE encoded.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>file_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.unlinkW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkW</span>(file_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a>!<span class="tok-type">void</span> {
    <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DeleteFile">DeleteFile</a>(file_path_w, .{ .dir = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().fd }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // we're not passing .remove_dir = true
        </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.unlinkat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlinkat</span><a href="#src.zig-std.posix.unlinkat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkat</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.UnlinkatError">UnlinkatError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Delete a file name and possibly the file it refers to, based on an open directory handle.
On Windows, <code>file_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>file_path</code> should be encoded as valid UTF-8.
On other platforms, <code>file_path</code> is an opaque sequence of bytes with no particular encoding.
Asserts that the path parameter has no null bytes.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.unlinkat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkat</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.UnlinkatError">UnlinkatError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> file_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(dirfd, file_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlinkatW">unlinkatW</a>(dirfd, file_path_w.span(), flags);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlinkatWasi">unlinkatWasi</a>(dirfd, file_path, flags);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> file_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(file_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlinkatZ">unlinkatZ</a>(dirfd, &amp;file_path_c, flags);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.unlinkatWasi" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlinkatWasi</span><a href="#src.zig-std.posix.unlinkatWasi">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkatWasi</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.UnlinkatError">UnlinkatError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>WASI-only. Same as <code><a href="std.posix.html#std.posix.unlinkat">unlinkat</a></code> but targeting WASI.
See also <code><a href="std.posix.html#std.posix.unlinkat">unlinkat</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.unlinkatWasi">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkatWasi</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.UnlinkatError">UnlinkatError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> remove_dir = (flags &amp; <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">REMOVEDIR</a>) != <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> res = <span class="tok-kw">if</span> (remove_dir)
        <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.path_remove_directory">path_remove_directory</a>(dirfd, file_path.ptr, file_path.len)
    <span class="tok-kw">else</span>
        <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.path_unlink_file">path_unlink_file</a>(dirfd, file_path.ptr, file_path.len);
    <span class="tok-kw">switch</span> (res) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .NOTEMPTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotEmpty,
        .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .ILSEQ =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8,

        .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid flags, or pathname has . as last component
        </span>.BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition

        </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.unlinkatZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlinkatZ</span><a href="#src.zig-std.posix.unlinkatZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkatZ</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.UnlinkatError">UnlinkatError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.unlinkat">unlinkat</a></code> but <code>file_path</code> is a null-terminated string.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>file_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.unlinkatZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkatZ</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.UnlinkatError">UnlinkatError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> file_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(dirfd, file_path_c);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlinkatW">unlinkatW</a>(dirfd, file_path_w.span(), flags);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlinkat">unlinkat</a>(dirfd, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(file_path_c, <span class="tok-number">0</span>), flags);
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">unlinkat</a>(dirfd, file_path_c, flags))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotEmpty,
        .NOTEMPTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotEmpty,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),

        .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid flags, or pathname has . as last component
        </span>.BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition

        </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.unlinkatW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlinkatW</span><a href="#src.zig-std.posix.unlinkatW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkatW</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.UnlinkatError">UnlinkatError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.unlinkat">unlinkat</a></code> but <code>sub_path_w</code> is WTF16LE, NT prefixed. Windows only.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.unlinkatW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkatW</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.UnlinkatError">UnlinkatError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> remove_dir = (flags &amp; <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">REMOVEDIR</a>) != <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DeleteFile">DeleteFile</a>(sub_path_w, .{ .dir = dirfd, .remove_dir = remove_dir });
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.rename" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rename</span><a href="#src.zig-std.posix.rename">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rename</span>(old_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Change the name or location of a file.
On Windows, both paths should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, both paths should be encoded as valid UTF-8.
On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>old_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>new_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.rename">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rename</span>(old_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.renameat">renameat</a>(<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, old_path, <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, new_path);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> old_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, old_path);
        <span class="tok-kw">const</span> new_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, new_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.renameW">renameW</a>(old_path_w.span().ptr, new_path_w.span().ptr);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> old_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(old_path);
        <span class="tok-kw">const</span> new_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(new_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.renameZ">renameZ</a>(&amp;old_path_c, &amp;new_path_c);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.renameZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">renameZ</span><a href="#src.zig-std.posix.renameZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameZ</span>(old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.rename">rename</a></code> except the parameters are null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.renameZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameZ</span>(old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> old_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, old_path);
        <span class="tok-kw">const</span> new_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, new_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.renameW">renameW</a>(old_path_w.span().ptr, new_path_w.span().ptr);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.rename">rename</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(old_path, <span class="tok-number">0</span>), <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(new_path, <span class="tok-number">0</span>));
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">rename</a>(old_path, new_path))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .MLINK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LinkQuotaExceeded,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .NOTEMPTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .XDEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.RenameAcrossMountPoints,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.renameW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">renameW</span><a href="#src.zig-std.posix.renameW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameW</span>(old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.rename">rename</a></code> except the parameters are null-terminated and WTF16LE encoded.
Assumes target is Windows.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.renameW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameW</span>(old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> flags = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.MOVEFILE_REPLACE_EXISTING">MOVEFILE_REPLACE_EXISTING</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.MOVEFILE_WRITE_THROUGH">MOVEFILE_WRITE_THROUGH</a>;
    <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.MoveFileExW">MoveFileExW</a>(old_path, new_path, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.renameat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">renameat</span><a href="#src.zig-std.posix.renameat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameat</span>( old_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, old_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, new_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Change the name or location of a file based on an open directory handle.
On Windows, both paths should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, both paths should be encoded as valid UTF-8.
On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>old_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>old_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>new_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>new_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.renameat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameat</span>(
    old_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    old_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    new_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    new_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> old_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(old_dir_fd, old_path);
        <span class="tok-kw">const</span> new_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(new_dir_fd, new_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.renameatW">renameatW</a>(old_dir_fd, old_path_w.span(), new_dir_fd, new_path_w.span(), <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TRUE">TRUE</a>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> old: <a href="std.posix.RelativePathWasi.html">RelativePathWasi</a> = .{ .dir_fd = old_dir_fd, .relative_path = old_path };
        <span class="tok-kw">const</span> new: <a href="std.posix.RelativePathWasi.html">RelativePathWasi</a> = .{ .dir_fd = new_dir_fd, .relative_path = new_path };
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.renameatWasi">renameatWasi</a>(old, new);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> old_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(old_path);
        <span class="tok-kw">const</span> new_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(new_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.renameatZ">renameatZ</a>(old_dir_fd, &amp;old_path_c, new_dir_fd, &amp;new_path_c);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.renameatZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">renameatZ</span><a href="#src.zig-std.posix.renameatZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameatZ</span>( old_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.renameat">renameat</a></code> except the parameters are null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>old_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>new_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.renameatZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameatZ</span>(
    old_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    new_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> old_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(old_dir_fd, old_path);
        <span class="tok-kw">const</span> new_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(new_dir_fd, new_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.renameatW">renameatW</a>(old_dir_fd, old_path_w.span(), new_dir_fd, new_path_w.span(), <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TRUE">TRUE</a>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.renameat">renameat</a>(old_dir_fd, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(old_path, <span class="tok-number">0</span>), new_dir_fd, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(new_path, <span class="tok-number">0</span>));
    }

    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">renameat</a>(old_dir_fd, old_path, new_dir_fd, new_path))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .MLINK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LinkQuotaExceeded,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .NOTEMPTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .XDEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.RenameAcrossMountPoints,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.renameatW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">renameatW</span><a href="#src.zig-std.posix.renameatW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameatW</span>( old_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, old_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, new_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, new_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, ReplaceIfExists: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.BYTE">BOOLEAN</a>, ) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.renameat">renameat</a></code> but Windows-only and the path parameters are
<a href="https://simonsapin.github.io/wtf-8/#potentially-ill-formed-utf-16">WTF-16</a> encoded.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>old_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>old_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>new_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>new_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>ReplaceIfExists: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.BYTE">BOOLEAN</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.renameatW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameatW</span>(
    old_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    old_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>,
    new_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    new_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>,
    ReplaceIfExists: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.BYTE">BOOLEAN</a>,
) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> src_fd = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.OpenFile">OpenFile</a>(old_path_w, .{
        .dir = old_dir_fd,
        .access_mask = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SYNCHRONIZE">SYNCHRONIZE</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GENERIC_WRITE">GENERIC_WRITE</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DELETE">DELETE</a>,
        .creation = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_OPEN">FILE_OPEN</a>,
        .filter = .any,<span class="tok-comment"> // This function is supposed to rename both files and directories.
        </span>.follow_symlinks = <span class="tok-null">false</span>,
    }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Not possible without `.share_access_nonblocking = true`.
        </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
    <span class="tok-kw">defer</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CloseHandle">CloseHandle</a>(src_fd);

    <span class="tok-kw">var</span> need_fallback = <span class="tok-null">true</span>;
    <span class="tok-kw">var</span> rc: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntstatus.NTSTATUS.html">NTSTATUS</a> = <span class="tok-null">undefined</span>;<span class="tok-comment">
    // FILE_RENAME_INFORMATION_EX and FILE_RENAME_POSIX_SEMANTICS require &gt;= win10_rs1,
    // but FILE_RENAME_IGNORE_READONLY_ATTRIBUTE requires &gt;= win10_rs5. We check &gt;= rs5 here
    // so that we only use POSIX_SEMANTICS when we know IGNORE_READONLY_ATTRIBUTE will also be
    // supported in order to avoid either (1) using a redundant call that we can know in advance will return
    // STATUS_NOT_SUPPORTED or (2) only setting IGNORE_READONLY_ATTRIBUTE when &gt;= rs5
    // and therefore having different behavior when the Windows version is &gt;= rs1 but &lt; rs5.
    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">isAtLeast</a>(.windows, .win10_rs5) <span class="tok-kw">orelse</span> <span class="tok-null">false</span>) {
        <span class="tok-kw">const</span> struct_buf_len = <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_RENAME_INFORMATION_EX.html">FILE_RENAME_INFORMATION_EX</a>) + (<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a> - <span class="tok-number">1</span>);
        <span class="tok-kw">var</span> rename_info_buf: [struct_buf_len]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_RENAME_INFORMATION_EX.html">FILE_RENAME_INFORMATION_EX</a>)) = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> struct_len = <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_RENAME_INFORMATION_EX.html">FILE_RENAME_INFORMATION_EX</a>) - <span class="tok-number">1</span> + new_path_w.len * <span class="tok-number">2</span>;
        <span class="tok-kw">if</span> (struct_len &gt; struct_buf_len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;

        <span class="tok-kw">const</span> rename_info: *<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_RENAME_INFORMATION_EX.html">FILE_RENAME_INFORMATION_EX</a> = <span class="tok-builtin">@ptrCast</span>(&amp;rename_info_buf);
        <span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;

        <span class="tok-kw">var</span> flags: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ULONG">ULONG</a> = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_RENAME_POSIX_SEMANTICS">FILE_RENAME_POSIX_SEMANTICS</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_RENAME_IGNORE_READONLY_ATTRIBUTE">FILE_RENAME_IGNORE_READONLY_ATTRIBUTE</a>;
        <span class="tok-kw">if</span> (ReplaceIfExists == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TRUE">TRUE</a>) flags |= <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_RENAME_REPLACE_IF_EXISTS">FILE_RENAME_REPLACE_IF_EXISTS</a>;
        rename_info.* = .{
            .Flags = flags,
            .RootDirectory = <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsWTF16">isAbsoluteWindowsWTF16</a>(new_path_w)) <span class="tok-null">null</span> <span class="tok-kw">else</span> new_dir_fd,
            .FileNameLength = <span class="tok-builtin">@intCast</span>(new_path_w.len * <span class="tok-number">2</span>),<span class="tok-comment"> // already checked error.NameTooLong
            </span>.FileName = <span class="tok-null">undefined</span>,
        };
        <span class="tok-builtin">@memcpy</span>((&amp;rename_info.FileName).ptr, new_path_w);
        rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtSetInformationFile">NtSetInformationFile</a>(
            src_fd,
            &amp;io_status_block,
            rename_info,
            <span class="tok-builtin">@intCast</span>(struct_len),<span class="tok-comment"> // already checked for error.NameTooLong
            </span>.FileRenameInformationEx,
        );
        <span class="tok-kw">switch</span> (rc) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,<span class="tok-comment">
            // INVALID_PARAMETER here means that the filesystem does not support FileRenameInformationEx
            </span>.INVALID_PARAMETER =&gt; {},<span class="tok-comment">
            // For all other statuses, fall down to the switch below to handle them.
            </span><span class="tok-kw">else</span> =&gt; need_fallback = <span class="tok-null">false</span>,
        }
    }

    <span class="tok-kw">if</span> (need_fallback) {
        <span class="tok-kw">const</span> struct_buf_len = <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_RENAME_INFORMATION.html">FILE_RENAME_INFORMATION</a>) + (<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a> - <span class="tok-number">1</span>);
        <span class="tok-kw">var</span> rename_info_buf: [struct_buf_len]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_RENAME_INFORMATION.html">FILE_RENAME_INFORMATION</a>)) = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> struct_len = <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_RENAME_INFORMATION.html">FILE_RENAME_INFORMATION</a>) - <span class="tok-number">1</span> + new_path_w.len * <span class="tok-number">2</span>;
        <span class="tok-kw">if</span> (struct_len &gt; struct_buf_len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;

        <span class="tok-kw">const</span> rename_info: *<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_RENAME_INFORMATION.html">FILE_RENAME_INFORMATION</a> = <span class="tok-builtin">@ptrCast</span>(&amp;rename_info_buf);
        <span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;

        rename_info.* = .{
            .Flags = ReplaceIfExists,
            .RootDirectory = <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsWTF16">isAbsoluteWindowsWTF16</a>(new_path_w)) <span class="tok-null">null</span> <span class="tok-kw">else</span> new_dir_fd,
            .FileNameLength = <span class="tok-builtin">@intCast</span>(new_path_w.len * <span class="tok-number">2</span>),<span class="tok-comment"> // already checked error.NameTooLong
            </span>.FileName = <span class="tok-null">undefined</span>,
        };
        <span class="tok-builtin">@memcpy</span>((&amp;rename_info.FileName).ptr, new_path_w);

        rc =
            <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtSetInformationFile">NtSetInformationFile</a>(
                src_fd,
                &amp;io_status_block,
                rename_info,
                <span class="tok-builtin">@intCast</span>(struct_len),<span class="tok-comment"> // already checked for error.NameTooLong
                </span>.FileRenameInformation,
            );
    }

    <span class="tok-kw">switch</span> (rc) {
        .SUCCESS =&gt; {},
        .INVALID_HANDLE =&gt; <span class="tok-kw">unreachable</span>,
        .INVALID_PARAMETER =&gt; <span class="tok-kw">unreachable</span>,
        .OBJECT_PATH_SYNTAX_BAD =&gt; <span class="tok-kw">unreachable</span>,
        .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .OBJECT_NAME_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .OBJECT_PATH_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOT_SAME_DEVICE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.RenameAcrossMountPoints,
        .OBJECT_NAME_COLLISION =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .DIRECTORY_NOT_EMPTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .FILE_IS_A_DIRECTORY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
        .NOT_A_DIRECTORY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedStatus">unexpectedStatus</a>(rc),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.mkdirat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mkdirat</span><a href="#src.zig-std.posix.mkdirat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdirat</span>(dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sub_dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>On Windows, <code>sub_dir_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>sub_dir_path</code> should be encoded as valid UTF-8.
On other platforms, <code>sub_dir_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>sub_dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.mkdirat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdirat</span>(dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sub_dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> sub_dir_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(dir_fd, sub_dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.mkdiratW">mkdiratW</a>(dir_fd, sub_dir_path_w.span(), mode);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.mkdiratWasi">mkdiratWasi</a>(dir_fd, sub_dir_path, mode);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> sub_dir_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sub_dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.mkdiratZ">mkdiratZ</a>(dir_fd, &amp;sub_dir_path_c, mode);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.mkdiratWasi" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mkdiratWasi</span><a href="#src.zig-std.posix.mkdiratWasi">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdiratWasi</span>(dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sub_dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>sub_dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.mkdiratWasi">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdiratWasi</span>(dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sub_dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span> {
    _ = mode;
    <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.path_create_directory">path_create_directory</a>(dir_fd, sub_dir_path.ptr, sub_dir_path.len)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .MLINK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LinkQuotaExceeded,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .ILSEQ =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.mkdiratZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mkdiratZ</span><a href="#src.zig-std.posix.mkdiratZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdiratZ</span>(dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sub_dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.mkdirat">mkdirat</a></code> except the parameters are null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>sub_dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.mkdiratZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdiratZ</span>(dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sub_dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> sub_dir_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(dir_fd, sub_dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.mkdiratW">mkdiratW</a>(dir_fd, sub_dir_path_w.span(), mode);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.mkdirat">mkdirat</a>(dir_fd, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sub_dir_path, <span class="tok-number">0</span>), mode);
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">mkdirat</a>(dir_fd, sub_dir_path, mode))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .MLINK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LinkQuotaExceeded,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,<span class="tok-comment">
        // dragonfly: when dir_fd is unlinked from filesystem
        </span>.NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.mkdiratW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mkdiratW</span><a href="#src.zig-std.posix.mkdiratW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdiratW</span>(dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Windows-only. Same as <code><a href="std.posix.html#std.posix.mkdirat">mkdirat</a></code> except the parameter WTF16 LE encoded.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.mkdiratW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdiratW</span>(dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span> {
    _ = mode;
    <span class="tok-kw">const</span> sub_dir_handle = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.OpenFile">OpenFile</a>(sub_path_w, .{
        .dir = dir_fd,
        .access_mask = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GENERIC_READ">GENERIC_READ</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SYNCHRONIZE">SYNCHRONIZE</a>,
        .creation = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_CREATE">FILE_CREATE</a>,
        .filter = .dir_only,
    }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.PipeBusy =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.NoDevice =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.AntivirusInterference =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
    <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CloseHandle">CloseHandle</a>(sub_dir_handle);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.mkdir" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mkdir</span><a href="#src.zig-std.posix.mkdir">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdir</span>(dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Create a directory.
<code>mode</code> is ignored on Windows and WASI.
On Windows, <code>dir_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>dir_path</code> should be encoded as valid UTF-8.
On other platforms, <code>dir_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.mkdir">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdir</span>(dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.mkdirat">mkdirat</a>(<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, dir_path, mode);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> dir_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.mkdirW">mkdirW</a>(dir_path_w.span(), mode);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> dir_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.mkdirZ">mkdirZ</a>(&amp;dir_path_c, mode);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.mkdirZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mkdirZ</span><a href="#src.zig-std.posix.mkdirZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdirZ</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.mkdir">mkdir</a></code> but the parameter is null-terminated.
On Windows, <code>dir_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>dir_path</code> should be encoded as valid UTF-8.
On other platforms, <code>dir_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.mkdirZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdirZ</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> dir_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.mkdirW">mkdirW</a>(dir_path_w.span(), mode);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.mkdir">mkdir</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(dir_path, <span class="tok-number">0</span>), mode);
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">mkdir</a>(dir_path, mode))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .MLINK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LinkQuotaExceeded,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.mkdirW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mkdirW</span><a href="#src.zig-std.posix.mkdirW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdirW</span>(dir_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Windows-only. Same as <code><a href="std.posix.html#std.posix.mkdir">mkdir</a></code> but the parameters is WTF16LE encoded.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.mkdirW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdirW</span>(dir_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span> {
    _ = mode;
    <span class="tok-kw">const</span> sub_dir_handle = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.OpenFile">OpenFile</a>(dir_path_w, .{
        .dir = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().fd,
        .access_mask = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GENERIC_READ">GENERIC_READ</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SYNCHRONIZE">SYNCHRONIZE</a>,
        .creation = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_CREATE">FILE_CREATE</a>,
        .filter = .dir_only,
    }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.PipeBusy =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.NoDevice =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.AntivirusInterference =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
    <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CloseHandle">CloseHandle</a>(sub_dir_handle);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.rmdir" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rmdir</span><a href="#src.zig-std.posix.rmdir">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rmdir</span>(dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.DeleteDirError">DeleteDirError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deletes an empty directory.
On Windows, <code>dir_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>dir_path</code> should be encoded as valid UTF-8.
On other platforms, <code>dir_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.rmdir">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rmdir</span>(dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.DeleteDirError">DeleteDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlinkat">unlinkat</a>(<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, dir_path, <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">REMOVEDIR</a>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileSystem =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // only occurs when targeting files
            </span><span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // only occurs when targeting files
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> dir_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.rmdirW">rmdirW</a>(dir_path_w.span());
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> dir_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.rmdirZ">rmdirZ</a>(&amp;dir_path_c);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.rmdirZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rmdirZ</span><a href="#src.zig-std.posix.rmdirZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rmdirZ</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.DeleteDirError">DeleteDirError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.rmdir">rmdir</a></code> except the parameter is null-terminated.
On Windows, <code>dir_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>dir_path</code> should be encoded as valid UTF-8.
On other platforms, <code>dir_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.rmdirZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rmdirZ</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.DeleteDirError">DeleteDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> dir_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.rmdirW">rmdirW</a>(dir_path_w.span());
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.rmdir">rmdir</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(dir_path, <span class="tok-number">0</span>));
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">rmdir</a>(dir_path))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadPathName,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotEmpty,
        .NOTEMPTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotEmpty,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.rmdirW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rmdirW</span><a href="#src.zig-std.posix.rmdirW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rmdirW</span>(dir_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.DeleteDirError">DeleteDirError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Windows-only. Same as <code><a href="std.posix.html#std.posix.rmdir">rmdir</a></code> except the parameter is WTF-16 LE encoded.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.rmdirW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rmdirW</span>(dir_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.DeleteDirError">DeleteDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DeleteFile">DeleteFile</a>(dir_path_w, .{ .dir = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().fd, .remove_dir = <span class="tok-null">true</span> }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.chdir" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">chdir</span><a href="#src.zig-std.posix.chdir">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chdir</span>(dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Changes the current working directory of the calling process.
On Windows, <code>dir_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>dir_path</code> should be encoded as valid UTF-8.
On other platforms, <code>dir_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.chdir">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chdir</span>(dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;WASI does not support os.chdir&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">var</span> wtf16_dir_path: [<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PATH_MAX_WIDE">PATH_MAX_WIDE</a>]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.checkWtf8ToWtf16LeOverflow">checkWtf8ToWtf16LeOverflow</a>(dir_path, &amp;wtf16_dir_path)) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
        }
        <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16Le">wtf8ToWtf16Le</a>(&amp;wtf16_dir_path, dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.chdirW">chdirW</a>(wtf16_dir_path[<span class="tok-number">0</span>..len]);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> dir_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.chdirZ">chdirZ</a>(&amp;dir_path_c);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.chdirZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">chdirZ</span><a href="#src.zig-std.posix.chdirZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chdirZ</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.chdir">chdir</a></code> except the parameter is null-terminated.
On Windows, <code>dir_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>dir_path</code> should be encoded as valid UTF-8.
On other platforms, <code>dir_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.chdirZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chdirZ</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> dir_path_span = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(dir_path);
        <span class="tok-kw">var</span> wtf16_dir_path: [<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PATH_MAX_WIDE">PATH_MAX_WIDE</a>]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.checkWtf8ToWtf16LeOverflow">checkWtf8ToWtf16LeOverflow</a>(dir_path_span, &amp;wtf16_dir_path)) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
        }
        <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16Le">wtf8ToWtf16Le</a>(&amp;wtf16_dir_path, dir_path_span);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.chdirW">chdirW</a>(wtf16_dir_path[<span class="tok-number">0</span>..len]);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.chdir">chdir</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(dir_path));
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">chdir</a>(dir_path))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.chdirW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">chdirW</span><a href="#src.zig-std.posix.chdirW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chdirW</span>(dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Windows-only. Same as <code><a href="std.posix.html#std.posix.chdir">chdir</a></code> except the parameter is WTF16 LE encoded.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.chdirW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chdirW</span>(dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a>!<span class="tok-type">void</span> {
    <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SetCurrentDirectory">SetCurrentDirectory</a>(dir_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.NoDevice =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.fchdir" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fchdir</span><a href="#src.zig-std.posix.fchdir">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fchdir</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.FchdirError">FchdirError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.fchdir">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fchdir</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.FchdirError">FchdirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (dirfd == <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>) <span class="tok-kw">return</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">fchdir</a>(dirfd))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.readlink" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readlink</span><a href="#src.zig-std.posix.readlink">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlink</span>(file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Read value of a symbolic link.
On Windows, <code>file_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>file_path</code> should be encoded as valid UTF-8.
On other platforms, <code>file_path</code> is an opaque sequence of bytes with no particular encoding.
The return value is a slice of <code>out_buffer</code> from index 0.
On Windows, the result is encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, the result is encoded as UTF-8.
On other platforms, the result is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>out_buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.readlink">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlink</span>(file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.readlinkat">readlinkat</a>(<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, file_path, out_buffer);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> file_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, file_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.readlinkW">readlinkW</a>(file_path_w.span(), out_buffer);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> file_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(file_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.readlinkZ">readlinkZ</a>(&amp;file_path_c, out_buffer);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.readlinkW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readlinkW</span><a href="#src.zig-std.posix.readlinkW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkW</span>(file_path: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Windows-only. Same as <code><a href="std.posix.html#std.posix.readlink">readlink</a></code> except <code>file_path</code> is WTF16 LE encoded.
The result is encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
See also <code><a href="std.posix.html#std.posix.readlinkZ">readlinkZ</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>file_path: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>out_buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.readlinkW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkW</span>(file_path: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ReadLink">ReadLink</a>(<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().fd, file_path, out_buffer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.readlinkZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readlinkZ</span><a href="#src.zig-std.posix.readlinkZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkZ</span>(file_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.readlink">readlink</a></code> except <code>file_path</code> is null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>file_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>out_buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.readlinkZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkZ</span>(file_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> file_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, file_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.readlinkW">readlinkW</a>(file_path_w.span(), out_buffer);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.readlink">readlink</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(file_path, <span class="tok-number">0</span>), out_buffer);
    }
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">readlink</a>(file_path, out_buffer.ptr, out_buffer.len);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> out_buffer[<span class="tok-number">0</span>..<span class="tok-builtin">@bitCast</span>(rc)],
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotLink,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.readlinkat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readlinkat</span><a href="#src.zig-std.posix.readlinkat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkat</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Similar to <code><a href="std.posix.html#std.posix.readlink">readlink</a></code> except reads value of a symbolink link <strong>relative</strong> to <code>dirfd</code> directory handle.
On Windows, <code>file_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>file_path</code> should be encoded as valid UTF-8.
On other platforms, <code>file_path</code> is an opaque sequence of bytes with no particular encoding.
The return value is a slice of <code>out_buffer</code> from index 0.
On Windows, the result is encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, the result is encoded as UTF-8.
On other platforms, the result is an opaque sequence of bytes with no particular encoding.
See also <code><a href="std.posix.html#std.posix.readlinkatWasi">readlinkatWasi</a></code>, <code>realinkatZ</code> and <code>realinkatW</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>out_buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.readlinkat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkat</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.readlinkatWasi">readlinkatWasi</a>(dirfd, file_path, out_buffer);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> file_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(dirfd, file_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.readlinkatW">readlinkatW</a>(dirfd, file_path_w.span(), out_buffer);
    }
    <span class="tok-kw">const</span> file_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(file_path);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.readlinkatZ">readlinkatZ</a>(dirfd, &amp;file_path_c, out_buffer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.readlinkatWasi" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readlinkatWasi</span><a href="#src.zig-std.posix.readlinkatWasi">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkatWasi</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>WASI-only. Same as <code><a href="std.posix.html#std.posix.readlinkat">readlinkat</a></code> but targets WASI.
See also <code><a href="std.posix.html#std.posix.readlinkat">readlinkat</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>out_buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.readlinkatWasi">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkatWasi</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">var</span> bufused: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.path_readlink">path_readlink</a>(dirfd, file_path.ptr, file_path.len, out_buffer.ptr, out_buffer.len, &amp;bufused)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> out_buffer[<span class="tok-number">0</span>..bufused],
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotLink,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .ILSEQ =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.readlinkatW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readlinkatW</span><a href="#src.zig-std.posix.readlinkatW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkatW</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Windows-only. Same as <code><a href="std.posix.html#std.posix.readlinkat">readlinkat</a></code> except <code>file_path</code> is null-terminated, WTF16 LE encoded.
The result is encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
See also <code><a href="std.posix.html#std.posix.readlinkat">readlinkat</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>file_path: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>out_buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.readlinkatW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkatW</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ReadLink">ReadLink</a>(dirfd, file_path, out_buffer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.readlinkatZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readlinkatZ</span><a href="#src.zig-std.posix.readlinkatZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkatZ</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.readlinkat">readlinkat</a></code> except <code>file_path</code> is null-terminated.
See also <code><a href="std.posix.html#std.posix.readlinkat">readlinkat</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>file_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>out_buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.readlinkatZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkatZ</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> file_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(dirfd, file_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.readlinkatW">readlinkatW</a>(dirfd, file_path_w.span(), out_buffer);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.readlinkat">readlinkat</a>(dirfd, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(file_path, <span class="tok-number">0</span>), out_buffer);
    }
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">readlinkat</a>(dirfd, file_path, out_buffer.ptr, out_buffer.len);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> out_buffer[<span class="tok-number">0</span>..<span class="tok-builtin">@bitCast</span>(rc)],
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotLink,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.setuid" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setuid</span><a href="#src.zig-std.posix.setuid">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setuid</span>(uid: <a href="std.posix.html#std.posix.uid_t">uid_t</a>) <a href="std.posix.html#std.posix.SetIdError">SetIdError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>uid: <a href="std.posix.html#std.posix.uid_t">uid_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.setuid">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setuid</span>(uid: <a href="std.posix.html#std.posix.uid_t">uid_t</a>) <a href="std.posix.html#std.posix.SetIdError">SetIdError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">setuid</a>(uid))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ResourceLimitReached,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUserId,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.seteuid" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">seteuid</span><a href="#src.zig-std.posix.seteuid">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">seteuid</span>(uid: <a href="std.posix.html#std.posix.uid_t">uid_t</a>) <a href="std.posix.html#std.posix.SetEidError">SetEidError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>uid: <a href="std.posix.html#std.posix.uid_t">uid_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.seteuid">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">seteuid</span>(uid: <a href="std.posix.html#std.posix.uid_t">uid_t</a>) <a href="std.posix.html#std.posix.SetEidError">SetEidError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">seteuid</a>(uid))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUserId,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.setreuid" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setreuid</span><a href="#src.zig-std.posix.setreuid">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setreuid</span>(ruid: <a href="std.posix.html#std.posix.uid_t">uid_t</a>, euid: <a href="std.posix.html#std.posix.uid_t">uid_t</a>) <a href="std.posix.html#std.posix.SetIdError">SetIdError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>ruid: <a href="std.posix.html#std.posix.uid_t">uid_t</a></code></pre></div><div><pre><code>euid: <a href="std.posix.html#std.posix.uid_t">uid_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.setreuid">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setreuid</span>(ruid: <a href="std.posix.html#std.posix.uid_t">uid_t</a>, euid: <a href="std.posix.html#std.posix.uid_t">uid_t</a>) <a href="std.posix.html#std.posix.SetIdError">SetIdError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">setreuid</a>(ruid, euid))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ResourceLimitReached,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUserId,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.setgid" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setgid</span><a href="#src.zig-std.posix.setgid">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setgid</span>(gid: <a href="std.posix.html#std.posix.gid_t">gid_t</a>) <a href="std.posix.html#std.posix.SetIdError">SetIdError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>gid: <a href="std.posix.html#std.posix.gid_t">gid_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.setgid">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setgid</span>(gid: <a href="std.posix.html#std.posix.gid_t">gid_t</a>) <a href="std.posix.html#std.posix.SetIdError">SetIdError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">setgid</a>(gid))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ResourceLimitReached,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUserId,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.setegid" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setegid</span><a href="#src.zig-std.posix.setegid">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setegid</span>(uid: <a href="std.posix.html#std.posix.uid_t">uid_t</a>) <a href="std.posix.html#std.posix.SetEidError">SetEidError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>uid: <a href="std.posix.html#std.posix.uid_t">uid_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.setegid">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setegid</span>(uid: <a href="std.posix.html#std.posix.uid_t">uid_t</a>) <a href="std.posix.html#std.posix.SetEidError">SetEidError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">setegid</a>(uid))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUserId,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.setregid" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setregid</span><a href="#src.zig-std.posix.setregid">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setregid</span>(rgid: <a href="std.posix.html#std.posix.gid_t">gid_t</a>, egid: <a href="std.posix.html#std.posix.gid_t">gid_t</a>) <a href="std.posix.html#std.posix.SetIdError">SetIdError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>rgid: <a href="std.posix.html#std.posix.gid_t">gid_t</a></code></pre></div><div><pre><code>egid: <a href="std.posix.html#std.posix.gid_t">gid_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.setregid">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setregid</span>(rgid: <a href="std.posix.html#std.posix.gid_t">gid_t</a>, egid: <a href="std.posix.html#std.posix.gid_t">gid_t</a>) <a href="std.posix.html#std.posix.SetIdError">SetIdError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">setregid</a>(rgid, egid))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ResourceLimitReached,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUserId,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.setpgid" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setpgid</span><a href="#src.zig-std.posix.setpgid">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setpgid</span>(pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>, pgid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>) <a href="std.posix.html#std.posix.SetPgidError">SetPgidError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a></code></pre></div><div><pre><code>pgid: <a href="std.posix.html#std.posix.pid_t">pid_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.setpgid">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setpgid</span>(pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>, pgid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>) <a href="std.posix.html#std.posix.SetPgidError">SetPgidError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">setpgid</a>(pid, pgid))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessAlreadyExec,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidProcessGroupId,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .SRCH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.isatty" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isatty</span><a href="#src.zig-std.posix.isatty">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isatty</span>(handle: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Test whether a file descriptor refers to a terminal.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>handle: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.isatty">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isatty</span>(handle: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.isCygwinPty">isCygwinPty</a>(.{ .handle = handle }))
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;

        <span class="tok-kw">var</span> out: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.GetConsoleMode">GetConsoleMode</a>(handle, &amp;out) != <span class="tok-number">0</span>;
    }
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">isatty</a>(handle) != <span class="tok-number">0</span>;
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi) {
        <span class="tok-kw">var</span> statbuf: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.fdstat_t.html">fdstat_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> err = <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_fdstat_get">fd_fdstat_get</a>(handle, &amp;statbuf);
        <span class="tok-kw">if</span> (err != .SUCCESS)
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;<span class="tok-comment">

        // A tty is a character device that we can't seek or tell on.
        </span><span class="tok-kw">if</span> (statbuf.fs_filetype != .CHARACTER_DEVICE)
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        <span class="tok-kw">if</span> (statbuf.fs_rights_base.FD_SEEK <span class="tok-kw">or</span> statbuf.fs_rights_base.FD_TELL)
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;

        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .linux) {
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">var</span> wsz: <a href="std.posix.winsize.html">winsize</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> fd: <span class="tok-type">usize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, handle));
            <span class="tok-kw">const</span> rc = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.syscall3">syscall3</a>(.ioctl, fd, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.T">T</a>.<a href="std.os.linux.html#std.os.linux.T.IOCGWINSZ">IOCGWINSZ</a>, <span class="tok-builtin">@intFromPtr</span>(&amp;wsz));
            <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(rc)) {
                .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,
                .INTR =&gt; <span class="tok-kw">continue</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
            }
        }
    }
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">isatty</a>(handle) != <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.socket" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">socket</span><a href="#src.zig-std.posix.socket">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">socket</span>(domain: <span class="tok-type">u32</span>, socket_type: <span class="tok-type">u32</span>, protocol: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.SocketError">SocketError</a>!<a href="std.posix.html#std.posix.socket_t">socket_t</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>domain: <span class="tok-type">u32</span></code></pre></div><div><pre><code>socket_type: <span class="tok-type">u32</span></code></pre></div><div><pre><code>protocol: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.socket">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">socket</span>(domain: <span class="tok-type">u32</span>, socket_type: <span class="tok-type">u32</span>, protocol: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.SocketError">SocketError</a>!<a href="std.posix.html#std.posix.socket_t">socket_t</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {<span class="tok-comment">
        // NOTE: windows translates the SOCK.NONBLOCK/SOCK.CLOEXEC flags into
        // windows-analogous operations
        </span><span class="tok-kw">const</span> filtered_sock_type = socket_type &amp; ~<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">NONBLOCK</a> | <a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>);
        <span class="tok-kw">const</span> flags: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> ((socket_type &amp; <a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>) != <span class="tok-number">0</span>)
            <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSA_FLAG_NO_HANDLE_INHERIT">WSA_FLAG_NO_HANDLE_INHERIT</a>
        <span class="tok-kw">else</span>
            <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> rc = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.WSASocketW">WSASocketW</a>(
            <span class="tok-builtin">@bitCast</span>(domain),
            <span class="tok-builtin">@bitCast</span>(filtered_sock_type),
            <span class="tok-builtin">@bitCast</span>(protocol),
            <span class="tok-null">null</span>,
            <span class="tok-number">0</span>,
            flags,
        );
        <span class="tok-kw">errdefer</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.closesocket">closesocket</a>(rc) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
        <span class="tok-kw">if</span> ((socket_type &amp; <a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">NONBLOCK</a>) != <span class="tok-number">0</span>) {
            <span class="tok-kw">var</span> mode: <span class="tok-type">c_ulong</span> = <span class="tok-number">1</span>;<span class="tok-comment"> // nonblocking
            </span><span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a> == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.ioctlsocket">ioctlsocket</a>(rc, <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.FIONBIO">FIONBIO</a>, &amp;mode)) {
                <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {<span class="tok-comment">
                    // have not identified any error codes that should be handled yet
                    </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                }
            }
        }
        <span class="tok-kw">return</span> rc;
    }

    <span class="tok-kw">const</span> have_sock_flags = !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a>.<a href="#">isDarwin</a>() <span class="tok-kw">and</span> <a href="std.posix.html#std.posix.native_os">native_os</a> != .haiku;
    <span class="tok-kw">const</span> filtered_sock_type = <span class="tok-kw">if</span> (!have_sock_flags)
        socket_type &amp; ~<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">NONBLOCK</a> | <a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>)
    <span class="tok-kw">else</span>
        socket_type;
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">socket</a>(domain, filtered_sock_type, protocol);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; {
            <span class="tok-kw">const</span> fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a> = <span class="tok-builtin">@intCast</span>(rc);
            <span class="tok-kw">errdefer</span> <a href="std.posix.html#std.posix.close">close</a>(fd);
            <span class="tok-kw">if</span> (!have_sock_flags) {
                <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.setSockFlags">setSockFlags</a>(fd, socket_type);
            }
            <span class="tok-kw">return</span> fd;
        },
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .AFNOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProtocolFamilyNotAvailable,
        .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .PROTONOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProtocolNotSupported,
        .PROTOTYPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketTypeNotSupported,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.shutdown" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shutdown</span><a href="#src.zig-std.posix.shutdown">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shutdown</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, how: <a href="std.posix.ShutdownHow.html">ShutdownHow</a>) <a href="std.posix.html#std.posix.ShutdownError">ShutdownError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shutdown socket send/receive operations</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a></code></pre></div><div><pre><code>how: <a href="std.posix.ShutdownHow.html">ShutdownHow</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.shutdown">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shutdown</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, how: <a href="std.posix.ShutdownHow.html">ShutdownHow</a>) <a href="std.posix.html#std.posix.ShutdownError">ShutdownError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> result = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.shutdown">shutdown</a>(sock, <span class="tok-kw">switch</span> (how) {
            .recv =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SD_RECEIVE">SD_RECEIVE</a>,
            .send =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SD_SEND">SD_SEND</a>,
            .both =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SD_BOTH">SD_BOTH</a>,
        });
        <span class="tok-kw">if</span> (<span class="tok-number">0</span> != result) <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
            .WSAECONNABORTED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionAborted,
            .WSAECONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .WSAEINPROGRESS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BlockingOperationInProgress,
            .WSAEINVAL =&gt; <span class="tok-kw">unreachable</span>,
            .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
            .WSAENOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .WSAENOTSOCK =&gt; <span class="tok-kw">unreachable</span>,
            .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">shutdown</a>(sock, <span class="tok-kw">switch</span> (how) {
            .recv =&gt; <a href="std.posix.html#std.posix.SHUT">SHUT</a>.<a href="#">RD</a>,
            .send =&gt; <a href="std.posix.html#std.posix.SHUT">SHUT</a>.<a href="#">WR</a>,
            .both =&gt; <a href="std.posix.html#std.posix.SHUT">SHUT</a>.<a href="#">RDWR</a>,
        });
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.bind" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bind</span><a href="#src.zig-std.posix.bind">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bind</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, addr: *<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sockaddr">sockaddr</a>, len: <a href="std.posix.html#std.posix.socklen_t">socklen_t</a>) <a href="std.posix.html#std.posix.BindError">BindError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>addr is <code>*const T</code> where T is one of the sockaddr</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a></code></pre></div><div><pre><code>addr: *<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sockaddr">sockaddr</a></code></pre></div><div><pre><code>len: <a href="std.posix.html#std.posix.socklen_t">socklen_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.bind">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bind</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, addr: *<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sockaddr">sockaddr</a>, len: <a href="std.posix.html#std.posix.socklen_t">socklen_t</a>) <a href="std.posix.html#std.posix.BindError">BindError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.bind">bind</a>(sock, addr, len);
        <span class="tok-kw">if</span> (rc == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a>) {
            <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not initialized WSA
                </span>.WSAEACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                .WSAEADDRINUSE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressInUse,
                .WSAEADDRNOTAVAIL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressNotAvailable,
                .WSAENOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
                .WSAEFAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid pointers
                </span>.WSAEINVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AlreadyBound,
                .WSAENOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
            }
            <span class="tok-kw">unreachable</span>;
        }
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">bind</a>(sock, addr, len);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .ACCES, .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .ADDRINUSE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressInUse,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition if this error is returned
            </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid parameters
            </span>.NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid `sockfd`
            </span>.AFNOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
            .ADDRNOTAVAIL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressNotAvailable,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid `addr` pointer
            </span>.LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
            .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
            .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">unreachable</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.listen" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">listen</span><a href="#src.zig-std.posix.listen">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">listen</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, backlog: <span class="tok-type">u31</span>) <a href="std.posix.html#std.posix.ListenError">ListenError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a></code></pre></div><div><pre><code>backlog: <span class="tok-type">u31</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.listen">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">listen</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, backlog: <span class="tok-type">u31</span>) <a href="std.posix.html#std.posix.ListenError">ListenError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.listen">listen</a>(sock, backlog);
        <span class="tok-kw">if</span> (rc == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a>) {
            <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not initialized WSA
                </span>.WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                .WSAEADDRINUSE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressInUse,
                .WSAEISCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AlreadyConnected,
                .WSAEINVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotBound,
                .WSAEMFILE, .WSAENOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                .WSAENOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
                .WSAEOPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OperationNotSupported,
                .WSAEINPROGRESS =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
            }
        }
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">listen</a>(sock, backlog);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .ADDRINUSE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressInUse,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .NOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
            .OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OperationNotSupported,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.accept" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">accept</span><a href="#src.zig-std.posix.accept">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accept</span>( sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, addr: ?*<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>, addr_size: ?*<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>, flags: <span class="tok-type">u32</span>, ) <a href="std.posix.html#std.posix.AcceptError">AcceptError</a>!<a href="std.posix.html#std.posix.socket_t">socket_t</a></code></pre></div><div class="tldDocs"><p>Accept a connection on a socket.
If <code>sockfd</code> is opened in non blocking mode, the function will
return error.WouldBlock when EAGAIN is received.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a></code></pre><div class="fieldDocs"><p>This argument is a socket that has been created with <code><a href="std.posix.html#std.posix.socket">socket</a></code>, bound to a local address
with <code><a href="std.posix.html#std.posix.bind">bind</a></code>, and is listening for connections after a <code><a href="std.posix.html#std.posix.listen">listen</a></code>.</p>
</div></div><div><pre><code>addr: ?*<a href="std.posix.html#std.posix.sockaddr">sockaddr</a></code></pre><div class="fieldDocs"><p>This argument is a pointer to a sockaddr structure.  This structure is filled in with  the
address  of  the  peer  socket, as known to the communications layer.  The exact format of the
address returned addr is determined by the socket's address  family  (see  <code><a href="std.posix.html#std.posix.socket">socket</a></code>  and  the
respective  protocol  man  pages).</p>
</div></div><div><pre><code>addr_size: ?*<a href="std.posix.html#std.posix.socklen_t">socklen_t</a></code></pre><div class="fieldDocs"><p>This argument is a value-result argument: the caller must initialize it to contain  the
size (in bytes) of the structure pointed to by addr; on return it will contain the actual size
of the peer address.</p>
<p>The returned address is truncated if the buffer provided is too small; in this  case,  <code>addr_size</code>
will return a value greater than was supplied to the call.</p>
</div></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre><div class="fieldDocs"><p>The following values can be bitwise ORed in flags to obtain different behavior:</p>
<ul>
<li><code>SOCK.NONBLOCK</code> - Set the <code>NONBLOCK</code> file status flag on the open file description (see <code><a href="std.posix.html#std.posix.open">open</a></code>)
referred  to by the new file descriptor.  Using this flag saves extra calls to <code><a href="std.posix.html#std.posix.fcntl">fcntl</a></code> to achieve
the same result.</li>
<li><code>SOCK.CLOEXEC</code>  - Set the close-on-exec (<code><a href="std.posix.html#std.posix.FD_CLOEXEC">FD_CLOEXEC</a></code>) flag on the new file descriptor.   See  the
description  of the <code>CLOEXEC</code> flag in <code><a href="std.posix.html#std.posix.open">open</a></code> for reasons why this may be useful.</li>
</ul>
</div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.accept">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accept</span>(
    <span class="tok-comment">/// This argument is a socket that has been created with `socket`, bound to a local address</span>
    <span class="tok-comment">/// with `bind`, and is listening for connections after a `listen`.</span>
    sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>,
    <span class="tok-comment">/// This argument is a pointer to a sockaddr structure.  This structure is filled in with  the</span>
    <span class="tok-comment">/// address  of  the  peer  socket, as known to the communications layer.  The exact format of the</span>
    <span class="tok-comment">/// address returned addr is determined by the socket's address  family  (see  `socket`  and  the</span>
    <span class="tok-comment">/// respective  protocol  man  pages).</span>
    addr: ?*<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>,
    <span class="tok-comment">/// This argument is a value-result argument: the caller must initialize it to contain  the</span>
    <span class="tok-comment">/// size (in bytes) of the structure pointed to by addr; on return it will contain the actual size</span>
    <span class="tok-comment">/// of the peer address.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The returned address is truncated if the buffer provided is too small; in this  case,  `addr_size`</span>
    <span class="tok-comment">/// will return a value greater than was supplied to the call.</span>
    addr_size: ?*<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>,
    <span class="tok-comment">/// The following values can be bitwise ORed in flags to obtain different behavior:</span>
    <span class="tok-comment">/// * `SOCK.NONBLOCK` - Set the `NONBLOCK` file status flag on the open file description (see `open`)</span>
    <span class="tok-comment">///   referred  to by the new file descriptor.  Using this flag saves extra calls to `fcntl` to achieve</span>
    <span class="tok-comment">///   the same result.</span>
    <span class="tok-comment">/// * `SOCK.CLOEXEC`  - Set the close-on-exec (`FD_CLOEXEC`) flag on the new file descriptor.   See  the</span>
    <span class="tok-comment">///   description  of the `CLOEXEC` flag in `open` for reasons why this may be useful.</span>
    flags: <span class="tok-type">u32</span>,
) <a href="std.posix.html#std.posix.AcceptError">AcceptError</a>!<a href="std.posix.html#std.posix.socket_t">socket_t</a> {
    <span class="tok-kw">const</span> have_accept4 = !(<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a>.<a href="#">isDarwin</a>() <span class="tok-kw">or</span> <a href="std.posix.html#std.posix.native_os">native_os</a> == .windows <span class="tok-kw">or</span> <a href="std.posix.html#std.posix.native_os">native_os</a> == .haiku);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-number">0</span> == (flags &amp; ~<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">NONBLOCK</a> | <a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>)));<span class="tok-comment"> // Unsupported flag(s)

    </span><span class="tok-kw">const</span> accepted_sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a> = <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <span class="tok-kw">if</span> (have_accept4)
            <a href="std.posix.html#std.posix.system">system</a>.<a href="#">accept4</a>(sock, addr, addr_size, flags)
        <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows)
            <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.accept">accept</a>(sock, addr, addr_size)
        <span class="tok-kw">else</span>
            <a href="std.posix.html#std.posix.system">system</a>.<a href="#">accept</a>(sock, addr, addr_size);

        <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
            <span class="tok-kw">if</span> (rc == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.INVALID_SOCKET">INVALID_SOCKET</a>) {
                <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                    .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not initialized WSA
                    </span>.WSAECONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
                    .WSAEFAULT =&gt; <span class="tok-kw">unreachable</span>,
                    .WSAEINVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotListening,
                    .WSAEMFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
                    .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                    .WSAENOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
                    .WSAEOPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OperationNotSupported,
                    .WSAEWOULDBLOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
                }
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">break</span> rc;
            }
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                .SUCCESS =&gt; <span class="tok-kw">break</span> <span class="tok-builtin">@intCast</span>(rc),
                .INTR =&gt; <span class="tok-kw">continue</span>,
                .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
                .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
                </span>.CONNABORTED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionAborted,
                .FAULT =&gt; <span class="tok-kw">unreachable</span>,
                .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotListening,
                .NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,
                .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
                .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
                .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                .OPNOTSUPP =&gt; <span class="tok-kw">unreachable</span>,
                .PROTO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProtocolFailure,
                .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BlockedByFirewall,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
        }
    };

    <span class="tok-kw">errdefer</span> <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .windows =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.closesocket">closesocket</a>(accepted_sock) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; <a href="std.posix.html#std.posix.close">close</a>(accepted_sock),
    };
    <span class="tok-kw">if</span> (!have_accept4) {
        <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.setSockFlags">setSockFlags</a>(accepted_sock, flags);
    }
    <span class="tok-kw">return</span> accepted_sock;
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.epoll_create1" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">epoll_create1</span><a href="#src.zig-std.posix.epoll_create1">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">epoll_create1</span>(flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.EpollCreateError">EpollCreateError</a>!<span class="tok-type">i32</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.epoll_create1">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">epoll_create1</span>(flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.EpollCreateError">EpollCreateError</a>!<span class="tok-type">i32</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">epoll_create1</a>(flags);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),

        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.epoll_ctl" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">epoll_ctl</span><a href="#src.zig-std.posix.epoll_ctl">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">epoll_ctl</span>(epfd: <span class="tok-type">i32</span>, op: <span class="tok-type">u32</span>, fd: <span class="tok-type">i32</span>, event: ?*<a href="std.posix.html#std.posix.system">system</a>.<a href="#">epoll_event</a>) <a href="std.posix.html#std.posix.EpollCtlError">EpollCtlError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>epfd: <span class="tok-type">i32</span></code></pre></div><div><pre><code>op: <span class="tok-type">u32</span></code></pre></div><div><pre><code>fd: <span class="tok-type">i32</span></code></pre></div><div><pre><code>event: ?*<a href="std.posix.html#std.posix.system">system</a>.<a href="#">epoll_event</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.epoll_ctl">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">epoll_ctl</span>(epfd: <span class="tok-type">i32</span>, op: <span class="tok-type">u32</span>, fd: <span class="tok-type">i32</span>, event: ?*<a href="std.posix.html#std.posix.system">system</a>.<a href="#">epoll_event</a>) <a href="std.posix.html#std.posix.EpollCtlError">EpollCtlError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">epoll_ctl</a>(epfd, op, fd, event);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),

        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition if this happens
        </span>.EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorAlreadyPresentInSet,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OperationCausesCircularLoop,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotRegistered,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UserResourceLimitReached,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorIncompatibleWithEpoll,
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.epoll_wait" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">epoll_wait</span><a href="#src.zig-std.posix.epoll_wait">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">epoll_wait</span>(epfd: <span class="tok-type">i32</span>, events: []<a href="std.posix.html#std.posix.system">system</a>.<a href="#">epoll_event</a>, timeout: <span class="tok-type">i32</span>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Waits for an I/O event on an epoll file descriptor.
Returns the number of file descriptors ready for the requested I/O,
or zero if no file descriptor became ready during the requested timeout milliseconds.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>epfd: <span class="tok-type">i32</span></code></pre></div><div><pre><code>events: []<a href="std.posix.html#std.posix.system">system</a>.<a href="#">epoll_event</a></code></pre></div><div><pre><code>timeout: <span class="tok-type">i32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.epoll_wait">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">epoll_wait</span>(epfd: <span class="tok-type">i32</span>, events: []<a href="std.posix.html#std.posix.system">system</a>.<a href="#">epoll_event</a>, timeout: <span class="tok-type">i32</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment">
        // TODO get rid of the @intCast
        </span><span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">epoll_wait</a>(epfd, events.ptr, <span class="tok-builtin">@intCast</span>(events.len), timeout);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.eventfd" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">eventfd</span><a href="#src.zig-std.posix.eventfd">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eventfd</span>(initval: <span class="tok-type">u32</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.EventFdError">EventFdError</a>!<span class="tok-type">i32</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>initval: <span class="tok-type">u32</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.eventfd">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eventfd</span>(initval: <span class="tok-type">u32</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.EventFdError">EventFdError</a>!<span class="tok-type">i32</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">eventfd</a>(initval, flags);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),

        .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid parameters
        </span>.MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.getsockname" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getsockname</span><a href="#src.zig-std.posix.getsockname">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getsockname</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, addr: *<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>, addrlen: *<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>) <a href="std.posix.html#std.posix.GetSockNameError">GetSockNameError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a></code></pre></div><div><pre><code>addr: *<a href="std.posix.html#std.posix.sockaddr">sockaddr</a></code></pre></div><div><pre><code>addrlen: *<a href="std.posix.html#std.posix.socklen_t">socklen_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.getsockname">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getsockname</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, addr: *<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>, addrlen: *<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>) <a href="std.posix.html#std.posix.GetSockNameError">GetSockNameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.getsockname">getsockname</a>(sock, addr, addrlen);
        <span class="tok-kw">if</span> (rc == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a>) {
            <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,
                .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                .WSAEFAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // addr or addrlen have invalid pointers or addrlen points to an incorrect value
                </span>.WSAENOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
                .WSAEINVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotBound,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
            }
        }
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">getsockname</a>(sock, addr, addrlen);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),

            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid parameters
            </span>.NOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.getpeername" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getpeername</span><a href="#src.zig-std.posix.getpeername">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getpeername</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, addr: *<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>, addrlen: *<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>) <a href="std.posix.html#std.posix.GetSockNameError">GetSockNameError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a></code></pre></div><div><pre><code>addr: *<a href="std.posix.html#std.posix.sockaddr">sockaddr</a></code></pre></div><div><pre><code>addrlen: *<a href="std.posix.html#std.posix.socklen_t">socklen_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.getpeername">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getpeername</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, addr: *<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>, addrlen: *<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>) <a href="std.posix.html#std.posix.GetSockNameError">GetSockNameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.getpeername">getpeername</a>(sock, addr, addrlen);
        <span class="tok-kw">if</span> (rc == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a>) {
            <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,
                .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                .WSAEFAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // addr or addrlen have invalid pointers or addrlen points to an incorrect value
                </span>.WSAENOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
                .WSAEINVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotBound,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
            }
        }
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">getpeername</a>(sock, addr, addrlen);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),

            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid parameters
            </span>.NOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.connect" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">connect</span><a href="#src.zig-std.posix.connect">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connect</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, sock_addr: *<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sockaddr">sockaddr</a>, len: <a href="std.posix.html#std.posix.socklen_t">socklen_t</a>) <a href="std.posix.html#std.posix.ConnectError">ConnectError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Initiate a connection on a socket.
If <code>sockfd</code> is opened in non blocking mode, the function will
return error.WouldBlock when EAGAIN or EINPROGRESS is received.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a></code></pre></div><div><pre><code>sock_addr: *<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sockaddr">sockaddr</a></code></pre></div><div><pre><code>len: <a href="std.posix.html#std.posix.socklen_t">socklen_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.connect">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connect</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, sock_addr: *<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sockaddr">sockaddr</a>, len: <a href="std.posix.html#std.posix.socklen_t">socklen_t</a>) <a href="std.posix.html#std.posix.ConnectError">ConnectError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.connect">connect</a>(sock, sock_addr, <span class="tok-builtin">@intCast</span>(len));
        <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
            .WSAEADDRINUSE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressInUse,
            .WSAEADDRNOTAVAIL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressNotAvailable,
            .WSAECONNREFUSED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionRefused,
            .WSAECONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .WSAETIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            .WSAEHOSTUNREACH,<span class="tok-comment"> // TODO: should we return NetworkUnreachable in this case as well?
            </span>.WSAENETUNREACH,
            =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
            .WSAEFAULT =&gt; <span class="tok-kw">unreachable</span>,
            .WSAEINVAL =&gt; <span class="tok-kw">unreachable</span>,
            .WSAEISCONN =&gt; <span class="tok-kw">unreachable</span>,
            .WSAENOTSOCK =&gt; <span class="tok-kw">unreachable</span>,
            .WSAEWOULDBLOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .WSAEACCES =&gt; <span class="tok-kw">unreachable</span>,
            .WSAENOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .WSAEAFNOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
        }
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">connect</a>(sock, sock_addr, len))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            .ADDRINUSE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressInUse,
            .ADDRNOTAVAIL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressNotAvailable,
            .AFNOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
            .AGAIN, .INPROGRESS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .ALREADY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionPending,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // sockfd is not a valid open file descriptor.
            </span>.CONNREFUSED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionRefused,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The socket structure address is outside the user's address space.
            </span>.INTR =&gt; <span class="tok-kw">continue</span>,
            .ISCONN =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The socket is already connected.
            </span>.HOSTUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
            .NETUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
            .NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The file descriptor sockfd does not refer to a socket.
            </span>.PROTOTYPE =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The socket type does not support the requested communications protocol.
            </span>.TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,<span class="tok-comment"> // Returned when socket is AF.UNIX and the given path does not exist.
            </span>.CONNABORTED =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Tried to reuse socket that previously received error.ConnectionRefused.
            </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.getsockopt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getsockopt</span><a href="#src.zig-std.posix.getsockopt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getsockopt</span>(fd: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, level: <span class="tok-type">i32</span>, optname: <span class="tok-type">u32</span>, opt: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.GetSockOptError">GetSockOptError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.socket_t">socket_t</a></code></pre></div><div><pre><code>level: <span class="tok-type">i32</span></code></pre></div><div><pre><code>optname: <span class="tok-type">u32</span></code></pre></div><div><pre><code>opt: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.getsockopt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getsockopt</span>(fd: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, level: <span class="tok-type">i32</span>, optname: <span class="tok-type">u32</span>, opt: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.GetSockOptError">GetSockOptError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> len: <a href="std.posix.html#std.posix.socklen_t">socklen_t</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">getsockopt</a>(fd, level, optname, opt.ptr, &amp;len))) {
        .SUCCESS =&gt; {
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>(len == opt.len);
        },
        .BADF =&gt; <span class="tok-kw">unreachable</span>,
        .NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .NOPROTOOPT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidProtocolOption,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.getsockoptError" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getsockoptError</span><a href="#src.zig-std.posix.getsockoptError">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getsockoptError</span>(sockfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.ConnectError">ConnectError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>sockfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.getsockoptError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getsockoptError</span>(sockfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.ConnectError">ConnectError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> err_code: <span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> size: <span class="tok-type">u32</span> = <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u32</span>);
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">getsockopt</a>(sockfd, <a href="std.posix.html#std.posix.SOL">SOL</a>.<a href="#">SOCKET</a>, <a href="std.posix.html#std.posix.SO">SO</a>.<a href="#">ERROR</a>, <span class="tok-builtin">@ptrCast</span>(&amp;err_code), &amp;size);
    <a href="std.debug.html#std.debug.assert">assert</a>(size == <span class="tok-number">4</span>);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.posix.html#std.posix.E">E</a>, <span class="tok-builtin">@enumFromInt</span>(err_code))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            .ADDRINUSE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressInUse,
            .ADDRNOTAVAIL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressNotAvailable,
            .AFNOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .ALREADY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionPending,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // sockfd is not a valid open file descriptor.
            </span>.CONNREFUSED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionRefused,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The socket structure address is outside the user's address space.
            </span>.ISCONN =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The socket is already connected.
            </span>.HOSTUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
            .NETUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
            .NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The file descriptor sockfd does not refer to a socket.
            </span>.PROTOTYPE =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The socket type does not support the requested communications protocol.
            </span>.TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        },
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The argument sockfd is not a valid file descriptor.
        </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The address pointed to by optval or optlen is not in a valid part of the process address space.
        </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .NOPROTOOPT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The option is unknown at the level indicated.
        </span>.NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The file descriptor sockfd does not refer to a socket.
        </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.waitpid" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">waitpid</span><a href="#src.zig-std.posix.waitpid">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">waitpid</span>(pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>, flags: <span class="tok-type">u32</span>) <a href="std.posix.WaitPidResult.html">WaitPidResult</a></code></pre></div><div class="tldDocs"><p>Use this version of the <code><a href="std.posix.html#std.posix.waitpid">waitpid</a></code> wrapper if you spawned your child process using explicit
<code><a href="std.posix.html#std.posix.fork">fork</a></code> and <code>execve</code> method.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.waitpid">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">waitpid</span>(pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>, flags: <span class="tok-type">u32</span>) <a href="std.posix.WaitPidResult.html">WaitPidResult</a> {
    <span class="tok-kw">var</span> status: <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) <span class="tok-type">c_int</span> <span class="tok-kw">else</span> <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">waitpid</a>(pid, &amp;status, <span class="tok-builtin">@intCast</span>(flags));
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> .{
                .pid = <span class="tok-builtin">@intCast</span>(rc),
                .status = <span class="tok-builtin">@bitCast</span>(status),
            },
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .CHILD =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The process specified does not exist. It would be a race condition to handle this error.
            </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid flags.
            </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.wait4" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">wait4</span><a href="#src.zig-std.posix.wait4">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">wait4</span>(pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>, flags: <span class="tok-type">u32</span>, ru: ?*<a href="std.posix.html#std.posix.rusage">rusage</a>) <a href="std.posix.WaitPidResult.html">WaitPidResult</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div><div><pre><code>ru: ?*<a href="std.posix.html#std.posix.rusage">rusage</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.wait4">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">wait4</span>(pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>, flags: <span class="tok-type">u32</span>, ru: ?*<a href="std.posix.html#std.posix.rusage">rusage</a>) <a href="std.posix.WaitPidResult.html">WaitPidResult</a> {
    <span class="tok-kw">var</span> status: <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) <span class="tok-type">c_int</span> <span class="tok-kw">else</span> <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">wait4</a>(pid, &amp;status, <span class="tok-builtin">@intCast</span>(flags), ru);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> .{
                .pid = <span class="tok-builtin">@intCast</span>(rc),
                .status = <span class="tok-builtin">@bitCast</span>(status),
            },
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .CHILD =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The process specified does not exist. It would be a race condition to handle this error.
            </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid flags.
            </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.fstat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fstat</span><a href="#src.zig-std.posix.fstat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fstat</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.FStatError">FStatError</a>!<a href="std.posix.html#std.posix.Stat">Stat</a></code></pre></div><div class="tldDocs"><p>Return information about a file descriptor.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.fstat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fstat</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.FStatError">FStatError</a>!<a href="std.posix.html#std.posix.Stat">Stat</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.Stat">Stat</a>.<a href="#">fromFilestat</a>(<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.fstat_wasi">fstat_wasi</a>(fd));
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;fstat is not yet implemented on Windows&quot;</span>);
    }

    <span class="tok-kw">const</span> fstat_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fstat64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fstat</a>;
    <span class="tok-kw">var</span> stat = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroes">zeroes</a>(<a href="std.posix.html#std.posix.Stat">Stat</a>);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(fstat_sym(fd, &amp;stat))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> stat,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition.
        </span>.NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.fstatat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fstatat</span><a href="#src.zig-std.posix.fstatat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fstatat</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.FStatAtError">FStatAtError</a>!<a href="std.posix.html#std.posix.Stat">Stat</a></code></pre></div><div class="tldDocs"><p>Similar to <code><a href="std.posix.html#std.posix.fstat">fstat</a></code>, but returns stat of a resource pointed to by <code>pathname</code>
which is relative to <code>dirfd</code> handle.
On WASI, <code>pathname</code> should be encoded as valid UTF-8.
On other platforms, <code>pathname</code> is an opaque sequence of bytes with no particular encoding.
See also <code><a href="std.posix.html#std.posix.fstatatZ">fstatatZ</a></code> and <code><a href="std.os.html#std.os.fstatat_wasi">std.os.fstatat_wasi</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.fstatat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fstatat</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.FStatAtError">FStatAtError</a>!<a href="std.posix.html#std.posix.Stat">Stat</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> filestat = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.fstatat_wasi">fstatat_wasi</a>(dirfd, pathname, .{
            .SYMLINK_FOLLOW = (flags &amp; <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">SYMLINK_NOFOLLOW</a>) == <span class="tok-number">0</span>,
        });
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.Stat">Stat</a>.<a href="#">fromFilestat</a>(filestat);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;fstatat is not yet implemented on Windows&quot;</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> pathname_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(pathname);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.fstatatZ">fstatatZ</a>(dirfd, &amp;pathname_c, flags);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.fstatatZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fstatatZ</span><a href="#src.zig-std.posix.fstatatZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fstatatZ</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.FStatAtError">FStatAtError</a>!<a href="std.posix.html#std.posix.Stat">Stat</a></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.fstatat">fstatat</a></code> but <code>pathname</code> is null-terminated.
See also <code><a href="std.posix.html#std.posix.fstatat">fstatat</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.fstatatZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fstatatZ</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.FStatAtError">FStatAtError</a>!<a href="std.posix.html#std.posix.Stat">Stat</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> filestat = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.fstatat_wasi">fstatat_wasi</a>(dirfd, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(pathname, <span class="tok-number">0</span>), .{
            .SYMLINK_FOLLOW = (flags &amp; <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">SYMLINK_NOFOLLOW</a>) == <span class="tok-number">0</span>,
        });
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.Stat">Stat</a>.<a href="#">fromFilestat</a>(filestat);
    }

    <span class="tok-kw">const</span> fstatat_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fstatat64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fstatat</a>;
    <span class="tok-kw">var</span> stat = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroes">zeroes</a>(<a href="std.posix.html#std.posix.Stat">Stat</a>);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(fstatat_sym(dirfd, pathname, &amp;stat, flags))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> stat,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition.
        </span>.NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.kqueue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">kqueue</span><a href="#src.zig-std.posix.kqueue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">kqueue</span>() <a href="std.posix.html#std.posix.KQueueError">KQueueError</a>!<span class="tok-type">i32</span></code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.kqueue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">kqueue</span>() <a href="std.posix.html#std.posix.KQueueError">KQueueError</a>!<span class="tok-type">i32</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">kqueue</a>();
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.kevent" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">kevent</span><a href="#src.zig-std.posix.kevent">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">kevent</span>( kq: <span class="tok-type">i32</span>, changelist: []<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.Kevent">Kevent</a>, eventlist: []<a href="std.posix.html#std.posix.Kevent">Kevent</a>, timeout: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.timespec">timespec</a>, ) <a href="std.posix.html#std.posix.KEventError">KEventError</a>!<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>kq: <span class="tok-type">i32</span></code></pre></div><div><pre><code>changelist: []<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.Kevent">Kevent</a></code></pre></div><div><pre><code>eventlist: []<a href="std.posix.html#std.posix.Kevent">Kevent</a></code></pre></div><div><pre><code>timeout: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.timespec">timespec</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.kevent">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">kevent</span>(
    kq: <span class="tok-type">i32</span>,
    changelist: []<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.Kevent">Kevent</a>,
    eventlist: []<a href="std.posix.html#std.posix.Kevent">Kevent</a>,
    timeout: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.timespec">timespec</a>,
) <a href="std.posix.html#std.posix.KEventError">KEventError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">kevent</a>(
            kq,
            changelist.ptr,
            <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">c_int</span>, changelist.len) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow,
            eventlist.ptr,
            <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">c_int</span>, eventlist.len) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow,
            timeout,
        );
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition.
            </span>.INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EventNotFound,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .SRCH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.inotify_init1" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">inotify_init1</span><a href="#src.zig-std.posix.inotify_init1">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inotify_init1</span>(flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.INotifyInitError">INotifyInitError</a>!<span class="tok-type">i32</span></code></pre></div><div class="tldDocs"><p>initialize an inotify instance</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.inotify_init1">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inotify_init1</span>(flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.INotifyInitError">INotifyInitError</a>!<span class="tok-type">i32</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">inotify_init1</a>(flags);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.inotify_add_watch" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">inotify_add_watch</span><a href="#src.zig-std.posix.inotify_add_watch">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inotify_add_watch</span>(inotify_fd: <span class="tok-type">i32</span>, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mask: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.INotifyAddWatchError">INotifyAddWatchError</a>!<span class="tok-type">i32</span></code></pre></div><div class="tldDocs"><p>add a watch to an initialized inotify instance</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>inotify_fd: <span class="tok-type">i32</span></code></pre></div><div><pre><code>pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>mask: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.inotify_add_watch">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inotify_add_watch</span>(inotify_fd: <span class="tok-type">i32</span>, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mask: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.INotifyAddWatchError">INotifyAddWatchError</a>!<span class="tok-type">i32</span> {
    <span class="tok-kw">const</span> pathname_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(pathname);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.inotify_add_watchZ">inotify_add_watchZ</a>(inotify_fd, &amp;pathname_c, mask);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.inotify_add_watchZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">inotify_add_watchZ</span><a href="#src.zig-std.posix.inotify_add_watchZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inotify_add_watchZ</span>(inotify_fd: <span class="tok-type">i32</span>, pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mask: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.INotifyAddWatchError">INotifyAddWatchError</a>!<span class="tok-type">i32</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.inotify_add_watch">inotify_add_watch</a></code> except pathname is null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>inotify_fd: <span class="tok-type">i32</span></code></pre></div><div><pre><code>pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>mask: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.inotify_add_watchZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inotify_add_watchZ</span>(inotify_fd: <span class="tok-type">i32</span>, pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mask: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.INotifyAddWatchError">INotifyAddWatchError</a>!<span class="tok-type">i32</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">inotify_add_watch</a>(inotify_fd, pathname, mask);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UserResourceLimitReached,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WatchAlreadyExists,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.inotify_rm_watch" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">inotify_rm_watch</span><a href="#src.zig-std.posix.inotify_rm_watch">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inotify_rm_watch</span>(inotify_fd: <span class="tok-type">i32</span>, wd: <span class="tok-type">i32</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>remove an existing watch from an inotify instance</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>inotify_fd: <span class="tok-type">i32</span></code></pre></div><div><pre><code>wd: <span class="tok-type">i32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.inotify_rm_watch">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inotify_rm_watch</span>(inotify_fd: <span class="tok-type">i32</span>, wd: <span class="tok-type">i32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">inotify_rm_watch</a>(inotify_fd, wd))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.fanotify_init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fanotify_init</span><a href="#src.zig-std.posix.fanotify_init">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fanotify_init</span>(flags: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.fanotify.html">fanotify</a>.<a href="std.os.linux.fanotify.InitFlags.html">InitFlags</a>, event_f_flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.FanotifyInitError">FanotifyInitError</a>!<span class="tok-type">i32</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>flags: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.fanotify.html">fanotify</a>.<a href="std.os.linux.fanotify.InitFlags.html">InitFlags</a></code></pre></div><div><pre><code>event_f_flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.fanotify_init">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fanotify_init</span>(flags: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.fanotify.html">fanotify</a>.<a href="std.os.linux.fanotify.InitFlags.html">InitFlags</a>, event_f_flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.FanotifyInitError">FanotifyInitError</a>!<span class="tok-type">i32</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fanotify_init</a>(flags, event_f_flags);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedFlags,
        .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.fanotify_mark" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fanotify_mark</span><a href="#src.zig-std.posix.fanotify_mark">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fanotify_mark</span>( fanotify_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, flags: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.fanotify.html">fanotify</a>.<a href="std.os.linux.fanotify.MarkFlags.html">MarkFlags</a>, mask: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.fanotify.html">fanotify</a>.<a href="std.os.linux.fanotify.MarkMask.html">MarkMask</a>, dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, pathname: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.posix.html#std.posix.FanotifyMarkError">FanotifyMarkError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fanotify_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>flags: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.fanotify.html">fanotify</a>.<a href="std.os.linux.fanotify.MarkFlags.html">MarkFlags</a></code></pre></div><div><pre><code>mask: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.fanotify.html">fanotify</a>.<a href="std.os.linux.fanotify.MarkMask.html">MarkMask</a></code></pre></div><div><pre><code>dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>pathname: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.fanotify_mark">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fanotify_mark</span>(
    fanotify_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    flags: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.fanotify.html">fanotify</a>.<a href="std.os.linux.fanotify.MarkFlags.html">MarkFlags</a>,
    mask: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.fanotify.html">fanotify</a>.<a href="std.os.linux.fanotify.MarkMask.html">MarkMask</a>,
    dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    pathname: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.posix.html#std.posix.FanotifyMarkError">FanotifyMarkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (pathname) |path| {
        <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.fanotify_markZ">fanotify_markZ</a>(fanotify_fd, flags, mask, dirfd, &amp;path_c);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.fanotify_markZ">fanotify_markZ</a>(fanotify_fd, flags, mask, dirfd, <span class="tok-null">null</span>);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.fanotify_markZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fanotify_markZ</span><a href="#src.zig-std.posix.fanotify_markZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fanotify_markZ</span>( fanotify_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, flags: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.fanotify.html">fanotify</a>.<a href="std.os.linux.fanotify.MarkFlags.html">MarkFlags</a>, mask: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.fanotify.html">fanotify</a>.<a href="std.os.linux.fanotify.MarkMask.html">MarkMask</a>, dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, pathname: ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.posix.html#std.posix.FanotifyMarkError">FanotifyMarkError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fanotify_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>flags: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.fanotify.html">fanotify</a>.<a href="std.os.linux.fanotify.MarkFlags.html">MarkFlags</a></code></pre></div><div><pre><code>mask: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.fanotify.html">fanotify</a>.<a href="std.os.linux.fanotify.MarkMask.html">MarkMask</a></code></pre></div><div><pre><code>dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>pathname: ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.fanotify_markZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fanotify_markZ</span>(
    fanotify_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    flags: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.fanotify.html">fanotify</a>.<a href="std.os.linux.fanotify.MarkFlags.html">MarkFlags</a>,
    mask: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.fanotify.html">fanotify</a>.<a href="std.os.linux.fanotify.MarkMask.html">MarkMask</a>,
    dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    pathname: ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.posix.html#std.posix.FanotifyMarkError">FanotifyMarkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fanotify_mark</a>(fanotify_fd, flags, mask, dirfd, pathname);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MarkAlreadyExists,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
        .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotAssociatedWithFileSystem,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UserMarkQuotaExceeded,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OperationNotSupported,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .XDEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotSameFileSystem,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.mprotect" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mprotect</span><a href="#src.zig-std.posix.mprotect">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mprotect</span>(memory: []<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, protection: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.MProtectError">MProtectError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>memory: []<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span></code></pre></div><div><pre><code>protection: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.mprotect">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mprotect</span>(memory: []<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, protection: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.MProtectError">MProtectError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> win_prot: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a> = <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@truncate</span>(protection))) {
            <span class="tok-number">0b000</span> =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PAGE_NOACCESS">PAGE_NOACCESS</a>,
            <span class="tok-number">0b001</span> =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PAGE_READONLY">PAGE_READONLY</a>,
            <span class="tok-number">0b010</span> =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // +w -r not allowed
            </span><span class="tok-number">0b011</span> =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PAGE_READWRITE">PAGE_READWRITE</a>,
            <span class="tok-number">0b100</span> =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PAGE_EXECUTE">PAGE_EXECUTE</a>,
            <span class="tok-number">0b101</span> =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PAGE_EXECUTE_READ">PAGE_EXECUTE_READ</a>,
            <span class="tok-number">0b110</span> =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // +w -r not allowed
            </span><span class="tok-number">0b111</span> =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PAGE_EXECUTE_READWRITE">PAGE_EXECUTE_READWRITE</a>,
        };
        <span class="tok-kw">var</span> old: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a> = <span class="tok-null">undefined</span>;
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.VirtualProtect">VirtualProtect</a>(memory.ptr, memory.len, win_prot, &amp;old) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.InvalidAddress =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">error</span>.Unexpected =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">mprotect</a>(memory.ptr, memory.len, protection))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.fork" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fork</span><a href="#src.zig-std.posix.fork">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fork</span>() <a href="std.posix.html#std.posix.ForkError">ForkError</a>!<a href="std.posix.html#std.posix.pid_t">pid_t</a></code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.fork">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fork</span>() <a href="std.posix.html#std.posix.ForkError">ForkError</a>!<a href="std.posix.html#std.posix.pid_t">pid_t</a> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fork</a>();
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.mmap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mmap</span><a href="#src.zig-std.posix.mmap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mmap</span>( ptr: ?[*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, length: <span class="tok-type">usize</span>, prot: <span class="tok-type">u32</span>, flags: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MAP</a>, fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, offset: <span class="tok-type">u64</span>, ) <a href="std.posix.html#std.posix.MMapError">MMapError</a>![]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Map files or devices into memory.
<code>length</code> does not need to be aligned.
Use of a mapped region can result in these signals:</p>
<ul>
<li>SIGSEGV - Attempted write into a region mapped as read-only.</li>
<li>SIGBUS - Attempted  access to a portion of the buffer that does not correspond to the file</li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>ptr: ?[*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span></code></pre></div><div><pre><code>length: <span class="tok-type">usize</span></code></pre></div><div><pre><code>prot: <span class="tok-type">u32</span></code></pre></div><div><pre><code>flags: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MAP</a></code></pre></div><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.mmap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mmap</span>(
    ptr: ?[*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>,
    length: <span class="tok-type">usize</span>,
    prot: <span class="tok-type">u32</span>,
    flags: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MAP</a>,
    fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    offset: <span class="tok-type">u64</span>,
) <a href="std.posix.html#std.posix.MMapError">MMapError</a>![]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> mmap_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">mmap64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">mmap</a>;
    <span class="tok-kw">const</span> rc = mmap_sym(ptr, length, prot, <span class="tok-builtin">@bitCast</span>(flags), fd, <span class="tok-builtin">@bitCast</span>(offset));
    <span class="tok-kw">const</span> err: <a href="std.posix.html#std.posix.E">E</a> = <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) blk: {
        <span class="tok-kw">if</span> (rc != <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.MAP_FAILED">MAP_FAILED</a>) <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(rc)))[<span class="tok-number">0</span>..length];
        <span class="tok-kw">break</span> :blk <span class="tok-builtin">@enumFromInt</span>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">_errno</a>().*);
    } <span class="tok-kw">else</span> blk: {
        <span class="tok-kw">const</span> err = <a href="std.posix.html#std.posix.errno">errno</a>(rc);
        <span class="tok-kw">if</span> (err == .SUCCESS) <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(rc))[<span class="tok-number">0</span>..length];
        <span class="tok-kw">break</span> :blk err;
    };
    <span class="tok-kw">switch</span> (err) {
        .SUCCESS =&gt; <span class="tok-kw">unreachable</span>,
        .TXTBSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LockedMemoryLimitExceeded,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition.
        </span>.OVERFLOW =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The number of pages used for length + offset would overflow.
        </span>.NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MemoryMappingNotSupported,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid parameters to mmap()
        </span>.MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MappingAlreadyExists,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.munmap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">munmap</span><a href="#src.zig-std.posix.munmap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">munmap</span>(memory: []<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deletes the mappings for the specified address range, causing
further references to addresses within the range to generate invalid memory references.
Note that while POSIX allows unmapping a region in the middle of an existing mapping,
Zig's munmap function does not, for two reasons:</p>
<ul>
<li>It violates the Zig principle that resource deallocation must succeed.</li>
<li>The Windows function, VirtualFree, has this restriction.</li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>memory: []<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.munmap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">munmap</span>(memory: []<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">munmap</a>(memory.ptr, memory.len))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid parameters.
        </span>.NOMEM =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Attempted to unmap a region in the middle of an existing mapping.
        </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.mremap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mremap</span><a href="#src.zig-std.posix.mremap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mremap</span>( old_address: ?[*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, old_len: <span class="tok-type">usize</span>, new_len: <span class="tok-type">usize</span>, flags: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MREMAP</a>, new_address: ?[*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, ) <a href="std.posix.html#std.posix.MRemapError">MRemapError</a>![]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>old_address: ?[*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span></code></pre></div><div><pre><code>old_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>flags: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MREMAP</a></code></pre></div><div><pre><code>new_address: ?[*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.mremap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mremap</span>(
    old_address: ?[*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>,
    old_len: <span class="tok-type">usize</span>,
    new_len: <span class="tok-type">usize</span>,
    flags: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MREMAP</a>,
    new_address: ?[*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>,
) <a href="std.posix.html#std.posix.MRemapError">MRemapError</a>![]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">mremap</a>(old_address, old_len, new_len, flags, new_address);
    <span class="tok-kw">const</span> err: <a href="std.posix.html#std.posix.E">E</a> = <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) blk: {
        <span class="tok-kw">if</span> (rc != <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.MAP_FAILED">MAP_FAILED</a>) <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(rc)))[<span class="tok-number">0</span>..new_len];
        <span class="tok-kw">break</span> :blk <span class="tok-builtin">@enumFromInt</span>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">_errno</a>().*);
    } <span class="tok-kw">else</span> blk: {
        <span class="tok-kw">const</span> err = <a href="std.posix.html#std.posix.errno">errno</a>(rc);
        <span class="tok-kw">if</span> (err == .SUCCESS) <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(rc))[<span class="tok-number">0</span>..new_len];
        <span class="tok-kw">break</span> :blk err;
    };
    <span class="tok-kw">switch</span> (err) {
        .SUCCESS =&gt; <span class="tok-kw">unreachable</span>,
        .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LockedMemoryLimitExceeded,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidSyscallParameters,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.msync" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">msync</span><a href="#src.zig-std.posix.msync">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">msync</span>(memory: []<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, flags: <span class="tok-type">i32</span>) <a href="std.posix.html#std.posix.MSyncError">MSyncError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>memory: []<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <span class="tok-type">i32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.msync">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">msync</span>(memory: []<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, flags: <span class="tok-type">i32</span>) <a href="std.posix.html#std.posix.MSyncError">MSyncError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">msync</a>(memory.ptr, memory.len, flags))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnmappedMemory,<span class="tok-comment"> // Unsuccessful, provided pointer does not point mapped memory
        </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid parameters.
        </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.access" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">access</span><a href="#src.zig-std.posix.access">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">access</span>(path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>check user's permissions for a file</p>
<ul>
<li>On Windows, asserts <code>path</code> is valid <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.</li>
<li>On WASI, invalid UTF-8 passed to <code>path</code> causes <code>error.InvalidUtf8</code>.</li>
<li>On other platforms, <code>path</code> is an opaque sequence of bytes with no particular encoding.</li>
</ul>
<p>On Windows, <code>mode</code> is ignored. This is a POSIX API that is only partially supported by
Windows. See <code><a href="std.fs.html">fs</a></code> for the cross-platform file system API.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>mode: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.access">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">access</span>(path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> path_w = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        _ = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetFileAttributesW">GetFileAttributesW</a>(path_w.span().ptr);
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.faccessat">faccessat</a>(<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, path, mode, <span class="tok-number">0</span>);
    }
    <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(path);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.accessZ">accessZ</a>(&amp;path_c, mode);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.accessZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">accessZ</span><a href="#src.zig-std.posix.accessZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessZ</span>(path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.access">access</a></code> except <code>path</code> is null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>mode: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.accessZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessZ</span>(path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> path_w = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        _ = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetFileAttributesW">GetFileAttributesW</a>(path_w.span().ptr);
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.access">access</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(path, <span class="tok-number">0</span>), mode);
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">access</a>(path, mode))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .TXTBSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.faccessat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">faccessat</span><a href="#src.zig-std.posix.faccessat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">faccessat</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <span class="tok-type">u32</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Check user's permissions for a file, based on an open directory handle.</p>
<ul>
<li>On Windows, asserts <code>path</code> is valid <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.</li>
<li>On WASI, invalid UTF-8 passed to <code>path</code> causes <code>error.InvalidUtf8</code>.</li>
<li>On other platforms, <code>path</code> is an opaque sequence of bytes with no particular encoding.</li>
</ul>
<p>On Windows, <code>mode</code> is ignored. This is a POSIX API that is only partially supported by
Windows. See <code><a href="std.fs.html">fs</a></code> for the cross-platform file system API.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>mode: <span class="tok-type">u32</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.faccessat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">faccessat</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <span class="tok-type">u32</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(dirfd, path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.faccessatW">faccessatW</a>(dirfd, path_w.span().ptr);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> resolved: <a href="std.posix.RelativePathWasi.html">RelativePathWasi</a> = .{ .dir_fd = dirfd, .relative_path = path };

        <span class="tok-kw">const</span> st = blk: {
            <span class="tok-kw">break</span> :blk <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.fstatat_wasi">fstatat_wasi</a>(dirfd, path, .{
                .SYMLINK_FOLLOW = (flags &amp; <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">SYMLINK_NOFOLLOW</a>) == <span class="tok-number">0</span>,
            });
        } <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };

        <span class="tok-kw">if</span> (mode != <a href="std.posix.html#std.posix.F_OK">F_OK</a>) {
            <span class="tok-kw">var</span> directory: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.fdstat_t.html">fdstat_t</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">if</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_fdstat_get">fd_fdstat_get</a>(resolved.dir_fd, &amp;directory) != .SUCCESS) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied;
            }

            <span class="tok-kw">var</span> rights: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.rights_t.html">rights_t</a> = .{};
            <span class="tok-kw">if</span> (mode &amp; <a href="std.posix.html#std.posix.R_OK">R_OK</a> != <span class="tok-number">0</span>) {
                <span class="tok-kw">if</span> (st.filetype == .DIRECTORY) {
                    rights.FD_READDIR = <span class="tok-null">true</span>;
                } <span class="tok-kw">else</span> {
                    rights.FD_READ = <span class="tok-null">true</span>;
                }
            }
            <span class="tok-kw">if</span> (mode &amp; <a href="std.posix.html#std.posix.W_OK">W_OK</a> != <span class="tok-number">0</span>) {
                rights.FD_WRITE = <span class="tok-null">true</span>;
            }<span class="tok-comment">
            // No validation for X_OK

            // https://github.com/ziglang/zig/issues/18882
            </span><span class="tok-kw">const</span> rights_int: <span class="tok-type">u64</span> = <span class="tok-builtin">@bitCast</span>(rights);
            <span class="tok-kw">const</span> inheriting_int: <span class="tok-type">u64</span> = <span class="tok-builtin">@bitCast</span>(directory.fs_rights_inheriting);
            <span class="tok-kw">if</span> ((rights_int &amp; inheriting_int) != rights_int) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied;
            }
        }
        <span class="tok-kw">return</span>;
    }
    <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(path);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.faccessatZ">faccessatZ</a>(dirfd, &amp;path_c, mode, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.faccessatZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">faccessatZ</span><a href="#src.zig-std.posix.faccessatZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">faccessatZ</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <span class="tok-type">u32</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.faccessat">faccessat</a></code> except the path parameter is null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>mode: <span class="tok-type">u32</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.faccessatZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">faccessatZ</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <span class="tok-type">u32</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(dirfd, path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.faccessatW">faccessatW</a>(dirfd, path_w.span().ptr);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.faccessat">faccessat</a>(dirfd, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(path, <span class="tok-number">0</span>), mode, flags);
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">faccessat</a>(dirfd, path, mode, flags))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .TXTBSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.faccessatW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">faccessatW</span><a href="#src.zig-std.posix.faccessatW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">faccessatW</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.faccessat">faccessat</a></code> except asserts the target is Windows and the path parameter
is NtDll-prefixed, null-terminated, WTF-16 encoded.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.faccessatW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">faccessatW</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (sub_path_w[<span class="tok-number">0</span>] == <span class="tok-str">'.'</span> <span class="tok-kw">and</span> sub_path_w[<span class="tok-number">1</span>] == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span>;
    }
    <span class="tok-kw">if</span> (sub_path_w[<span class="tok-number">0</span>] == <span class="tok-str">'.'</span> <span class="tok-kw">and</span> sub_path_w[<span class="tok-number">1</span>] == <span class="tok-str">'.'</span> <span class="tok-kw">and</span> sub_path_w[<span class="tok-number">2</span>] == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">const</span> path_len_bytes = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u16</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sub_path_w, <span class="tok-number">0</span>).len * <span class="tok-number">2</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
    <span class="tok-kw">var</span> nt_name = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.UNICODE_STRING.html">UNICODE_STRING</a>{
        .Length = path_len_bytes,
        .MaximumLength = path_len_bytes,
        .Buffer = <span class="tok-builtin">@constCast</span>(sub_path_w),
    };
    <span class="tok-kw">var</span> attr = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.OBJECT_ATTRIBUTES.html">OBJECT_ATTRIBUTES</a>{
        .Length = <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.OBJECT_ATTRIBUTES.html">OBJECT_ATTRIBUTES</a>),
        .RootDirectory = <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(sub_path_w)) <span class="tok-null">null</span> <span class="tok-kw">else</span> dirfd,
        .Attributes = <span class="tok-number">0</span>,<span class="tok-comment"> // Note we do not use OBJ_CASE_INSENSITIVE here.
        </span>.ObjectName = &amp;nt_name,
        .SecurityDescriptor = <span class="tok-null">null</span>,
        .SecurityQualityOfService = <span class="tok-null">null</span>,
    };
    <span class="tok-kw">var</span> basic_info: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_BASIC_INFORMATION.html">FILE_BASIC_INFORMATION</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtQueryAttributesFile">NtQueryAttributesFile</a>(&amp;attr, &amp;basic_info)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .OBJECT_NAME_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .OBJECT_PATH_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .OBJECT_NAME_INVALID =&gt; <span class="tok-kw">unreachable</span>,
        .INVALID_PARAMETER =&gt; <span class="tok-kw">unreachable</span>,
        .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .OBJECT_PATH_SYNTAX_BAD =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; |rc| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedStatus">unexpectedStatus</a>(rc),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.pipe" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pipe</span><a href="#src.zig-std.posix.pipe">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pipe</span>() <a href="std.posix.html#std.posix.PipeError">PipeError</a>![<span class="tok-number">2</span>]<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div class="tldDocs"><p>Creates a unidirectional data channel that can be used for interprocess communication.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.pipe">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pipe</span>() <a href="std.posix.html#std.posix.PipeError">PipeError</a>![<span class="tok-number">2</span>]<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">var</span> fds: [<span class="tok-number">2</span>]<a href="std.posix.html#std.posix.fd_t">fd_t</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">pipe</a>(&amp;fds))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> fds,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid parameters to pipe()
        </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid fds pointer
        </span>.NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.pipe2" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pipe2</span><a href="#src.zig-std.posix.pipe2">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pipe2</span>(flags: <a href="std.posix.html#std.posix.O">O</a>) <a href="std.posix.html#std.posix.PipeError">PipeError</a>![<span class="tok-number">2</span>]<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>flags: <a href="std.posix.html#std.posix.O">O</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.pipe2">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pipe2</span>(flags: <a href="std.posix.html#std.posix.O">O</a>) <a href="std.posix.html#std.posix.PipeError">PipeError</a>![<span class="tok-number">2</span>]<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@TypeOf</span>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">pipe2</a>) != <span class="tok-type">void</span>) {
        <span class="tok-kw">var</span> fds: [<span class="tok-number">2</span>]<a href="std.posix.html#std.posix.fd_t">fd_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">pipe2</a>(&amp;fds, flags))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> fds,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid flags
            </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid fds pointer
            </span>.NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
            .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">const</span> fds: [<span class="tok-number">2</span>]<a href="std.posix.html#std.posix.fd_t">fd_t</a> = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.pipe">pipe</a>();
    <span class="tok-kw">errdefer</span> {
        <a href="std.posix.html#std.posix.close">close</a>(fds[<span class="tok-number">0</span>]);
        <a href="std.posix.html#std.posix.close">close</a>(fds[<span class="tok-number">1</span>]);
    }<span class="tok-comment">

    // https://github.com/ziglang/zig/issues/18882
    </span><span class="tok-kw">if</span> (<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(flags)) == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> fds;<span class="tok-comment">

    // CLOEXEC is special, it's a file descriptor flag and must be set using
    // F.SETFD.
    </span><span class="tok-kw">if</span> (flags.CLOEXEC) {
        <span class="tok-kw">for</span> (fds) |fd| {
            <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">fcntl</a>(fd, <a href="std.posix.html#std.posix.F">F</a>.<a href="#">SETFD</a>, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <a href="std.posix.html#std.posix.FD_CLOEXEC">FD_CLOEXEC</a>)))) {
                .SUCCESS =&gt; {},
                .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid flags
                </span>.BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition
                </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
        }
    }

    <span class="tok-kw">const</span> new_flags: <span class="tok-type">u32</span> = f: {
        <span class="tok-kw">var</span> new_flags = flags;
        new_flags.CLOEXEC = <span class="tok-null">false</span>;
        <span class="tok-kw">break</span> :f <span class="tok-builtin">@bitCast</span>(new_flags);
    };<span class="tok-comment">
    // Set every other flag affecting the file status using F.SETFL.
    </span><span class="tok-kw">if</span> (new_flags != <span class="tok-number">0</span>) {
        <span class="tok-kw">for</span> (fds) |fd| {
            <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">fcntl</a>(fd, <a href="std.posix.html#std.posix.F">F</a>.<a href="#">SETFL</a>, new_flags))) {
                .SUCCESS =&gt; {},
                .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid flags
                </span>.BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition
                </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
        }
    }

    <span class="tok-kw">return</span> fds;
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.sysctl" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sysctl</span><a href="#src.zig-std.posix.sysctl">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sysctl</span>( name: []<span class="tok-kw">const</span> <span class="tok-type">c_int</span>, oldp: ?*<span class="tok-type">anyopaque</span>, oldlenp: ?*<span class="tok-type">usize</span>, newp: ?*<span class="tok-type">anyopaque</span>, newlen: <span class="tok-type">usize</span>, ) <a href="std.posix.html#std.posix.SysCtlError">SysCtlError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">c_int</span></code></pre></div><div><pre><code>oldp: ?*<span class="tok-type">anyopaque</span></code></pre></div><div><pre><code>oldlenp: ?*<span class="tok-type">usize</span></code></pre></div><div><pre><code>newp: ?*<span class="tok-type">anyopaque</span></code></pre></div><div><pre><code>newlen: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.sysctl">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sysctl</span>(
    name: []<span class="tok-kw">const</span> <span class="tok-type">c_int</span>,
    oldp: ?*<span class="tok-type">anyopaque</span>,
    oldlenp: ?*<span class="tok-type">usize</span>,
    newp: ?*<span class="tok-type">anyopaque</span>,
    newlen: <span class="tok-type">usize</span>,
) <a href="std.posix.html#std.posix.SysCtlError">SysCtlError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;sysctl not supported on WASI&quot;</span>);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .haiku) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;sysctl not supported on Haiku&quot;</span>);
    }

    <span class="tok-kw">const</span> name_len = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">c_uint</span>, name.len) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">sysctl</a>(name.ptr, name_len, oldp, oldlenp, newp, newlen))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownName,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.sysctlbynameZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sysctlbynameZ</span><a href="#src.zig-std.posix.sysctlbynameZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sysctlbynameZ</span>( name: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, oldp: ?*<span class="tok-type">anyopaque</span>, oldlenp: ?*<span class="tok-type">usize</span>, newp: ?*<span class="tok-type">anyopaque</span>, newlen: <span class="tok-type">usize</span>, ) <a href="std.posix.html#std.posix.SysCtlError">SysCtlError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>name: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>oldp: ?*<span class="tok-type">anyopaque</span></code></pre></div><div><pre><code>oldlenp: ?*<span class="tok-type">usize</span></code></pre></div><div><pre><code>newp: ?*<span class="tok-type">anyopaque</span></code></pre></div><div><pre><code>newlen: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.sysctlbynameZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sysctlbynameZ</span>(
    name: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    oldp: ?*<span class="tok-type">anyopaque</span>,
    oldlenp: ?*<span class="tok-type">usize</span>,
    newp: ?*<span class="tok-type">anyopaque</span>,
    newlen: <span class="tok-type">usize</span>,
) <a href="std.posix.html#std.posix.SysCtlError">SysCtlError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;sysctl not supported on WASI&quot;</span>);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .haiku) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;sysctl not supported on Haiku&quot;</span>);
    }

    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">sysctlbyname</a>(name, oldp, oldlenp, newp, newlen))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownName,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.gettimeofday" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">gettimeofday</span><a href="#src.zig-std.posix.gettimeofday">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gettimeofday</span>(tv: ?*<a href="std.posix.html#std.posix.timeval">timeval</a>, tz: ?*<a href="std.posix.html#std.posix.timezone">timezone</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tv: ?*<a href="std.posix.html#std.posix.timeval">timeval</a></code></pre></div><div><pre><code>tz: ?*<a href="std.posix.html#std.posix.timezone">timezone</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.gettimeofday">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gettimeofday</span>(tv: ?*<a href="std.posix.html#std.posix.timeval">timeval</a>, tz: ?*<a href="std.posix.html#std.posix.timezone">timezone</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">gettimeofday</a>(tv, tz))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.lseek_SET" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lseek_SET</span><a href="#src.zig-std.posix.lseek_SET">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lseek_SET</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Repositions read/write file offset relative to the beginning.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.lseek_SET">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lseek_SET</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .linux <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a> <span class="tok-kw">and</span> <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) == <span class="tok-number">4</span>) {
        <span class="tok-kw">var</span> result: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">llseek</a>(fd, offset, &amp;result, <a href="std.posix.html#std.posix.SEEK">SEEK</a>.<a href="#">SET</a>))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SetFilePointerEx_BEGIN">SetFilePointerEx_BEGIN</a>(fd, offset);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> new_offset: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.filesize_t">filesize_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_seek">fd_seek</a>(fd, <span class="tok-builtin">@bitCast</span>(offset), .SET, &amp;new_offset)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">const</span> lseek_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">lseek64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">lseek</a>;
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(lseek_sym(fd, <span class="tok-builtin">@bitCast</span>(offset), <a href="std.posix.html#std.posix.SEEK">SEEK</a>.<a href="#">SET</a>))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
        </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.lseek_CUR" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lseek_CUR</span><a href="#src.zig-std.posix.lseek_CUR">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lseek_CUR</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, offset: <span class="tok-type">i64</span>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Repositions read/write file offset relative to the current offset.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>offset: <span class="tok-type">i64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.lseek_CUR">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lseek_CUR</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, offset: <span class="tok-type">i64</span>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .linux <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a> <span class="tok-kw">and</span> <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) == <span class="tok-number">4</span>) {
        <span class="tok-kw">var</span> result: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">llseek</a>(fd, <span class="tok-builtin">@bitCast</span>(offset), &amp;result, <a href="std.posix.html#std.posix.SEEK">SEEK</a>.<a href="#">CUR</a>))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SetFilePointerEx_CURRENT">SetFilePointerEx_CURRENT</a>(fd, offset);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> new_offset: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.filesize_t">filesize_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_seek">fd_seek</a>(fd, offset, .CUR, &amp;new_offset)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">const</span> lseek_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">lseek64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">lseek</a>;
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(lseek_sym(fd, <span class="tok-builtin">@bitCast</span>(offset), <a href="std.posix.html#std.posix.SEEK">SEEK</a>.<a href="#">CUR</a>))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
        </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.lseek_END" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lseek_END</span><a href="#src.zig-std.posix.lseek_END">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lseek_END</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, offset: <span class="tok-type">i64</span>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Repositions read/write file offset relative to the end.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>offset: <span class="tok-type">i64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.lseek_END">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lseek_END</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, offset: <span class="tok-type">i64</span>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .linux <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a> <span class="tok-kw">and</span> <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) == <span class="tok-number">4</span>) {
        <span class="tok-kw">var</span> result: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">llseek</a>(fd, <span class="tok-builtin">@bitCast</span>(offset), &amp;result, <a href="std.posix.html#std.posix.SEEK">SEEK</a>.<a href="#">END</a>))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SetFilePointerEx_END">SetFilePointerEx_END</a>(fd, offset);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> new_offset: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.filesize_t">filesize_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_seek">fd_seek</a>(fd, offset, .END, &amp;new_offset)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">const</span> lseek_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">lseek64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">lseek</a>;
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(lseek_sym(fd, <span class="tok-builtin">@bitCast</span>(offset), <a href="std.posix.html#std.posix.SEEK">SEEK</a>.<a href="#">END</a>))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
        </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.lseek_CUR_get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lseek_CUR_get</span><a href="#src.zig-std.posix.lseek_CUR_get">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lseek_CUR_get</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">u64</span></code></pre></div><div class="tldDocs"><p>Returns the read/write file offset relative to the beginning.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.lseek_CUR_get">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lseek_CUR_get</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">u64</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .linux <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a> <span class="tok-kw">and</span> <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) == <span class="tok-number">4</span>) {
        <span class="tok-kw">var</span> result: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">llseek</a>(fd, <span class="tok-number">0</span>, &amp;result, <a href="std.posix.html#std.posix.SEEK">SEEK</a>.<a href="#">CUR</a>))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> result,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SetFilePointerEx_CURRENT_get">SetFilePointerEx_CURRENT_get</a>(fd);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> new_offset: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.filesize_t">filesize_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_seek">fd_seek</a>(fd, <span class="tok-number">0</span>, .CUR, &amp;new_offset)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> new_offset,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">const</span> lseek_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">lseek64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">lseek</a>;
    <span class="tok-kw">const</span> rc = lseek_sym(fd, <span class="tok-number">0</span>, <a href="std.posix.html#std.posix.SEEK">SEEK</a>.<a href="#">CUR</a>);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(rc),
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
        </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.fcntl" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fcntl</span><a href="#src.zig-std.posix.fcntl">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fcntl</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, cmd: <span class="tok-type">i32</span>, arg: <span class="tok-type">usize</span>) <a href="std.posix.html#std.posix.FcntlError">FcntlError</a>!<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>cmd: <span class="tok-type">i32</span></code></pre></div><div><pre><code>arg: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.fcntl">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fcntl</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, cmd: <span class="tok-type">i32</span>, arg: <span class="tok-type">usize</span>) <a href="std.posix.html#std.posix.FcntlError">FcntlError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fcntl</a>(fd, cmd, arg);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .AGAIN, .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Locked,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid parameters
            </span>.PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
            .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid parameter
            </span>.DEADLK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeadLock,
            .NOLCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LockedRegionLimitExceeded,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.flock" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">flock</span><a href="#src.zig-std.posix.flock">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">flock</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, operation: <span class="tok-type">i32</span>) <a href="std.posix.html#std.posix.FlockError">FlockError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Depending on the operating system <code><a href="std.posix.html#std.posix.flock">flock</a></code> may or may not interact with
<code><a href="std.posix.html#std.posix.fcntl">fcntl</a></code> locks made by other processes.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>operation: <span class="tok-type">i32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.flock">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">flock</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, operation: <span class="tok-type">i32</span>) <a href="std.posix.html#std.posix.FlockError">FlockError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">flock</a>(fd, operation);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid parameters
            </span>.NOLCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,<span class="tok-comment"> // TODO: integrate with async instead of just returning an error
            </span>.OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileLocksNotSupported,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.realpath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">realpath</span><a href="#src.zig-std.posix.realpath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpath</span>(pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Return the canonicalized absolute pathname.</p>
<p>Expands all symbolic links and resolves references to <code>.</code>, <code>..</code>, and
extra <code>/</code> characters in <code>pathname</code>.</p>
<p>On Windows, <code>pathname</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.</p>
<p>On other platforms, <code>pathname</code> is an opaque sequence of bytes with no particular encoding.</p>
<p>The return value is a slice of <code>out_buffer</code>, but not necessarily from the beginning.</p>
<p>See also <code><a href="std.posix.html#std.posix.realpathZ">realpathZ</a></code> and <code><a href="std.posix.html#std.posix.realpathW">realpathW</a></code>.</p>
<ul>
<li>On Windows, the result is encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.</li>
<li>On other platforms, the result is an opaque sequence of bytes with no particular encoding.</li>
</ul>
<p>Calling this function is usually a bug.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.realpath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpath</span>(pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> pathname_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, pathname);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.realpathW">realpathW</a>(pathname_w.span(), out_buffer);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;WASI does not support os.realpath&quot;</span>);
    }
    <span class="tok-kw">const</span> pathname_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(pathname);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.realpathZ">realpathZ</a>(&amp;pathname_c, out_buffer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.realpathZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">realpathZ</span><a href="#src.zig-std.posix.realpathZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathZ</span>(pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.realpath">realpath</a></code> except <code>pathname</code> is null-terminated.</p>
<p>Calling this function is usually a bug.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.realpathZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathZ</span>(pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> pathname_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, pathname);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.realpathW">realpathW</a>(pathname_w.span(), out_buffer);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.realpath">realpath</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(pathname, <span class="tok-number">0</span>), out_buffer);
    }
    <span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> flags: <a href="std.posix.html#std.posix.O">O</a> = <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
            .linux =&gt; .{
                .NONBLOCK = <span class="tok-null">true</span>,
                .CLOEXEC = <span class="tok-null">true</span>,
                .PATH = <span class="tok-null">true</span>,
            },
            <span class="tok-kw">else</span> =&gt; .{
                .NONBLOCK = <span class="tok-null">true</span>,
                .CLOEXEC = <span class="tok-null">true</span>,
            },
        };
        <span class="tok-kw">const</span> fd = <a href="std.posix.html#std.posix.openZ">openZ</a>(pathname, flags, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not asking for write permissions
            </span><span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // WASI-only
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        <span class="tok-kw">defer</span> <a href="std.posix.html#std.posix.close">close</a>(fd);

        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.getFdPath">getFdPath</a>(fd, out_buffer);
    }
    <span class="tok-kw">const</span> result_path = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.realpath">realpath</a>(pathname, out_buffer) <span class="tok-kw">orelse</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.posix.html#std.posix.E">E</a>, <span class="tok-builtin">@enumFromInt</span>(<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c._errno">_errno</a>().*))) {
        .SUCCESS =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotSupported,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    };
    <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(result_path, <span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.realpathW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">realpathW</span><a href="#src.zig-std.posix.realpathW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathW</span>(pathname: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.realpath">realpath</a></code> except <code>pathname</code> is WTF16LE-encoded.</p>
<p>The result is encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.</p>
<p>Calling this function is usually a bug.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>pathname: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.realpathW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathW</span>(pathname: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> w = <a href="std.os.windows.html">windows</a>;

    <span class="tok-kw">const</span> dir = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().fd;
    <span class="tok-kw">const</span> access_mask = w.GENERIC_READ | w.SYNCHRONIZE;
    <span class="tok-kw">const</span> share_access = w.FILE_SHARE_READ | w.FILE_SHARE_WRITE | w.FILE_SHARE_DELETE;
    <span class="tok-kw">const</span> creation = w.FILE_OPEN;
    <span class="tok-kw">const</span> h_file = blk: {
        <span class="tok-kw">const</span> res = w.OpenFile(pathname, .{
            .dir = dir,
            .access_mask = access_mask,
            .share_access = share_access,
            .creation = creation,
            .filter = .any,
        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        <span class="tok-kw">break</span> :blk res;
    };
    <span class="tok-kw">defer</span> w.CloseHandle(h_file);

    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.getFdPath">getFdPath</a>(h_file, out_buffer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.nanosleep" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">nanosleep</span><a href="#src.zig-std.posix.nanosleep">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nanosleep</span>(seconds: <span class="tok-type">u64</span>, nanoseconds: <span class="tok-type">u64</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Spurious wakeups are possible and no precision of timing is guaranteed.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>seconds: <span class="tok-type">u64</span></code></pre></div><div><pre><code>nanoseconds: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.nanosleep">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nanosleep</span>(seconds: <span class="tok-type">u64</span>, nanoseconds: <span class="tok-type">u64</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> req = <a href="std.posix.html#std.posix.timespec">timespec</a>{
        .sec = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">isize</span>, seconds) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">isize</span>),
        .nsec = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">isize</span>, nanoseconds) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">isize</span>),
    };
    <span class="tok-kw">var</span> rem: <a href="std.posix.html#std.posix.timespec">timespec</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">nanosleep</a>(&amp;req, &amp;rem))) {
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; {<span class="tok-comment">
                // Sometimes Darwin returns EINVAL for no reason.
                // We treat it as a spurious wakeup.
                </span><span class="tok-kw">return</span>;
            },
            .INTR =&gt; {
                req = rem;
                <span class="tok-kw">continue</span>;
            },<span class="tok-comment">
            // This prong handles success as well as unexpected errors.
            </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span>,
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.dl_iterate_phdr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dl_iterate_phdr</span><a href="#src.zig-std.posix.dl_iterate_phdr">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dl_iterate_phdr</span>( context: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> Error: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> callback: <span class="tok-kw">fn</span> (info: *<a href="std.posix.html#std.posix.dl_phdr_info">dl_phdr_info</a>, size: <span class="tok-type">usize</span>, context: <span class="tok-builtin">@TypeOf</span>(context)) Error!<span class="tok-type">void</span>, ) Error!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>Error: <span class="tok-type">type</span></code></pre></div><div><pre><code>callback: <span class="tok-kw">fn</span> (info: *<a href="std.posix.html#std.posix.dl_phdr_info">dl_phdr_info</a>, size: <span class="tok-type">usize</span>, context: <span class="tok-builtin">@TypeOf</span>(context)) Error!<span class="tok-type">void</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.dl_iterate_phdr">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dl_iterate_phdr</span>(
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> Error: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> callback: <span class="tok-kw">fn</span> (info: *<a href="std.posix.html#std.posix.dl_phdr_info">dl_phdr_info</a>, size: <span class="tok-type">usize</span>, context: <span class="tok-builtin">@TypeOf</span>(context)) Error!<span class="tok-type">void</span>,
) Error!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> Context = <span class="tok-builtin">@TypeOf</span>(context);
    <span class="tok-kw">const</span> elf = <a href="std.html">std</a>.<a href="std.elf.html">elf</a>;
    <span class="tok-kw">const</span> dl = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dynamic_library.zig&quot;</span>);

    <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.object_format">object_format</a>) {
        .elf, .c =&gt; {},
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;dl_iterate_phdr is not available for this target&quot;</span>),
    }

    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.system">system</a>.<a href="#">dl_iterate_phdr</a>(<span class="tok-kw">struct</span> {
            <span class="tok-kw">fn</span> <span class="tok-fn">callbackC</span>(info: *<a href="std.posix.html#std.posix.dl_phdr_info">dl_phdr_info</a>, size: <span class="tok-type">usize</span>, data: ?*<span class="tok-type">anyopaque</span>) <span class="tok-kw">callconv</span>(.c) <span class="tok-type">c_int</span> {
                <span class="tok-kw">const</span> context_ptr: *<span class="tok-kw">const</span> Context = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(data));
                callback(info, size, context_ptr.*) <span class="tok-kw">catch</span> |err| <span class="tok-kw">return</span> <span class="tok-builtin">@intFromError</span>(err);
                <span class="tok-kw">return</span> <span class="tok-number">0</span>;
            }
        }.callbackC, <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@constCast</span>(&amp;context)))) {
            <span class="tok-number">0</span> =&gt; <span class="tok-kw">return</span>,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(Error, <span class="tok-builtin">@errorCast</span>(<span class="tok-builtin">@errorFromInt</span>(<span class="tok-builtin">@as</span>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">anyerror</span>)), <span class="tok-builtin">@intCast</span>(err))))),
        }
    }

    <span class="tok-kw">const</span> elf_base = <a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.html#std.process.getBaseAddress">getBaseAddress</a>();
    <span class="tok-kw">const</span> ehdr: *elf.Ehdr = <span class="tok-builtin">@ptrFromInt</span>(elf_base);<span class="tok-comment">
    // Make sure the base address points to an ELF image.
    </span><a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, ehdr.e_ident[<span class="tok-number">0</span>..<span class="tok-number">4</span>], elf.MAGIC));
    <span class="tok-kw">const</span> n_phdr = ehdr.e_phnum;
    <span class="tok-kw">const</span> phdrs = (<span class="tok-builtin">@as</span>([*]elf.Phdr, <span class="tok-builtin">@ptrFromInt</span>(elf_base + ehdr.e_phoff)))[<span class="tok-number">0</span>..n_phdr];

    <span class="tok-kw">var</span> it = dl.linkmap_iterator(phdrs) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;<span class="tok-comment">

    // The executable has no dynamic link segment, create a single entry for
    // the whole ELF image.
    </span><span class="tok-kw">if</span> (it.end()) {<span class="tok-comment">
        // Find the base address for the ELF image, if this is a PIE the value
        // is non-zero.
        </span><span class="tok-kw">const</span> base_address = <span class="tok-kw">for</span> (phdrs) |*phdr| {
            <span class="tok-kw">if</span> (phdr.p_type == elf.PT_PHDR) {
                <span class="tok-kw">break</span> <span class="tok-builtin">@intFromPtr</span>(phdrs.ptr) - phdr.p_vaddr;<span class="tok-comment">
                // We could try computing the difference between _DYNAMIC and
                // the p_vaddr of the PT_DYNAMIC section, but using the phdr is
                // good enough (Is it?).
            </span>}
        } <span class="tok-kw">else</span> <span class="tok-kw">unreachable</span>;

        <span class="tok-kw">var</span> info = <a href="std.posix.html#std.posix.dl_phdr_info">dl_phdr_info</a>{
            .addr = base_address,
            .name = <span class="tok-str">&quot;/proc/self/exe&quot;</span>,
            .phdr = phdrs.ptr,
            .phnum = ehdr.e_phnum,
        };

        <span class="tok-kw">return</span> callback(&amp;info, <span class="tok-builtin">@sizeOf</span>(<a href="std.posix.html#std.posix.dl_phdr_info">dl_phdr_info</a>), context);
    }<span class="tok-comment">

    // Last return value from the callback function.
    </span><span class="tok-kw">while</span> (it.next()) |entry| {
        <span class="tok-kw">var</span> phdr: [*]elf.Phdr = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> phnum: <span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;

        <span class="tok-kw">if</span> (entry.l_addr != <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> elf_header: *elf.Ehdr = <span class="tok-builtin">@ptrFromInt</span>(entry.l_addr);
            phdr = <span class="tok-builtin">@ptrFromInt</span>(entry.l_addr + elf_header.e_phoff);
            phnum = elf_header.e_phnum;
        } <span class="tok-kw">else</span> {<span class="tok-comment">
            // This is the running ELF image
            </span>phdr = <span class="tok-builtin">@ptrFromInt</span>(elf_base + ehdr.e_phoff);
            phnum = ehdr.e_phnum;
        }

        <span class="tok-kw">var</span> info = <a href="std.posix.html#std.posix.dl_phdr_info">dl_phdr_info</a>{
            .addr = entry.l_addr,
            .name = entry.l_name,
            .phdr = phdr,
            .phnum = phnum,
        };

        <span class="tok-kw">try</span> callback(&amp;info, <span class="tok-builtin">@sizeOf</span>(<a href="std.posix.html#std.posix.dl_phdr_info">dl_phdr_info</a>), context);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.clock_gettime" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clock_gettime</span><a href="#src.zig-std.posix.clock_gettime">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clock_gettime</span>(clock_id: <a href="std.posix.html#std.posix.clockid_t">clockid_t</a>) <a href="std.posix.html#std.posix.ClockGetTimeError">ClockGetTimeError</a>!<a href="std.posix.html#std.posix.timespec">timespec</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>clock_id: <a href="std.posix.html#std.posix.clockid_t">clockid_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.clock_gettime">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clock_gettime</span>(clock_id: <a href="std.posix.html#std.posix.clockid_t">clockid_t</a>) <a href="std.posix.html#std.posix.ClockGetTimeError">ClockGetTimeError</a>!<a href="std.posix.html#std.posix.timespec">timespec</a> {
    <span class="tok-kw">var</span> tp: <a href="std.posix.html#std.posix.timespec">timespec</a> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Windows does not support POSIX; use Windows-specific API or cross-platform std.time API&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> ts: <a href="std.posix.html#std.posix.timestamp_t">timestamp_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.system">system</a>.<a href="#">clock_time_get</a>(clock_id, <span class="tok-number">1</span>, &amp;ts)) {
            .SUCCESS =&gt; {
                tp = .{
                    .sec = <span class="tok-builtin">@intCast</span>(ts / <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a>),
                    .nsec = <span class="tok-builtin">@intCast</span>(ts % <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a>),
                };
            },
            .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedClock,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
        <span class="tok-kw">return</span> tp;
    }

    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">clock_gettime</a>(clock_id, &amp;tp))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> tp,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedClock,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.clock_getres" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clock_getres</span><a href="#src.zig-std.posix.clock_getres">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clock_getres</span>(clock_id: <a href="std.posix.html#std.posix.clockid_t">clockid_t</a>, res: *<a href="std.posix.html#std.posix.timespec">timespec</a>) <a href="std.posix.html#std.posix.ClockGetTimeError">ClockGetTimeError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>clock_id: <a href="std.posix.html#std.posix.clockid_t">clockid_t</a></code></pre></div><div><pre><code>res: *<a href="std.posix.html#std.posix.timespec">timespec</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.clock_getres">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clock_getres</span>(clock_id: <a href="std.posix.html#std.posix.clockid_t">clockid_t</a>, res: *<a href="std.posix.html#std.posix.timespec">timespec</a>) <a href="std.posix.html#std.posix.ClockGetTimeError">ClockGetTimeError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> ts: <a href="std.posix.html#std.posix.timestamp_t">timestamp_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.system">system</a>.<a href="#">clock_res_get</a>(<span class="tok-builtin">@bitCast</span>(clock_id), &amp;ts)) {
            .SUCCESS =&gt; res.* = .{
                .sec = <span class="tok-builtin">@intCast</span>(ts / <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a>),
                .nsec = <span class="tok-builtin">@intCast</span>(ts % <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a>),
            },
            .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedClock,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">clock_getres</a>(clock_id, res))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedClock,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.sched_getaffinity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sched_getaffinity</span><a href="#src.zig-std.posix.sched_getaffinity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sched_getaffinity</span>(pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>) <a href="std.posix.html#std.posix.SchedGetAffinityError">SchedGetAffinityError</a>!<a href="std.posix.html#std.posix.cpu_set_t">cpu_set_t</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.sched_getaffinity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sched_getaffinity</span>(pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>) <a href="std.posix.html#std.posix.SchedGetAffinityError">SchedGetAffinityError</a>!<a href="std.posix.html#std.posix.cpu_set_t">cpu_set_t</a> {
    <span class="tok-kw">var</span> set: <a href="std.posix.html#std.posix.cpu_set_t">cpu_set_t</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">sched_getaffinity</a>(pid, <span class="tok-builtin">@sizeOf</span>(<a href="std.posix.html#std.posix.cpu_set_t">cpu_set_t</a>), &amp;set))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> set,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .SRCH =&gt; <span class="tok-kw">unreachable</span>,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.sigaltstack" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sigaltstack</span><a href="#src.zig-std.posix.sigaltstack">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sigaltstack</span>(ss: ?*<a href="std.posix.html#std.posix.stack_t">stack_t</a>, old_ss: ?*<a href="std.posix.html#std.posix.stack_t">stack_t</a>) <a href="std.posix.html#std.posix.SigaltstackError">SigaltstackError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>ss: ?*<a href="std.posix.html#std.posix.stack_t">stack_t</a></code></pre></div><div><pre><code>old_ss: ?*<a href="std.posix.html#std.posix.stack_t">stack_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.sigaltstack">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sigaltstack</span>(ss: ?*<a href="std.posix.html#std.posix.stack_t">stack_t</a>, old_ss: ?*<a href="std.posix.html#std.posix.stack_t">stack_t</a>) <a href="std.posix.html#std.posix.SigaltstackError">SigaltstackError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">sigaltstack</a>(ss, old_ss))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SizeTooSmall,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.sigaction" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sigaction</span><a href="#src.zig-std.posix.sigaction">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sigaction</span>(sig: <span class="tok-type">u6</span>, <span class="tok-kw">noalias</span> act: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.Sigaction">Sigaction</a>, <span class="tok-kw">noalias</span> oact: ?*<a href="std.posix.html#std.posix.Sigaction">Sigaction</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Examine and change a signal action.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>sig: <span class="tok-type">u6</span></code></pre></div><div><pre><code>act: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.Sigaction">Sigaction</a></code></pre></div><div><pre><code>oact: ?*<a href="std.posix.html#std.posix.Sigaction">Sigaction</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.sigaction">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sigaction</span>(sig: <span class="tok-type">u6</span>, <span class="tok-kw">noalias</span> act: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.Sigaction">Sigaction</a>, <span class="tok-kw">noalias</span> oact: ?*<a href="std.posix.html#std.posix.Sigaction">Sigaction</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">sigaction</a>(sig, act, oact))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,<span class="tok-comment">
        // EINVAL means the signal is either invalid or some signal that cannot have its action
        // changed. For POSIX, this means SIGKILL/SIGSTOP. For e.g. Solaris, this also includes the
        // non-standard SIGWAITING, SIGCANCEL, and SIGLWP. Either way, programmer error.
        </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.sigprocmask" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sigprocmask</span><a href="#src.zig-std.posix.sigprocmask">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sigprocmask</span>(flags: <span class="tok-type">u32</span>, <span class="tok-kw">noalias</span> set: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sigset_t">sigset_t</a>, <span class="tok-kw">noalias</span> oldset: ?*<a href="std.posix.html#std.posix.sigset_t">sigset_t</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sets the thread signal mask.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div><div><pre><code>set: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sigset_t">sigset_t</a></code></pre></div><div><pre><code>oldset: ?*<a href="std.posix.html#std.posix.sigset_t">sigset_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.sigprocmask">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sigprocmask</span>(flags: <span class="tok-type">u32</span>, <span class="tok-kw">noalias</span> set: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sigset_t">sigset_t</a>, <span class="tok-kw">noalias</span> oldset: ?*<a href="std.posix.html#std.posix.sigset_t">sigset_t</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">sigprocmask</a>(<span class="tok-builtin">@bitCast</span>(flags), set, oldset))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.futimens" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">futimens</span><a href="#src.zig-std.posix.futimens">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">futimens</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, times: ?*<span class="tok-kw">const</span> [<span class="tok-number">2</span>]<a href="std.posix.html#std.posix.timespec">timespec</a>) <a href="std.posix.html#std.posix.FutimensError">FutimensError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>times: ?*<span class="tok-kw">const</span> [<span class="tok-number">2</span>]<a href="std.posix.html#std.posix.timespec">timespec</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.futimens">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">futimens</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, times: ?*<span class="tok-kw">const</span> [<span class="tok-number">2</span>]<a href="std.posix.html#std.posix.timespec">timespec</a>) <a href="std.posix.html#std.posix.FutimensError">FutimensError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {<span class="tok-comment">
        // TODO WASI encodes `wasi.fstflags` to signify magic values
        // similar to UTIME_NOW and UTIME_OMIT. Currently, we ignore
        // this here, but we should really handle it somehow.
        </span><span class="tok-kw">const</span> error_code = blk: {
            <span class="tok-kw">if</span> (times) |times_arr| {
                <span class="tok-kw">const</span> atim = times_arr[<span class="tok-number">0</span>].toTimestamp();
                <span class="tok-kw">const</span> mtim = times_arr[<span class="tok-number">1</span>].toTimestamp();
                <span class="tok-kw">break</span> :blk <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_filestat_set_times">fd_filestat_set_times</a>(fd, atim, mtim, .{
                    .ATIM = <span class="tok-null">true</span>,
                    .MTIM = <span class="tok-null">true</span>,
                });
            }

            <span class="tok-kw">break</span> :blk <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_filestat_set_times">fd_filestat_set_times</a>(fd, <span class="tok-number">0</span>, <span class="tok-number">0</span>, .{
                .ATIM_NOW = <span class="tok-null">true</span>,
                .MTIM_NOW = <span class="tok-null">true</span>,
            });
        };
        <span class="tok-kw">switch</span> (error_code) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">futimens</a>(fd, times))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
        </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.gethostname" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">gethostname</span><a href="#src.zig-std.posix.gethostname">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gethostname</span>(name_buffer: *[<a href="std.posix.html#std.posix.HOST_NAME_MAX">HOST_NAME_MAX</a>]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.GetHostNameError">GetHostNameError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>name_buffer: *[<a href="std.posix.html#std.posix.HOST_NAME_MAX">HOST_NAME_MAX</a>]<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.gethostname">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gethostname</span>(name_buffer: *[<a href="std.posix.html#std.posix.HOST_NAME_MAX">HOST_NAME_MAX</a>]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.GetHostNameError">GetHostNameError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">gethostname</a>(name_buffer, name_buffer.len))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(name_buffer, <span class="tok-number">0</span>),
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .NAMETOOLONG =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // HOST_NAME_MAX prevents this
            </span>.PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .linux) {
        <span class="tok-kw">const</span> uts = <a href="std.posix.html#std.posix.uname">uname</a>();
        <span class="tok-kw">const</span> hostname = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;uts.nodename, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> result = name_buffer[<span class="tok-number">0</span>..hostname.len];
        <span class="tok-builtin">@memcpy</span>(result, hostname);
        <span class="tok-kw">return</span> result;
    }

    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;TODO implement gethostname for this OS&quot;</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.uname" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">uname</span><a href="#src.zig-std.posix.uname">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">uname</span>() <a href="std.posix.html#std.posix.utsname">utsname</a></code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.uname">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">uname</span>() <a href="std.posix.html#std.posix.utsname">utsname</a> {
    <span class="tok-kw">var</span> uts: <a href="std.posix.html#std.posix.utsname">utsname</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">uname</a>(&amp;uts))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> uts,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.res_mkquery" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">res_mkquery</span><a href="#src.zig-std.posix.res_mkquery">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">res_mkquery</span>( op: <span class="tok-type">u4</span>, dname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, class: <span class="tok-type">u8</span>, ty: <span class="tok-type">u8</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, newrr: ?[*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buf: []<span class="tok-type">u8</span>, ) <span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>op: <span class="tok-type">u4</span></code></pre></div><div><pre><code>dname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>class: <span class="tok-type">u8</span></code></pre></div><div><pre><code>ty: <span class="tok-type">u8</span></code></pre></div><div><pre><code>data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>newrr: ?[*]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>buf: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.res_mkquery">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">res_mkquery</span>(
    op: <span class="tok-type">u4</span>,
    dname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    class: <span class="tok-type">u8</span>,
    ty: <span class="tok-type">u8</span>,
    data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    newrr: ?[*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    buf: []<span class="tok-type">u8</span>,
) <span class="tok-type">usize</span> {
    _ = data;
    _ = newrr;<span class="tok-comment">
    // This implementation is ported from musl libc.
    // A more idiomatic &quot;ziggy&quot; implementation would be welcome.
    </span><span class="tok-kw">var</span> name = dname;
    <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.endsWith">endsWith</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>)) name.len -= <span class="tok-number">1</span>;
    <a href="std.debug.html#std.debug.assert">assert</a>(name.len &lt;= <span class="tok-number">253</span>);
    <span class="tok-kw">const</span> n = <span class="tok-number">17</span> + name.len + <span class="tok-builtin">@intFromBool</span>(name.len != <span class="tok-number">0</span>);<span class="tok-comment">

    // Construct query template - ID will be filled later
    </span><span class="tok-kw">var</span> q: [<span class="tok-number">280</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-builtin">@memset</span>(q[<span class="tok-number">0</span>..n], <span class="tok-number">0</span>);
    q[<span class="tok-number">2</span>] = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, op) * <span class="tok-number">8</span> + <span class="tok-number">1</span>;
    q[<span class="tok-number">5</span>] = <span class="tok-number">1</span>;
    <span class="tok-builtin">@memcpy</span>(q[<span class="tok-number">13</span>..][<span class="tok-number">0</span>..name.len], name);
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">13</span>;
    <span class="tok-kw">var</span> j: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">while</span> (q[i] != <span class="tok-number">0</span>) : (i = j + <span class="tok-number">1</span>) {
        j = i;
        <span class="tok-kw">while</span> (q[j] != <span class="tok-number">0</span> <span class="tok-kw">and</span> q[j] != <span class="tok-str">'.'</span>) : (j += <span class="tok-number">1</span>) {}<span class="tok-comment">
        // TODO determine the circumstances for this and whether or
        // not this should be an error.
        </span><span class="tok-kw">if</span> (j - i - <span class="tok-number">1</span> &gt; <span class="tok-number">62</span>) <span class="tok-kw">unreachable</span>;
        q[i - <span class="tok-number">1</span>] = <span class="tok-builtin">@intCast</span>(j - i);
    }
    q[i + <span class="tok-number">1</span>] = ty;
    q[i + <span class="tok-number">3</span>] = class;<span class="tok-comment">

    // Make a reasonably unpredictable id
    </span><span class="tok-kw">const</span> ts = <a href="std.posix.html#std.posix.clock_gettime">clock_gettime</a>(.REALTIME) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">const</span> UInt = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-builtin">@TypeOf</span>(ts.nsec)));
    <span class="tok-kw">const</span> unsec: UInt = <span class="tok-builtin">@bitCast</span>(ts.nsec);
    <span class="tok-kw">const</span> id: <span class="tok-type">u32</span> = <span class="tok-builtin">@truncate</span>(unsec + unsec / <span class="tok-number">65536</span>);
    q[<span class="tok-number">0</span>] = <span class="tok-builtin">@truncate</span>(id / <span class="tok-number">256</span>);
    q[<span class="tok-number">1</span>] = <span class="tok-builtin">@truncate</span>(id);

    <span class="tok-builtin">@memcpy</span>(buf[<span class="tok-number">0</span>..n], q[<span class="tok-number">0</span>..n]);
    <span class="tok-kw">return</span> n;
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.sendmsg" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sendmsg</span><a href="#src.zig-std.posix.sendmsg">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sendmsg</span>( sockfd: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, msg: *<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.msghdr_const">msghdr_const</a>, flags: <span class="tok-type">u32</span>, ) <a href="std.posix.html#std.posix.SendMsgError">SendMsgError</a>!<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>sockfd: <a href="std.posix.html#std.posix.socket_t">socket_t</a></code></pre><div class="fieldDocs"><p>The file descriptor of the sending socket.</p>
</div></div><div><pre><code>msg: *<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.msghdr_const">msghdr_const</a></code></pre><div class="fieldDocs"><p>Message header and iovecs</p>
</div></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.sendmsg">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sendmsg</span>(
    <span class="tok-comment">/// The file descriptor of the sending socket.</span>
    sockfd: <a href="std.posix.html#std.posix.socket_t">socket_t</a>,
    <span class="tok-comment">/// Message header and iovecs</span>
    msg: *<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.msghdr_const">msghdr_const</a>,
    flags: <span class="tok-type">u32</span>,
) <a href="std.posix.html#std.posix.SendMsgError">SendMsgError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">sendmsg</a>(sockfd, msg, flags);
        <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
            <span class="tok-kw">if</span> (rc == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a>) {
                <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                    .WSAEACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                    .WSAEADDRNOTAVAIL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressNotAvailable,
                    .WSAECONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
                    .WSAEMSGSIZE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MessageTooBig,
                    .WSAENOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                    .WSAENOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
                    .WSAEAFNOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
                    .WSAEDESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // A destination address is required.
                    </span>.WSAEFAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The lpBuffers, lpTo, lpOverlapped, lpNumberOfBytesSent, or lpCompletionRoutine parameters are not part of the user address space, or the lpTo parameter is too small.
                    </span>.WSAEHOSTUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,<span class="tok-comment">
                    // TODO: WSAEINPROGRESS, WSAEINTR
                    </span>.WSAEINVAL =&gt; <span class="tok-kw">unreachable</span>,
                    .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                    .WSAENETRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
                    .WSAENETUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
                    .WSAENOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
                    .WSAESHUTDOWN =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The socket has been shut down; it is not possible to WSASendTo on a socket after shutdown has been invoked with how set to SD_SEND or SD_BOTH.
                    </span>.WSAEWOULDBLOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
                    .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // A successful WSAStartup call must occur before using this function.
                    </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
                }
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc);
            }
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),

                .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
                .ALREADY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FastOpenAlreadyInProgress,
                .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
                </span>.CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
                .DESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The socket is not connection-mode, and no peer address is set.
                </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // An invalid user space address was specified for an argument.
                </span>.INTR =&gt; <span class="tok-kw">continue</span>,
                .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid argument passed.
                </span>.ISCONN =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // connection-mode socket was connected already but a recipient was specified
                </span>.MSGSIZE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MessageTooBig,
                .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                .NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The file descriptor sockfd does not refer to a socket.
                </span>.OPNOTSUPP =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Some bit in the flags argument is inappropriate for the socket type.
                </span>.PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
                .AFNOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
                .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
                .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
                .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
                .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
                .HOSTUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
                .NETUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
                .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
                .NETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.sendto" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sendto</span><a href="#src.zig-std.posix.sendto">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sendto</span>( sockfd: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>, dest_addr: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sockaddr">sockaddr</a>, addrlen: <a href="std.posix.html#std.posix.socklen_t">socklen_t</a>, ) <a href="std.posix.html#std.posix.SendToError">SendToError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Transmit a message to another socket.</p>
<p>The <code><a href="std.posix.html#std.posix.sendto">sendto</a></code> call may be used only when the socket is in a connected state (so that the intended
recipient  is  known). The  following call</p>
<p>send(sockfd, buf, len, flags);</p>
<p>is equivalent to</p>
<p>sendto(sockfd, buf, len, flags, NULL, 0);</p>
<p>If  sendto()  is used on a connection-mode (<code>SOCK.STREAM</code>, <code>SOCK.SEQPACKET</code>) socket, the arguments
<code>dest_addr</code> and <code>addrlen</code> are asserted to be <code>null</code> and <code>0</code> respectively, and asserted
that the socket was actually connected.
Otherwise, the address of the target is given by <code>dest_addr</code> with <code>addrlen</code> specifying  its  size.</p>
<p>If the message is too long to pass atomically through the underlying protocol,
<code>SendError.MessageTooBig</code> is returned, and the message is not transmitted.</p>
<p>There is no  indication  of  failure  to  deliver.</p>
<p>When the message does not fit into the send buffer of  the  socket,  <code><a href="std.posix.html#std.posix.sendto">sendto</a></code>  normally  blocks,
unless  the socket has been placed in nonblocking I/O mode.  In nonblocking mode it would fail
with <code>SendError.WouldBlock</code>.  The <code>select</code> call may be used  to  determine when it is
possible to send more data.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>sockfd: <a href="std.posix.html#std.posix.socket_t">socket_t</a></code></pre><div class="fieldDocs"><p>The file descriptor of the sending socket.</p>
</div></div><div><pre><code>buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre><div class="fieldDocs"><p>Message to send.</p>
</div></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div><div><pre><code>dest_addr: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sockaddr">sockaddr</a></code></pre></div><div><pre><code>addrlen: <a href="std.posix.html#std.posix.socklen_t">socklen_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.sendto">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sendto</span>(
    <span class="tok-comment">/// The file descriptor of the sending socket.</span>
    sockfd: <a href="std.posix.html#std.posix.socket_t">socket_t</a>,
    <span class="tok-comment">/// Message to send.</span>
    buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <span class="tok-type">u32</span>,
    dest_addr: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sockaddr">sockaddr</a>,
    addrlen: <a href="std.posix.html#std.posix.socklen_t">socklen_t</a>,
) <a href="std.posix.html#std.posix.SendToError">SendToError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sendto">sendto</a>(sockfd, buf.ptr, buf.len, flags, dest_addr, addrlen)) {
            <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a> =&gt; <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                .WSAEACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                .WSAEADDRNOTAVAIL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressNotAvailable,
                .WSAECONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
                .WSAEMSGSIZE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MessageTooBig,
                .WSAENOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                .WSAENOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
                .WSAEAFNOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
                .WSAEDESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // A destination address is required.
                </span>.WSAEFAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The lpBuffers, lpTo, lpOverlapped, lpNumberOfBytesSent, or lpCompletionRoutine parameters are not part of the user address space, or the lpTo parameter is too small.
                </span>.WSAEHOSTUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,<span class="tok-comment">
                // TODO: WSAEINPROGRESS, WSAEINTR
                </span>.WSAEINVAL =&gt; <span class="tok-kw">unreachable</span>,
                .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                .WSAENETRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
                .WSAENETUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
                .WSAENOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
                .WSAESHUTDOWN =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The socket has been shut down; it is not possible to WSASendTo on a socket after shutdown has been invoked with how set to SD_SEND or SD_BOTH.
                </span>.WSAEWOULDBLOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
                .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // A successful WSAStartup call must occur before using this function.
                </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
            },
            <span class="tok-kw">else</span> =&gt; |rc| <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        }
    }
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">sendto</a>(sockfd, buf.ptr, buf.len, flags, dest_addr, addrlen);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),

            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .ALREADY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FastOpenAlreadyInProgress,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.CONNREFUSED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionRefused,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .DESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The socket is not connection-mode, and no peer address is set.
            </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // An invalid user space address was specified for an argument.
            </span>.INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnreachableAddress,
            .ISCONN =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // connection-mode socket was connected already but a recipient was specified
            </span>.MSGSIZE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MessageTooBig,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The file descriptor sockfd does not refer to a socket.
            </span>.OPNOTSUPP =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Some bit in the flags argument is inappropriate for the socket type.
            </span>.PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
            .AFNOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
            .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
            .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
            .HOSTUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
            .NETUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
            .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .NETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.send" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">send</span><a href="#src.zig-std.posix.send">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">send</span>( sockfd: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>, ) <a href="std.posix.html#std.posix.SendError">SendError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Transmit a message to another socket.</p>
<p>The <code><a href="std.posix.html#std.posix.send">send</a></code> call may be used only when the socket is in a connected state (so that the intended
recipient  is  known).   The  only  difference  between <code><a href="std.posix.html#std.posix.send">send</a></code> and <code><a href="std.posix.html#std.posix.write">write</a></code> is the presence of
flags.  With a zero flags argument, <code><a href="std.posix.html#std.posix.send">send</a></code> is equivalent to  <code><a href="std.posix.html#std.posix.write">write</a></code>.   Also,  the  following
call</p>
<p>send(sockfd, buf, len, flags);</p>
<p>is equivalent to</p>
<p>sendto(sockfd, buf, len, flags, NULL, 0);</p>
<p>There is no  indication  of  failure  to  deliver.</p>
<p>When the message does not fit into the send buffer of  the  socket,  <code><a href="std.posix.html#std.posix.send">send</a></code>  normally  blocks,
unless  the socket has been placed in nonblocking I/O mode.  In nonblocking mode it would fail
with <code>SendError.WouldBlock</code>.  The <code>select</code> call may be used  to  determine when it is
possible to send more data.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>sockfd: <a href="std.posix.html#std.posix.socket_t">socket_t</a></code></pre><div class="fieldDocs"><p>The file descriptor of the sending socket.</p>
</div></div><div><pre><code>buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.send">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">send</span>(
    <span class="tok-comment">/// The file descriptor of the sending socket.</span>
    sockfd: <a href="std.posix.html#std.posix.socket_t">socket_t</a>,
    buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <span class="tok-type">u32</span>,
) <a href="std.posix.html#std.posix.SendError">SendError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.sendto">sendto</a>(sockfd, buf, flags, <span class="tok-null">null</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.AddressFamilyNotSupported =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.SymLinkLoop =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.NotDir =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.NetworkUnreachable =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.AddressNotAvailable =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.SocketNotConnected =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.UnreachableAddress =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.ConnectionRefused =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.sendfile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sendfile</span><a href="#src.zig-std.posix.sendfile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sendfile</span>( out_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, in_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, in_offset: <span class="tok-type">u64</span>, in_len: <span class="tok-type">u64</span>, headers: []<span class="tok-kw">const</span> <a href="std.posix.iovec_const.html">iovec_const</a>, trailers: []<span class="tok-kw">const</span> <a href="std.posix.iovec_const.html">iovec_const</a>, flags: <span class="tok-type">u32</span>, ) <a href="std.posix.html#std.posix.SendFileError">SendFileError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Transfer data between file descriptors, with optional headers and trailers.</p>
<p>Returns the number of bytes written, which can be zero.</p>
<p>The <code><a href="std.posix.html#std.posix.sendfile">sendfile</a></code> call copies <code>in_len</code> bytes from one file descriptor to another. When possible,
this is done within the operating system kernel, which can provide better performance
characteristics than transferring data from kernel to user space and back, such as with
<code><a href="std.posix.html#std.posix.read">read</a></code> and <code><a href="std.posix.html#std.posix.write">write</a></code> calls. When <code>in_len</code> is <code>0</code>, it means to copy until the end of the input file has been
reached. Note, however, that partial writes are still possible in this case.</p>
<p><code>in_fd</code> must be a file descriptor opened for reading, and <code>out_fd</code> must be a file descriptor
opened for writing. They may be any kind of file descriptor; however, if <code>in_fd</code> is not a regular
file system file, it may cause this function to fall back to calling <code><a href="std.posix.html#std.posix.read">read</a></code> and <code><a href="std.posix.html#std.posix.write">write</a></code>, in which case
atomicity guarantees no longer apply.</p>
<p>Copying begins reading at <code>in_offset</code>. The input file descriptor seek position is ignored and not updated.
If the output file descriptor has a seek position, it is updated as bytes are written. When
<code>in_offset</code> is past the end of the input file, it successfully reads 0 bytes.</p>
<p><code>flags</code> has different meanings per operating system; refer to the respective man pages.</p>
<p>These systems support atomically sending everything, including headers and trailers:</p>
<ul>
<li>macOS</li>
<li>FreeBSD</li>
</ul>
<p>These systems support in-kernel data copying, but headers and trailers are not sent atomically:</p>
<ul>
<li>Linux</li>
</ul>
<p>Other systems fall back to calling <code><a href="std.posix.html#std.posix.read">read</a></code> / <code><a href="std.posix.html#std.posix.write">write</a></code>.</p>
<p>Linux has a limit on how many bytes may be transferred in one <code><a href="std.posix.html#std.posix.sendfile">sendfile</a></code> call, which is <code>0x7ffff000</code>
on both 64-bit and 32-bit systems. This is due to using a signed C int as the return value, as
well as stuffing the errno codes into the last <code>4096</code> values. This is noted on the <code><a href="std.posix.html#std.posix.sendfile">sendfile</a></code> man page.
The limit on Darwin is <code>0x7fffffff</code>, trying to write more than that returns EINVAL.
The corresponding POSIX limit on this is <code>maxInt(isize)</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>out_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>in_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>in_offset: <span class="tok-type">u64</span></code></pre></div><div><pre><code>in_len: <span class="tok-type">u64</span></code></pre></div><div><pre><code>headers: []<span class="tok-kw">const</span> <a href="std.posix.iovec_const.html">iovec_const</a></code></pre></div><div><pre><code>trailers: []<span class="tok-kw">const</span> <a href="std.posix.iovec_const.html">iovec_const</a></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.sendfile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sendfile</span>(
    out_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    in_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    in_offset: <span class="tok-type">u64</span>,
    in_len: <span class="tok-type">u64</span>,
    headers: []<span class="tok-kw">const</span> <a href="std.posix.iovec_const.html">iovec_const</a>,
    trailers: []<span class="tok-kw">const</span> <a href="std.posix.iovec_const.html">iovec_const</a>,
    flags: <span class="tok-type">u32</span>,
) <a href="std.posix.html#std.posix.SendFileError">SendFileError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> header_done = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> total_written: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;<span class="tok-comment">

    // Prevents EOVERFLOW.
    </span><span class="tok-kw">const</span> size_t = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <span class="tok-builtin">@typeInfo</span>(<span class="tok-type">usize</span>).int.bits - <span class="tok-number">1</span>);
    <span class="tok-kw">const</span> max_count = <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .linux =&gt; <span class="tok-number">0x7ffff000</span>,
        .macos, .ios, .watchos, .tvos, .visionos =&gt; <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">i32</span>),
        <span class="tok-kw">else</span> =&gt; <a href="std.math.html#std.math.maxInt">maxInt</a>(size_t),
    };

    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .linux =&gt; sf: {
            <span class="tok-kw">if</span> (headers.len != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.writev">writev</a>(out_fd, headers);
                total_written += amt;
                <span class="tok-kw">if</span> (amt &lt; <a href="std.posix.html#std.posix.count_iovec_bytes">count_iovec_bytes</a>(headers)) <span class="tok-kw">return</span> total_written;
                header_done = <span class="tok-null">true</span>;
            }<span class="tok-comment">

            // Here we match BSD behavior, making a zero count value send as many bytes as possible.
            </span><span class="tok-kw">const</span> adjusted_count = <span class="tok-kw">if</span> (in_len == <span class="tok-number">0</span>) max_count <span class="tok-kw">else</span> <span class="tok-builtin">@min</span>(in_len, max_count);

            <span class="tok-kw">const</span> sendfile_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">sendfile64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">sendfile</a>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">var</span> offset: <a href="std.posix.html#std.posix.off_t">off_t</a> = <span class="tok-builtin">@bitCast</span>(in_offset);
                <span class="tok-kw">const</span> rc = sendfile_sym(out_fd, in_fd, &amp;offset, adjusted_count);
                <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                    .SUCCESS =&gt; {
                        <span class="tok-kw">const</span> amt: <span class="tok-type">usize</span> = <span class="tok-builtin">@bitCast</span>(rc);
                        total_written += amt;
                        <span class="tok-kw">if</span> (in_len == <span class="tok-number">0</span> <span class="tok-kw">and</span> amt == <span class="tok-number">0</span>) {<span class="tok-comment">
                            // We have detected EOF from `in_fd`.
                            </span><span class="tok-kw">break</span>;
                        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (amt &lt; in_len) {
                            <span class="tok-kw">return</span> total_written;
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">break</span>;
                        }
                    },

                    .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition.
                    </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Segmentation fault.
                    </span>.OVERFLOW =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // We avoid passing too large of a `count`.
                    </span>.NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,<span class="tok-comment"> // `out_fd` is an unconnected socket

                    </span>.INVAL =&gt; {<span class="tok-comment">
                        // EINVAL could be any of the following situations:
                        // * Descriptor is not valid or locked
                        // * an mmap(2)-like operation is  not  available  for in_fd
                        // * count is negative
                        // * out_fd has the APPEND flag set
                        // Because of the &quot;mmap(2)-like operation&quot; possibility, we fall back to doing read/write
                        // manually.
                        </span><span class="tok-kw">break</span> :sf;
                    },
                    .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
                    .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
                    .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
                    .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                    .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
                    .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
                    <span class="tok-kw">else</span> =&gt; |err| {
                        <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err) <span class="tok-kw">catch</span> {};
                        <span class="tok-kw">break</span> :sf;
                    },
                }
            }

            <span class="tok-kw">if</span> (trailers.len != <span class="tok-number">0</span>) {
                total_written += <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.writev">writev</a>(out_fd, trailers);
            }

            <span class="tok-kw">return</span> total_written;
        },
        .freebsd =&gt; sf: {
            <span class="tok-kw">var</span> hdtr_data: <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.sf_hdtr">sf_hdtr</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">var</span> hdtr: ?*<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.sf_hdtr">sf_hdtr</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (headers.len != <span class="tok-number">0</span> <span class="tok-kw">or</span> trailers.len != <span class="tok-number">0</span>) {<span class="tok-comment">
                // Here we carefully avoid `@intCast` by returning partial writes when
                // too many io vectors are provided.
                </span><span class="tok-kw">const</span> hdr_cnt = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u31</span>, headers.len) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u31</span>);
                <span class="tok-kw">if</span> (headers.len &gt; hdr_cnt) <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.writev">writev</a>(out_fd, headers);

                <span class="tok-kw">const</span> trl_cnt = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u31</span>, trailers.len) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u31</span>);

                hdtr_data = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.sf_hdtr">sf_hdtr</a>{
                    .headers = headers.ptr,
                    .hdr_cnt = hdr_cnt,
                    .trailers = trailers.ptr,
                    .trl_cnt = trl_cnt,
                };
                hdtr = &amp;hdtr_data;
            }

            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">var</span> sbytes: <a href="std.posix.html#std.posix.off_t">off_t</a> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">const</span> err = <a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">sendfile</a>(in_fd, out_fd, <span class="tok-builtin">@bitCast</span>(in_offset), <span class="tok-builtin">@min</span>(in_len, max_count), hdtr, &amp;sbytes, flags));
                <span class="tok-kw">const</span> amt: <span class="tok-type">usize</span> = <span class="tok-builtin">@bitCast</span>(sbytes);
                <span class="tok-kw">switch</span> (err) {
                    .SUCCESS =&gt; <span class="tok-kw">return</span> amt,

                    .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition.
                    </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Segmentation fault.
                    </span>.NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,<span class="tok-comment"> // `out_fd` is an unconnected socket

                    </span>.INVAL, .OPNOTSUPP, .NOTSOCK, .NOSYS =&gt; {<span class="tok-comment">
                        // EINVAL could be any of the following situations:
                        // * The fd argument is not a regular file.
                        // * The s argument is not a SOCK.STREAM type socket.
                        // * The offset argument is negative.
                        // Because of some of these possibilities, we fall back to doing read/write
                        // manually, the same as ENOSYS.
                        </span><span class="tok-kw">break</span> :sf;
                    },

                    .INTR =&gt; <span class="tok-kw">if</span> (amt != <span class="tok-number">0</span>) <span class="tok-kw">return</span> amt <span class="tok-kw">else</span> <span class="tok-kw">continue</span>,

                    .AGAIN =&gt; <span class="tok-kw">if</span> (amt != <span class="tok-number">0</span>) {
                        <span class="tok-kw">return</span> amt;
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock;
                    },

                    .BUSY =&gt; <span class="tok-kw">if</span> (amt != <span class="tok-number">0</span>) {
                        <span class="tok-kw">return</span> amt;
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock;
                    },

                    .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
                    .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                    .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,

                    <span class="tok-kw">else</span> =&gt; {
                        <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err) <span class="tok-kw">catch</span> {};
                        <span class="tok-kw">if</span> (amt != <span class="tok-number">0</span>) {
                            <span class="tok-kw">return</span> amt;
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">break</span> :sf;
                        }
                    },
                }
            }
        },
        .macos, .ios, .tvos, .watchos, .visionos =&gt; sf: {
            <span class="tok-kw">var</span> hdtr_data: <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.sf_hdtr">sf_hdtr</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">var</span> hdtr: ?*<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.sf_hdtr">sf_hdtr</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (headers.len != <span class="tok-number">0</span> <span class="tok-kw">or</span> trailers.len != <span class="tok-number">0</span>) {<span class="tok-comment">
                // Here we carefully avoid `@intCast` by returning partial writes when
                // too many io vectors are provided.
                </span><span class="tok-kw">const</span> hdr_cnt = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u31</span>, headers.len) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u31</span>);
                <span class="tok-kw">if</span> (headers.len &gt; hdr_cnt) <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.writev">writev</a>(out_fd, headers);

                <span class="tok-kw">const</span> trl_cnt = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u31</span>, trailers.len) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u31</span>);

                hdtr_data = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.sf_hdtr">sf_hdtr</a>{
                    .headers = headers.ptr,
                    .hdr_cnt = hdr_cnt,
                    .trailers = trailers.ptr,
                    .trl_cnt = trl_cnt,
                };
                hdtr = &amp;hdtr_data;
            }

            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">var</span> sbytes: <a href="std.posix.html#std.posix.off_t">off_t</a> = <span class="tok-builtin">@min</span>(in_len, max_count);
                <span class="tok-kw">const</span> err = <a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">sendfile</a>(in_fd, out_fd, <span class="tok-builtin">@bitCast</span>(in_offset), &amp;sbytes, hdtr, flags));
                <span class="tok-kw">const</span> amt: <span class="tok-type">usize</span> = <span class="tok-builtin">@bitCast</span>(sbytes);
                <span class="tok-kw">switch</span> (err) {
                    .SUCCESS =&gt; <span class="tok-kw">return</span> amt,

                    .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition.
                    </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Segmentation fault.
                    </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,
                    .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,<span class="tok-comment"> // `out_fd` is an unconnected socket

                    </span>.OPNOTSUPP, .NOTSOCK, .NOSYS =&gt; <span class="tok-kw">break</span> :sf,

                    .INTR =&gt; <span class="tok-kw">if</span> (amt != <span class="tok-number">0</span>) <span class="tok-kw">return</span> amt <span class="tok-kw">else</span> <span class="tok-kw">continue</span>,

                    .AGAIN =&gt; <span class="tok-kw">if</span> (amt != <span class="tok-number">0</span>) {
                        <span class="tok-kw">return</span> amt;
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock;
                    },

                    .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
                    .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,

                    <span class="tok-kw">else</span> =&gt; {
                        <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err) <span class="tok-kw">catch</span> {};
                        <span class="tok-kw">if</span> (amt != <span class="tok-number">0</span>) {
                            <span class="tok-kw">return</span> amt;
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">break</span> :sf;
                        }
                    },
                }
            }
        },
        <span class="tok-kw">else</span> =&gt; {},<span class="tok-comment"> // fall back to read/write
    </span>}

    <span class="tok-kw">if</span> (headers.len != <span class="tok-number">0</span> <span class="tok-kw">and</span> !header_done) {
        <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.writev">writev</a>(out_fd, headers);
        total_written += amt;
        <span class="tok-kw">if</span> (amt &lt; <a href="std.posix.html#std.posix.count_iovec_bytes">count_iovec_bytes</a>(headers)) <span class="tok-kw">return</span> total_written;
    }

    rw: {
        <span class="tok-kw">var</span> buf: [<span class="tok-number">8</span> * <span class="tok-number">4096</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">
        // Here we match BSD behavior, making a zero count value send as many bytes as possible.
        </span><span class="tok-kw">const</span> adjusted_count = <span class="tok-kw">if</span> (in_len == <span class="tok-number">0</span>) buf.len <span class="tok-kw">else</span> <span class="tok-builtin">@min</span>(buf.len, in_len);
        <span class="tok-kw">const</span> amt_read = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.pread">pread</a>(in_fd, buf[<span class="tok-number">0</span>..adjusted_count], in_offset);
        <span class="tok-kw">if</span> (amt_read == <span class="tok-number">0</span>) {
            <span class="tok-kw">if</span> (in_len == <span class="tok-number">0</span>) {<span class="tok-comment">
                // We have detected EOF from `in_fd`.
                </span><span class="tok-kw">break</span> :rw;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> total_written;
            }
        }
        <span class="tok-kw">const</span> amt_written = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.write">write</a>(out_fd, buf[<span class="tok-number">0</span>..amt_read]);
        total_written += amt_written;
        <span class="tok-kw">if</span> (amt_written &lt; in_len <span class="tok-kw">or</span> in_len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> total_written;
    }

    <span class="tok-kw">if</span> (trailers.len != <span class="tok-number">0</span>) {
        total_written += <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.writev">writev</a>(out_fd, trailers);
    }

    <span class="tok-kw">return</span> total_written;
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.copy_file_range" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">copy_file_range</span><a href="#src.zig-std.posix.copy_file_range">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copy_file_range</span>(fd_in: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, off_in: <span class="tok-type">u64</span>, fd_out: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, off_out: <span class="tok-type">u64</span>, len: <span class="tok-type">usize</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.CopyFileRangeError">CopyFileRangeError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Transfer data between file descriptors at specified offsets.</p>
<p>Returns the number of bytes written, which can less than requested.</p>
<p>The <code><a href="std.posix.html#std.posix.copy_file_range">copy_file_range</a></code> call copies <code>len</code> bytes from one file descriptor to another. When possible,
this is done within the operating system kernel, which can provide better performance
characteristics than transferring data from kernel to user space and back, such as with
<code><a href="std.posix.html#std.posix.pread">pread</a></code> and <code><a href="std.posix.html#std.posix.pwrite">pwrite</a></code> calls.</p>
<p><code>fd_in</code> must be a file descriptor opened for reading, and <code>fd_out</code> must be a file descriptor
opened for writing. They may be any kind of file descriptor; however, if <code>fd_in</code> is not a regular
file system file, it may cause this function to fall back to calling <code><a href="std.posix.html#std.posix.pread">pread</a></code> and <code><a href="std.posix.html#std.posix.pwrite">pwrite</a></code>, in which case
atomicity guarantees no longer apply.</p>
<p>If <code>fd_in</code> and <code>fd_out</code> are the same, source and target ranges must not overlap.
The file descriptor seek positions are ignored and not updated.
When <code>off_in</code> is past the end of the input file, it successfully reads 0 bytes.</p>
<p><code>flags</code> has different meanings per operating system; refer to the respective man pages.</p>
<p>These systems support in-kernel data copying:</p>
<ul>
<li>Linux (cross-filesystem from version 5.3)</li>
<li>FreeBSD 13.0</li>
</ul>
<p>Other systems fall back to calling <code><a href="std.posix.html#std.posix.pread">pread</a></code> / <code><a href="std.posix.html#std.posix.pwrite">pwrite</a></code>.</p>
<p>Maximum offsets on Linux and FreeBSD are <code>maxInt(i64)</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd_in: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>off_in: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd_out: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>off_out: <span class="tok-type">u64</span></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.copy_file_range">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copy_file_range</span>(fd_in: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, off_in: <span class="tok-type">u64</span>, fd_out: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, off_out: <span class="tok-type">u64</span>, len: <span class="tok-type">usize</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.CopyFileRangeError">CopyFileRangeError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> ((<span class="tok-kw">comptime</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">isAtLeast</a>(.freebsd, .{ .major = <span class="tok-number">13</span>, .minor = <span class="tok-number">0</span>, .patch = <span class="tok-number">0</span> }) <span class="tok-kw">orelse</span> <span class="tok-null">false</span>) <span class="tok-kw">or</span>
        (<span class="tok-kw">comptime</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .linux <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.versionCheck">versionCheck</a>(.{ .major = <span class="tok-number">2</span>, .minor = <span class="tok-number">27</span>, .patch = <span class="tok-number">0</span> })))
    {
        <span class="tok-kw">var</span> off_in_copy: <span class="tok-type">i64</span> = <span class="tok-builtin">@bitCast</span>(off_in);
        <span class="tok-kw">var</span> off_out_copy: <span class="tok-type">i64</span> = <span class="tok-builtin">@bitCast</span>(off_out);

        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">copy_file_range</a>(fd_in, &amp;off_in_copy, fd_out, &amp;off_out_copy, len, flags);
            <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .freebsd) {
                <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                    .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
                    .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FilesOpenedWithWrongFlags,
                    .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
                    .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
                    .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
                    .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
                    .INVAL =&gt; <span class="tok-kw">break</span>,<span class="tok-comment"> // these may not be regular files, try fallback
                    </span>.INTEGRITY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CorruptedData,
                    .INTR =&gt; <span class="tok-kw">continue</span>,
                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                }
            } <span class="tok-kw">else</span> {<span class="tok-comment"> // assume linux
                </span><span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                    .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
                    .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FilesOpenedWithWrongFlags,
                    .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
                    .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
                    .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
                    .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
                    .INVAL =&gt; <span class="tok-kw">break</span>,<span class="tok-comment"> // these may not be regular files, try fallback
                    </span>.NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
                    .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
                    .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
                    .TXTBSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SwapFile,
                    .XDEV =&gt; <span class="tok-kw">break</span>,<span class="tok-comment"> // support for cross-filesystem copy added in Linux 5.3, use fallback
                    </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                }
            }
        }
    }

    <span class="tok-kw">var</span> buf: [<span class="tok-number">8</span> * <span class="tok-number">4096</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> amt_read = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.pread">pread</a>(fd_in, buf[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(buf.len, len)], off_in);
    <span class="tok-kw">if</span> (amt_read == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.pwrite">pwrite</a>(fd_out, buf[<span class="tok-number">0</span>..amt_read], off_out);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.poll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">poll</span><a href="#src.zig-std.posix.poll">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">poll</span>(fds: []<a href="std.posix.html#std.posix.pollfd">pollfd</a>, timeout: <span class="tok-type">i32</span>) <a href="std.posix.html#std.posix.PollError">PollError</a>!<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fds: []<a href="std.posix.html#std.posix.pollfd">pollfd</a></code></pre></div><div><pre><code>timeout: <span class="tok-type">i32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.poll">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">poll</span>(fds: []<a href="std.posix.html#std.posix.pollfd">pollfd</a>, timeout: <span class="tok-type">i32</span>) <a href="std.posix.html#std.posix.PollError">PollError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.poll">poll</a>(fds.ptr, <span class="tok-builtin">@intCast</span>(fds.len), timeout)) {
            <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a> =&gt; <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,
                .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                .WSAENOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,<span class="tok-comment">
                // TODO: handle more errors
                </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
            },
            <span class="tok-kw">else</span> =&gt; |rc| <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        }
    }
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> fds_count = <a href="std.math.html#std.math.cast">cast</a>(<a href="std.posix.html#std.posix.nfds_t">nfds_t</a>, fds.len) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources;
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">poll</a>(fds.ptr, fds_count, timeout);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">unreachable</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.ppoll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ppoll</span><a href="#src.zig-std.posix.ppoll">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ppoll</span>(fds: []<a href="std.posix.html#std.posix.pollfd">pollfd</a>, timeout: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.timespec">timespec</a>, mask: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sigset_t">sigset_t</a>) <a href="std.posix.html#std.posix.PPollError">PPollError</a>!<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fds: []<a href="std.posix.html#std.posix.pollfd">pollfd</a></code></pre></div><div><pre><code>timeout: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.timespec">timespec</a></code></pre></div><div><pre><code>mask: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sigset_t">sigset_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.ppoll">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ppoll</span>(fds: []<a href="std.posix.html#std.posix.pollfd">pollfd</a>, timeout: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.timespec">timespec</a>, mask: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sigset_t">sigset_t</a>) <a href="std.posix.html#std.posix.PPollError">PPollError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> ts: <a href="std.posix.html#std.posix.timespec">timespec</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> ts_ptr: ?*<a href="std.posix.html#std.posix.timespec">timespec</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (timeout) |timeout_ns| {
        ts_ptr = &amp;ts;
        ts = timeout_ns.*;
    }
    <span class="tok-kw">const</span> fds_count = <a href="std.math.html#std.math.cast">cast</a>(<a href="std.posix.html#std.posix.nfds_t">nfds_t</a>, fds.len) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources;
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">ppoll</a>(fds.ptr, fds_count, ts_ptr, mask);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INTR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SignalInterrupt,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.recv" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">recv</span><a href="#src.zig-std.posix.recv">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">recv</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, buf: []<span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.RecvFromError">RecvFromError</a>!<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a></code></pre></div><div><pre><code>buf: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.recv">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">recv</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, buf: []<span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.RecvFromError">RecvFromError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.recvfrom">recvfrom</a>(sock, buf, flags, <span class="tok-null">null</span>, <span class="tok-null">null</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.recvfrom" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">recvfrom</span><a href="#src.zig-std.posix.recvfrom">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">recvfrom</span>( sockfd: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, buf: []<span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>, src_addr: ?*<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>, addrlen: ?*<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>, ) <a href="std.posix.html#std.posix.RecvFromError">RecvFromError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>If <code>sockfd</code> is opened in non blocking mode, the function will
return error.WouldBlock when EAGAIN is received.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>sockfd: <a href="std.posix.html#std.posix.socket_t">socket_t</a></code></pre></div><div><pre><code>buf: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div><div><pre><code>src_addr: ?*<a href="std.posix.html#std.posix.sockaddr">sockaddr</a></code></pre></div><div><pre><code>addrlen: ?*<a href="std.posix.html#std.posix.socklen_t">socklen_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.recvfrom">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">recvfrom</span>(
    sockfd: <a href="std.posix.html#std.posix.socket_t">socket_t</a>,
    buf: []<span class="tok-type">u8</span>,
    flags: <span class="tok-type">u32</span>,
    src_addr: ?*<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>,
    addrlen: ?*<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>,
) <a href="std.posix.html#std.posix.RecvFromError">RecvFromError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">recvfrom</a>(sockfd, buf.ptr, buf.len, flags, src_addr, addrlen);
        <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
            <span class="tok-kw">if</span> (rc == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a>) {
                <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                    .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,
                    .WSAECONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
                    .WSAEINVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotBound,
                    .WSAEMSGSIZE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MessageTooBig,
                    .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                    .WSAENOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
                    .WSAEWOULDBLOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
                    .WSAETIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,<span class="tok-comment">
                    // TODO: handle more errors
                    </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
                }
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc);
            }
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
                .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
                </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
                .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
                .NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,
                .INTR =&gt; <span class="tok-kw">continue</span>,
                .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
                .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                .CONNREFUSED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionRefused,
                .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
                .TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.dn_expand" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dn_expand</span><a href="#src.zig-std.posix.dn_expand">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dn_expand</span>( msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, comp_dn: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, exp_dn: []<span class="tok-type">u8</span>, ) <a href="std.posix.html#std.posix.DnExpandError">DnExpandError</a>!<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>comp_dn: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>exp_dn: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.dn_expand">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dn_expand</span>(
    msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    comp_dn: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    exp_dn: []<span class="tok-type">u8</span>,
) <a href="std.posix.html#std.posix.DnExpandError">DnExpandError</a>!<span class="tok-type">usize</span> {<span class="tok-comment">
    // This implementation is ported from musl libc.
    // A more idiomatic &quot;ziggy&quot; implementation would be welcome.
    </span><span class="tok-kw">var</span> p = comp_dn.ptr;
    <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>);
    <span class="tok-kw">const</span> end = msg.ptr + msg.len;
    <span class="tok-kw">if</span> (p == end <span class="tok-kw">or</span> exp_dn.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDnsPacket;
    <span class="tok-kw">var</span> dest = exp_dn.ptr;
    <span class="tok-kw">const</span> dend = dest + <span class="tok-builtin">@min</span>(exp_dn.len, <span class="tok-number">254</span>);<span class="tok-comment">
    // detect reference loop using an iteration counter
    </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; msg.len) : (i += <span class="tok-number">2</span>) {<span class="tok-comment">
        // loop invariants: p&lt;end, dest&lt;dend
        </span><span class="tok-kw">if</span> ((p[<span class="tok-number">0</span>] &amp; <span class="tok-number">0xc0</span>) != <span class="tok-number">0</span>) {
            <span class="tok-kw">if</span> (p + <span class="tok-number">1</span> == end) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDnsPacket;
            <span class="tok-kw">const</span> j = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, p[<span class="tok-number">0</span>] &amp; <span class="tok-number">0x3f</span>) &lt;&lt; <span class="tok-number">8</span> | p[<span class="tok-number">1</span>];
            <span class="tok-kw">if</span> (len == <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>)) len = <span class="tok-builtin">@intFromPtr</span>(p) + <span class="tok-number">2</span> - <span class="tok-builtin">@intFromPtr</span>(comp_dn.ptr);
            <span class="tok-kw">if</span> (j &gt;= msg.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDnsPacket;
            p = msg.ptr + j;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (p[<span class="tok-number">0</span>] != <span class="tok-number">0</span>) {
            <span class="tok-kw">if</span> (dest != exp_dn.ptr) {
                dest[<span class="tok-number">0</span>] = <span class="tok-str">'.'</span>;
                dest += <span class="tok-number">1</span>;
            }
            <span class="tok-kw">var</span> j = p[<span class="tok-number">0</span>];
            p += <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (j &gt;= <span class="tok-builtin">@intFromPtr</span>(end) - <span class="tok-builtin">@intFromPtr</span>(p) <span class="tok-kw">or</span> j &gt;= <span class="tok-builtin">@intFromPtr</span>(dend) - <span class="tok-builtin">@intFromPtr</span>(dest)) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDnsPacket;
            }
            <span class="tok-kw">while</span> (j != <span class="tok-number">0</span>) {
                j -= <span class="tok-number">1</span>;
                dest[<span class="tok-number">0</span>] = p[<span class="tok-number">0</span>];
                dest += <span class="tok-number">1</span>;
                p += <span class="tok-number">1</span>;
            }
        } <span class="tok-kw">else</span> {
            dest[<span class="tok-number">0</span>] = <span class="tok-number">0</span>;
            <span class="tok-kw">if</span> (len == <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>)) len = <span class="tok-builtin">@intFromPtr</span>(p) + <span class="tok-number">1</span> - <span class="tok-builtin">@intFromPtr</span>(comp_dn.ptr);
            <span class="tok-kw">return</span> len;
        }
    }
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDnsPacket;
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.setsockopt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setsockopt</span><a href="#src.zig-std.posix.setsockopt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setsockopt</span>(fd: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, level: <span class="tok-type">i32</span>, optname: <span class="tok-type">u32</span>, opt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.SetSockOptError">SetSockOptError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Set a socket's options.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.socket_t">socket_t</a></code></pre></div><div><pre><code>level: <span class="tok-type">i32</span></code></pre></div><div><pre><code>optname: <span class="tok-type">u32</span></code></pre></div><div><pre><code>opt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.setsockopt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setsockopt</span>(fd: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, level: <span class="tok-type">i32</span>, optname: <span class="tok-type">u32</span>, opt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.SetSockOptError">SetSockOptError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.setsockopt">setsockopt</a>(fd, level, <span class="tok-builtin">@intCast</span>(optname), opt.ptr, <span class="tok-builtin">@intCast</span>(opt.len));
        <span class="tok-kw">if</span> (rc == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a>) {
            <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,
                .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                .WSAEFAULT =&gt; <span class="tok-kw">unreachable</span>,
                .WSAENOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
                .WSAEINVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotBound,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
            }
        }
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">setsockopt</a>(fd, level, optname, opt.ptr, <span class="tok-builtin">@intCast</span>(opt.len)))) {
            .SUCCESS =&gt; {},
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .DOM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TimeoutTooBig,
            .ISCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AlreadyConnected,
            .NOPROTOOPT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidProtocolOption,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoDevice,
            .OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OperationNotSupported,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.memfd_createZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">memfd_createZ</span><a href="#src.zig-std.posix.memfd_createZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">memfd_createZ</span>(name: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.MemFdCreateError">MemFdCreateError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>name: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.memfd_createZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">memfd_createZ</span>(name: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.MemFdCreateError">MemFdCreateError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .linux =&gt; {<span class="tok-comment">
            // memfd_create is available only in glibc versions starting with 2.27.
            </span><span class="tok-kw">const</span> use_c = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.versionCheck">versionCheck</a>(.{ .major = <span class="tok-number">2</span>, .minor = <span class="tok-number">27</span>, .patch = <span class="tok-number">0</span> });
            <span class="tok-kw">const</span> sys = <span class="tok-kw">if</span> (use_c) <a href="std.html">std</a>.<a href="std.c.html">c</a> <span class="tok-kw">else</span> <a href="std.os.linux.html">linux</a>;
            <span class="tok-kw">const</span> rc = sys.memfd_create(name, flags);
            <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
                .FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // name has invalid memory
                </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,<span class="tok-comment"> // or, program has a bug and flags are faulty
                </span>.NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
                .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
                .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
        },
        .freebsd =&gt; {
            <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">version_range</a>.<a href="#">semver</a>.<a href="#">max</a>.<a href="#">order</a>(.{ .major = <span class="tok-number">13</span>, .minor = <span class="tok-number">0</span>, .patch = <span class="tok-number">0</span> }) == .lt)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;memfd_create is unavailable on FreeBSD &lt; 13.0&quot;</span>);
            <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">memfd_create</a>(name, flags);
            <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                .SUCCESS =&gt; <span class="tok-kw">return</span> rc,
                .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // name argument NULL
                </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // name too long or invalid/unsupported flags.
                </span>.MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
                .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
                .NOSYS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemOutdated,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;target OS does not support memfd_create()&quot;</span>),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.memfd_create" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">memfd_create</span><a href="#src.zig-std.posix.memfd_create">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">memfd_create</span>(name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.MemFdCreateError">MemFdCreateError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.memfd_create">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">memfd_create</span>(name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.MemFdCreateError">MemFdCreateError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">var</span> buffer: [<a href="std.posix.html#std.posix.NAME_MAX">NAME_MAX</a> - <span class="tok-str">&quot;memfd:&quot;</span>.len - <span class="tok-number">1</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">if</span> (name.len &gt; buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
    <span class="tok-builtin">@memcpy</span>(buffer[<span class="tok-number">0</span>..name.len], name);
    buffer[name.len] = <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.memfd_createZ">memfd_createZ</a>(&amp;buffer, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.getrusage" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getrusage</span><a href="#src.zig-std.posix.getrusage">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getrusage</span>(who: <span class="tok-type">i32</span>) <a href="std.posix.html#std.posix.rusage">rusage</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>who: <span class="tok-type">i32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.getrusage">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getrusage</span>(who: <span class="tok-type">i32</span>) <a href="std.posix.html#std.posix.rusage">rusage</a> {
    <span class="tok-kw">var</span> result: <a href="std.posix.html#std.posix.rusage">rusage</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">getrusage</a>(who, &amp;result);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> result,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.tcgetattr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">tcgetattr</span><a href="#src.zig-std.posix.tcgetattr">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tcgetattr</span>(handle: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.TermiosGetError">TermiosGetError</a>!<a href="std.posix.html#std.posix.termios">termios</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>handle: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.tcgetattr">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tcgetattr</span>(handle: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.TermiosGetError">TermiosGetError</a>!<a href="std.posix.html#std.posix.termios">termios</a> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">var</span> term: <a href="std.posix.html#std.posix.termios">termios</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">tcgetattr</a>(handle, &amp;term))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> term,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .NOTTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotATerminal,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.tcsetattr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">tcsetattr</span><a href="#src.zig-std.posix.tcsetattr">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tcsetattr</span>(handle: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, optional_action: <a href="std.posix.TCSA.html">TCSA</a>, termios_p: <a href="std.posix.html#std.posix.termios">termios</a>) <a href="std.posix.html#std.posix.TermiosSetError">TermiosSetError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>handle: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>optional_action: <a href="std.posix.TCSA.html">TCSA</a></code></pre></div><div><pre><code>termios_p: <a href="std.posix.html#std.posix.termios">termios</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.tcsetattr">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tcsetattr</span>(handle: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, optional_action: <a href="std.posix.TCSA.html">TCSA</a>, termios_p: <a href="std.posix.html#std.posix.termios">termios</a>) <a href="std.posix.html#std.posix.TermiosSetError">TermiosSetError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">tcsetattr</a>(handle, optional_action, &amp;termios_p))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .NOTTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotATerminal,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessOrphaned,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.tcgetpgrp" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">tcgetpgrp</span><a href="#src.zig-std.posix.tcgetpgrp">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tcgetpgrp</span>(handle: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.TermioGetPgrpError">TermioGetPgrpError</a>!<a href="std.posix.html#std.posix.pid_t">pid_t</a></code></pre></div><div class="tldDocs"><p>Returns the process group ID for the TTY associated with the given handle.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>handle: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.tcgetpgrp">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tcgetpgrp</span>(handle: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.TermioGetPgrpError">TermioGetPgrpError</a>!<a href="std.posix.html#std.posix.pid_t">pid_t</a> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">var</span> pgrp: <a href="std.posix.html#std.posix.pid_t">pid_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">tcgetpgrp</a>(handle, &amp;pgrp))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> pgrp,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .NOTTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotATerminal,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.tcsetpgrp" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">tcsetpgrp</span><a href="#src.zig-std.posix.tcsetpgrp">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tcsetpgrp</span>(handle: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, pgrp: <a href="std.posix.html#std.posix.pid_t">pid_t</a>) <a href="std.posix.html#std.posix.TermioSetPgrpError">TermioSetPgrpError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sets the controlling process group ID for given TTY.
handle must be valid fd_t to a TTY associated with calling process.
pgrp must be a valid process group, and the calling process must be a member
of that group.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>handle: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>pgrp: <a href="std.posix.html#std.posix.pid_t">pid_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.tcsetpgrp">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tcsetpgrp</span>(handle: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, pgrp: <a href="std.posix.html#std.posix.pid_t">pid_t</a>) <a href="std.posix.html#std.posix.TermioSetPgrpError">TermioSetPgrpError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">tcsetpgrp</a>(handle, &amp;pgrp))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .NOTTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotATerminal,
            .PERM =&gt; <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.TermioSetPgrpError">TermioSetPgrpError</a>.<a href="#">NotAPgrpMember</a>,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.signalfd" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">signalfd</span><a href="#src.zig-std.posix.signalfd">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">signalfd</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, mask: *<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sigset_t">sigset_t</a>, flags: <span class="tok-type">u32</span>) !<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>mask: *<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sigset_t">sigset_t</a></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.signalfd">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">signalfd</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, mask: *<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sigset_t">sigset_t</a>, flags: <span class="tok-type">u32</span>) !<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">signalfd</a>(fd, mask, flags);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        .BADF, .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessResources,
        .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InodeMountFail,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.sync" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sync</span><a href="#src.zig-std.posix.sync">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sync</span>() <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Write all pending file contents and metadata modifications to all filesystems.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.sync">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sync</span>() <span class="tok-type">void</span> {
    <a href="std.posix.html#std.posix.system">system</a>.<a href="#">sync</a>();
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.syncfs" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">syncfs</span><a href="#src.zig-std.posix.syncfs">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">syncfs</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.SyncError">SyncError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Write all pending file contents and metadata modifications to the filesystem which contains the specified file.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.syncfs">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">syncfs</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.SyncError">SyncError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">syncfs</a>(fd);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .BADF, .INVAL, .ROFS =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.fsync" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fsync</span><a href="#src.zig-std.posix.fsync">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fsync</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.SyncError">SyncError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Write all pending file contents and metadata modifications for the specified file descriptor to the underlying filesystem.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.fsync">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fsync</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.SyncError">SyncError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.FlushFileBuffers">FlushFileBuffers</a>(fd) != <span class="tok-number">0</span>)
            <span class="tok-kw">return</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetLastError">GetLastError</a>()) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .INVALID_HANDLE =&gt; <span class="tok-kw">unreachable</span>,
            .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,<span class="tok-comment"> // a sync was performed but the system couldn't update the access time
            </span>.UNEXP_NET_ERR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
        }
    }
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fsync</a>(fd);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .BADF, .INVAL, .ROFS =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.fdatasync" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fdatasync</span><a href="#src.zig-std.posix.fdatasync">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fdatasync</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.SyncError">SyncError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Write all pending file contents for the specified file descriptor to the underlying filesystem, but not necessarily the metadata.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.fdatasync">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fdatasync</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.SyncError">SyncError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.fsync">fsync</a>(fd) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <a href="std.posix.html#std.posix.SyncError">SyncError</a>.<a href="#">AccessDenied</a> =&gt; <span class="tok-kw">return</span>,<span class="tok-comment"> // fdatasync doesn't promise that the access time was synced
            </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
        };
    }
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fdatasync</a>(fd);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .BADF, .INVAL, .ROFS =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.prctl" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">prctl</span><a href="#src.zig-std.posix.prctl">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prctl</span>(option: <a href="std.posix.html#std.posix.PR">PR</a>, args: <span class="tok-kw">anytype</span>) <a href="std.posix.html#std.posix.PrctlError">PrctlError</a>!<span class="tok-type">u31</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>option: <a href="std.posix.html#std.posix.PR">PR</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.prctl">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prctl</span>(option: <a href="std.posix.html#std.posix.PR">PR</a>, args: <span class="tok-kw">anytype</span>) <a href="std.posix.html#std.posix.PrctlError">PrctlError</a>!<span class="tok-type">u31</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(args)) != .@&quot;struct&quot;)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Expected tuple or struct argument, found &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(args)));
    <span class="tok-kw">if</span> (args.len &gt; <span class="tok-number">4</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;prctl takes a maximum of 4 optional arguments&quot;</span>);

    <span class="tok-kw">var</span> buf: [<span class="tok-number">4</span>]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
    {
        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
        <span class="tok-kw">inline</span> <span class="tok-kw">while</span> (i &lt; args.len) : (i += <span class="tok-number">1</span>) buf[i] = args[i];
    }

    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">prctl</a>(<span class="tok-builtin">@intFromEnum</span>(option), buf[<span class="tok-number">0</span>], buf[<span class="tok-number">1</span>], buf[<span class="tok-number">2</span>], buf[<span class="tok-number">3</span>]);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFileDescriptor,
        .FAULT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidAddress,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .NODEV, .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedFeature,
        .OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OperationNotSupported,
        .PERM, .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .RANGE =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.getrlimit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getrlimit</span><a href="#src.zig-std.posix.getrlimit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getrlimit</span>(resource: <a href="std.posix.html#std.posix.rlimit_resource">rlimit_resource</a>) <a href="std.posix.html#std.posix.UnexpectedError">GetrlimitError</a>!<a href="std.posix.html#std.posix.rlimit">rlimit</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>resource: <a href="std.posix.html#std.posix.rlimit_resource">rlimit_resource</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.getrlimit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getrlimit</span>(resource: <a href="std.posix.html#std.posix.rlimit_resource">rlimit_resource</a>) <a href="std.posix.html#std.posix.UnexpectedError">GetrlimitError</a>!<a href="std.posix.html#std.posix.rlimit">rlimit</a> {
    <span class="tok-kw">const</span> getrlimit_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">getrlimit64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">getrlimit</a>;

    <span class="tok-kw">var</span> limits: <a href="std.posix.html#std.posix.rlimit">rlimit</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(getrlimit_sym(resource, &amp;limits))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> limits,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // bogus pointer
        </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.setrlimit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setrlimit</span><a href="#src.zig-std.posix.setrlimit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setrlimit</span>(resource: <a href="std.posix.html#std.posix.rlimit_resource">rlimit_resource</a>, limits: <a href="std.posix.html#std.posix.rlimit">rlimit</a>) <a href="std.posix.html#std.posix.SetrlimitError">SetrlimitError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>resource: <a href="std.posix.html#std.posix.rlimit_resource">rlimit_resource</a></code></pre></div><div><pre><code>limits: <a href="std.posix.html#std.posix.rlimit">rlimit</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.setrlimit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setrlimit</span>(resource: <a href="std.posix.html#std.posix.rlimit_resource">rlimit_resource</a>, limits: <a href="std.posix.html#std.posix.rlimit">rlimit</a>) <a href="std.posix.html#std.posix.SetrlimitError">SetrlimitError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> setrlimit_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">setrlimit64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">setrlimit</a>;

    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(setrlimit_sym(resource, &amp;limits))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // bogus pointer
        </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LimitTooBig,<span class="tok-comment"> // this could also mean &quot;invalid resource&quot;, but that would be unreachable
        </span>.PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.mincore" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mincore</span><a href="#src.zig-std.posix.mincore">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mincore</span>(ptr: [*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, length: <span class="tok-type">usize</span>, vec: [*]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.MincoreError">MincoreError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Determine whether pages are resident in memory.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>ptr: [*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span></code></pre></div><div><pre><code>length: <span class="tok-type">usize</span></code></pre></div><div><pre><code>vec: [*]<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.mincore">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mincore</span>(ptr: [*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, length: <span class="tok-type">usize</span>, vec: [*]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.MincoreError">MincoreError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">mincore</a>(ptr, length, vec))) {
        .SUCCESS =&gt; {},
        .AGAIN =&gt; <span class="tok-kw">error</span>.SystemResources,
        .FAULT =&gt; <span class="tok-kw">error</span>.InvalidAddress,
        .INVAL =&gt; <span class="tok-kw">error</span>.InvalidSyscall,
        .NOMEM =&gt; <span class="tok-kw">error</span>.OutOfMemory,
        .NOSYS =&gt; <span class="tok-kw">error</span>.MincoreUnavailable,
        <span class="tok-kw">else</span> =&gt; |err| <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.madvise" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">madvise</span><a href="#src.zig-std.posix.madvise">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">madvise</span>(ptr: [*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, length: <span class="tok-type">usize</span>, advice: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.MadviseError">MadviseError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Give advice about use of memory.
This syscall is optional and is sometimes configured to be disabled.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>ptr: [*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span></code></pre></div><div><pre><code>length: <span class="tok-type">usize</span></code></pre></div><div><pre><code>advice: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.madvise">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">madvise</span>(ptr: [*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, length: <span class="tok-type">usize</span>, advice: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.MadviseError">MadviseError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">madvise</a>(ptr, length, advice))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The map exists, but the area maps something that isn't a file.
        </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidSyscall,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldExceedMaximumResidentSetSize,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
        .NOSYS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MadviseUnavailable,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.perf_event_open" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">perf_event_open</span><a href="#src.zig-std.posix.perf_event_open">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">perf_event_open</span>( attr: *<a href="std.posix.html#std.posix.system">system</a>.<a href="#">perf_event_attr</a>, pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>, cpu: <span class="tok-type">i32</span>, group_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, flags: <span class="tok-type">usize</span>, ) <a href="std.posix.html#std.posix.PerfEventOpenError">PerfEventOpenError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>attr: *<a href="std.posix.html#std.posix.system">system</a>.<a href="#">perf_event_attr</a></code></pre></div><div><pre><code>pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a></code></pre></div><div><pre><code>cpu: <span class="tok-type">i32</span></code></pre></div><div><pre><code>group_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>flags: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.perf_event_open">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">perf_event_open</span>(
    attr: *<a href="std.posix.html#std.posix.system">system</a>.<a href="#">perf_event_attr</a>,
    pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>,
    cpu: <span class="tok-type">i32</span>,
    group_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    flags: <span class="tok-type">usize</span>,
) <a href="std.posix.html#std.posix.PerfEventOpenError">PerfEventOpenError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .linux) {<span class="tok-comment">
        // There is no syscall wrapper for this function exposed by libcs
        </span><span class="tok-kw">const</span> rc = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.perf_event_open">perf_event_open</a>(attr, pid, cpu, group_fd, flags);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .@&quot;2BIG&quot; =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TooBig,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // group_fd file descriptor is not valid.
            </span>.BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeviceBusy,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Segmentation fault.
            </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Bad attr settings.
            </span>.INTR =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Mixed perf and ftrace handling for a uprobe.
            </span>.MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessResources,
            .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EventRequiresUnsupportedCpuFeature,
            .NOENT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid type setting.
            </span>.NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TooManyBreakpoints,
            .NOSYS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SampleStackNotSupported,
            .OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EventNotSupported,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SampleMaxStackOverflow,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            .SRCH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.timerfd_create" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">timerfd_create</span><a href="#src.zig-std.posix.timerfd_create">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">timerfd_create</span>(clock_id: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">timerfd_clockid_t</a>, flags: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">TFD</a>) <a href="std.posix.html#std.posix.TimerFdCreateError">TimerFdCreateError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>clock_id: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">timerfd_clockid_t</a></code></pre></div><div><pre><code>flags: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">TFD</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.timerfd_create">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">timerfd_create</span>(clock_id: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">timerfd_clockid_t</a>, flags: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">TFD</a>) <a href="std.posix.html#std.posix.TimerFdCreateError">TimerFdCreateError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">timerfd_create</a>(clock_id, <span class="tok-builtin">@bitCast</span>(flags));
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-builtin">@intCast</span>(rc),
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoDevice,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.timerfd_settime" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">timerfd_settime</span><a href="#src.zig-std.posix.timerfd_settime">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">timerfd_settime</span>( fd: <span class="tok-type">i32</span>, flags: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">TFD</a>.<a href="#">TIMER</a>, new_value: *<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">itimerspec</a>, old_value: ?*<a href="std.posix.html#std.posix.system">system</a>.<a href="#">itimerspec</a>, ) <a href="std.posix.html#std.posix.TimerFdSetError">TimerFdSetError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <span class="tok-type">i32</span></code></pre></div><div><pre><code>flags: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">TFD</a>.<a href="#">TIMER</a></code></pre></div><div><pre><code>new_value: *<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">itimerspec</a></code></pre></div><div><pre><code>old_value: ?*<a href="std.posix.html#std.posix.system">system</a>.<a href="#">itimerspec</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.timerfd_settime">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">timerfd_settime</span>(
    fd: <span class="tok-type">i32</span>,
    flags: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">TFD</a>.<a href="#">TIMER</a>,
    new_value: *<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">itimerspec</a>,
    old_value: ?*<a href="std.posix.html#std.posix.system">system</a>.<a href="#">itimerspec</a>,
) <a href="std.posix.html#std.posix.TimerFdSetError">TimerFdSetError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">timerfd_settime</a>(fd, <span class="tok-builtin">@bitCast</span>(flags), new_value, old_value);
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; {},
        .BADF =&gt; <span class="tok-kw">error</span>.InvalidHandle,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .CANCELED =&gt; <span class="tok-kw">error</span>.Canceled,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.timerfd_gettime" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">timerfd_gettime</span><a href="#src.zig-std.posix.timerfd_gettime">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">timerfd_gettime</span>(fd: <span class="tok-type">i32</span>) <a href="std.posix.html#std.posix.TimerFdGetError">TimerFdGetError</a>!<a href="std.posix.html#std.posix.system">system</a>.<a href="#">itimerspec</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <span class="tok-type">i32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.timerfd_gettime">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">timerfd_gettime</span>(fd: <span class="tok-type">i32</span>) <a href="std.posix.html#std.posix.TimerFdGetError">TimerFdGetError</a>!<a href="std.posix.html#std.posix.system">system</a>.<a href="#">itimerspec</a> {
    <span class="tok-kw">var</span> curr_value: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">itimerspec</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">timerfd_gettime</a>(fd, &amp;curr_value);
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> curr_value,
        .BADF =&gt; <span class="tok-kw">error</span>.InvalidHandle,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.ptrace" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ptrace</span><a href="#src.zig-std.posix.ptrace">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrace</span>(request: <span class="tok-type">u32</span>, pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>, addr: <span class="tok-type">usize</span>, signal: <span class="tok-type">usize</span>) <a href="std.posix.html#std.posix.PtraceError">PtraceError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>request: <span class="tok-type">u32</span></code></pre></div><div><pre><code>pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a></code></pre></div><div><pre><code>addr: <span class="tok-type">usize</span></code></pre></div><div><pre><code>signal: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.ptrace">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrace</span>(request: <span class="tok-type">u32</span>, pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>, addr: <span class="tok-type">usize</span>, signal: <span class="tok-type">usize</span>) <a href="std.posix.html#std.posix.PtraceError">PtraceError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows <span class="tok-kw">or</span> <a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported OS&quot;</span>);

    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .linux =&gt; <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.ptrace">ptrace</a>(request, pid, addr, signal, <span class="tok-number">0</span>))) {
            .SUCCESS =&gt; {},
            .SRCH =&gt; <span class="tok-kw">error</span>.ProcessNotFound,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .PERM =&gt; <span class="tok-kw">error</span>.PermissionDenied,
            .BUSY =&gt; <span class="tok-kw">error</span>.DeviceBusy,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        },

        .macos, .ios, .tvos, .watchos, .visionos =&gt; <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.darwin.html#std.c.darwin.ptrace">ptrace</a>(
            <span class="tok-builtin">@intCast</span>(request),
            pid,
            <span class="tok-builtin">@ptrFromInt</span>(addr),
            <span class="tok-builtin">@intCast</span>(signal),
        ))) {
            .SUCCESS =&gt; {},
            .SRCH =&gt; <span class="tok-kw">error</span>.ProcessNotFound,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .PERM =&gt; <span class="tok-kw">error</span>.PermissionDenied,
            .BUSY =&gt; <span class="tok-kw">error</span>.DeviceBusy,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        },

        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">ptrace</a>(request, pid, addr, signal))) {
            .SUCCESS =&gt; {},
            .SRCH =&gt; <span class="tok-kw">error</span>.ProcessNotFound,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .PERM =&gt; <span class="tok-kw">error</span>.PermissionDenied,
            .BUSY =&gt; <span class="tok-kw">error</span>.DeviceBusy,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.name_to_handle_at" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">name_to_handle_at</span><a href="#src.zig-std.posix.name_to_handle_at">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">name_to_handle_at</span>( dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, handle: *<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.file_handle.html">file_handle</a>, mount_id: *<span class="tok-type">i32</span>, flags: <span class="tok-type">u32</span>, ) <a href="std.posix.html#std.posix.NameToFileHandleAtError">NameToFileHandleAtError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>handle: *<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.file_handle.html">file_handle</a></code></pre></div><div><pre><code>mount_id: *<span class="tok-type">i32</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.name_to_handle_at">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">name_to_handle_at</span>(
    dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    handle: *<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.file_handle.html">file_handle</a>,
    mount_id: *<span class="tok-type">i32</span>,
    flags: <span class="tok-type">u32</span>,
) <a href="std.posix.html#std.posix.NameToFileHandleAtError">NameToFileHandleAtError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> pathname_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(pathname);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.name_to_handle_atZ">name_to_handle_atZ</a>(dirfd, &amp;pathname_c, handle, mount_id, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.name_to_handle_atZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">name_to_handle_atZ</span><a href="#src.zig-std.posix.name_to_handle_atZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">name_to_handle_atZ</span>( dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, pathname_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, handle: *<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.file_handle.html">file_handle</a>, mount_id: *<span class="tok-type">i32</span>, flags: <span class="tok-type">u32</span>, ) <a href="std.posix.html#std.posix.NameToFileHandleAtError">NameToFileHandleAtError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>pathname_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>handle: *<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.file_handle.html">file_handle</a></code></pre></div><div><pre><code>mount_id: *<span class="tok-type">i32</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.name_to_handle_atZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">name_to_handle_atZ</span>(
    dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    pathname_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    handle: *<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.file_handle.html">file_handle</a>,
    mount_id: *<span class="tok-type">i32</span>,
    flags: <span class="tok-type">u32</span>,
) <a href="std.posix.html#std.posix.NameToFileHandleAtError">NameToFileHandleAtError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">name_to_handle_at</a>(dirfd, pathname_z, handle, mount_id, flags))) {
        .SUCCESS =&gt; {},
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // pathname, mount_id, or handle outside accessible address space
        </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // bad flags, or handle_bytes too big
        </span>.NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OperationNotSupported,
        .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.ioctl_SIOCGIFINDEX" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ioctl_SIOCGIFINDEX</span><a href="#src.zig-std.posix.ioctl_SIOCGIFINDEX">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ioctl_SIOCGIFINDEX</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, ifr: *<a href="std.posix.html#std.posix.ifreq">ifreq</a>) <a href="std.posix.html#std.posix.IoCtl_SIOCGIFINDEX_Error">IoCtl_SIOCGIFINDEX_Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>ifr: *<a href="std.posix.html#std.posix.ifreq">ifreq</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.ioctl_SIOCGIFINDEX">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ioctl_SIOCGIFINDEX</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, ifr: *<a href="std.posix.html#std.posix.ifreq">ifreq</a>) <a href="std.posix.html#std.posix.IoCtl_SIOCGIFINDEX_Error">IoCtl_SIOCGIFINDEX_Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">ioctl</a>(fd, <a href="std.posix.html#std.posix.SIOCGIFINDEX">SIOCGIFINDEX</a>, <span class="tok-builtin">@intFromPtr</span>(ifr)))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Bad parameters.
            </span>.NOTTY =&gt; <span class="tok-kw">unreachable</span>,
            .NXIO =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition.
            </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Bad pointer parameter.
            </span>.INTR =&gt; <span class="tok-kw">continue</span>,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
            .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InterfaceNotFound,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.unexpectedErrno" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unexpectedErrno</span><a href="#src.zig-std.posix.unexpectedErrno">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unexpectedErrno</span>(err: <a href="std.posix.html#std.posix.E">E</a>) <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></div><div class="tldDocs"><p>Call this when you made a syscall or something that sets errno
and you get an unexpected error.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>err: <a href="std.posix.html#std.posix.E">E</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.unexpectedErrno">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unexpectedErrno</span>(err: <a href="std.posix.html#std.posix.E">E</a>) <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.unexpected_error_tracing">unexpected_error_tracing</a>) {
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;unexpected errno: {d}\n&quot;</span>, .{<span class="tok-builtin">@intFromEnum</span>(err)});
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.dumpCurrentStackTrace">dumpCurrentStackTrace</a>(<span class="tok-null">null</span>);
    }
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected;
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.toPosixPath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toPosixPath</span><a href="#src.zig-std.posix.toPosixPath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toPosixPath</span>(file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{NameTooLong}![<a href="std.posix.html#std.posix.PATH_MAX">PATH_MAX</a> - <span class="tok-number">1</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Used to convert a slice to a null terminated slice on the stack.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.toPosixPath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toPosixPath</span>(file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{NameTooLong}![<a href="std.posix.html#std.posix.PATH_MAX">PATH_MAX</a> - <span class="tok-number">1</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.runtime_safety">runtime_safety</a>) <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, file_path, <span class="tok-number">0</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">var</span> path_with_null: [<a href="std.posix.html#std.posix.PATH_MAX">PATH_MAX</a> - <span class="tok-number">1</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">
    // &gt;= rather than &gt; to make room for the null byte
    </span><span class="tok-kw">if</span> (file_path.len &gt;= <a href="std.posix.html#std.posix.PATH_MAX">PATH_MAX</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
    <span class="tok-builtin">@memcpy</span>(path_with_null[<span class="tok-number">0</span>..file_path.len], file_path);
    path_with_null[file_path.len] = <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> path_with_null;
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.posix">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! POSIX API layer.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! This is more cross platform than using OS-specific APIs, however, it is</span>
<span class="tok-comment">//! lower-level and less portable than other namespaces such as `std.fs` and</span>
<span class="tok-comment">//! `std.process`.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! These APIs are generally lowered to libc function calls if and only if libc</span>
<span class="tok-comment">//! is linked. Most operating systems other than Windows, Linux, and WASI</span>
<span class="tok-comment">//! require always linking libc because they use it as the stable syscall ABI.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! Operating systems that are not POSIX-compliant are sometimes supported by</span>
<span class="tok-comment">//! this API layer; sometimes not. Generally, an implementation will be</span>
<span class="tok-comment">//! provided only if such implementation is straightforward on that operating</span>
<span class="tok-comment">//! system. Otherwise, programmers are expected to use OS-specific logic to</span>
<span class="tok-comment">//! deal with the exception.</span>

<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> root = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);
<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> fs = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>;
<span class="tok-kw">const</span> max_path_bytes = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>;
<span class="tok-kw">const</span> maxInt = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>;
<span class="tok-kw">const</span> cast = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> native_os = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>;
<span class="tok-kw">const</span> page_size_min = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>;

<span class="tok-kw">test</span> {
    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;posix/test.zig&quot;</span>);
}

<span class="tok-comment">/// Whether to use libc for the POSIX API layer.</span>
<span class="tok-kw">const</span> use_libc = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a> <span class="tok-kw">or</span> <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
    .windows, .wasi =&gt; <span class="tok-null">true</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
};

<span class="tok-kw">const</span> linux = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>;
<span class="tok-kw">const</span> windows = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>;
<span class="tok-kw">const</span> wasi = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>;

<span class="tok-comment">/// A libc-compatible API layer.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> system = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.use_libc">use_libc</a>)
    <a href="std.html">std</a>.<a href="std.c.html">c</a>
<span class="tok-kw">else</span> <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
    .linux =&gt; <a href="std.os.linux.html">linux</a>,
    .plan9 =&gt; <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.plan9.html">plan9</a>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ucontext_t = <span class="tok-type">void</span>;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> pid_t = <span class="tok-type">void</span>;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> pollfd = <span class="tok-type">void</span>;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> fd_t = <span class="tok-type">void</span>;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> uid_t = <span class="tok-type">void</span>;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> gid_t = <span class="tok-type">void</span>;
    },
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AF = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">AF</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AF_SUN = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">AF_SUN</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AI = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">AI</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ARCH = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">ARCH</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AT = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">AT</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AT_SUN = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">AT_SUN</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> CLOCK = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">CLOCK</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> CPU_COUNT = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">CPU_COUNT</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> CTL = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">CTL</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> DT = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">DT</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> E = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">E</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Elf_Symndx = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">Elf_Symndx</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> F = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">F</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FD_CLOEXEC = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">FD_CLOEXEC</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Flock = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">Flock</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> HOST_NAME_MAX = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">HOST_NAME_MAX</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> HW = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">HW</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> IFNAMESIZE = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">IFNAMESIZE</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> IOV_MAX = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">IOV_MAX</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> IPPROTO = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">IPPROTO</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> KERN = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">KERN</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Kevent = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">Kevent</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MADV = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MADV</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MAP = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MAP</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MAX_ADDR_LEN = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MAX_ADDR_LEN</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MFD = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MFD</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MMAP2_UNIT = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MMAP2_UNIT</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MREMAP = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MREMAP</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MSF = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MSF</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MSG = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MSG</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> NAME_MAX = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">NAME_MAX</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> O = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">O</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PATH_MAX = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">PATH_MAX</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> POLL = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">POLL</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> POSIX_FADV = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">POSIX_FADV</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PR = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">PR</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PROT = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">PROT</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> REG = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">REG</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RLIM = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">RLIM</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RR = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">RR</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> S = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">S</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SA = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">SA</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SC = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">SC</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SEEK = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">SEEK</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SHUT = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">SHUT</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SIG = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">SIG</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SIOCGIFINDEX = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">SIOCGIFINDEX</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SO = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">SO</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SOCK = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">SOCK</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SOL = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">SOL</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> IFF = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">IFF</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> STDERR_FILENO = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">STDERR_FILENO</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> STDIN_FILENO = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">STDIN_FILENO</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> STDOUT_FILENO = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">STDOUT_FILENO</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SYS = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">SYS</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Sigaction = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">Sigaction</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Stat = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">Stat</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> T = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">T</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TCP = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">TCP</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> VDSO = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">VDSO</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> W = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">W</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> _SC = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">_SC</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> addrinfo = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">addrinfo</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> blkcnt_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">blkcnt_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> blksize_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">blksize_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> clock_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">clock_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> clockid_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">clockid_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> timerfd_clockid_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">timerfd_clockid_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> cpu_set_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">cpu_set_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> dev_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">dev_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> dl_phdr_info = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">dl_phdr_info</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty_sigset = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">empty_sigset</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> fd_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="std.posix.html#std.posix.system.fd_t">fd_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> file_obj = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">file_obj</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> filled_sigset = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">filled_sigset</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> gid_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="std.posix.html#std.posix.system.gid_t">gid_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ifreq = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">ifreq</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ino_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">ino_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> mcontext_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">mcontext_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> mode_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">mode_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> msghdr = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">msghdr</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> msghdr_const = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">msghdr_const</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> nfds_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">nfds_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> nlink_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">nlink_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> off_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">off_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> pid_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="std.posix.html#std.posix.system.pid_t">pid_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> pollfd = <a href="std.posix.html#std.posix.system">system</a>.<a href="std.posix.html#std.posix.system.pollfd">pollfd</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> port_event = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">port_event</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> port_notify = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">port_notify</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> port_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">port_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> rlim_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">rlim_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> rlimit = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">rlimit</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> rlimit_resource = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">rlimit_resource</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> rusage = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">rusage</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> sa_family_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">sa_family_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> siginfo_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">siginfo_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> sigset_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">sigset_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> sockaddr = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">sockaddr</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> socklen_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">socklen_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> stack_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">stack_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> time_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">time_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> timespec = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">timespec</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> timestamp_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">timestamp_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> timeval = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">timeval</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> timezone = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">timezone</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ucontext_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="std.posix.html#std.posix.system.ucontext_t">ucontext_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> uid_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="std.posix.html#std.posix.system.uid_t">uid_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> user_desc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">user_desc</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> utsname = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">utsname</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> termios = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">termios</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> CSIZE = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">CSIZE</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> NCCS = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">NCCS</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> cc_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">cc_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> V = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">V</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> speed_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">speed_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> tc_iflag_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">tc_iflag_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> tc_oflag_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">tc_oflag_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> tc_cflag_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">tc_cflag_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> tc_lflag_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">tc_lflag_t</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> F_OK = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">F_OK</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> R_OK = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">R_OK</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> W_OK = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">W_OK</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> X_OK = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">X_OK</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> iovec = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
    base: [*]<span class="tok-type">u8</span>,
    len: <span class="tok-type">usize</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> iovec_const = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
    base: [*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    len: <span class="tok-type">usize</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ACCMODE = <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) {
    RDONLY = <span class="tok-number">0</span>,
    WRONLY = <span class="tok-number">1</span>,
    RDWR = <span class="tok-number">2</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TCSA = <span class="tok-kw">enum</span>(<span class="tok-type">c_uint</span>) {
    NOW,
    DRAIN,
    FLUSH,
    _,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> winsize = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
    row: <span class="tok-type">u16</span>,
    col: <span class="tok-type">u16</span>,
    xpixel: <span class="tok-type">u16</span>,
    ypixel: <span class="tok-type">u16</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> LOCK = <span class="tok-kw">struct</span> {
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SH = <span class="tok-number">1</span>;
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> EX = <span class="tok-number">2</span>;
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> NB = <span class="tok-number">4</span>;
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> UN = <span class="tok-number">8</span>;
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> LOG = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// system is unusable</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> EMERG = <span class="tok-number">0</span>;
    <span class="tok-comment">/// action must be taken immediately</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ALERT = <span class="tok-number">1</span>;
    <span class="tok-comment">/// critical conditions</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> CRIT = <span class="tok-number">2</span>;
    <span class="tok-comment">/// error conditions</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ERR = <span class="tok-number">3</span>;
    <span class="tok-comment">/// warning conditions</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> WARNING = <span class="tok-number">4</span>;
    <span class="tok-comment">/// normal but significant condition</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> NOTICE = <span class="tok-number">5</span>;
    <span class="tok-comment">/// informational</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> INFO = <span class="tok-number">6</span>;
    <span class="tok-comment">/// debug-level messages</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DEBUG = <span class="tok-number">7</span>;
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> socket_t = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET">SOCKET</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.fd_t">fd_t</a>;

<span class="tok-comment">/// Obtains errno from the return value of a system function call.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// For some systems this will obtain the value directly from the syscall return value;</span>
<span class="tok-comment">/// for others it will use a thread-local errno variable. Therefore, this</span>
<span class="tok-comment">/// function only returns a well-defined value when it is called directly after</span>
<span class="tok-comment">/// the system function call whose errno value is intended to be observed.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">errno</span>(rc: <span class="tok-kw">anytype</span>) <a href="std.posix.html#std.posix.E">E</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.use_libc">use_libc</a>) {
        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (rc == -<span class="tok-number">1</span>) <span class="tok-builtin">@enumFromInt</span>(<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c._errno">_errno</a>().*) <span class="tok-kw">else</span> .SUCCESS;
    }
    <span class="tok-kw">const</span> signed: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(rc);
    <span class="tok-kw">const</span> int = <span class="tok-kw">if</span> (signed &gt; -<span class="tok-number">4096</span> <span class="tok-kw">and</span> signed &lt; <span class="tok-number">0</span>) -signed <span class="tok-kw">else</span> <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(int);
}

<span class="tok-comment">/// Closes the file descriptor.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Asserts the file descriptor is open.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This function is not capable of returning any indication of failure. An</span>
<span class="tok-comment">/// application which wants to ensure writes have succeeded before closing must</span>
<span class="tok-comment">/// call `fsync` before `close`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The Zig standard library does not support POSIX thread cancellation.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CloseHandle">CloseHandle</a>(fd);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        _ = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_close">fd_close</a>(fd);
        <span class="tok-kw">return</span>;
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">close</a>(fd))) {
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition.
        </span>.INTR =&gt; <span class="tok-kw">return</span>,<span class="tok-comment"> // This is still a success. See https://github.com/ziglang/zig/issues/2425
        </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span>,
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FChmodError = <span class="tok-kw">error</span>{
    AccessDenied,
    InputOutput,
    SymLinkLoop,
    FileNotFound,
    SystemResources,
    ReadOnlyFileSystem,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Changes the mode of the file referred to by the file descriptor.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The process must have the correct privileges in order to do this</span>
<span class="tok-comment">/// successfully, or must have the effective user ID matching the owner</span>
<span class="tok-comment">/// of the file.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fchmod</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.FChmodError">FChmodError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.has_executable_bit">has_executable_bit</a>) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;fchmod unsupported by target OS&quot;</span>);

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> res = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fchmod</a>(fd, mode);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(res)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FChmodAtError = <a href="std.posix.html#std.posix.FChmodError">FChmodError</a> || <span class="tok-kw">error</span>{
    <span class="tok-comment">/// A component of `path` exceeded `NAME_MAX`, or the entire path exceeded</span>
    <span class="tok-comment">/// `PATH_MAX`.</span>
    NameTooLong,
    <span class="tok-comment">/// `path` resolves to a symbolic link, and `AT.SYMLINK_NOFOLLOW` was set</span>
    <span class="tok-comment">/// in `flags`. This error only occurs on Linux, where changing the mode of</span>
    <span class="tok-comment">/// a symbolic link has no meaning and can cause undefined behaviour on</span>
    <span class="tok-comment">/// certain filesystems.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The procfs fallback was used but procfs was not mounted.</span>
    OperationNotSupported,
    <span class="tok-comment">/// The procfs fallback was used but the process exceeded its open file</span>
    <span class="tok-comment">/// limit.</span>
    ProcessFdQuotaExceeded,
    <span class="tok-comment">/// The procfs fallback was used but the system exceeded it open file limit.</span>
    SystemFdQuotaExceeded,
};

<span class="tok-comment">/// Changes the `mode` of `path` relative to the directory referred to by</span>
<span class="tok-comment">/// `dirfd`. The process must have the correct privileges in order to do this</span>
<span class="tok-comment">/// successfully, or must have the effective user ID matching the owner of the</span>
<span class="tok-comment">/// file.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// On Linux the `fchmodat2` syscall will be used if available, otherwise a</span>
<span class="tok-comment">/// workaround using procfs will be employed. Changing the mode of a symbolic</span>
<span class="tok-comment">/// link with `AT.SYMLINK_NOFOLLOW` set will also return</span>
<span class="tok-comment">/// `OperationNotSupported`, as:</span>
<span class="tok-comment">///</span>
<span class="tok-comment">///  1. Permissions on the link are ignored when resolving its target.</span>
<span class="tok-comment">///  2. This operation has been known to invoke undefined behaviour across</span>
<span class="tok-comment">///     different filesystems[1].</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// [1]: https://sourceware.org/legacy-ml/libc-alpha/2020-02/msg00467.html.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">fchmodat</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.FChmodAtError">FChmodAtError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.has_executable_bit">has_executable_bit</a>) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;fchmodat unsupported by target OS&quot;</span>);<span class="tok-comment">

    // No special handling for linux is needed if we can use the libc fallback
    // or `flags` is empty. Glibc only added the fallback in 2.32.
    </span><span class="tok-kw">const</span> skip_fchmodat_fallback = <a href="std.posix.html#std.posix.native_os">native_os</a> != .linux <span class="tok-kw">or</span>
        <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.versionCheck">versionCheck</a>(.{ .major = <span class="tok-number">2</span>, .minor = <span class="tok-number">32</span>, .patch = <span class="tok-number">0</span> }) <span class="tok-kw">or</span>
        flags == <span class="tok-number">0</span>;<span class="tok-comment">

    // This function is marked inline so that when flags is comptime-known,
    // skip_fchmodat_fallback will be comptime-known true.
    </span><span class="tok-kw">if</span> (skip_fchmodat_fallback)
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.fchmodat1">fchmodat1</a>(dirfd, path, mode, flags);

    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.fchmodat2">fchmodat2</a>(dirfd, path, mode, flags);
}

<span class="tok-kw">fn</span> <span class="tok-fn">fchmodat1</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.FChmodAtError">FChmodAtError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(path);
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> res = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fchmodat</a>(dirfd, &amp;path_c, mode, flags);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(res)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
            .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
            .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
            .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OperationNotSupported,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">fchmodat2</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.FChmodAtError">FChmodAtError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> global = <span class="tok-kw">struct</span> {
        <span class="tok-kw">var</span> has_fchmodat2: <span class="tok-type">bool</span> = <span class="tok-null">true</span>;
    };
    <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(path);
    <span class="tok-kw">const</span> use_fchmodat2 = (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">isAtLeast</a>(.linux, .{ .major = <span class="tok-number">6</span>, .minor = <span class="tok-number">6</span>, .patch = <span class="tok-number">0</span> }) <span class="tok-kw">orelse</span> <span class="tok-null">false</span>) <span class="tok-kw">and</span>
        <span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">bool</span>, &amp;global.has_fchmodat2, .monotonic);
    <span class="tok-kw">while</span> (use_fchmodat2) {<span class="tok-comment">
        // Later on this should be changed to `system.fchmodat2`
        // when the musl/glibc add a wrapper.
        </span><span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.fchmodat2">fchmodat2</a>(dirfd, &amp;path_c, mode, flags);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.E">E</a>.<a href="#">init</a>(res)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OperationNotSupported,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,

            .NOSYS =&gt; {
                <span class="tok-builtin">@atomicStore</span>(<span class="tok-type">bool</span>, &amp;global.has_fchmodat2, <span class="tok-null">false</span>, .monotonic);
                <span class="tok-kw">break</span>;
            },
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }<span class="tok-comment">

    // Fallback to changing permissions using procfs:
    //
    // 1. Open `path` as a `PATH` descriptor.
    // 2. Stat the fd and check if it isn't a symbolic link.
    // 3. Generate the procfs reference to the fd via `/proc/self/fd/{fd}`.
    // 4. Pass the procfs path to `chmod` with the `mode`.
    </span><span class="tok-kw">var</span> pathfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">openat</a>(dirfd, &amp;path_c, .{ .PATH = <span class="tok-null">true</span>, .NOFOLLOW = <span class="tok-null">true</span>, .CLOEXEC = <span class="tok-null">true</span> }, <span class="tok-builtin">@as</span>(<a href="std.posix.html#std.posix.mode_t">mode_t</a>, <span class="tok-number">0</span>));
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; {
                pathfd = <span class="tok-builtin">@intCast</span>(rc);
                <span class="tok-kw">break</span>;
            },
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
            .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
            .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
            .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">defer</span> <a href="std.posix.html#std.posix.close">close</a>(pathfd);

    <span class="tok-kw">const</span> stat = <a href="std.posix.html#std.posix.fstatatZ">fstatatZ</a>(pathfd, <span class="tok-str">&quot;&quot;</span>, <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">EMPTY_PATH</a>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
    <span class="tok-kw">if</span> ((stat.mode &amp; <a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFMT</a>) == <a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFLNK</a>)
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OperationNotSupported;

    <span class="tok-kw">var</span> procfs_buf: [<span class="tok-str">&quot;/proc/self/fd/-2147483648\x00&quot;</span>.len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> proc_path = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.bufPrintZ">bufPrintZ</a>(procfs_buf[<span class="tok-number">0</span>..], <span class="tok-str">&quot;/proc/self/fd/{d}&quot;</span>, .{pathfd}) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> res = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">chmod</a>(proc_path, mode);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(res)) {<span class="tok-comment">
            // Getting NOENT here means that procfs isn't mounted.
            </span>.NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OperationNotSupported,

            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FChownError = <span class="tok-kw">error</span>{
    AccessDenied,
    InputOutput,
    SymLinkLoop,
    FileNotFound,
    SystemResources,
    ReadOnlyFileSystem,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Changes the owner and group of the file referred to by the file descriptor.</span>
<span class="tok-comment">/// The process must have the correct privileges in order to do this</span>
<span class="tok-comment">/// successfully. The group may be changed by the owner of the directory to</span>
<span class="tok-comment">/// any group of which the owner is a member. If the owner or group is</span>
<span class="tok-comment">/// specified as `null`, the ID is not changed.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fchown</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, owner: ?<a href="std.posix.html#std.posix.uid_t">uid_t</a>, group: ?<a href="std.posix.html#std.posix.gid_t">gid_t</a>) <a href="std.posix.html#std.posix.FChownError">FChownError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .windows, .wasi =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported OS&quot;</span>),
        <span class="tok-kw">else</span> =&gt; {},
    }

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> res = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fchown</a>(fd, owner <span class="tok-kw">orelse</span> ~<span class="tok-builtin">@as</span>(<a href="std.posix.html#std.posix.uid_t">uid_t</a>, <span class="tok-number">0</span>), group <span class="tok-kw">orelse</span> ~<span class="tok-builtin">@as</span>(<a href="std.posix.html#std.posix.gid_t">gid_t</a>, <span class="tok-number">0</span>));

        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(res)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Can be reached if the fd refers to a directory opened without `Dir.OpenOptions{ .iterate = true }`

            </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RebootError = <span class="tok-kw">error</span>{
    PermissionDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RebootCommand = <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
    .linux =&gt; <span class="tok-kw">union</span>(linux.LINUX_REBOOT.CMD) {
        RESTART: <span class="tok-type">void</span>,
        HALT: <span class="tok-type">void</span>,
        CAD_ON: <span class="tok-type">void</span>,
        CAD_OFF: <span class="tok-type">void</span>,
        POWER_OFF: <span class="tok-type">void</span>,
        RESTART2: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        SW_SUSPEND: <span class="tok-type">void</span>,
        KEXEC: <span class="tok-type">void</span>,
    },
    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported OS&quot;</span>),
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reboot</span>(cmd: <a href="std.posix.html#std.posix.RebootCommand">RebootCommand</a>) <a href="std.posix.html#std.posix.RebootError">RebootError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .linux =&gt; {
            <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.reboot">reboot</a>(
                .MAGIC1,
                .MAGIC2,
                cmd,
                <span class="tok-kw">switch</span> (cmd) {
                    .RESTART2 =&gt; |s| s,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
                },
            ))) {
                .SUCCESS =&gt; {},
                .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
            <span class="tok-kw">switch</span> (cmd) {
                .CAD_OFF =&gt; {},
                .CAD_ON =&gt; {},
                .SW_SUSPEND =&gt; {},

                .HALT =&gt; <span class="tok-kw">unreachable</span>,
                .KEXEC =&gt; <span class="tok-kw">unreachable</span>,
                .POWER_OFF =&gt; <span class="tok-kw">unreachable</span>,
                .RESTART =&gt; <span class="tok-kw">unreachable</span>,
                .RESTART2 =&gt; <span class="tok-kw">unreachable</span>,
            }
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported OS&quot;</span>),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetRandomError = <a href="std.posix.html#std.posix.OpenError">OpenError</a>;

<span class="tok-comment">/// Obtain a series of random bytes. These bytes can be used to seed user-space</span>
<span class="tok-comment">/// random number generators or for cryptographic purposes.</span>
<span class="tok-comment">/// When linking against libc, this calls the</span>
<span class="tok-comment">/// appropriate OS-specific library call. Otherwise it uses the zig standard</span>
<span class="tok-comment">/// library implementation.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getrandom</span>(buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.OpenError">GetRandomError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.RtlGenRandom">RtlGenRandom</a>(buffer);
    }
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a> <span class="tok-kw">and</span> <span class="tok-builtin">@TypeOf</span>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">arc4random_buf</a>) != <span class="tok-type">void</span>) {
        <a href="std.posix.html#std.posix.system">system</a>.<a href="#">arc4random_buf</a>(buffer.ptr, buffer.len);
        <span class="tok-kw">return</span>;
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi) <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.random_get">random_get</a>(buffer.ptr, buffer.len)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    };
    <span class="tok-kw">if</span> (<span class="tok-builtin">@TypeOf</span>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">getrandom</a>) != <span class="tok-type">void</span>) {
        <span class="tok-kw">var</span> buf = buffer;
        <span class="tok-kw">const</span> use_c = <a href="std.posix.html#std.posix.native_os">native_os</a> != .linux <span class="tok-kw">or</span>
            <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.versionCheck">versionCheck</a>(<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a>{ .major = <span class="tok-number">2</span>, .minor = <span class="tok-number">25</span>, .patch = <span class="tok-number">0</span> });

        <span class="tok-kw">while</span> (buf.len != <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> num_read: <span class="tok-type">usize</span>, <span class="tok-kw">const</span> err = <span class="tok-kw">if</span> (use_c) res: {
                <span class="tok-kw">const</span> rc = std.c.getrandom(buf.ptr, buf.len, <span class="tok-number">0</span>);
                <span class="tok-kw">break</span> :res .{ <span class="tok-builtin">@bitCast</span>(rc), errno(rc) };
            } <span class="tok-kw">else</span> res: {
                <span class="tok-kw">const</span> rc = linux.getrandom(buf.ptr, buf.len, <span class="tok-number">0</span>);
                <span class="tok-kw">break</span> :res .{ rc, linux.E.init(rc) };
            };

            <span class="tok-kw">switch</span> (err) {
                .SUCCESS =&gt; buf = buf[num_read..],
                .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                .FAULT =&gt; <span class="tok-kw">unreachable</span>,
                .INTR =&gt; <span class="tok-kw">continue</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
        }
        <span class="tok-kw">return</span>;
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .emscripten) {
        <span class="tok-kw">const</span> err = <a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.getentropy">getentropy</a>(buffer.ptr, buffer.len));
        <span class="tok-kw">switch</span> (err) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.getRandomBytesDevURandom">getRandomBytesDevURandom</a>(buffer);
}

<span class="tok-kw">fn</span> <span class="tok-fn">getRandomBytesDevURandom</span>(buf: []<span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.openZ">openZ</a>(<span class="tok-str">&quot;/dev/urandom&quot;</span>, .{ .ACCMODE = .RDONLY, .CLOEXEC = <span class="tok-null">true</span> }, <span class="tok-number">0</span>);
    <span class="tok-kw">defer</span> <a href="std.posix.html#std.posix.close">close</a>(fd);

    <span class="tok-kw">const</span> st = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.fstat">fstat</a>(fd);
    <span class="tok-kw">if</span> (!<a href="std.posix.html#std.posix.S">S</a>.<a href="#">ISCHR</a>(st.mode)) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoDevice;
    }

    <span class="tok-kw">const</span> file: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a> = .{ .handle = fd };
    <span class="tok-kw">const</span> stream = file.reader();
    stream.readNoEof(buf) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected;
}

<span class="tok-comment">/// Causes abnormal process termination.</span>
<span class="tok-comment">/// If linking against libc, this calls the abort() libc function. Otherwise</span>
<span class="tok-comment">/// it raises SIGABRT followed by SIGKILL and finally lo</span>
<span class="tok-comment">/// Invokes the current signal handler for SIGABRT, if any.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">abort</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);<span class="tok-comment">
    // MSVCRT abort() sometimes opens a popup window which is undesirable, so
    // even when linking libc on Windows we use our own abort implementation.
    // See https://github.com/ziglang/zig/issues/2071 for more details.
    </span><span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.mode">mode</a> == .Debug) {
            <span class="tok-builtin">@breakpoint</span>();
        }
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.ExitProcess">ExitProcess</a>(<span class="tok-number">3</span>);
    }
    <span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a> <span class="tok-kw">and</span> <a href="std.posix.html#std.posix.native_os">native_os</a> == .linux) {<span class="tok-comment">
        // The Linux man page says that the libc abort() function
        // &quot;first unblocks the SIGABRT signal&quot;, but this is a footgun
        // for user-defined signal handlers that want to restore some state in
        // some program sections and crash in others.
        // So, the user-installed SIGABRT handler is run, if present.
        </span><a href="std.posix.html#std.posix.raise">raise</a>(<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">ABRT</a>) <span class="tok-kw">catch</span> {};<span class="tok-comment">

        // Disable all signal handlers.
        </span><a href="std.posix.html#std.posix.sigprocmask">sigprocmask</a>(<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">BLOCK</a>, &amp;<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.all_mask">all_mask</a>, <span class="tok-null">null</span>);<span class="tok-comment">

        // Only one thread may proceed to the rest of abort().
        </span><span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>) {
            <span class="tok-kw">const</span> global = <span class="tok-kw">struct</span> {
                <span class="tok-kw">var</span> abort_entered: <span class="tok-type">bool</span> = <span class="tok-null">false</span>;
            };
            <span class="tok-kw">while</span> (<span class="tok-builtin">@cmpxchgWeak</span>(<span class="tok-type">bool</span>, &amp;global.abort_entered, <span class="tok-null">false</span>, <span class="tok-null">true</span>, .seq_cst, .seq_cst)) |_| {}
        }<span class="tok-comment">

        // Install default handler so that the tkill below will terminate.
        </span><span class="tok-kw">const</span> sigact = <a href="std.posix.html#std.posix.Sigaction">Sigaction</a>{
            .handler = .{ .handler = <a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">DFL</a> },
            .mask = <a href="std.posix.html#std.posix.empty_sigset">empty_sigset</a>,
            .flags = <span class="tok-number">0</span>,
        };
        <a href="std.posix.html#std.posix.sigaction">sigaction</a>(<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">ABRT</a>, &amp;sigact, <span class="tok-null">null</span>);

        _ = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.tkill">tkill</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.gettid">gettid</a>(), <a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">ABRT</a>);

        <span class="tok-kw">const</span> sigabrtmask: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.sigset_t">sigset_t</a> = [_]<span class="tok-type">u32</span>{<span class="tok-number">0</span>} ** <span class="tok-number">31</span> ++ [_]<span class="tok-type">u32</span>{<span class="tok-number">1</span> &lt;&lt; (<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">ABRT</a> - <span class="tok-number">1</span>)};
        <a href="std.posix.html#std.posix.sigprocmask">sigprocmask</a>(<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">UNBLOCK</a>, &amp;sigabrtmask, <span class="tok-null">null</span>);<span class="tok-comment">

        // Beyond this point should be unreachable.
        </span><span class="tok-builtin">@as</span>(*<span class="tok-kw">allowzero</span> <span class="tok-kw">volatile</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0</span>)).* = <span class="tok-number">0</span>;
        <a href="std.posix.html#std.posix.raise">raise</a>(<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">KILL</a>) <span class="tok-kw">catch</span> {};
        <a href="std.posix.html#std.posix.exit">exit</a>(<span class="tok-number">127</span>);<span class="tok-comment"> // Pid 1 might not be signalled in some containers.
    </span>}
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .uefi, .wasi, .emscripten, .cuda, .amdhsa =&gt; <span class="tok-builtin">@trap</span>(),
        <span class="tok-kw">else</span> =&gt; <a href="std.posix.html#std.posix.system">system</a>.<a href="#">abort</a>(),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RaiseError = <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">raise</span>(sig: <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.UnexpectedError">RaiseError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">raise</a>(sig))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .linux) {<span class="tok-comment">
        // https://git.musl-libc.org/cgit/musl/commit/?id=0bed7e0acfd34e3fb63ca0e4d99b7592571355a9
        //
        // Unlike musl, libc-less Zig std does not have any internal signals for implementation purposes, so we
        // need to block all signals on the assumption that any of them could potentially fork() in a handler.
        </span><span class="tok-kw">var</span> set: <a href="std.posix.html#std.posix.sigset_t">sigset_t</a> = <span class="tok-null">undefined</span>;
        <a href="std.posix.html#std.posix.sigprocmask">sigprocmask</a>(<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">BLOCK</a>, &amp;<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.all_mask">all_mask</a>, &amp;set);

        <span class="tok-kw">const</span> tid = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.gettid">gettid</a>();
        <span class="tok-kw">const</span> rc = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.tkill">tkill</a>(tid, sig);<span class="tok-comment">

        // restore signal mask
        </span><a href="std.posix.html#std.posix.sigprocmask">sigprocmask</a>(<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">SETMASK</a>, &amp;set, <span class="tok-null">null</span>);

        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.posix.raise unimplemented for this target&quot;</span>);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> KillError = <span class="tok-kw">error</span>{ ProcessNotFound, PermissionDenied } || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">kill</span>(pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>, sig: <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.KillError">KillError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">kill</a>(pid, sig))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid signal
        </span>.PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .SRCH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Exits all threads of the program with the specified status code.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">exit</span>(status: <span class="tok-type">u8</span>) <span class="tok-type">noreturn</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.exit">exit</a>(status);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.ExitProcess">ExitProcess</a>(status);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi) {
        <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.proc_exit">proc_exit</a>(status);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .linux <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>) {
        <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.exit_group">exit_group</a>(status);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .uefi) {
        <span class="tok-kw">const</span> uefi = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.uefi.html">uefi</a>;<span class="tok-comment">
        // exit() is only available if exitBootServices() has not been called yet.
        // This call to exit should not fail, so we don't care about its return value.
        </span><span class="tok-kw">if</span> (uefi.system_table.boot_services) |bs| {
            _ = bs.exit(uefi.handle, <span class="tok-builtin">@enumFromInt</span>(status), <span class="tok-number">0</span>, <span class="tok-null">null</span>);
        }<span class="tok-comment">
        // If we can't exit, reboot the system instead.
        </span>uefi.system_table.runtime_services.resetSystem(.reset_cold, <span class="tok-builtin">@enumFromInt</span>(status), <span class="tok-number">0</span>, <span class="tok-null">null</span>);
    }
    <a href="std.posix.html#std.posix.system">system</a>.<a href="#">exit</a>(status);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadError = <span class="tok-kw">error</span>{
    InputOutput,
    SystemResources,
    IsDir,
    OperationAborted,
    BrokenPipe,
    ConnectionResetByPeer,
    ConnectionTimedOut,
    NotOpenForReading,
    SocketNotConnected,

    <span class="tok-comment">/// This error occurs when no global event loop is configured,</span>
    <span class="tok-comment">/// and reading from the file descriptor would block.</span>
    WouldBlock,

    <span class="tok-comment">/// reading a timerfd with CANCEL_ON_SET will lead to this error</span>
    <span class="tok-comment">/// when the clock goes through a discontinuous change</span>
    Canceled,

    <span class="tok-comment">/// In WASI, this error occurs when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to read from it.</span>
    AccessDenied,

    <span class="tok-comment">/// This error occurs in Linux if the process to be read from</span>
    <span class="tok-comment">/// no longer exists.</span>
    ProcessNotFound,

    <span class="tok-comment">/// Unable to read file due to lock.</span>
    LockViolation,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Returns the number of bytes that were read, which can be less than</span>
<span class="tok-comment">/// buf.len. If 0 bytes were read, that means EOF.</span>
<span class="tok-comment">/// If `fd` is opened in non blocking mode, the function will return error.WouldBlock</span>
<span class="tok-comment">/// when EAGAIN is received.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Linux has a limit on how many bytes may be transferred in one `read` call, which is `0x7ffff000`</span>
<span class="tok-comment">/// on both 64-bit and 32-bit systems. This is due to using a signed C int as the return value, as</span>
<span class="tok-comment">/// well as stuffing the errno codes into the last `4096` values. This is noted on the `read` man page.</span>
<span class="tok-comment">/// The limit on Darwin is `0x7fffffff`, trying to read more than that returns EINVAL.</span>
<span class="tok-comment">/// The corresponding POSIX limit is `maxInt(isize)`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, buf: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (buf.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ReadFile">ReadFile</a>(fd, buf, <span class="tok-null">null</span>);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> iovs = [<span class="tok-number">1</span>]<a href="std.posix.iovec.html">iovec</a>{<a href="std.posix.iovec.html">iovec</a>{
            .base = buf.ptr,
            .len = buf.len,
        }};

        <span class="tok-kw">var</span> nread: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_read">fd_read</a>(fd, &amp;iovs, iovs.len, &amp;nread)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> nread,
            .INTR =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .AGAIN =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForReading,<span class="tok-comment"> // Can be a race condition.
            </span>.IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }<span class="tok-comment">

    // Prevents EINVAL.
    </span><span class="tok-kw">const</span> max_count = <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .linux =&gt; <span class="tok-number">0x7ffff000</span>,
        .macos, .ios, .watchos, .tvos, .visionos =&gt; <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">i32</span>),
        <span class="tok-kw">else</span> =&gt; <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">isize</span>),
    };
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">read</a>(fd, buf.ptr, <span class="tok-builtin">@min</span>(buf.len, max_count));
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .CANCELED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Canceled,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForReading,<span class="tok-comment"> // Can be a race condition.
            </span>.IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-comment">/// Number of bytes read is returned. Upon reading end-of-file, zero is returned.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// For POSIX systems, if `fd` is opened in non blocking mode, the function will</span>
<span class="tok-comment">/// return error.WouldBlock when EAGAIN is received.</span>
<span class="tok-comment">/// On Windows, if the application has a global event loop enabled, I/O Completion Ports are</span>
<span class="tok-comment">/// used to perform the I/O. `error.WouldBlock` is not possible on Windows.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This operation is non-atomic on the following systems:</span>
<span class="tok-comment">/// * Windows</span>
<span class="tok-comment">/// On these systems, the read races with concurrent writes to the same file descriptor.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This function assumes that all vectors, including zero-length vectors, have</span>
<span class="tok-comment">/// a pointer within the address space of the application.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readv</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, iov: []<span class="tok-kw">const</span> <a href="std.posix.iovec.html">iovec</a>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {<span class="tok-comment">
        // TODO improve this to use ReadFileScatter
        </span><span class="tok-kw">if</span> (iov.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> first = iov[<span class="tok-number">0</span>];
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.read">read</a>(fd, first.base[<span class="tok-number">0</span>..first.len]);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> nread: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_read">fd_read</a>(fd, iov.ptr, iov.len, &amp;nread)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> nread,
            .INTR =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .AGAIN =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // currently not support in WASI
            </span>.BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForReading,<span class="tok-comment"> // can be a race condition
            </span>.IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">readv</a>(fd, iov.ptr, <span class="tok-builtin">@min</span>(iov.len, <a href="std.posix.html#std.posix.IOV_MAX">IOV_MAX</a>));
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForReading,<span class="tok-comment"> // can be a race condition
            </span>.IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PReadError = <a href="std.posix.html#std.posix.ReadError">ReadError</a> || <span class="tok-kw">error</span>{Unseekable};

<span class="tok-comment">/// Number of bytes read is returned. Upon reading end-of-file, zero is returned.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Retries when interrupted by a signal.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// For POSIX systems, if `fd` is opened in non blocking mode, the function will</span>
<span class="tok-comment">/// return error.WouldBlock when EAGAIN is received.</span>
<span class="tok-comment">/// On Windows, if the application has a global event loop enabled, I/O Completion Ports are</span>
<span class="tok-comment">/// used to perform the I/O. `error.WouldBlock` is not possible on Windows.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Linux has a limit on how many bytes may be transferred in one `pread` call, which is `0x7ffff000`</span>
<span class="tok-comment">/// on both 64-bit and 32-bit systems. This is due to using a signed C int as the return value, as</span>
<span class="tok-comment">/// well as stuffing the errno codes into the last `4096` values. This is noted on the `read` man page.</span>
<span class="tok-comment">/// The limit on Darwin is `0x7fffffff`, trying to read more than that returns EINVAL.</span>
<span class="tok-comment">/// The corresponding POSIX limit is `maxInt(isize)`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pread</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, buf: []<span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PReadError">PReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (buf.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ReadFile">ReadFile</a>(fd, buf, offset);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> iovs = [<span class="tok-number">1</span>]<a href="std.posix.iovec.html">iovec</a>{<a href="std.posix.iovec.html">iovec</a>{
            .base = buf.ptr,
            .len = buf.len,
        }};

        <span class="tok-kw">var</span> nread: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_pread">fd_pread</a>(fd, &amp;iovs, iovs.len, offset, &amp;nread)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> nread,
            .INTR =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .AGAIN =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForReading,<span class="tok-comment"> // Can be a race condition.
            </span>.IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }<span class="tok-comment">

    // Prevent EINVAL.
    </span><span class="tok-kw">const</span> max_count = <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .linux =&gt; <span class="tok-number">0x7ffff000</span>,
        .macos, .ios, .watchos, .tvos, .visionos =&gt; <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">i32</span>),
        <span class="tok-kw">else</span> =&gt; <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">isize</span>),
    };

    <span class="tok-kw">const</span> pread_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">pread64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">pread</a>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = pread_sym(fd, buf.ptr, <span class="tok-builtin">@min</span>(buf.len, max_count), <span class="tok-builtin">@bitCast</span>(offset));
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForReading,<span class="tok-comment"> // Can be a race condition.
            </span>.IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TruncateError = <span class="tok-kw">error</span>{
    FileTooBig,
    InputOutput,
    FileBusy,

    <span class="tok-comment">/// In WASI, this error occurs when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to call `ftruncate` on it.</span>
    AccessDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ftruncate</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, length: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.TruncateError">TruncateError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> eof_info = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_END_OF_FILE_INFORMATION.html">FILE_END_OF_FILE_INFORMATION</a>{
            .EndOfFile = <span class="tok-builtin">@bitCast</span>(length),
        };

        <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtSetInformationFile">NtSetInformationFile</a>(
            fd,
            &amp;io_status_block,
            &amp;eof_info,
            <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_END_OF_FILE_INFORMATION.html">FILE_END_OF_FILE_INFORMATION</a>),
            .FileEndOfFileInformation,
        );

        <span class="tok-kw">switch</span> (rc) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .INVALID_HANDLE =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handle not open for writing
            </span>.ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .USER_MAPPED_FILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedStatus">unexpectedStatus</a>(rc),
        }
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_filestat_set_size">fd_filestat_set_size</a>(fd, length)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .INTR =&gt; <span class="tok-kw">unreachable</span>,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .TXTBSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handle not open for writing
            </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handle not open for writing
            </span>.NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">const</span> ftruncate_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">ftruncate64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">ftruncate</a>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(ftruncate_sym(fd, <span class="tok-builtin">@bitCast</span>(length)))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .TXTBSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handle not open for writing
            </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handle not open for writing
            </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-comment">/// Number of bytes read is returned. Upon reading end-of-file, zero is returned.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Retries when interrupted by a signal.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// For POSIX systems, if `fd` is opened in non blocking mode, the function will</span>
<span class="tok-comment">/// return error.WouldBlock when EAGAIN is received.</span>
<span class="tok-comment">/// On Windows, if the application has a global event loop enabled, I/O Completion Ports are</span>
<span class="tok-comment">/// used to perform the I/O. `error.WouldBlock` is not possible on Windows.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This operation is non-atomic on the following systems:</span>
<span class="tok-comment">/// * Darwin</span>
<span class="tok-comment">/// * Windows</span>
<span class="tok-comment">/// On these systems, the read races with concurrent writes to the same file descriptor.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">preadv</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, iov: []<span class="tok-kw">const</span> <a href="std.posix.iovec.html">iovec</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PReadError">PReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> have_pread_but_not_preadv = <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .windows, .macos, .ios, .watchos, .tvos, .visionos, .haiku =&gt; <span class="tok-null">true</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
    };
    <span class="tok-kw">if</span> (have_pread_but_not_preadv) {<span class="tok-comment">
        // We could loop here; but proper usage of `preadv` must handle partial reads anyway.
        // So we simply read into the first vector only.
        </span><span class="tok-kw">if</span> (iov.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> first = iov[<span class="tok-number">0</span>];
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.pread">pread</a>(fd, first.base[<span class="tok-number">0</span>..first.len], offset);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> nread: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_pread">fd_pread</a>(fd, iov.ptr, iov.len, offset, &amp;nread)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> nread,
            .INTR =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .AGAIN =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForReading,<span class="tok-comment"> // can be a race condition
            </span>.IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">const</span> preadv_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">preadv64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">preadv</a>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = preadv_sym(fd, iov.ptr, <span class="tok-builtin">@min</span>(iov.len, <a href="std.posix.html#std.posix.IOV_MAX">IOV_MAX</a>), <span class="tok-builtin">@bitCast</span>(offset));
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForReading,<span class="tok-comment"> // can be a race condition
            </span>.IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteError = <span class="tok-kw">error</span>{
    DiskQuota,
    FileTooBig,
    InputOutput,
    NoSpaceLeft,
    DeviceBusy,
    InvalidArgument,

    <span class="tok-comment">/// File descriptor does not hold the required rights to write to it.</span>
    AccessDenied,
    BrokenPipe,
    SystemResources,
    OperationAborted,
    NotOpenForWriting,

    <span class="tok-comment">/// The process cannot access the file because another process has locked</span>
    <span class="tok-comment">/// a portion of the file. Windows-only.</span>
    LockViolation,

    <span class="tok-comment">/// This error occurs when no global event loop is configured,</span>
    <span class="tok-comment">/// and reading from the file descriptor would block.</span>
    WouldBlock,

    <span class="tok-comment">/// Connection reset by peer.</span>
    ConnectionResetByPeer,

    <span class="tok-comment">/// This error occurs in Linux if the process being written to</span>
    <span class="tok-comment">/// no longer exists.</span>
    ProcessNotFound,
    <span class="tok-comment">/// This error occurs when a device gets disconnected before or mid-flush</span>
    <span class="tok-comment">/// while it's being written to - errno(6): No such device or address.</span>
    NoDevice,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Write to a file descriptor.</span>
<span class="tok-comment">/// Retries when interrupted by a signal.</span>
<span class="tok-comment">/// Returns the number of bytes written. If nonzero bytes were supplied, this will be nonzero.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Note that a successful write() may transfer fewer than count bytes.  Such partial  writes  can</span>
<span class="tok-comment">/// occur  for  various reasons; for example, because there was insufficient space on the disk</span>
<span class="tok-comment">/// device to write all of the requested bytes, or because a blocked write() to a socket,  pipe,  or</span>
<span class="tok-comment">/// similar  was  interrupted by a signal handler after it had transferred some, but before it had</span>
<span class="tok-comment">/// transferred all of the requested bytes.  In the event of a partial write, the caller can  make</span>
<span class="tok-comment">/// another  write() call to transfer the remaining bytes.  The subsequent call will either</span>
<span class="tok-comment">/// transfer further bytes or may result in an error (e.g., if the disk is now full).</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// For POSIX systems, if `fd` is opened in non blocking mode, the function will</span>
<span class="tok-comment">/// return error.WouldBlock when EAGAIN is received.</span>
<span class="tok-comment">/// On Windows, if the application has a global event loop enabled, I/O Completion Ports are</span>
<span class="tok-comment">/// used to perform the I/O. `error.WouldBlock` is not possible on Windows.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Linux has a limit on how many bytes may be transferred in one `write` call, which is `0x7ffff000`</span>
<span class="tok-comment">/// on both 64-bit and 32-bit systems. This is due to using a signed C int as the return value, as</span>
<span class="tok-comment">/// well as stuffing the errno codes into the last `4096` values. This is noted on the `write` man page.</span>
<span class="tok-comment">/// The limit on Darwin is `0x7fffffff`, trying to read more than that returns EINVAL.</span>
<span class="tok-comment">/// The corresponding POSIX limit is `maxInt(isize)`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (bytes.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.WriteFile">WriteFile</a>(fd, bytes, <span class="tok-null">null</span>);
    }

    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> ciovs = [_]<a href="std.posix.iovec_const.html">iovec_const</a>{<a href="std.posix.iovec_const.html">iovec_const</a>{
            .base = bytes.ptr,
            .len = bytes.len,
        }};
        <span class="tok-kw">var</span> nwritten: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_write">fd_write</a>(fd, &amp;ciovs, ciovs.len, &amp;nwritten)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> nwritten,
            .INTR =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .AGAIN =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForWriting,<span class="tok-comment"> // can be a race condition.
            </span>.DESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // `connect` was never called.
            </span>.DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">const</span> max_count = <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .linux =&gt; <span class="tok-number">0x7ffff000</span>,
        .macos, .ios, .watchos, .tvos, .visionos =&gt; <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">i32</span>),
        <span class="tok-kw">else</span> =&gt; <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">isize</span>),
    };
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">write</a>(fd, bytes.ptr, <span class="tok-builtin">@min</span>(bytes.len, max_count));
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidArgument,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForWriting,<span class="tok-comment"> // can be a race condition.
            </span>.DESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // `connect` was never called.
            </span>.DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeviceBusy,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoDevice,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-comment">/// Write multiple buffers to a file descriptor.</span>
<span class="tok-comment">/// Retries when interrupted by a signal.</span>
<span class="tok-comment">/// Returns the number of bytes written. If nonzero bytes were supplied, this will be nonzero.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Note that a successful write() may transfer fewer bytes than supplied.  Such partial  writes  can</span>
<span class="tok-comment">/// occur  for  various reasons; for example, because there was insufficient space on the disk</span>
<span class="tok-comment">/// device to write all of the requested bytes, or because a blocked write() to a socket,  pipe,  or</span>
<span class="tok-comment">/// similar  was  interrupted by a signal handler after it had transferred some, but before it had</span>
<span class="tok-comment">/// transferred all of the requested bytes.  In the event of a partial write, the caller can  make</span>
<span class="tok-comment">/// another  write() call to transfer the remaining bytes.  The subsequent call will either</span>
<span class="tok-comment">/// transfer further bytes or may result in an error (e.g., if the disk is now full).</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// For POSIX systems, if `fd` is opened in non blocking mode, the function will</span>
<span class="tok-comment">/// return error.WouldBlock when EAGAIN is received.</span>
<span class="tok-comment">/// On Windows, if the application has a global event loop enabled, I/O Completion Ports are</span>
<span class="tok-comment">/// used to perform the I/O. `error.WouldBlock` is not possible on Windows.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// If `iov.len` is larger than `IOV_MAX`, a partial write will occur.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This function assumes that all vectors, including zero-length vectors, have</span>
<span class="tok-comment">/// a pointer within the address space of the application.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writev</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, iov: []<span class="tok-kw">const</span> <a href="std.posix.iovec_const.html">iovec_const</a>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {<span class="tok-comment">
        // TODO improve this to use WriteFileScatter
        </span><span class="tok-kw">if</span> (iov.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> first = iov[<span class="tok-number">0</span>];
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.write">write</a>(fd, first.base[<span class="tok-number">0</span>..first.len]);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> nwritten: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_write">fd_write</a>(fd, iov.ptr, iov.len, &amp;nwritten)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> nwritten,
            .INTR =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .AGAIN =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForWriting,<span class="tok-comment"> // can be a race condition.
            </span>.DESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // `connect` was never called.
            </span>.DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">writev</a>(fd, iov.ptr, <span class="tok-builtin">@min</span>(iov.len, <a href="std.posix.html#std.posix.IOV_MAX">IOV_MAX</a>));
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidArgument,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForWriting,<span class="tok-comment"> // Can be a race condition.
            </span>.DESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // `connect` was never called.
            </span>.DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeviceBusy,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PWriteError = <a href="std.posix.html#std.posix.WriteError">WriteError</a> || <span class="tok-kw">error</span>{Unseekable};

<span class="tok-comment">/// Write to a file descriptor, with a position offset.</span>
<span class="tok-comment">/// Retries when interrupted by a signal.</span>
<span class="tok-comment">/// Returns the number of bytes written. If nonzero bytes were supplied, this will be nonzero.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Note that a successful write() may transfer fewer bytes than supplied.  Such partial  writes  can</span>
<span class="tok-comment">/// occur  for  various reasons; for example, because there was insufficient space on the disk</span>
<span class="tok-comment">/// device to write all of the requested bytes, or because a blocked write() to a socket,  pipe,  or</span>
<span class="tok-comment">/// similar  was  interrupted by a signal handler after it had transferred some, but before it had</span>
<span class="tok-comment">/// transferred all of the requested bytes.  In the event of a partial write, the caller can  make</span>
<span class="tok-comment">/// another  write() call to transfer the remaining bytes.  The subsequent call will either</span>
<span class="tok-comment">/// transfer further bytes or may result in an error (e.g., if the disk is now full).</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// For POSIX systems, if `fd` is opened in non blocking mode, the function will</span>
<span class="tok-comment">/// return error.WouldBlock when EAGAIN is received.</span>
<span class="tok-comment">/// On Windows, if the application has a global event loop enabled, I/O Completion Ports are</span>
<span class="tok-comment">/// used to perform the I/O. `error.WouldBlock` is not possible on Windows.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Linux has a limit on how many bytes may be transferred in one `pwrite` call, which is `0x7ffff000`</span>
<span class="tok-comment">/// on both 64-bit and 32-bit systems. This is due to using a signed C int as the return value, as</span>
<span class="tok-comment">/// well as stuffing the errno codes into the last `4096` values. This is noted on the `write` man page.</span>
<span class="tok-comment">/// The limit on Darwin is `0x7fffffff`, trying to write more than that returns EINVAL.</span>
<span class="tok-comment">/// The corresponding POSIX limit is `maxInt(isize)`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pwrite</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PWriteError">PWriteError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (bytes.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.WriteFile">WriteFile</a>(fd, bytes, offset);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> ciovs = [<span class="tok-number">1</span>]<a href="std.posix.iovec_const.html">iovec_const</a>{<a href="std.posix.iovec_const.html">iovec_const</a>{
            .base = bytes.ptr,
            .len = bytes.len,
        }};

        <span class="tok-kw">var</span> nwritten: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_pwrite">fd_pwrite</a>(fd, &amp;ciovs, ciovs.len, offset, &amp;nwritten)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> nwritten,
            .INTR =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .AGAIN =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForWriting,<span class="tok-comment"> // can be a race condition.
            </span>.DESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // `connect` was never called.
            </span>.DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }<span class="tok-comment">

    // Prevent EINVAL.
    </span><span class="tok-kw">const</span> max_count = <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .linux =&gt; <span class="tok-number">0x7ffff000</span>,
        .macos, .ios, .watchos, .tvos, .visionos =&gt; <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">i32</span>),
        <span class="tok-kw">else</span> =&gt; <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">isize</span>),
    };

    <span class="tok-kw">const</span> pwrite_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">pwrite64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">pwrite</a>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = pwrite_sym(fd, bytes.ptr, <span class="tok-builtin">@min</span>(bytes.len, max_count), <span class="tok-builtin">@bitCast</span>(offset));
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidArgument,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForWriting,<span class="tok-comment"> // Can be a race condition.
            </span>.DESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // `connect` was never called.
            </span>.DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeviceBusy,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-comment">/// Write multiple buffers to a file descriptor, with a position offset.</span>
<span class="tok-comment">/// Retries when interrupted by a signal.</span>
<span class="tok-comment">/// Returns the number of bytes written. If nonzero bytes were supplied, this will be nonzero.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Note that a successful write() may transfer fewer than count bytes.  Such partial  writes  can</span>
<span class="tok-comment">/// occur  for  various reasons; for example, because there was insufficient space on the disk</span>
<span class="tok-comment">/// device to write all of the requested bytes, or because a blocked write() to a socket,  pipe,  or</span>
<span class="tok-comment">/// similar  was  interrupted by a signal handler after it had transferred some, but before it had</span>
<span class="tok-comment">/// transferred all of the requested bytes.  In the event of a partial write, the caller can  make</span>
<span class="tok-comment">/// another  write() call to transfer the remaining bytes.  The subsequent call will either</span>
<span class="tok-comment">/// transfer further bytes or may result in an error (e.g., if the disk is now full).</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// If `fd` is opened in non blocking mode, the function will</span>
<span class="tok-comment">/// return error.WouldBlock when EAGAIN is received.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The following systems do not have this syscall, and will return partial writes if more than one</span>
<span class="tok-comment">/// vector is provided:</span>
<span class="tok-comment">/// * Darwin</span>
<span class="tok-comment">/// * Windows</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// If `iov.len` is larger than `IOV_MAX`, a partial write will occur.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pwritev</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, iov: []<span class="tok-kw">const</span> <a href="std.posix.iovec_const.html">iovec_const</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PWriteError">PWriteError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> have_pwrite_but_not_pwritev = <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .windows, .macos, .ios, .watchos, .tvos, .visionos, .haiku =&gt; <span class="tok-null">true</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
    };

    <span class="tok-kw">if</span> (have_pwrite_but_not_pwritev) {<span class="tok-comment">
        // We could loop here; but proper usage of `pwritev` must handle partial writes anyway.
        // So we simply write the first vector only.
        </span><span class="tok-kw">if</span> (iov.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> first = iov[<span class="tok-number">0</span>];
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.pwrite">pwrite</a>(fd, first.base[<span class="tok-number">0</span>..first.len], offset);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> nwritten: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_pwrite">fd_pwrite</a>(fd, iov.ptr, iov.len, offset, &amp;nwritten)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> nwritten,
            .INTR =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .AGAIN =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForWriting,<span class="tok-comment"> // Can be a race condition.
            </span>.DESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // `connect` was never called.
            </span>.DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">const</span> pwritev_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">pwritev64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">pwritev</a>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = pwritev_sym(fd, iov.ptr, <span class="tok-builtin">@min</span>(iov.len, <a href="std.posix.html#std.posix.IOV_MAX">IOV_MAX</a>), <span class="tok-builtin">@bitCast</span>(offset));
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidArgument,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotOpenForWriting,<span class="tok-comment"> // Can be a race condition.
            </span>.DESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // `connect` was never called.
            </span>.DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeviceBusy,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to open a new resource relative to it.</span>
    AccessDenied,
    SymLinkLoop,
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    NoDevice,
    <span class="tok-comment">/// Either:</span>
    <span class="tok-comment">/// * One of the path components does not exist.</span>
    <span class="tok-comment">/// * Cwd was used, but cwd has been deleted.</span>
    <span class="tok-comment">/// * The path associated with the open directory handle has been deleted.</span>
    <span class="tok-comment">/// * On macOS, multiple processes or threads raced to create the same file</span>
    <span class="tok-comment">///   with `O.EXCL` set to `false`.</span>
    FileNotFound,

    <span class="tok-comment">/// The path exceeded `max_path_bytes` bytes.</span>
    NameTooLong,

    <span class="tok-comment">/// Insufficient kernel memory was available, or</span>
    <span class="tok-comment">/// the named file is a FIFO and per-user hard limit on</span>
    <span class="tok-comment">/// memory allocation for pipes has been reached.</span>
    SystemResources,

    <span class="tok-comment">/// The file is too large to be opened. This error is unreachable</span>
    <span class="tok-comment">/// for 64-bit targets, as well as when opening directories.</span>
    FileTooBig,

    <span class="tok-comment">/// The path refers to directory but the `DIRECTORY` flag was not provided.</span>
    IsDir,

    <span class="tok-comment">/// A new path cannot be created because the device has no room for the new file.</span>
    <span class="tok-comment">/// This error is only reachable when the `CREAT` flag is provided.</span>
    NoSpaceLeft,

    <span class="tok-comment">/// A component used as a directory in the path was not, in fact, a directory, or</span>
    <span class="tok-comment">/// `DIRECTORY` was specified and the path was not a directory.</span>
    NotDir,

    <span class="tok-comment">/// The path already exists and the `CREAT` and `EXCL` flags were provided.</span>
    PathAlreadyExists,
    DeviceBusy,

    <span class="tok-comment">/// The underlying filesystem does not support file locks</span>
    FileLocksNotSupported,

    <span class="tok-comment">/// Path contains characters that are disallowed by the underlying filesystem.</span>
    BadPathName,

    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,

    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,

    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,

    <span class="tok-comment">/// One of these three things:</span>
    <span class="tok-comment">/// * pathname  refers to an executable image which is currently being</span>
    <span class="tok-comment">///   executed and write access was requested.</span>
    <span class="tok-comment">/// * pathname refers to a file that is currently in  use  as  a  swap</span>
    <span class="tok-comment">///   file, and the O_TRUNC flag was specified.</span>
    <span class="tok-comment">/// * pathname  refers  to  a file that is currently being read by the</span>
    <span class="tok-comment">///   kernel (e.g., for module/firmware loading), and write access was</span>
    <span class="tok-comment">///   requested.</span>
    FileBusy,

    WouldBlock,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Open and possibly create a file. Keeps trying if it gets interrupted.</span>
<span class="tok-comment">/// On Windows, `file_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `file_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `file_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">/// See also `openZ`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">open</span>(file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.posix.html#std.posix.O">O</a>, perm: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.OpenError">OpenError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Windows does not support POSIX; use Windows-specific API or cross-platform std.fs API&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.openat">openat</a>(<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, file_path, flags, perm);
    }
    <span class="tok-kw">const</span> file_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(file_path);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.openZ">openZ</a>(&amp;file_path_c, flags, perm);
}

<span class="tok-comment">/// Open and possibly create a file. Keeps trying if it gets interrupted.</span>
<span class="tok-comment">/// On Windows, `file_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `file_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `file_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">/// See also `open`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openZ</span>(file_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.posix.html#std.posix.O">O</a>, perm: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.OpenError">OpenError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Windows does not support POSIX; use Windows-specific API or cross-platform std.fs API&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.open">open</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(file_path, <span class="tok-number">0</span>), flags, perm);
    }

    <span class="tok-kw">const</span> open_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">open64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">open</a>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = open_sym(file_path, flags, perm);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,

            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadPathName,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
            .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
            .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
            .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
            .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoDevice,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
            .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeviceBusy,
            .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
            <span class="tok-kw">else</span>
                <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-comment">/// Open and possibly create a file. Keeps trying if it gets interrupted.</span>
<span class="tok-comment">/// `file_path` is relative to the open directory handle `dir_fd`.</span>
<span class="tok-comment">/// On Windows, `file_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `file_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `file_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">/// See also `openatZ`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openat</span>(dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.posix.html#std.posix.O">O</a>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.OpenError">OpenError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Windows does not support POSIX; use Windows-specific API or cross-platform std.fs API&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {<span class="tok-comment">
        // `mode` is ignored on WASI, which does not support unix-style file permissions
        </span><span class="tok-kw">const</span> opts = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.openOptionsFromFlagsWasi">openOptionsFromFlagsWasi</a>(flags);
        <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.openatWasi">openatWasi</a>(
            dir_fd,
            file_path,
            opts.lookup_flags,
            opts.oflags,
            opts.fs_flags,
            opts.fs_rights_base,
            opts.fs_rights_inheriting,
        );
        <span class="tok-kw">errdefer</span> <a href="std.posix.html#std.posix.close">close</a>(fd);

        <span class="tok-kw">if</span> (flags.write) {
            <span class="tok-kw">const</span> info = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.fstat_wasi">fstat_wasi</a>(fd);
            <span class="tok-kw">if</span> (info.filetype == .DIRECTORY)
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir;
        }

        <span class="tok-kw">return</span> fd;
    }
    <span class="tok-kw">const</span> file_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(file_path);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.openatZ">openatZ</a>(dir_fd, &amp;file_path_c, flags, mode);
}

<span class="tok-comment">/// Open and possibly create a file in WASI.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openatWasi</span>(
    dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    lookup_flags: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.lookupflags_t.html">lookupflags_t</a>,
    oflags: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.oflags_t.html">oflags_t</a>,
    fdflags: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.fdflags_t.html">fdflags_t</a>,
    base: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.rights_t.html">rights_t</a>,
    inheriting: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.rights_t.html">rights_t</a>,
) <a href="std.posix.html#std.posix.OpenError">OpenError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">var</span> fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.path_open">path_open</a>(dir_fd, lookup_flags, file_path.ptr, file_path.len, oflags, base, inheriting, fdflags, &amp;fd)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> fd,
            .INTR =&gt; <span class="tok-kw">continue</span>,

            .FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment">
            // Provides INVAL with a linux host on a bad path name, but NOENT on Windows
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadPathName,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
            .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
            .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
            .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
            .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoDevice,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
            .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeviceBusy,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .ILSEQ =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-comment">/// A struct to contain all lookup/rights flags accepted by `wasi.path_open`</span>
<span class="tok-kw">const</span> WasiOpenOptions = <span class="tok-kw">struct</span> {
    oflags: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.oflags_t.html">oflags_t</a>,
    lookup_flags: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.lookupflags_t.html">lookupflags_t</a>,
    fs_rights_base: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.rights_t.html">rights_t</a>,
    fs_rights_inheriting: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.rights_t.html">rights_t</a>,
    fs_flags: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.fdflags_t.html">fdflags_t</a>,
};

<span class="tok-comment">/// Compute rights + flags corresponding to the provided POSIX access mode.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">openOptionsFromFlagsWasi</span>(oflag: <a href="std.posix.html#std.posix.O">O</a>) <a href="std.posix.html#std.posix.OpenError">OpenError</a>!<a href="std.posix.WasiOpenOptions.html">WasiOpenOptions</a> {
    <span class="tok-kw">const</span> w = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>;<span class="tok-comment">

    // Next, calculate the read/write rights to request, depending on the
    // provided POSIX access mode
    </span><span class="tok-kw">var</span> rights: w.rights_t = .{};
    <span class="tok-kw">if</span> (oflag.read) {
        rights.FD_READ = <span class="tok-null">true</span>;
        rights.FD_READDIR = <span class="tok-null">true</span>;
    }
    <span class="tok-kw">if</span> (oflag.write) {
        rights.FD_DATASYNC = <span class="tok-null">true</span>;
        rights.FD_WRITE = <span class="tok-null">true</span>;
        rights.FD_ALLOCATE = <span class="tok-null">true</span>;
        rights.FD_FILESTAT_SET_SIZE = <span class="tok-null">true</span>;
    }<span class="tok-comment">

    // https://github.com/ziglang/zig/issues/18882
    </span><span class="tok-kw">const</span> flag_bits: <span class="tok-type">u32</span> = <span class="tok-builtin">@bitCast</span>(oflag);
    <span class="tok-kw">const</span> oflags_int: <span class="tok-type">u16</span> = <span class="tok-builtin">@as</span>(<span class="tok-type">u12</span>, <span class="tok-builtin">@truncate</span>(flag_bits &gt;&gt; <span class="tok-number">12</span>));
    <span class="tok-kw">const</span> fs_flags_int: <span class="tok-type">u16</span> = <span class="tok-builtin">@as</span>(<span class="tok-type">u12</span>, <span class="tok-builtin">@truncate</span>(flag_bits));

    <span class="tok-kw">return</span> .{<span class="tok-comment">
        // https://github.com/ziglang/zig/issues/18882
        </span>.oflags = <span class="tok-builtin">@bitCast</span>(oflags_int),
        .lookup_flags = .{
            .SYMLINK_FOLLOW = !oflag.NOFOLLOW,
        },
        .fs_rights_base = rights,
        .fs_rights_inheriting = rights,<span class="tok-comment">
        // https://github.com/ziglang/zig/issues/18882
        </span>.fs_flags = <span class="tok-builtin">@bitCast</span>(fs_flags_int),
    };
}

<span class="tok-comment">/// Open and possibly create a file. Keeps trying if it gets interrupted.</span>
<span class="tok-comment">/// `file_path` is relative to the open directory handle `dir_fd`.</span>
<span class="tok-comment">/// On Windows, `file_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `file_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `file_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">/// See also `openat`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openatZ</span>(dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.posix.html#std.posix.O">O</a>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.OpenError">OpenError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Windows does not support POSIX; use Windows-specific API or cross-platform std.fs API&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.openat">openat</a>(dir_fd, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(file_path, <span class="tok-number">0</span>), flags, mode);
    }

    <span class="tok-kw">const</span> openat_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">openat64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">openat</a>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = openat_sym(dir_fd, file_path, flags, mode);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,

            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadPathName,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
            .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
            .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
            .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
            .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
            .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
            .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoDevice,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
            .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeviceBusy,
            .OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileLocksNotSupported,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .TXTBSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoDevice,
            .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
            <span class="tok-kw">else</span>
                <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dup</span>(old_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) !<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">dup</a>(old_fd);
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        .MFILE =&gt; <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid file descriptor
        </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dup2</span>(old_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, new_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">dup2</a>(old_fd, new_fd))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BUSY, .INTR =&gt; <span class="tok-kw">continue</span>,
            .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid parameters passed to dup2
            </span>.BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid file descriptor
            </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExecveError = <span class="tok-kw">error</span>{
    SystemResources,
    AccessDenied,
    InvalidExe,
    FileSystem,
    IsDir,
    FileNotFound,
    NotDir,
    FileBusy,
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    NameTooLong,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// This function ignores PATH environment variable. See `execvpeZ` for that.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">execveZ</span>(
    path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    child_argv: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    envp: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.posix.html#std.posix.ExecveError">ExecveError</a> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">execve</a>(path, child_argv, envp))) {
        .SUCCESS =&gt; <span class="tok-kw">unreachable</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .@&quot;2BIG&quot; =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExe,
        .NOEXEC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExe,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .TXTBSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
            .macos, .ios, .tvos, .watchos, .visionos =&gt; <span class="tok-kw">switch</span> (err) {
                .BADEXEC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExe,
                .BADARCH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExe,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            },
            .linux =&gt; <span class="tok-kw">switch</span> (err) {
                .LIBBAD =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExe,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        },
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Arg0Expand = <span class="tok-kw">enum</span> {
    expand,
    no_expand,
};

<span class="tok-comment">/// Like `execvpeZ` except if `arg0_expand` is `.expand`, then `argv` is mutable,</span>
<span class="tok-comment">/// and `argv[0]` is expanded to be the same absolute path that is passed to the execve syscall.</span>
<span class="tok-comment">/// If this function returns with an error, `argv[0]` will be restored to the value it was when it was passed in.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">execvpeZ_expandArg0</span>(
    <span class="tok-kw">comptime</span> arg0_expand: <a href="std.posix.Arg0Expand.html">Arg0Expand</a>,
    file: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    child_argv: <span class="tok-kw">switch</span> (arg0_expand) {
        .expand =&gt; [*:<span class="tok-null">null</span>]?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        .no_expand =&gt; [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    },
    envp: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.posix.html#std.posix.ExecveError">ExecveError</a> {
    <span class="tok-kw">const</span> file_slice = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(file, <span class="tok-number">0</span>);
    <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, file_slice, <span class="tok-str">'/'</span>) != <span class="tok-null">null</span>) <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.execveZ">execveZ</a>(file, child_argv, envp);

    <span class="tok-kw">const</span> PATH = <a href="std.posix.html#std.posix.getenvZ">getenvZ</a>(<span class="tok-str">&quot;PATH&quot;</span>) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;/usr/local/bin:/bin/:/usr/bin&quot;</span>;<span class="tok-comment">
    // Use of PATH_MAX here is valid as the path_buf will be passed
    // directly to the operating system in execveZ.
    </span><span class="tok-kw">var</span> path_buf: [<a href="std.posix.html#std.posix.PATH_MAX">PATH_MAX</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, PATH, <span class="tok-str">':'</span>);
    <span class="tok-kw">var</span> seen_eacces = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> err: <a href="std.posix.html#std.posix.ExecveError">ExecveError</a> = <span class="tok-kw">error</span>.FileNotFound;<span class="tok-comment">

    // In case of expanding arg0 we must put it back if we return with an error.
    </span><span class="tok-kw">const</span> prev_arg0 = child_argv[<span class="tok-number">0</span>];
    <span class="tok-kw">defer</span> <span class="tok-kw">switch</span> (arg0_expand) {
        .expand =&gt; child_argv[<span class="tok-number">0</span>] = prev_arg0,
        .no_expand =&gt; {},
    };

    <span class="tok-kw">while</span> (it.next()) |search_path| {
        <span class="tok-kw">const</span> path_len = search_path.len + file_slice.len + <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (path_buf.len &lt; path_len + <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
        <span class="tok-builtin">@memcpy</span>(path_buf[<span class="tok-number">0</span>..search_path.len], search_path);
        path_buf[search_path.len] = <span class="tok-str">'/'</span>;
        <span class="tok-builtin">@memcpy</span>(path_buf[search_path.len + <span class="tok-number">1</span> ..][<span class="tok-number">0</span>..file_slice.len], file_slice);
        path_buf[path_len] = <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> full_path = path_buf[<span class="tok-number">0</span>..path_len :<span class="tok-number">0</span>].ptr;
        <span class="tok-kw">switch</span> (arg0_expand) {
            .expand =&gt; child_argv[<span class="tok-number">0</span>] = full_path,
            .no_expand =&gt; {},
        }
        err = <a href="std.posix.html#std.posix.execveZ">execveZ</a>(full_path, child_argv, envp);
        <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.AccessDenied =&gt; seen_eacces = <span class="tok-null">true</span>,
            <span class="tok-kw">error</span>.FileNotFound, <span class="tok-kw">error</span>.NotDir =&gt; {},
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        }
    }
    <span class="tok-kw">if</span> (seen_eacces) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied;
    <span class="tok-kw">return</span> err;
}

<span class="tok-comment">/// This function also uses the PATH environment variable to get the full path to the executable.</span>
<span class="tok-comment">/// If `file` is an absolute path, this is the same as `execveZ`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">execvpeZ</span>(
    file: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    argv_ptr: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    envp: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.posix.html#std.posix.ExecveError">ExecveError</a> {
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.execvpeZ_expandArg0">execvpeZ_expandArg0</a>(.no_expand, file, argv_ptr, envp);
}

<span class="tok-comment">/// Get an environment variable.</span>
<span class="tok-comment">/// See also `getenvZ`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getenv</span>(key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.posix.getenv is unavailable for Windows because environment strings are in WTF-16 format. See std.process.getEnvVarOwned for a cross-platform API or std.process.getenvW for a Windows-specific API.&quot;</span>);
    }
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> ptr = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.environ">environ</a>;
        <span class="tok-kw">while</span> (ptr[<span class="tok-number">0</span>]) |line| : (ptr += <span class="tok-number">1</span>) {
            <span class="tok-kw">var</span> line_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (line[line_i] != <span class="tok-number">0</span> <span class="tok-kw">and</span> line[line_i] != <span class="tok-str">'='</span>) : (line_i += <span class="tok-number">1</span>) {}
            <span class="tok-kw">const</span> this_key = line[<span class="tok-number">0</span>..line_i];

            <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, this_key, key)) <span class="tok-kw">continue</span>;

            <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(line + line_i + <span class="tok-number">1</span>, <span class="tok-number">0</span>);
        }
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.posix.getenv is unavailable for WASI. See std.process.getEnvMap or std.process.getEnvVarOwned for a cross-platform API.&quot;</span>);
    }<span class="tok-comment">
    // The simplified start logic doesn't populate environ.
    </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.start.html">start</a>.<a href="std.start.html#std.start.simplified_logic">simplified_logic</a>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;<span class="tok-comment">
    // TODO see https://github.com/ziglang/zig/issues/4524
    </span><span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.environ">environ</a>) |ptr| {
        <span class="tok-kw">var</span> line_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (ptr[line_i] != <span class="tok-number">0</span> <span class="tok-kw">and</span> ptr[line_i] != <span class="tok-str">'='</span>) : (line_i += <span class="tok-number">1</span>) {}
        <span class="tok-kw">const</span> this_key = ptr[<span class="tok-number">0</span>..line_i];
        <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, key, this_key)) <span class="tok-kw">continue</span>;

        <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(ptr + line_i + <span class="tok-number">1</span>, <span class="tok-number">0</span>);
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-comment">/// Get an environment variable with a null-terminated name.</span>
<span class="tok-comment">/// See also `getenv`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getenvZ</span>(key: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> value = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">getenv</a>(key) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(value, <span class="tok-number">0</span>);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.posix.getenvZ is unavailable for Windows because environment string is in WTF-16 format. See std.process.getEnvVarOwned for cross-platform API or std.process.getenvW for Windows-specific API.&quot;</span>);
    }
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.getenv">getenv</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(key, <span class="tok-number">0</span>));
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetCwdError = <span class="tok-kw">error</span>{
    NameTooLong,
    CurrentWorkingDirectoryUnlinked,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// The result is a slice of out_buffer, indexed from 0.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getcwd</span>(out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.GetCwdError">GetCwdError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetCurrentDirectory">GetCurrentDirectory</a>(out_buffer);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> path = <span class="tok-str">&quot;.&quot;</span>;
        <span class="tok-kw">if</span> (out_buffer.len &lt; path.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
        <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..path.len];
        <span class="tok-builtin">@memcpy</span>(result, path);
        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">const</span> err: <a href="std.posix.html#std.posix.E">E</a> = <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) err: {
        <span class="tok-kw">const</span> c_err = <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.getcwd">getcwd</a>(out_buffer.ptr, out_buffer.len)) |_| <span class="tok-number">0</span> <span class="tok-kw">else</span> <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c._errno">_errno</a>().*;
        <span class="tok-kw">break</span> :err <span class="tok-builtin">@enumFromInt</span>(c_err);
    } <span class="tok-kw">else</span> err: {
        <span class="tok-kw">break</span> :err <a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">getcwd</a>(out_buffer.ptr, out_buffer.len));
    };
    <span class="tok-kw">switch</span> (err) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(out_buffer, <span class="tok-number">0</span>),
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CurrentWorkingDirectoryUnlinked,
        .RANGE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SymLinkError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to create a new symbolic link relative to it.</span>
    AccessDenied,
    DiskQuota,
    PathAlreadyExists,
    FileSystem,
    SymLinkLoop,
    FileNotFound,
    SystemResources,
    NoSpaceLeft,
    ReadOnlyFileSystem,
    NotDir,
    NameTooLong,

    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,

    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,

    BadPathName,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Creates a symbolic link named `sym_link_path` which contains the string `target_path`.</span>
<span class="tok-comment">/// A symbolic link (also known as a soft link) may point to an existing file or to a nonexistent</span>
<span class="tok-comment">/// one; the latter case is known as a dangling link.</span>
<span class="tok-comment">/// On Windows, both paths should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">/// If `sym_link_path` exists, it will not be overwritten.</span>
<span class="tok-comment">/// See also `symlinkZ.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symlink</span>(target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.SymLinkError">SymLinkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;symlink is not supported on Windows; use std.os.windows.CreateSymbolicLink instead&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.symlinkat">symlinkat</a>(target_path, <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, sym_link_path);
    }
    <span class="tok-kw">const</span> target_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(target_path);
    <span class="tok-kw">const</span> sym_link_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sym_link_path);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.symlinkZ">symlinkZ</a>(&amp;target_path_c, &amp;sym_link_path_c);
}

<span class="tok-comment">/// This is the same as `symlink` except the parameters are null-terminated pointers.</span>
<span class="tok-comment">/// See also `symlink`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symlinkZ</span>(target_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, sym_link_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.SymLinkError">SymLinkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;symlink is not supported on Windows; use std.os.windows.CreateSymbolicLink instead&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.symlinkatZ">symlinkatZ</a>(target_path, <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().fd, sym_link_path);
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">symlink</a>(target_path, sym_link_path))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Similar to `symlink`, however, creates a symbolic link named `sym_link_path` which contains the string</span>
<span class="tok-comment">/// `target_path` **relative** to `newdirfd` directory handle.</span>
<span class="tok-comment">/// A symbolic link (also known as a soft link) may point to an existing file or to a nonexistent</span>
<span class="tok-comment">/// one; the latter case is known as a dangling link.</span>
<span class="tok-comment">/// On Windows, both paths should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">/// If `sym_link_path` exists, it will not be overwritten.</span>
<span class="tok-comment">/// See also `symlinkatWasi`, `symlinkatZ` and `symlinkatW`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symlinkat</span>(target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, newdirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.SymLinkError">SymLinkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;symlinkat is not supported on Windows; use std.os.windows.CreateSymbolicLink instead&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.symlinkatWasi">symlinkatWasi</a>(target_path, newdirfd, sym_link_path);
    }
    <span class="tok-kw">const</span> target_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(target_path);
    <span class="tok-kw">const</span> sym_link_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sym_link_path);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.symlinkatZ">symlinkatZ</a>(&amp;target_path_c, newdirfd, &amp;sym_link_path_c);
}

<span class="tok-comment">/// WASI-only. The same as `symlinkat` but targeting WASI.</span>
<span class="tok-comment">/// See also `symlinkat`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symlinkatWasi</span>(target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, newdirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.SymLinkError">SymLinkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.path_symlink">path_symlink</a>(target_path.ptr, target_path.len, newdirfd, sym_link_path.ptr, sym_link_path.len)) {
        .SUCCESS =&gt; {},
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .ILSEQ =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// The same as `symlinkat` except the parameters are null-terminated pointers.</span>
<span class="tok-comment">/// See also `symlinkat`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symlinkatZ</span>(target_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, newdirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sym_link_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.SymLinkError">SymLinkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;symlinkat is not supported on Windows; use std.os.windows.CreateSymbolicLink instead&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.symlinkat">symlinkat</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(target_path, <span class="tok-number">0</span>), newdirfd, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sym_link_path, <span class="tok-number">0</span>));
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">symlinkat</a>(target_path, newdirfd, sym_link_path))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> LinkError = <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a> || <span class="tok-kw">error</span>{
    AccessDenied,
    DiskQuota,
    PathAlreadyExists,
    FileSystem,
    SymLinkLoop,
    LinkQuotaExceeded,
    NameTooLong,
    FileNotFound,
    SystemResources,
    NoSpaceLeft,
    ReadOnlyFileSystem,
    NotSameFileSystem,

    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
};

<span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkZ</span>(oldpath: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, newpath: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.LinkError">LinkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.link">link</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(oldpath, <span class="tok-number">0</span>), <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(newpath, <span class="tok-number">0</span>));
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">link</a>(oldpath, newpath))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .MLINK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LinkQuotaExceeded,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .XDEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotSameFileSystem,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">link</span>(oldpath: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, newpath: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.LinkError">LinkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.linkat">linkat</a>(<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, oldpath, <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, newpath, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.NotDir =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // link() does not support directories
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    }
    <span class="tok-kw">const</span> old = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(oldpath);
    <span class="tok-kw">const</span> new = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(newpath);
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.linkZ">linkZ</a>(&amp;old, &amp;new);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> LinkatError = <a href="std.posix.html#std.posix.LinkError">LinkError</a> || <span class="tok-kw">error</span>{NotDir};

<span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkatZ</span>(
    olddir: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    oldpath: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    newdir: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    newpath: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <span class="tok-type">i32</span>,
) <a href="std.posix.html#std.posix.LinkatError">LinkatError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.linkat">linkat</a>(olddir, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(oldpath, <span class="tok-number">0</span>), newdir, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(newpath, <span class="tok-number">0</span>), flags);
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">linkat</a>(olddir, oldpath, newdir, newpath, flags))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .MLINK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LinkQuotaExceeded,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .XDEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotSameFileSystem,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkat</span>(
    olddir: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    oldpath: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    newdir: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    newpath: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <span class="tok-type">i32</span>,
) <a href="std.posix.html#std.posix.LinkatError">LinkatError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> old: <a href="std.posix.RelativePathWasi.html">RelativePathWasi</a> = .{ .dir_fd = olddir, .relative_path = oldpath };
        <span class="tok-kw">const</span> new: <a href="std.posix.RelativePathWasi.html">RelativePathWasi</a> = .{ .dir_fd = newdir, .relative_path = newpath };
        <span class="tok-kw">const</span> old_flags: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.lookupflags_t.html">lookupflags_t</a> = .{
            .SYMLINK_FOLLOW = (flags &amp; <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">SYMLINK_FOLLOW</a>) != <span class="tok-number">0</span>,
        };
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.path_link">path_link</a>(
            old.dir_fd,
            old_flags,
            old.relative_path.ptr,
            old.relative_path.len,
            new.dir_fd,
            new.relative_path.ptr,
            new.relative_path.len,
        )) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
            .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
            .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
            .MLINK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LinkQuotaExceeded,
            .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
            .XDEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotSameFileSystem,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .ILSEQ =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">const</span> old = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(oldpath);
    <span class="tok-kw">const</span> new = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(newpath);
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.linkatZ">linkatZ</a>(olddir, &amp;old, newdir, &amp;new, flags);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnlinkError = <span class="tok-kw">error</span>{
    FileNotFound,

    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to unlink a resource by path relative to it.</span>
    AccessDenied,
    FileBusy,
    FileSystem,
    IsDir,
    SymLinkLoop,
    NameTooLong,
    NotDir,
    SystemResources,
    ReadOnlyFileSystem,

    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,

    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,

    <span class="tok-comment">/// On Windows, file paths cannot contain these characters:</span>
    <span class="tok-comment">/// '/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</span>
    BadPathName,

    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Delete a name and possibly the file it refers to.</span>
<span class="tok-comment">/// On Windows, `file_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `file_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `file_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">/// See also `unlinkZ`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlink</span>(file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlinkat">unlinkat</a>(<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, file_path, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // only occurs when targeting directories
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> file_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, file_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlinkW">unlinkW</a>(file_path_w.span());
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> file_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(file_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlinkZ">unlinkZ</a>(&amp;file_path_c);
    }
}

<span class="tok-comment">/// Same as `unlink` except the parameter is null terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkZ</span>(file_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> file_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, file_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlinkW">unlinkW</a>(file_path_w.span());
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlink">unlink</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(file_path, <span class="tok-number">0</span>));
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">unlink</a>(file_path))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Windows-only. Same as `unlink` except the parameter is null-terminated, WTF16 LE encoded.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkW</span>(file_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a>!<span class="tok-type">void</span> {
    <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DeleteFile">DeleteFile</a>(file_path_w, .{ .dir = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().fd }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // we're not passing .remove_dir = true
        </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnlinkatError = <a href="std.posix.html#std.posix.UnlinkError">UnlinkError</a> || <span class="tok-kw">error</span>{
    <span class="tok-comment">/// When passing `AT.REMOVEDIR`, this error occurs when the named directory is not empty.</span>
    DirNotEmpty,
};

<span class="tok-comment">/// Delete a file name and possibly the file it refers to, based on an open directory handle.</span>
<span class="tok-comment">/// On Windows, `file_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `file_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `file_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkat</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.UnlinkatError">UnlinkatError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> file_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(dirfd, file_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlinkatW">unlinkatW</a>(dirfd, file_path_w.span(), flags);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlinkatWasi">unlinkatWasi</a>(dirfd, file_path, flags);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> file_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(file_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlinkatZ">unlinkatZ</a>(dirfd, &amp;file_path_c, flags);
    }
}

<span class="tok-comment">/// WASI-only. Same as `unlinkat` but targeting WASI.</span>
<span class="tok-comment">/// See also `unlinkat`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkatWasi</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.UnlinkatError">UnlinkatError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> remove_dir = (flags &amp; <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">REMOVEDIR</a>) != <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> res = <span class="tok-kw">if</span> (remove_dir)
        <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.path_remove_directory">path_remove_directory</a>(dirfd, file_path.ptr, file_path.len)
    <span class="tok-kw">else</span>
        <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.path_unlink_file">path_unlink_file</a>(dirfd, file_path.ptr, file_path.len);
    <span class="tok-kw">switch</span> (res) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .NOTEMPTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotEmpty,
        .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .ILSEQ =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8,

        .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid flags, or pathname has . as last component
        </span>.BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition

        </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Same as `unlinkat` but `file_path` is a null-terminated string.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkatZ</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.UnlinkatError">UnlinkatError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> file_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(dirfd, file_path_c);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlinkatW">unlinkatW</a>(dirfd, file_path_w.span(), flags);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlinkat">unlinkat</a>(dirfd, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(file_path_c, <span class="tok-number">0</span>), flags);
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">unlinkat</a>(dirfd, file_path_c, flags))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotEmpty,
        .NOTEMPTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotEmpty,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),

        .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid flags, or pathname has . as last component
        </span>.BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition

        </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Same as `unlinkat` but `sub_path_w` is WTF16LE, NT prefixed. Windows only.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkatW</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.UnlinkatError">UnlinkatError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> remove_dir = (flags &amp; <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">REMOVEDIR</a>) != <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DeleteFile">DeleteFile</a>(sub_path_w, .{ .dir = dirfd, .remove_dir = remove_dir });
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RenameError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to rename a resource by path relative to it.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// On Windows, this error may be returned instead of PathAlreadyExists when</span>
    <span class="tok-comment">/// renaming a directory over an existing directory.</span>
    AccessDenied,
    FileBusy,
    DiskQuota,
    IsDir,
    SymLinkLoop,
    LinkQuotaExceeded,
    NameTooLong,
    FileNotFound,
    NotDir,
    SystemResources,
    NoSpaceLeft,
    PathAlreadyExists,
    ReadOnlyFileSystem,
    RenameAcrossMountPoints,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
    BadPathName,
    NoDevice,
    SharingViolation,
    PipeBusy,
    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
    <span class="tok-comment">/// On Windows, antivirus software is enabled by default. It can be</span>
    <span class="tok-comment">/// disabled, but Windows Update sometimes ignores the user's preference</span>
    <span class="tok-comment">/// and re-enables it. When enabled, antivirus software on Windows</span>
    <span class="tok-comment">/// intercepts file system operations and makes them significantly slower</span>
    <span class="tok-comment">/// in addition to possibly failing with this error code.</span>
    AntivirusInterference,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Change the name or location of a file.</span>
<span class="tok-comment">/// On Windows, both paths should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rename</span>(old_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.renameat">renameat</a>(<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, old_path, <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, new_path);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> old_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, old_path);
        <span class="tok-kw">const</span> new_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, new_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.renameW">renameW</a>(old_path_w.span().ptr, new_path_w.span().ptr);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> old_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(old_path);
        <span class="tok-kw">const</span> new_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(new_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.renameZ">renameZ</a>(&amp;old_path_c, &amp;new_path_c);
    }
}

<span class="tok-comment">/// Same as `rename` except the parameters are null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameZ</span>(old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> old_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, old_path);
        <span class="tok-kw">const</span> new_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, new_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.renameW">renameW</a>(old_path_w.span().ptr, new_path_w.span().ptr);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.rename">rename</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(old_path, <span class="tok-number">0</span>), <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(new_path, <span class="tok-number">0</span>));
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">rename</a>(old_path, new_path))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .MLINK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LinkQuotaExceeded,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .NOTEMPTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .XDEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.RenameAcrossMountPoints,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Same as `rename` except the parameters are null-terminated and WTF16LE encoded.</span>
<span class="tok-comment">/// Assumes target is Windows.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameW</span>(old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> flags = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.MOVEFILE_REPLACE_EXISTING">MOVEFILE_REPLACE_EXISTING</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.MOVEFILE_WRITE_THROUGH">MOVEFILE_WRITE_THROUGH</a>;
    <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.MoveFileExW">MoveFileExW</a>(old_path, new_path, flags);
}

<span class="tok-comment">/// Change the name or location of a file based on an open directory handle.</span>
<span class="tok-comment">/// On Windows, both paths should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameat</span>(
    old_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    old_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    new_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    new_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> old_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(old_dir_fd, old_path);
        <span class="tok-kw">const</span> new_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(new_dir_fd, new_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.renameatW">renameatW</a>(old_dir_fd, old_path_w.span(), new_dir_fd, new_path_w.span(), <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TRUE">TRUE</a>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> old: <a href="std.posix.RelativePathWasi.html">RelativePathWasi</a> = .{ .dir_fd = old_dir_fd, .relative_path = old_path };
        <span class="tok-kw">const</span> new: <a href="std.posix.RelativePathWasi.html">RelativePathWasi</a> = .{ .dir_fd = new_dir_fd, .relative_path = new_path };
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.renameatWasi">renameatWasi</a>(old, new);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> old_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(old_path);
        <span class="tok-kw">const</span> new_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(new_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.renameatZ">renameatZ</a>(old_dir_fd, &amp;old_path_c, new_dir_fd, &amp;new_path_c);
    }
}

<span class="tok-comment">/// WASI-only. Same as `renameat` expect targeting WASI.</span>
<span class="tok-comment">/// See also `renameat`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">renameatWasi</span>(old: <a href="std.posix.RelativePathWasi.html">RelativePathWasi</a>, new: <a href="std.posix.RelativePathWasi.html">RelativePathWasi</a>) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.path_rename">path_rename</a>(old.dir_fd, old.relative_path.ptr, old.relative_path.len, new.dir_fd, new.relative_path.ptr, new.relative_path.len)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .MLINK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LinkQuotaExceeded,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .NOTEMPTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .XDEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.RenameAcrossMountPoints,
        .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .ILSEQ =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// An fd-relative file path</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This is currently only used for WASI-specific functionality, but the concept</span>
<span class="tok-comment">/// is the same as the dirfd/pathname pairs in the `*at(...)` POSIX functions.</span>
<span class="tok-kw">const</span> RelativePathWasi = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// Handle to directory</span>
    dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    <span class="tok-comment">/// Path to resource within `dir_fd`.</span>
    relative_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
};

<span class="tok-comment">/// Same as `renameat` except the parameters are null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameatZ</span>(
    old_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    new_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> old_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(old_dir_fd, old_path);
        <span class="tok-kw">const</span> new_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(new_dir_fd, new_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.renameatW">renameatW</a>(old_dir_fd, old_path_w.span(), new_dir_fd, new_path_w.span(), <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TRUE">TRUE</a>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.renameat">renameat</a>(old_dir_fd, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(old_path, <span class="tok-number">0</span>), new_dir_fd, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(new_path, <span class="tok-number">0</span>));
    }

    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">renameat</a>(old_dir_fd, old_path, new_dir_fd, new_path))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .MLINK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LinkQuotaExceeded,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .NOTEMPTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .XDEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.RenameAcrossMountPoints,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Same as `renameat` but Windows-only and the path parameters are</span>
<span class="tok-comment">/// [WTF-16](https://simonsapin.github.io/wtf-8/#potentially-ill-formed-utf-16) encoded.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameatW</span>(
    old_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    old_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>,
    new_dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    new_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>,
    ReplaceIfExists: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.BYTE">BOOLEAN</a>,
) <a href="std.posix.html#std.posix.RenameError">RenameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> src_fd = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.OpenFile">OpenFile</a>(old_path_w, .{
        .dir = old_dir_fd,
        .access_mask = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SYNCHRONIZE">SYNCHRONIZE</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GENERIC_WRITE">GENERIC_WRITE</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DELETE">DELETE</a>,
        .creation = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_OPEN">FILE_OPEN</a>,
        .filter = .any,<span class="tok-comment"> // This function is supposed to rename both files and directories.
        </span>.follow_symlinks = <span class="tok-null">false</span>,
    }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Not possible without `.share_access_nonblocking = true`.
        </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
    <span class="tok-kw">defer</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CloseHandle">CloseHandle</a>(src_fd);

    <span class="tok-kw">var</span> need_fallback = <span class="tok-null">true</span>;
    <span class="tok-kw">var</span> rc: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntstatus.NTSTATUS.html">NTSTATUS</a> = <span class="tok-null">undefined</span>;<span class="tok-comment">
    // FILE_RENAME_INFORMATION_EX and FILE_RENAME_POSIX_SEMANTICS require &gt;= win10_rs1,
    // but FILE_RENAME_IGNORE_READONLY_ATTRIBUTE requires &gt;= win10_rs5. We check &gt;= rs5 here
    // so that we only use POSIX_SEMANTICS when we know IGNORE_READONLY_ATTRIBUTE will also be
    // supported in order to avoid either (1) using a redundant call that we can know in advance will return
    // STATUS_NOT_SUPPORTED or (2) only setting IGNORE_READONLY_ATTRIBUTE when &gt;= rs5
    // and therefore having different behavior when the Windows version is &gt;= rs1 but &lt; rs5.
    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">isAtLeast</a>(.windows, .win10_rs5) <span class="tok-kw">orelse</span> <span class="tok-null">false</span>) {
        <span class="tok-kw">const</span> struct_buf_len = <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_RENAME_INFORMATION_EX.html">FILE_RENAME_INFORMATION_EX</a>) + (<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a> - <span class="tok-number">1</span>);
        <span class="tok-kw">var</span> rename_info_buf: [struct_buf_len]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_RENAME_INFORMATION_EX.html">FILE_RENAME_INFORMATION_EX</a>)) = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> struct_len = <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_RENAME_INFORMATION_EX.html">FILE_RENAME_INFORMATION_EX</a>) - <span class="tok-number">1</span> + new_path_w.len * <span class="tok-number">2</span>;
        <span class="tok-kw">if</span> (struct_len &gt; struct_buf_len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;

        <span class="tok-kw">const</span> rename_info: *<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_RENAME_INFORMATION_EX.html">FILE_RENAME_INFORMATION_EX</a> = <span class="tok-builtin">@ptrCast</span>(&amp;rename_info_buf);
        <span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;

        <span class="tok-kw">var</span> flags: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ULONG">ULONG</a> = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_RENAME_POSIX_SEMANTICS">FILE_RENAME_POSIX_SEMANTICS</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_RENAME_IGNORE_READONLY_ATTRIBUTE">FILE_RENAME_IGNORE_READONLY_ATTRIBUTE</a>;
        <span class="tok-kw">if</span> (ReplaceIfExists == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TRUE">TRUE</a>) flags |= <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_RENAME_REPLACE_IF_EXISTS">FILE_RENAME_REPLACE_IF_EXISTS</a>;
        rename_info.* = .{
            .Flags = flags,
            .RootDirectory = <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsWTF16">isAbsoluteWindowsWTF16</a>(new_path_w)) <span class="tok-null">null</span> <span class="tok-kw">else</span> new_dir_fd,
            .FileNameLength = <span class="tok-builtin">@intCast</span>(new_path_w.len * <span class="tok-number">2</span>),<span class="tok-comment"> // already checked error.NameTooLong
            </span>.FileName = <span class="tok-null">undefined</span>,
        };
        <span class="tok-builtin">@memcpy</span>((&amp;rename_info.FileName).ptr, new_path_w);
        rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtSetInformationFile">NtSetInformationFile</a>(
            src_fd,
            &amp;io_status_block,
            rename_info,
            <span class="tok-builtin">@intCast</span>(struct_len),<span class="tok-comment"> // already checked for error.NameTooLong
            </span>.FileRenameInformationEx,
        );
        <span class="tok-kw">switch</span> (rc) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,<span class="tok-comment">
            // INVALID_PARAMETER here means that the filesystem does not support FileRenameInformationEx
            </span>.INVALID_PARAMETER =&gt; {},<span class="tok-comment">
            // For all other statuses, fall down to the switch below to handle them.
            </span><span class="tok-kw">else</span> =&gt; need_fallback = <span class="tok-null">false</span>,
        }
    }

    <span class="tok-kw">if</span> (need_fallback) {
        <span class="tok-kw">const</span> struct_buf_len = <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_RENAME_INFORMATION.html">FILE_RENAME_INFORMATION</a>) + (<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a> - <span class="tok-number">1</span>);
        <span class="tok-kw">var</span> rename_info_buf: [struct_buf_len]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_RENAME_INFORMATION.html">FILE_RENAME_INFORMATION</a>)) = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> struct_len = <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_RENAME_INFORMATION.html">FILE_RENAME_INFORMATION</a>) - <span class="tok-number">1</span> + new_path_w.len * <span class="tok-number">2</span>;
        <span class="tok-kw">if</span> (struct_len &gt; struct_buf_len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;

        <span class="tok-kw">const</span> rename_info: *<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_RENAME_INFORMATION.html">FILE_RENAME_INFORMATION</a> = <span class="tok-builtin">@ptrCast</span>(&amp;rename_info_buf);
        <span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;

        rename_info.* = .{
            .Flags = ReplaceIfExists,
            .RootDirectory = <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsWTF16">isAbsoluteWindowsWTF16</a>(new_path_w)) <span class="tok-null">null</span> <span class="tok-kw">else</span> new_dir_fd,
            .FileNameLength = <span class="tok-builtin">@intCast</span>(new_path_w.len * <span class="tok-number">2</span>),<span class="tok-comment"> // already checked error.NameTooLong
            </span>.FileName = <span class="tok-null">undefined</span>,
        };
        <span class="tok-builtin">@memcpy</span>((&amp;rename_info.FileName).ptr, new_path_w);

        rc =
            <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtSetInformationFile">NtSetInformationFile</a>(
                src_fd,
                &amp;io_status_block,
                rename_info,
                <span class="tok-builtin">@intCast</span>(struct_len),<span class="tok-comment"> // already checked for error.NameTooLong
                </span>.FileRenameInformation,
            );
    }

    <span class="tok-kw">switch</span> (rc) {
        .SUCCESS =&gt; {},
        .INVALID_HANDLE =&gt; <span class="tok-kw">unreachable</span>,
        .INVALID_PARAMETER =&gt; <span class="tok-kw">unreachable</span>,
        .OBJECT_PATH_SYNTAX_BAD =&gt; <span class="tok-kw">unreachable</span>,
        .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .OBJECT_NAME_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .OBJECT_PATH_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOT_SAME_DEVICE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.RenameAcrossMountPoints,
        .OBJECT_NAME_COLLISION =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .DIRECTORY_NOT_EMPTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .FILE_IS_A_DIRECTORY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
        .NOT_A_DIRECTORY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedStatus">unexpectedStatus</a>(rc),
    }
}

<span class="tok-comment">/// On Windows, `sub_dir_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `sub_dir_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `sub_dir_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdirat</span>(dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sub_dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> sub_dir_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(dir_fd, sub_dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.mkdiratW">mkdiratW</a>(dir_fd, sub_dir_path_w.span(), mode);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.mkdiratWasi">mkdiratWasi</a>(dir_fd, sub_dir_path, mode);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> sub_dir_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(sub_dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.mkdiratZ">mkdiratZ</a>(dir_fd, &amp;sub_dir_path_c, mode);
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdiratWasi</span>(dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sub_dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span> {
    _ = mode;
    <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.path_create_directory">path_create_directory</a>(dir_fd, sub_dir_path.ptr, sub_dir_path.len)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .MLINK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LinkQuotaExceeded,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .ILSEQ =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Same as `mkdirat` except the parameters are null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdiratZ</span>(dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sub_dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> sub_dir_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(dir_fd, sub_dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.mkdiratW">mkdiratW</a>(dir_fd, sub_dir_path_w.span(), mode);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.mkdirat">mkdirat</a>(dir_fd, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sub_dir_path, <span class="tok-number">0</span>), mode);
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">mkdirat</a>(dir_fd, sub_dir_path, mode))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .MLINK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LinkQuotaExceeded,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,<span class="tok-comment">
        // dragonfly: when dir_fd is unlinked from filesystem
        </span>.NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Windows-only. Same as `mkdirat` except the parameter WTF16 LE encoded.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdiratW</span>(dir_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span> {
    _ = mode;
    <span class="tok-kw">const</span> sub_dir_handle = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.OpenFile">OpenFile</a>(sub_path_w, .{
        .dir = dir_fd,
        .access_mask = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GENERIC_READ">GENERIC_READ</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SYNCHRONIZE">SYNCHRONIZE</a>,
        .creation = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_CREATE">FILE_CREATE</a>,
        .filter = .dir_only,
    }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.PipeBusy =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.NoDevice =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.AntivirusInterference =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
    <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CloseHandle">CloseHandle</a>(sub_dir_handle);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MakeDirError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to create a new directory relative to it.</span>
    AccessDenied,
    DiskQuota,
    PathAlreadyExists,
    SymLinkLoop,
    LinkQuotaExceeded,
    NameTooLong,
    FileNotFound,
    SystemResources,
    NoSpaceLeft,
    NotDir,
    ReadOnlyFileSystem,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
    BadPathName,
    NoDevice,
    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Create a directory.</span>
<span class="tok-comment">/// `mode` is ignored on Windows and WASI.</span>
<span class="tok-comment">/// On Windows, `dir_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `dir_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `dir_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdir</span>(dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.mkdirat">mkdirat</a>(<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, dir_path, mode);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> dir_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.mkdirW">mkdirW</a>(dir_path_w.span(), mode);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> dir_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.mkdirZ">mkdirZ</a>(&amp;dir_path_c, mode);
    }
}

<span class="tok-comment">/// Same as `mkdir` but the parameter is null-terminated.</span>
<span class="tok-comment">/// On Windows, `dir_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `dir_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `dir_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdirZ</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> dir_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.mkdirW">mkdirW</a>(dir_path_w.span(), mode);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.mkdir">mkdir</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(dir_path, <span class="tok-number">0</span>), mode);
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">mkdir</a>(dir_path, mode))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathAlreadyExists,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .MLINK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LinkQuotaExceeded,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Windows-only. Same as `mkdir` but the parameters is WTF16LE encoded.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdirW</span>(dir_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, mode: <a href="std.posix.html#std.posix.mode_t">mode_t</a>) <a href="std.posix.html#std.posix.MakeDirError">MakeDirError</a>!<span class="tok-type">void</span> {
    _ = mode;
    <span class="tok-kw">const</span> sub_dir_handle = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.OpenFile">OpenFile</a>(dir_path_w, .{
        .dir = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().fd,
        .access_mask = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GENERIC_READ">GENERIC_READ</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SYNCHRONIZE">SYNCHRONIZE</a>,
        .creation = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_CREATE">FILE_CREATE</a>,
        .filter = .dir_only,
    }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.PipeBusy =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.NoDevice =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">error</span>.AntivirusInterference =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
    <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CloseHandle">CloseHandle</a>(sub_dir_handle);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeleteDirError = <span class="tok-kw">error</span>{
    AccessDenied,
    FileBusy,
    SymLinkLoop,
    NameTooLong,
    FileNotFound,
    SystemResources,
    NotDir,
    DirNotEmpty,
    ReadOnlyFileSystem,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
    BadPathName,
    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Deletes an empty directory.</span>
<span class="tok-comment">/// On Windows, `dir_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `dir_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `dir_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rmdir</span>(dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.DeleteDirError">DeleteDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unlinkat">unlinkat</a>(<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, dir_path, <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">REMOVEDIR</a>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileSystem =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // only occurs when targeting files
            </span><span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // only occurs when targeting files
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> dir_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.rmdirW">rmdirW</a>(dir_path_w.span());
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> dir_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.rmdirZ">rmdirZ</a>(&amp;dir_path_c);
    }
}

<span class="tok-comment">/// Same as `rmdir` except the parameter is null-terminated.</span>
<span class="tok-comment">/// On Windows, `dir_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `dir_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `dir_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rmdirZ</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.DeleteDirError">DeleteDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> dir_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.rmdirW">rmdirW</a>(dir_path_w.span());
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.rmdir">rmdir</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(dir_path, <span class="tok-number">0</span>));
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">rmdir</a>(dir_path))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadPathName,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotEmpty,
        .NOTEMPTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotEmpty,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Windows-only. Same as `rmdir` except the parameter is WTF-16 LE encoded.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rmdirW</span>(dir_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.DeleteDirError">DeleteDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DeleteFile">DeleteFile</a>(dir_path_w, .{ .dir = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().fd, .remove_dir = <span class="tok-null">true</span> }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ChangeCurDirError = <span class="tok-kw">error</span>{
    AccessDenied,
    FileSystem,
    SymLinkLoop,
    NameTooLong,
    FileNotFound,
    SystemResources,
    NotDir,
    BadPathName,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Changes the current working directory of the calling process.</span>
<span class="tok-comment">/// On Windows, `dir_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `dir_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `dir_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chdir</span>(dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;WASI does not support os.chdir&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">var</span> wtf16_dir_path: [<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PATH_MAX_WIDE">PATH_MAX_WIDE</a>]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.checkWtf8ToWtf16LeOverflow">checkWtf8ToWtf16LeOverflow</a>(dir_path, &amp;wtf16_dir_path)) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
        }
        <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16Le">wtf8ToWtf16Le</a>(&amp;wtf16_dir_path, dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.chdirW">chdirW</a>(wtf16_dir_path[<span class="tok-number">0</span>..len]);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> dir_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.chdirZ">chdirZ</a>(&amp;dir_path_c);
    }
}

<span class="tok-comment">/// Same as `chdir` except the parameter is null-terminated.</span>
<span class="tok-comment">/// On Windows, `dir_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `dir_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `dir_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chdirZ</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> dir_path_span = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(dir_path);
        <span class="tok-kw">var</span> wtf16_dir_path: [<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PATH_MAX_WIDE">PATH_MAX_WIDE</a>]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.checkWtf8ToWtf16LeOverflow">checkWtf8ToWtf16LeOverflow</a>(dir_path_span, &amp;wtf16_dir_path)) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
        }
        <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16Le">wtf8ToWtf16Le</a>(&amp;wtf16_dir_path, dir_path_span);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.chdirW">chdirW</a>(wtf16_dir_path[<span class="tok-number">0</span>..len]);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.chdir">chdir</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(dir_path));
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">chdir</a>(dir_path))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Windows-only. Same as `chdir` except the parameter is WTF16 LE encoded.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chdirW</span>(dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a>!<span class="tok-type">void</span> {
    <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SetCurrentDirectory">SetCurrentDirectory</a>(dir_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.NoDevice =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FchdirError = <span class="tok-kw">error</span>{
    AccessDenied,
    NotDir,
    FileSystem,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fchdir</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.FchdirError">FchdirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (dirfd == <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>) <span class="tok-kw">return</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">fchdir</a>(dirfd))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadLinkError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to read value of a symbolic link relative to it.</span>
    AccessDenied,
    FileSystem,
    SymLinkLoop,
    NameTooLong,
    FileNotFound,
    SystemResources,
    NotLink,
    NotDir,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
    BadPathName,
    <span class="tok-comment">/// Windows-only. This error may occur if the opened reparse point is</span>
    <span class="tok-comment">/// of unsupported type.</span>
    UnsupportedReparsePointType,
    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Read value of a symbolic link.</span>
<span class="tok-comment">/// On Windows, `file_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `file_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `file_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">/// The return value is a slice of `out_buffer` from index 0.</span>
<span class="tok-comment">/// On Windows, the result is encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, the result is encoded as UTF-8.</span>
<span class="tok-comment">/// On other platforms, the result is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlink</span>(file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.readlinkat">readlinkat</a>(<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, file_path, out_buffer);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> file_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, file_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.readlinkW">readlinkW</a>(file_path_w.span(), out_buffer);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> file_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(file_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.readlinkZ">readlinkZ</a>(&amp;file_path_c, out_buffer);
    }
}

<span class="tok-comment">/// Windows-only. Same as `readlink` except `file_path` is WTF16 LE encoded.</span>
<span class="tok-comment">/// The result is encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// See also `readlinkZ`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkW</span>(file_path: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ReadLink">ReadLink</a>(<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().fd, file_path, out_buffer);
}

<span class="tok-comment">/// Same as `readlink` except `file_path` is null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkZ</span>(file_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> file_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, file_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.readlinkW">readlinkW</a>(file_path_w.span(), out_buffer);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.readlink">readlink</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(file_path, <span class="tok-number">0</span>), out_buffer);
    }
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">readlink</a>(file_path, out_buffer.ptr, out_buffer.len);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> out_buffer[<span class="tok-number">0</span>..<span class="tok-builtin">@bitCast</span>(rc)],
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotLink,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Similar to `readlink` except reads value of a symbolink link **relative** to `dirfd` directory handle.</span>
<span class="tok-comment">/// On Windows, `file_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `file_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `file_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">/// The return value is a slice of `out_buffer` from index 0.</span>
<span class="tok-comment">/// On Windows, the result is encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, the result is encoded as UTF-8.</span>
<span class="tok-comment">/// On other platforms, the result is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">/// See also `readlinkatWasi`, `realinkatZ` and `realinkatW`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkat</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.readlinkatWasi">readlinkatWasi</a>(dirfd, file_path, out_buffer);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> file_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(dirfd, file_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.readlinkatW">readlinkatW</a>(dirfd, file_path_w.span(), out_buffer);
    }
    <span class="tok-kw">const</span> file_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(file_path);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.readlinkatZ">readlinkatZ</a>(dirfd, &amp;file_path_c, out_buffer);
}

<span class="tok-comment">/// WASI-only. Same as `readlinkat` but targets WASI.</span>
<span class="tok-comment">/// See also `readlinkat`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkatWasi</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">var</span> bufused: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.path_readlink">path_readlink</a>(dirfd, file_path.ptr, file_path.len, out_buffer.ptr, out_buffer.len, &amp;bufused)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> out_buffer[<span class="tok-number">0</span>..bufused],
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotLink,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .ILSEQ =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Windows-only. Same as `readlinkat` except `file_path` is null-terminated, WTF16 LE encoded.</span>
<span class="tok-comment">/// The result is encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// See also `readlinkat`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkatW</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ReadLink">ReadLink</a>(dirfd, file_path, out_buffer);
}

<span class="tok-comment">/// Same as `readlinkat` except `file_path` is null-terminated.</span>
<span class="tok-comment">/// See also `readlinkat`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkatZ</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, file_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadLinkError">ReadLinkError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> file_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(dirfd, file_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.readlinkatW">readlinkatW</a>(dirfd, file_path_w.span(), out_buffer);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.readlinkat">readlinkat</a>(dirfd, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(file_path, <span class="tok-number">0</span>), out_buffer);
    }
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">readlinkat</a>(dirfd, file_path, out_buffer.ptr, out_buffer.len);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> out_buffer[<span class="tok-number">0</span>..<span class="tok-builtin">@bitCast</span>(rc)],
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotLink,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SetEidError = <span class="tok-kw">error</span>{
    InvalidUserId,
    PermissionDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SetIdError = <span class="tok-kw">error</span>{ResourceLimitReached} || <a href="std.posix.html#std.posix.SetEidError">SetEidError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setuid</span>(uid: <a href="std.posix.html#std.posix.uid_t">uid_t</a>) <a href="std.posix.html#std.posix.SetIdError">SetIdError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">setuid</a>(uid))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ResourceLimitReached,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUserId,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">seteuid</span>(uid: <a href="std.posix.html#std.posix.uid_t">uid_t</a>) <a href="std.posix.html#std.posix.SetEidError">SetEidError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">seteuid</a>(uid))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUserId,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setreuid</span>(ruid: <a href="std.posix.html#std.posix.uid_t">uid_t</a>, euid: <a href="std.posix.html#std.posix.uid_t">uid_t</a>) <a href="std.posix.html#std.posix.SetIdError">SetIdError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">setreuid</a>(ruid, euid))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ResourceLimitReached,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUserId,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setgid</span>(gid: <a href="std.posix.html#std.posix.gid_t">gid_t</a>) <a href="std.posix.html#std.posix.SetIdError">SetIdError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">setgid</a>(gid))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ResourceLimitReached,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUserId,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setegid</span>(uid: <a href="std.posix.html#std.posix.uid_t">uid_t</a>) <a href="std.posix.html#std.posix.SetEidError">SetEidError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">setegid</a>(uid))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUserId,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setregid</span>(rgid: <a href="std.posix.html#std.posix.gid_t">gid_t</a>, egid: <a href="std.posix.html#std.posix.gid_t">gid_t</a>) <a href="std.posix.html#std.posix.SetIdError">SetIdError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">setregid</a>(rgid, egid))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ResourceLimitReached,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUserId,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SetPgidError = <span class="tok-kw">error</span>{
    ProcessAlreadyExec,
    InvalidProcessGroupId,
    PermissionDenied,
    ProcessNotFound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setpgid</span>(pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>, pgid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>) <a href="std.posix.html#std.posix.SetPgidError">SetPgidError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">setpgid</a>(pid, pgid))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessAlreadyExec,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidProcessGroupId,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .SRCH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Test whether a file descriptor refers to a terminal.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isatty</span>(handle: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.isCygwinPty">isCygwinPty</a>(.{ .handle = handle }))
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;

        <span class="tok-kw">var</span> out: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.GetConsoleMode">GetConsoleMode</a>(handle, &amp;out) != <span class="tok-number">0</span>;
    }
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">isatty</a>(handle) != <span class="tok-number">0</span>;
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi) {
        <span class="tok-kw">var</span> statbuf: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.fdstat_t.html">fdstat_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> err = <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_fdstat_get">fd_fdstat_get</a>(handle, &amp;statbuf);
        <span class="tok-kw">if</span> (err != .SUCCESS)
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;<span class="tok-comment">

        // A tty is a character device that we can't seek or tell on.
        </span><span class="tok-kw">if</span> (statbuf.fs_filetype != .CHARACTER_DEVICE)
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        <span class="tok-kw">if</span> (statbuf.fs_rights_base.FD_SEEK <span class="tok-kw">or</span> statbuf.fs_rights_base.FD_TELL)
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;

        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .linux) {
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">var</span> wsz: <a href="std.posix.winsize.html">winsize</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> fd: <span class="tok-type">usize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, handle));
            <span class="tok-kw">const</span> rc = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.syscall3">syscall3</a>(.ioctl, fd, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.T">T</a>.<a href="std.os.linux.html#std.os.linux.T.IOCGWINSZ">IOCGWINSZ</a>, <span class="tok-builtin">@intFromPtr</span>(&amp;wsz));
            <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(rc)) {
                .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,
                .INTR =&gt; <span class="tok-kw">continue</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
            }
        }
    }
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">isatty</a>(handle) != <span class="tok-number">0</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SocketError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// Permission to create a socket of the specified type and/or</span>
    <span class="tok-comment">/// pro‐tocol is denied.</span>
    PermissionDenied,

    <span class="tok-comment">/// The implementation does not support the specified address family.</span>
    AddressFamilyNotSupported,

    <span class="tok-comment">/// Unknown protocol, or protocol family not available.</span>
    ProtocolFamilyNotAvailable,

    <span class="tok-comment">/// The per-process limit on the number of open file descriptors has been reached.</span>
    ProcessFdQuotaExceeded,

    <span class="tok-comment">/// The system-wide limit on the total number of open files has been reached.</span>
    SystemFdQuotaExceeded,

    <span class="tok-comment">/// Insufficient memory is available. The socket cannot be created until sufficient</span>
    <span class="tok-comment">/// resources are freed.</span>
    SystemResources,

    <span class="tok-comment">/// The protocol type or the specified protocol is not supported within this domain.</span>
    ProtocolNotSupported,

    <span class="tok-comment">/// The socket type is not supported by the protocol.</span>
    SocketTypeNotSupported,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">socket</span>(domain: <span class="tok-type">u32</span>, socket_type: <span class="tok-type">u32</span>, protocol: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.SocketError">SocketError</a>!<a href="std.posix.html#std.posix.socket_t">socket_t</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {<span class="tok-comment">
        // NOTE: windows translates the SOCK.NONBLOCK/SOCK.CLOEXEC flags into
        // windows-analogous operations
        </span><span class="tok-kw">const</span> filtered_sock_type = socket_type &amp; ~<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">NONBLOCK</a> | <a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>);
        <span class="tok-kw">const</span> flags: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> ((socket_type &amp; <a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>) != <span class="tok-number">0</span>)
            <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSA_FLAG_NO_HANDLE_INHERIT">WSA_FLAG_NO_HANDLE_INHERIT</a>
        <span class="tok-kw">else</span>
            <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> rc = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.WSASocketW">WSASocketW</a>(
            <span class="tok-builtin">@bitCast</span>(domain),
            <span class="tok-builtin">@bitCast</span>(filtered_sock_type),
            <span class="tok-builtin">@bitCast</span>(protocol),
            <span class="tok-null">null</span>,
            <span class="tok-number">0</span>,
            flags,
        );
        <span class="tok-kw">errdefer</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.closesocket">closesocket</a>(rc) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
        <span class="tok-kw">if</span> ((socket_type &amp; <a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">NONBLOCK</a>) != <span class="tok-number">0</span>) {
            <span class="tok-kw">var</span> mode: <span class="tok-type">c_ulong</span> = <span class="tok-number">1</span>;<span class="tok-comment"> // nonblocking
            </span><span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a> == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.ioctlsocket">ioctlsocket</a>(rc, <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.FIONBIO">FIONBIO</a>, &amp;mode)) {
                <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {<span class="tok-comment">
                    // have not identified any error codes that should be handled yet
                    </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                }
            }
        }
        <span class="tok-kw">return</span> rc;
    }

    <span class="tok-kw">const</span> have_sock_flags = !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a>.<a href="#">isDarwin</a>() <span class="tok-kw">and</span> <a href="std.posix.html#std.posix.native_os">native_os</a> != .haiku;
    <span class="tok-kw">const</span> filtered_sock_type = <span class="tok-kw">if</span> (!have_sock_flags)
        socket_type &amp; ~<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">NONBLOCK</a> | <a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>)
    <span class="tok-kw">else</span>
        socket_type;
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">socket</a>(domain, filtered_sock_type, protocol);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; {
            <span class="tok-kw">const</span> fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a> = <span class="tok-builtin">@intCast</span>(rc);
            <span class="tok-kw">errdefer</span> <a href="std.posix.html#std.posix.close">close</a>(fd);
            <span class="tok-kw">if</span> (!have_sock_flags) {
                <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.setSockFlags">setSockFlags</a>(fd, socket_type);
            }
            <span class="tok-kw">return</span> fd;
        },
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .AFNOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProtocolFamilyNotAvailable,
        .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .PROTONOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProtocolNotSupported,
        .PROTOTYPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketTypeNotSupported,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ShutdownError = <span class="tok-kw">error</span>{
    ConnectionAborted,

    <span class="tok-comment">/// Connection was reset by peer, application should close socket as it is no longer usable.</span>
    ConnectionResetByPeer,
    BlockingOperationInProgress,

    <span class="tok-comment">/// The network subsystem has failed.</span>
    NetworkSubsystemFailed,

    <span class="tok-comment">/// The socket is not connected (connection-oriented sockets only).</span>
    SocketNotConnected,
    SystemResources,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ShutdownHow = <span class="tok-kw">enum</span> { <a href="std.posix.html#std.posix.recv">recv</a>, <a href="std.posix.html#std.posix.send">send</a>, both };

<span class="tok-comment">/// Shutdown socket send/receive operations</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shutdown</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, how: <a href="std.posix.ShutdownHow.html">ShutdownHow</a>) <a href="std.posix.html#std.posix.ShutdownError">ShutdownError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> result = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.shutdown">shutdown</a>(sock, <span class="tok-kw">switch</span> (how) {
            .recv =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SD_RECEIVE">SD_RECEIVE</a>,
            .send =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SD_SEND">SD_SEND</a>,
            .both =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SD_BOTH">SD_BOTH</a>,
        });
        <span class="tok-kw">if</span> (<span class="tok-number">0</span> != result) <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
            .WSAECONNABORTED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionAborted,
            .WSAECONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .WSAEINPROGRESS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BlockingOperationInProgress,
            .WSAEINVAL =&gt; <span class="tok-kw">unreachable</span>,
            .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
            .WSAENOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .WSAENOTSOCK =&gt; <span class="tok-kw">unreachable</span>,
            .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">shutdown</a>(sock, <span class="tok-kw">switch</span> (how) {
            .recv =&gt; <a href="std.posix.html#std.posix.SHUT">SHUT</a>.<a href="#">RD</a>,
            .send =&gt; <a href="std.posix.html#std.posix.SHUT">SHUT</a>.<a href="#">WR</a>,
            .both =&gt; <a href="std.posix.html#std.posix.SHUT">SHUT</a>.<a href="#">RDWR</a>,
        });
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> BindError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The address is protected, and the user is not the superuser.</span>
    <span class="tok-comment">/// For UNIX domain sockets: Search permission is denied on  a  component</span>
    <span class="tok-comment">/// of  the  path  prefix.</span>
    AccessDenied,

    <span class="tok-comment">/// The given address is already in use, or in the case of Internet domain sockets,</span>
    <span class="tok-comment">/// The  port number was specified as zero in the socket</span>
    <span class="tok-comment">/// address structure, but, upon attempting to bind to  an  ephemeral  port,  it  was</span>
    <span class="tok-comment">/// determined  that  all  port  numbers in the ephemeral port range are currently in</span>
    <span class="tok-comment">/// use.  See the discussion of /proc/sys/net/ipv4/ip_local_port_range ip(7).</span>
    AddressInUse,

    <span class="tok-comment">/// A nonexistent interface was requested or the requested address was not local.</span>
    AddressNotAvailable,

    <span class="tok-comment">/// The address is not valid for the address family of socket.</span>
    AddressFamilyNotSupported,

    <span class="tok-comment">/// Too many symbolic links were encountered in resolving addr.</span>
    SymLinkLoop,

    <span class="tok-comment">/// addr is too long.</span>
    NameTooLong,

    <span class="tok-comment">/// A component in the directory prefix of the socket pathname does not exist.</span>
    FileNotFound,

    <span class="tok-comment">/// Insufficient kernel memory was available.</span>
    SystemResources,

    <span class="tok-comment">/// A component of the path prefix is not a directory.</span>
    NotDir,

    <span class="tok-comment">/// The socket inode would reside on a read-only filesystem.</span>
    ReadOnlyFileSystem,

    <span class="tok-comment">/// The network subsystem has failed.</span>
    NetworkSubsystemFailed,

    FileDescriptorNotASocket,

    AlreadyBound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// addr is `*const T` where T is one of the sockaddr</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bind</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, addr: *<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sockaddr">sockaddr</a>, len: <a href="std.posix.html#std.posix.socklen_t">socklen_t</a>) <a href="std.posix.html#std.posix.BindError">BindError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.bind">bind</a>(sock, addr, len);
        <span class="tok-kw">if</span> (rc == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a>) {
            <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not initialized WSA
                </span>.WSAEACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                .WSAEADDRINUSE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressInUse,
                .WSAEADDRNOTAVAIL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressNotAvailable,
                .WSAENOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
                .WSAEFAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid pointers
                </span>.WSAEINVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AlreadyBound,
                .WSAENOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
            }
            <span class="tok-kw">unreachable</span>;
        }
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">bind</a>(sock, addr, len);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .ACCES, .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .ADDRINUSE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressInUse,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition if this error is returned
            </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid parameters
            </span>.NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid `sockfd`
            </span>.AFNOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
            .ADDRNOTAVAIL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressNotAvailable,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid `addr` pointer
            </span>.LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
            .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
            .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">unreachable</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ListenError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// Another socket is already listening on the same port.</span>
    <span class="tok-comment">/// For Internet domain sockets, the  socket referred to by sockfd had not previously</span>
    <span class="tok-comment">/// been bound to an address and, upon attempting to bind it to an ephemeral port, it</span>
    <span class="tok-comment">/// was determined that all port numbers in the ephemeral port range are currently in</span>
    <span class="tok-comment">/// use.  See the discussion of /proc/sys/net/ipv4/ip_local_port_range in ip(7).</span>
    AddressInUse,

    <span class="tok-comment">/// The file descriptor sockfd does not refer to a socket.</span>
    FileDescriptorNotASocket,

    <span class="tok-comment">/// The socket is not of a type that supports the listen() operation.</span>
    OperationNotSupported,

    <span class="tok-comment">/// The network subsystem has failed.</span>
    NetworkSubsystemFailed,

    <span class="tok-comment">/// Ran out of system resources</span>
    <span class="tok-comment">/// On Windows it can either run out of socket descriptors or buffer space</span>
    SystemResources,

    <span class="tok-comment">/// Already connected</span>
    AlreadyConnected,

    <span class="tok-comment">/// Socket has not been bound yet</span>
    SocketNotBound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">listen</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, backlog: <span class="tok-type">u31</span>) <a href="std.posix.html#std.posix.ListenError">ListenError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.listen">listen</a>(sock, backlog);
        <span class="tok-kw">if</span> (rc == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a>) {
            <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not initialized WSA
                </span>.WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                .WSAEADDRINUSE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressInUse,
                .WSAEISCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AlreadyConnected,
                .WSAEINVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotBound,
                .WSAEMFILE, .WSAENOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                .WSAENOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
                .WSAEOPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OperationNotSupported,
                .WSAEINPROGRESS =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
            }
        }
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">listen</a>(sock, backlog);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .ADDRINUSE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressInUse,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .NOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
            .OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OperationNotSupported,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AcceptError = <span class="tok-kw">error</span>{
    ConnectionAborted,

    <span class="tok-comment">/// The file descriptor sockfd does not refer to a socket.</span>
    FileDescriptorNotASocket,

    <span class="tok-comment">/// The per-process limit on the number of open file descriptors has been reached.</span>
    ProcessFdQuotaExceeded,

    <span class="tok-comment">/// The system-wide limit on the total number of open files has been reached.</span>
    SystemFdQuotaExceeded,

    <span class="tok-comment">/// Not enough free memory.  This often means that the memory allocation  is  limited</span>
    <span class="tok-comment">/// by the socket buffer limits, not by the system memory.</span>
    SystemResources,

    <span class="tok-comment">/// Socket is not listening for new connections.</span>
    SocketNotListening,

    ProtocolFailure,

    <span class="tok-comment">/// Firewall rules forbid connection.</span>
    BlockedByFirewall,

    <span class="tok-comment">/// This error occurs when no global event loop is configured,</span>
    <span class="tok-comment">/// and accepting from the socket would block.</span>
    WouldBlock,

    <span class="tok-comment">/// An incoming connection was indicated, but was subsequently terminated by the</span>
    <span class="tok-comment">/// remote peer prior to accepting the call.</span>
    ConnectionResetByPeer,

    <span class="tok-comment">/// The network subsystem has failed.</span>
    NetworkSubsystemFailed,

    <span class="tok-comment">/// The referenced socket is not a type that supports connection-oriented service.</span>
    OperationNotSupported,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Accept a connection on a socket.</span>
<span class="tok-comment">/// If `sockfd` is opened in non blocking mode, the function will</span>
<span class="tok-comment">/// return error.WouldBlock when EAGAIN is received.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accept</span>(
    <span class="tok-comment">/// This argument is a socket that has been created with `socket`, bound to a local address</span>
    <span class="tok-comment">/// with `bind`, and is listening for connections after a `listen`.</span>
    sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>,
    <span class="tok-comment">/// This argument is a pointer to a sockaddr structure.  This structure is filled in with  the</span>
    <span class="tok-comment">/// address  of  the  peer  socket, as known to the communications layer.  The exact format of the</span>
    <span class="tok-comment">/// address returned addr is determined by the socket's address  family  (see  `socket`  and  the</span>
    <span class="tok-comment">/// respective  protocol  man  pages).</span>
    addr: ?*<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>,
    <span class="tok-comment">/// This argument is a value-result argument: the caller must initialize it to contain  the</span>
    <span class="tok-comment">/// size (in bytes) of the structure pointed to by addr; on return it will contain the actual size</span>
    <span class="tok-comment">/// of the peer address.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The returned address is truncated if the buffer provided is too small; in this  case,  `addr_size`</span>
    <span class="tok-comment">/// will return a value greater than was supplied to the call.</span>
    addr_size: ?*<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>,
    <span class="tok-comment">/// The following values can be bitwise ORed in flags to obtain different behavior:</span>
    <span class="tok-comment">/// * `SOCK.NONBLOCK` - Set the `NONBLOCK` file status flag on the open file description (see `open`)</span>
    <span class="tok-comment">///   referred  to by the new file descriptor.  Using this flag saves extra calls to `fcntl` to achieve</span>
    <span class="tok-comment">///   the same result.</span>
    <span class="tok-comment">/// * `SOCK.CLOEXEC`  - Set the close-on-exec (`FD_CLOEXEC`) flag on the new file descriptor.   See  the</span>
    <span class="tok-comment">///   description  of the `CLOEXEC` flag in `open` for reasons why this may be useful.</span>
    flags: <span class="tok-type">u32</span>,
) <a href="std.posix.html#std.posix.AcceptError">AcceptError</a>!<a href="std.posix.html#std.posix.socket_t">socket_t</a> {
    <span class="tok-kw">const</span> have_accept4 = !(<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a>.<a href="#">isDarwin</a>() <span class="tok-kw">or</span> <a href="std.posix.html#std.posix.native_os">native_os</a> == .windows <span class="tok-kw">or</span> <a href="std.posix.html#std.posix.native_os">native_os</a> == .haiku);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-number">0</span> == (flags &amp; ~<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">NONBLOCK</a> | <a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>)));<span class="tok-comment"> // Unsupported flag(s)

    </span><span class="tok-kw">const</span> accepted_sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a> = <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <span class="tok-kw">if</span> (have_accept4)
            <a href="std.posix.html#std.posix.system">system</a>.<a href="#">accept4</a>(sock, addr, addr_size, flags)
        <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows)
            <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.accept">accept</a>(sock, addr, addr_size)
        <span class="tok-kw">else</span>
            <a href="std.posix.html#std.posix.system">system</a>.<a href="#">accept</a>(sock, addr, addr_size);

        <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
            <span class="tok-kw">if</span> (rc == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.INVALID_SOCKET">INVALID_SOCKET</a>) {
                <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                    .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not initialized WSA
                    </span>.WSAECONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
                    .WSAEFAULT =&gt; <span class="tok-kw">unreachable</span>,
                    .WSAEINVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotListening,
                    .WSAEMFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
                    .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                    .WSAENOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
                    .WSAEOPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OperationNotSupported,
                    .WSAEWOULDBLOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
                }
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">break</span> rc;
            }
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                .SUCCESS =&gt; <span class="tok-kw">break</span> <span class="tok-builtin">@intCast</span>(rc),
                .INTR =&gt; <span class="tok-kw">continue</span>,
                .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
                .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
                </span>.CONNABORTED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionAborted,
                .FAULT =&gt; <span class="tok-kw">unreachable</span>,
                .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotListening,
                .NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,
                .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
                .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
                .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                .OPNOTSUPP =&gt; <span class="tok-kw">unreachable</span>,
                .PROTO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProtocolFailure,
                .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BlockedByFirewall,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
        }
    };

    <span class="tok-kw">errdefer</span> <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .windows =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.closesocket">closesocket</a>(accepted_sock) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; <a href="std.posix.html#std.posix.close">close</a>(accepted_sock),
    };
    <span class="tok-kw">if</span> (!have_accept4) {
        <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.setSockFlags">setSockFlags</a>(accepted_sock, flags);
    }
    <span class="tok-kw">return</span> accepted_sock;
}

<span class="tok-kw">fn</span> <span class="tok-fn">setSockFlags</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, flags: <span class="tok-type">u32</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> ((flags &amp; <a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>) != <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {<span class="tok-comment">
            // TODO: Find out if this is supported for sockets
        </span>} <span class="tok-kw">else</span> {
            <span class="tok-kw">var</span> fd_flags = <a href="std.posix.html#std.posix.fcntl">fcntl</a>(sock, <a href="std.posix.html#std.posix.F">F</a>.<a href="#">GETFD</a>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };
            fd_flags |= <a href="std.posix.html#std.posix.FD_CLOEXEC">FD_CLOEXEC</a>;
            _ = <a href="std.posix.html#std.posix.fcntl">fcntl</a>(sock, <a href="std.posix.html#std.posix.F">F</a>.<a href="#">SETFD</a>, fd_flags) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };
        }
    }
    <span class="tok-kw">if</span> ((flags &amp; <a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">NONBLOCK</a>) != <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
            <span class="tok-kw">var</span> mode: <span class="tok-type">c_ulong</span> = <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.ioctlsocket">ioctlsocket</a>(sock, <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.FIONBIO">FIONBIO</a>, &amp;mode) == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a>) {
                <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                    .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,
                    .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                    .WSAENOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,<span class="tok-comment">
                    // TODO: handle more errors
                    </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
                }
            }
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">var</span> fl_flags = <a href="std.posix.html#std.posix.fcntl">fcntl</a>(sock, <a href="std.posix.html#std.posix.F">F</a>.<a href="#">GETFL</a>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };
            fl_flags |= <span class="tok-number">1</span> &lt;&lt; <span class="tok-builtin">@bitOffsetOf</span>(<a href="std.posix.html#std.posix.O">O</a>, <span class="tok-str">&quot;NONBLOCK&quot;</span>);
            _ = <a href="std.posix.html#std.posix.fcntl">fcntl</a>(sock, <a href="std.posix.html#std.posix.F">F</a>.<a href="#">SETFL</a>, fl_flags) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> EpollCreateError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The  per-user   limit   on   the   number   of   epoll   instances   imposed   by</span>
    <span class="tok-comment">/// /proc/sys/fs/epoll/max_user_instances  was encountered.  See epoll(7) for further</span>
    <span class="tok-comment">/// details.</span>
    <span class="tok-comment">/// Or, The per-process limit on the number of open file descriptors has been reached.</span>
    ProcessFdQuotaExceeded,

    <span class="tok-comment">/// The system-wide limit on the total number of open files has been reached.</span>
    SystemFdQuotaExceeded,

    <span class="tok-comment">/// There was insufficient memory to create the kernel object.</span>
    SystemResources,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">epoll_create1</span>(flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.EpollCreateError">EpollCreateError</a>!<span class="tok-type">i32</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">epoll_create1</a>(flags);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),

        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> EpollCtlError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// op was EPOLL_CTL_ADD, and the supplied file descriptor fd is  already  registered</span>
    <span class="tok-comment">/// with this epoll instance.</span>
    FileDescriptorAlreadyPresentInSet,

    <span class="tok-comment">/// fd refers to an epoll instance and this EPOLL_CTL_ADD operation would result in a</span>
    <span class="tok-comment">/// circular loop of epoll instances monitoring one another.</span>
    OperationCausesCircularLoop,

    <span class="tok-comment">/// op was EPOLL_CTL_MOD or EPOLL_CTL_DEL, and fd is not registered with  this  epoll</span>
    <span class="tok-comment">/// instance.</span>
    FileDescriptorNotRegistered,

    <span class="tok-comment">/// There was insufficient memory to handle the requested op control operation.</span>
    SystemResources,

    <span class="tok-comment">/// The  limit  imposed  by /proc/sys/fs/epoll/max_user_watches was encountered while</span>
    <span class="tok-comment">/// trying to register (EPOLL_CTL_ADD) a new file descriptor on  an  epoll  instance.</span>
    <span class="tok-comment">/// See epoll(7) for further details.</span>
    UserResourceLimitReached,

    <span class="tok-comment">/// The target file fd does not support epoll.  This error can occur if fd refers to,</span>
    <span class="tok-comment">/// for example, a regular file or a directory.</span>
    FileDescriptorIncompatibleWithEpoll,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">epoll_ctl</span>(epfd: <span class="tok-type">i32</span>, op: <span class="tok-type">u32</span>, fd: <span class="tok-type">i32</span>, event: ?*<a href="std.posix.html#std.posix.system">system</a>.<a href="#">epoll_event</a>) <a href="std.posix.html#std.posix.EpollCtlError">EpollCtlError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">epoll_ctl</a>(epfd, op, fd, event);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),

        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition if this happens
        </span>.EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorAlreadyPresentInSet,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OperationCausesCircularLoop,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotRegistered,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UserResourceLimitReached,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorIncompatibleWithEpoll,
    }
}

<span class="tok-comment">/// Waits for an I/O event on an epoll file descriptor.</span>
<span class="tok-comment">/// Returns the number of file descriptors ready for the requested I/O,</span>
<span class="tok-comment">/// or zero if no file descriptor became ready during the requested timeout milliseconds.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">epoll_wait</span>(epfd: <span class="tok-type">i32</span>, events: []<a href="std.posix.html#std.posix.system">system</a>.<a href="#">epoll_event</a>, timeout: <span class="tok-type">i32</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment">
        // TODO get rid of the @intCast
        </span><span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">epoll_wait</a>(epfd, events.ptr, <span class="tok-builtin">@intCast</span>(events.len), timeout);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> EventFdError = <span class="tok-kw">error</span>{
    SystemResources,
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eventfd</span>(initval: <span class="tok-type">u32</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.EventFdError">EventFdError</a>!<span class="tok-type">i32</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">eventfd</a>(initval, flags);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),

        .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid parameters
        </span>.MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetSockNameError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// Insufficient resources were available in the system to perform the operation.</span>
    SystemResources,

    <span class="tok-comment">/// The network subsystem has failed.</span>
    NetworkSubsystemFailed,

    <span class="tok-comment">/// Socket hasn't been bound yet</span>
    SocketNotBound,

    FileDescriptorNotASocket,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getsockname</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, addr: *<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>, addrlen: *<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>) <a href="std.posix.html#std.posix.GetSockNameError">GetSockNameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.getsockname">getsockname</a>(sock, addr, addrlen);
        <span class="tok-kw">if</span> (rc == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a>) {
            <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,
                .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                .WSAEFAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // addr or addrlen have invalid pointers or addrlen points to an incorrect value
                </span>.WSAENOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
                .WSAEINVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotBound,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
            }
        }
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">getsockname</a>(sock, addr, addrlen);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),

            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid parameters
            </span>.NOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getpeername</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, addr: *<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>, addrlen: *<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>) <a href="std.posix.html#std.posix.GetSockNameError">GetSockNameError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.getpeername">getpeername</a>(sock, addr, addrlen);
        <span class="tok-kw">if</span> (rc == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a>) {
            <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,
                .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                .WSAEFAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // addr or addrlen have invalid pointers or addrlen points to an incorrect value
                </span>.WSAENOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
                .WSAEINVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotBound,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
            }
        }
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">getpeername</a>(sock, addr, addrlen);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),

            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid parameters
            </span>.NOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ConnectError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// For UNIX domain sockets, which are identified by pathname: Write permission is denied on  the  socket</span>
    <span class="tok-comment">/// file,  or  search  permission  is  denied  for  one of the directories in the path prefix.</span>
    <span class="tok-comment">/// or</span>
    <span class="tok-comment">/// The user tried to connect to a broadcast address without having the socket broadcast flag enabled  or</span>
    <span class="tok-comment">/// the connection request failed because of a local firewall rule.</span>
    PermissionDenied,

    <span class="tok-comment">/// Local address is already in use.</span>
    AddressInUse,

    <span class="tok-comment">/// (Internet  domain  sockets)  The  socket  referred  to  by sockfd had not previously been bound to an</span>
    <span class="tok-comment">/// address and, upon attempting to bind it to an ephemeral port, it was determined that all port numbers</span>
    <span class="tok-comment">/// in    the    ephemeral    port    range    are   currently   in   use.    See   the   discussion   of</span>
    <span class="tok-comment">/// /proc/sys/net/ipv4/ip_local_port_range in ip(7).</span>
    AddressNotAvailable,

    <span class="tok-comment">/// The passed address didn't have the correct address family in its sa_family field.</span>
    AddressFamilyNotSupported,

    <span class="tok-comment">/// Insufficient entries in the routing cache.</span>
    SystemResources,

    <span class="tok-comment">/// A connect() on a stream socket found no one listening on the remote address.</span>
    ConnectionRefused,

    <span class="tok-comment">/// Network is unreachable.</span>
    NetworkUnreachable,

    <span class="tok-comment">/// Timeout  while  attempting  connection.   The server may be too busy to accept new connections.  Note</span>
    <span class="tok-comment">/// that for IP sockets the timeout may be very long when syncookies are enabled on the server.</span>
    ConnectionTimedOut,

    <span class="tok-comment">/// This error occurs when no global event loop is configured,</span>
    <span class="tok-comment">/// and connecting to the socket would block.</span>
    WouldBlock,

    <span class="tok-comment">/// The given path for the unix socket does not exist.</span>
    FileNotFound,

    <span class="tok-comment">/// Connection was reset by peer before connect could complete.</span>
    ConnectionResetByPeer,

    <span class="tok-comment">/// Socket is non-blocking and already has a pending connection in progress.</span>
    ConnectionPending,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Initiate a connection on a socket.</span>
<span class="tok-comment">/// If `sockfd` is opened in non blocking mode, the function will</span>
<span class="tok-comment">/// return error.WouldBlock when EAGAIN or EINPROGRESS is received.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connect</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, sock_addr: *<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sockaddr">sockaddr</a>, len: <a href="std.posix.html#std.posix.socklen_t">socklen_t</a>) <a href="std.posix.html#std.posix.ConnectError">ConnectError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.connect">connect</a>(sock, sock_addr, <span class="tok-builtin">@intCast</span>(len));
        <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
            .WSAEADDRINUSE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressInUse,
            .WSAEADDRNOTAVAIL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressNotAvailable,
            .WSAECONNREFUSED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionRefused,
            .WSAECONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .WSAETIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            .WSAEHOSTUNREACH,<span class="tok-comment"> // TODO: should we return NetworkUnreachable in this case as well?
            </span>.WSAENETUNREACH,
            =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
            .WSAEFAULT =&gt; <span class="tok-kw">unreachable</span>,
            .WSAEINVAL =&gt; <span class="tok-kw">unreachable</span>,
            .WSAEISCONN =&gt; <span class="tok-kw">unreachable</span>,
            .WSAENOTSOCK =&gt; <span class="tok-kw">unreachable</span>,
            .WSAEWOULDBLOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .WSAEACCES =&gt; <span class="tok-kw">unreachable</span>,
            .WSAENOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .WSAEAFNOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
        }
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">connect</a>(sock, sock_addr, len))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            .ADDRINUSE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressInUse,
            .ADDRNOTAVAIL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressNotAvailable,
            .AFNOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
            .AGAIN, .INPROGRESS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .ALREADY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionPending,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // sockfd is not a valid open file descriptor.
            </span>.CONNREFUSED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionRefused,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The socket structure address is outside the user's address space.
            </span>.INTR =&gt; <span class="tok-kw">continue</span>,
            .ISCONN =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The socket is already connected.
            </span>.HOSTUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
            .NETUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
            .NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The file descriptor sockfd does not refer to a socket.
            </span>.PROTOTYPE =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The socket type does not support the requested communications protocol.
            </span>.TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,<span class="tok-comment"> // Returned when socket is AF.UNIX and the given path does not exist.
            </span>.CONNABORTED =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Tried to reuse socket that previously received error.ConnectionRefused.
            </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetSockOptError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The calling process does not have the appropriate privileges.</span>
    AccessDenied,

    <span class="tok-comment">/// The option is not supported by the protocol.</span>
    InvalidProtocolOption,

    <span class="tok-comment">/// Insufficient resources are available in the system to complete the call.</span>
    SystemResources,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getsockopt</span>(fd: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, level: <span class="tok-type">i32</span>, optname: <span class="tok-type">u32</span>, opt: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.GetSockOptError">GetSockOptError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> len: <a href="std.posix.html#std.posix.socklen_t">socklen_t</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">getsockopt</a>(fd, level, optname, opt.ptr, &amp;len))) {
        .SUCCESS =&gt; {
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>(len == opt.len);
        },
        .BADF =&gt; <span class="tok-kw">unreachable</span>,
        .NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .NOPROTOOPT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidProtocolOption,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getsockoptError</span>(sockfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.ConnectError">ConnectError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> err_code: <span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> size: <span class="tok-type">u32</span> = <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u32</span>);
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">getsockopt</a>(sockfd, <a href="std.posix.html#std.posix.SOL">SOL</a>.<a href="#">SOCKET</a>, <a href="std.posix.html#std.posix.SO">SO</a>.<a href="#">ERROR</a>, <span class="tok-builtin">@ptrCast</span>(&amp;err_code), &amp;size);
    <a href="std.debug.html#std.debug.assert">assert</a>(size == <span class="tok-number">4</span>);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.posix.html#std.posix.E">E</a>, <span class="tok-builtin">@enumFromInt</span>(err_code))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            .ADDRINUSE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressInUse,
            .ADDRNOTAVAIL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressNotAvailable,
            .AFNOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .ALREADY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionPending,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // sockfd is not a valid open file descriptor.
            </span>.CONNREFUSED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionRefused,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The socket structure address is outside the user's address space.
            </span>.ISCONN =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The socket is already connected.
            </span>.HOSTUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
            .NETUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
            .NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The file descriptor sockfd does not refer to a socket.
            </span>.PROTOTYPE =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The socket type does not support the requested communications protocol.
            </span>.TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        },
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The argument sockfd is not a valid file descriptor.
        </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The address pointed to by optval or optlen is not in a valid part of the process address space.
        </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .NOPROTOOPT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The option is unknown at the level indicated.
        </span>.NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The file descriptor sockfd does not refer to a socket.
        </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> WaitPidResult = <span class="tok-kw">struct</span> {
    pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>,
    status: <span class="tok-type">u32</span>,
};

<span class="tok-comment">/// Use this version of the `waitpid` wrapper if you spawned your child process using explicit</span>
<span class="tok-comment">/// `fork` and `execve` method.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">waitpid</span>(pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>, flags: <span class="tok-type">u32</span>) <a href="std.posix.WaitPidResult.html">WaitPidResult</a> {
    <span class="tok-kw">var</span> status: <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) <span class="tok-type">c_int</span> <span class="tok-kw">else</span> <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">waitpid</a>(pid, &amp;status, <span class="tok-builtin">@intCast</span>(flags));
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> .{
                .pid = <span class="tok-builtin">@intCast</span>(rc),
                .status = <span class="tok-builtin">@bitCast</span>(status),
            },
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .CHILD =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The process specified does not exist. It would be a race condition to handle this error.
            </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid flags.
            </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">wait4</span>(pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>, flags: <span class="tok-type">u32</span>, ru: ?*<a href="std.posix.html#std.posix.rusage">rusage</a>) <a href="std.posix.WaitPidResult.html">WaitPidResult</a> {
    <span class="tok-kw">var</span> status: <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) <span class="tok-type">c_int</span> <span class="tok-kw">else</span> <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">wait4</a>(pid, &amp;status, <span class="tok-builtin">@intCast</span>(flags), ru);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> .{
                .pid = <span class="tok-builtin">@intCast</span>(rc),
                .status = <span class="tok-builtin">@bitCast</span>(status),
            },
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .CHILD =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The process specified does not exist. It would be a race condition to handle this error.
            </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid flags.
            </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FStatError = <span class="tok-kw">error</span>{
    SystemResources,

    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to get its filestat information.</span>
    AccessDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Return information about a file descriptor.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fstat</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.FStatError">FStatError</a>!<a href="std.posix.html#std.posix.Stat">Stat</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.Stat">Stat</a>.<a href="#">fromFilestat</a>(<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.fstat_wasi">fstat_wasi</a>(fd));
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;fstat is not yet implemented on Windows&quot;</span>);
    }

    <span class="tok-kw">const</span> fstat_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fstat64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fstat</a>;
    <span class="tok-kw">var</span> stat = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroes">zeroes</a>(<a href="std.posix.html#std.posix.Stat">Stat</a>);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(fstat_sym(fd, &amp;stat))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> stat,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition.
        </span>.NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FStatAtError = <a href="std.posix.html#std.posix.FStatError">FStatError</a> || <span class="tok-kw">error</span>{
    NameTooLong,
    FileNotFound,
    SymLinkLoop,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
};

<span class="tok-comment">/// Similar to `fstat`, but returns stat of a resource pointed to by `pathname`</span>
<span class="tok-comment">/// which is relative to `dirfd` handle.</span>
<span class="tok-comment">/// On WASI, `pathname` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `pathname` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">/// See also `fstatatZ` and `std.os.fstatat_wasi`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fstatat</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.FStatAtError">FStatAtError</a>!<a href="std.posix.html#std.posix.Stat">Stat</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> filestat = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.fstatat_wasi">fstatat_wasi</a>(dirfd, pathname, .{
            .SYMLINK_FOLLOW = (flags &amp; <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">SYMLINK_NOFOLLOW</a>) == <span class="tok-number">0</span>,
        });
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.Stat">Stat</a>.<a href="#">fromFilestat</a>(filestat);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;fstatat is not yet implemented on Windows&quot;</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> pathname_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(pathname);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.fstatatZ">fstatatZ</a>(dirfd, &amp;pathname_c, flags);
    }
}

<span class="tok-comment">/// Same as `fstatat` but `pathname` is null-terminated.</span>
<span class="tok-comment">/// See also `fstatat`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fstatatZ</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.FStatAtError">FStatAtError</a>!<a href="std.posix.html#std.posix.Stat">Stat</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> filestat = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.fstatat_wasi">fstatat_wasi</a>(dirfd, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(pathname, <span class="tok-number">0</span>), .{
            .SYMLINK_FOLLOW = (flags &amp; <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">SYMLINK_NOFOLLOW</a>) == <span class="tok-number">0</span>,
        });
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.Stat">Stat</a>.<a href="#">fromFilestat</a>(filestat);
    }

    <span class="tok-kw">const</span> fstatat_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fstatat64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fstatat</a>;
    <span class="tok-kw">var</span> stat = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroes">zeroes</a>(<a href="std.posix.html#std.posix.Stat">Stat</a>);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(fstatat_sym(dirfd, pathname, &amp;stat, flags))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> stat,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition.
        </span>.NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> KQueueError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The per-process limit on the number of open file descriptors has been reached.</span>
    ProcessFdQuotaExceeded,

    <span class="tok-comment">/// The system-wide limit on the total number of open files has been reached.</span>
    SystemFdQuotaExceeded,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">kqueue</span>() <a href="std.posix.html#std.posix.KQueueError">KQueueError</a>!<span class="tok-type">i32</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">kqueue</a>();
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> KEventError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The process does not have permission to register a filter.</span>
    AccessDenied,

    <span class="tok-comment">/// The event could not be found to be modified or deleted.</span>
    EventNotFound,

    <span class="tok-comment">/// No memory was available to register the event.</span>
    SystemResources,

    <span class="tok-comment">/// The specified process to attach to does not exist.</span>
    ProcessNotFound,

    <span class="tok-comment">/// changelist or eventlist had too many items on it.</span>
    <span class="tok-comment">/// TODO remove this possibility</span>
    Overflow,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">kevent</span>(
    kq: <span class="tok-type">i32</span>,
    changelist: []<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.Kevent">Kevent</a>,
    eventlist: []<a href="std.posix.html#std.posix.Kevent">Kevent</a>,
    timeout: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.timespec">timespec</a>,
) <a href="std.posix.html#std.posix.KEventError">KEventError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">kevent</a>(
            kq,
            changelist.ptr,
            <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">c_int</span>, changelist.len) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow,
            eventlist.ptr,
            <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">c_int</span>, eventlist.len) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow,
            timeout,
        );
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition.
            </span>.INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EventNotFound,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .SRCH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> INotifyInitError = <span class="tok-kw">error</span>{
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    SystemResources,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// initialize an inotify instance</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inotify_init1</span>(flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.INotifyInitError">INotifyInitError</a>!<span class="tok-type">i32</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">inotify_init1</a>(flags);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> INotifyAddWatchError = <span class="tok-kw">error</span>{
    AccessDenied,
    NameTooLong,
    FileNotFound,
    SystemResources,
    UserResourceLimitReached,
    NotDir,
    WatchAlreadyExists,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// add a watch to an initialized inotify instance</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inotify_add_watch</span>(inotify_fd: <span class="tok-type">i32</span>, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mask: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.INotifyAddWatchError">INotifyAddWatchError</a>!<span class="tok-type">i32</span> {
    <span class="tok-kw">const</span> pathname_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(pathname);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.inotify_add_watchZ">inotify_add_watchZ</a>(inotify_fd, &amp;pathname_c, mask);
}

<span class="tok-comment">/// Same as `inotify_add_watch` except pathname is null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inotify_add_watchZ</span>(inotify_fd: <span class="tok-type">i32</span>, pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mask: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.INotifyAddWatchError">INotifyAddWatchError</a>!<span class="tok-type">i32</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">inotify_add_watch</a>(inotify_fd, pathname, mask);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UserResourceLimitReached,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WatchAlreadyExists,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// remove an existing watch from an inotify instance</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inotify_rm_watch</span>(inotify_fd: <span class="tok-type">i32</span>, wd: <span class="tok-type">i32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">inotify_rm_watch</a>(inotify_fd, wd))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FanotifyInitError = <span class="tok-kw">error</span>{
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    SystemResources,
    PermissionDenied,
    <span class="tok-comment">/// The kernel does not recognize the flags passed, likely because it is an</span>
    <span class="tok-comment">/// older version.</span>
    UnsupportedFlags,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fanotify_init</span>(flags: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.fanotify.html">fanotify</a>.<a href="std.os.linux.fanotify.InitFlags.html">InitFlags</a>, event_f_flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.FanotifyInitError">FanotifyInitError</a>!<span class="tok-type">i32</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fanotify_init</a>(flags, event_f_flags);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedFlags,
        .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FanotifyMarkError = <span class="tok-kw">error</span>{
    MarkAlreadyExists,
    IsDir,
    NotAssociatedWithFileSystem,
    FileNotFound,
    SystemResources,
    UserMarkQuotaExceeded,
    NotDir,
    OperationNotSupported,
    PermissionDenied,
    NotSameFileSystem,
    NameTooLong,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fanotify_mark</span>(
    fanotify_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    flags: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.fanotify.html">fanotify</a>.<a href="std.os.linux.fanotify.MarkFlags.html">MarkFlags</a>,
    mask: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.fanotify.html">fanotify</a>.<a href="std.os.linux.fanotify.MarkMask.html">MarkMask</a>,
    dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    pathname: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.posix.html#std.posix.FanotifyMarkError">FanotifyMarkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (pathname) |path| {
        <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.fanotify_markZ">fanotify_markZ</a>(fanotify_fd, flags, mask, dirfd, &amp;path_c);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.fanotify_markZ">fanotify_markZ</a>(fanotify_fd, flags, mask, dirfd, <span class="tok-null">null</span>);
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fanotify_markZ</span>(
    fanotify_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    flags: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.fanotify.html">fanotify</a>.<a href="std.os.linux.fanotify.MarkFlags.html">MarkFlags</a>,
    mask: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.fanotify.html">fanotify</a>.<a href="std.os.linux.fanotify.MarkMask.html">MarkMask</a>,
    dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    pathname: ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.posix.html#std.posix.FanotifyMarkError">FanotifyMarkError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fanotify_mark</a>(fanotify_fd, flags, mask, dirfd, pathname);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MarkAlreadyExists,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
        .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotAssociatedWithFileSystem,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UserMarkQuotaExceeded,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OperationNotSupported,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .XDEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotSameFileSystem,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MProtectError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The memory cannot be given the specified access.  This can happen, for example, if you</span>
    <span class="tok-comment">/// mmap(2)  a  file  to  which  you have read-only access, then ask mprotect() to mark it</span>
    <span class="tok-comment">/// PROT_WRITE.</span>
    AccessDenied,

    <span class="tok-comment">/// Changing  the  protection  of a memory region would result in the total number of map‐</span>
    <span class="tok-comment">/// pings with distinct attributes (e.g., read versus read/write protection) exceeding the</span>
    <span class="tok-comment">/// allowed maximum.  (For example, making the protection of a range PROT_READ in the mid‐</span>
    <span class="tok-comment">/// dle of a region currently protected as PROT_READ|PROT_WRITE would result in three map‐</span>
    <span class="tok-comment">/// pings: two read/write mappings at each end and a read-only mapping in the middle.)</span>
    OutOfMemory,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mprotect</span>(memory: []<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, protection: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.MProtectError">MProtectError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> win_prot: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a> = <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@truncate</span>(protection))) {
            <span class="tok-number">0b000</span> =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PAGE_NOACCESS">PAGE_NOACCESS</a>,
            <span class="tok-number">0b001</span> =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PAGE_READONLY">PAGE_READONLY</a>,
            <span class="tok-number">0b010</span> =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // +w -r not allowed
            </span><span class="tok-number">0b011</span> =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PAGE_READWRITE">PAGE_READWRITE</a>,
            <span class="tok-number">0b100</span> =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PAGE_EXECUTE">PAGE_EXECUTE</a>,
            <span class="tok-number">0b101</span> =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PAGE_EXECUTE_READ">PAGE_EXECUTE_READ</a>,
            <span class="tok-number">0b110</span> =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // +w -r not allowed
            </span><span class="tok-number">0b111</span> =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PAGE_EXECUTE_READWRITE">PAGE_EXECUTE_READWRITE</a>,
        };
        <span class="tok-kw">var</span> old: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a> = <span class="tok-null">undefined</span>;
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.VirtualProtect">VirtualProtect</a>(memory.ptr, memory.len, win_prot, &amp;old) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.InvalidAddress =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">error</span>.Unexpected =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">mprotect</a>(memory.ptr, memory.len, protection))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ForkError = <span class="tok-kw">error</span>{SystemResources} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fork</span>() <a href="std.posix.html#std.posix.ForkError">ForkError</a>!<a href="std.posix.html#std.posix.pid_t">pid_t</a> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fork</a>();
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MMapError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The underlying filesystem of the specified file does not support memory mapping.</span>
    MemoryMappingNotSupported,

    <span class="tok-comment">/// A file descriptor refers to a non-regular file. Or a file mapping was requested,</span>
    <span class="tok-comment">/// but the file descriptor is not open for reading. Or `MAP.SHARED` was requested</span>
    <span class="tok-comment">/// and `PROT_WRITE` is set, but the file descriptor is not open in `RDWR` mode.</span>
    <span class="tok-comment">/// Or `PROT_WRITE` is set, but the file is append-only.</span>
    AccessDenied,

    <span class="tok-comment">/// The `prot` argument asks for `PROT_EXEC` but the mapped area belongs to a file on</span>
    <span class="tok-comment">/// a filesystem that was mounted no-exec.</span>
    PermissionDenied,
    LockedMemoryLimitExceeded,
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    OutOfMemory,

    <span class="tok-comment">/// Using FIXED_NOREPLACE flag and the process has already mapped memory at the given address</span>
    MappingAlreadyExists,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Map files or devices into memory.</span>
<span class="tok-comment">/// `length` does not need to be aligned.</span>
<span class="tok-comment">/// Use of a mapped region can result in these signals:</span>
<span class="tok-comment">/// * SIGSEGV - Attempted write into a region mapped as read-only.</span>
<span class="tok-comment">/// * SIGBUS - Attempted  access to a portion of the buffer that does not correspond to the file</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mmap</span>(
    ptr: ?[*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>,
    length: <span class="tok-type">usize</span>,
    prot: <span class="tok-type">u32</span>,
    flags: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MAP</a>,
    fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    offset: <span class="tok-type">u64</span>,
) <a href="std.posix.html#std.posix.MMapError">MMapError</a>![]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> mmap_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">mmap64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">mmap</a>;
    <span class="tok-kw">const</span> rc = mmap_sym(ptr, length, prot, <span class="tok-builtin">@bitCast</span>(flags), fd, <span class="tok-builtin">@bitCast</span>(offset));
    <span class="tok-kw">const</span> err: <a href="std.posix.html#std.posix.E">E</a> = <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) blk: {
        <span class="tok-kw">if</span> (rc != <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.MAP_FAILED">MAP_FAILED</a>) <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(rc)))[<span class="tok-number">0</span>..length];
        <span class="tok-kw">break</span> :blk <span class="tok-builtin">@enumFromInt</span>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">_errno</a>().*);
    } <span class="tok-kw">else</span> blk: {
        <span class="tok-kw">const</span> err = <a href="std.posix.html#std.posix.errno">errno</a>(rc);
        <span class="tok-kw">if</span> (err == .SUCCESS) <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(rc))[<span class="tok-number">0</span>..length];
        <span class="tok-kw">break</span> :blk err;
    };
    <span class="tok-kw">switch</span> (err) {
        .SUCCESS =&gt; <span class="tok-kw">unreachable</span>,
        .TXTBSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LockedMemoryLimitExceeded,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition.
        </span>.OVERFLOW =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The number of pages used for length + offset would overflow.
        </span>.NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MemoryMappingNotSupported,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid parameters to mmap()
        </span>.MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
        .EXIST =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MappingAlreadyExists,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Deletes the mappings for the specified address range, causing</span>
<span class="tok-comment">/// further references to addresses within the range to generate invalid memory references.</span>
<span class="tok-comment">/// Note that while POSIX allows unmapping a region in the middle of an existing mapping,</span>
<span class="tok-comment">/// Zig's munmap function does not, for two reasons:</span>
<span class="tok-comment">/// * It violates the Zig principle that resource deallocation must succeed.</span>
<span class="tok-comment">/// * The Windows function, VirtualFree, has this restriction.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">munmap</span>(memory: []<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">munmap</a>(memory.ptr, memory.len))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid parameters.
        </span>.NOMEM =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Attempted to unmap a region in the middle of an existing mapping.
        </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MRemapError = <span class="tok-kw">error</span>{
    LockedMemoryLimitExceeded,
    <span class="tok-comment">/// Either a bug in the calling code, or the operating system abused the</span>
    <span class="tok-comment">/// EINVAL error code.</span>
    InvalidSyscallParameters,
    OutOfMemory,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mremap</span>(
    old_address: ?[*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>,
    old_len: <span class="tok-type">usize</span>,
    new_len: <span class="tok-type">usize</span>,
    flags: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">MREMAP</a>,
    new_address: ?[*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>,
) <a href="std.posix.html#std.posix.MRemapError">MRemapError</a>![]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">mremap</a>(old_address, old_len, new_len, flags, new_address);
    <span class="tok-kw">const</span> err: <a href="std.posix.html#std.posix.E">E</a> = <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) blk: {
        <span class="tok-kw">if</span> (rc != <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.MAP_FAILED">MAP_FAILED</a>) <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(rc)))[<span class="tok-number">0</span>..new_len];
        <span class="tok-kw">break</span> :blk <span class="tok-builtin">@enumFromInt</span>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">_errno</a>().*);
    } <span class="tok-kw">else</span> blk: {
        <span class="tok-kw">const</span> err = <a href="std.posix.html#std.posix.errno">errno</a>(rc);
        <span class="tok-kw">if</span> (err == .SUCCESS) <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(rc))[<span class="tok-number">0</span>..new_len];
        <span class="tok-kw">break</span> :blk err;
    };
    <span class="tok-kw">switch</span> (err) {
        .SUCCESS =&gt; <span class="tok-kw">unreachable</span>,
        .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LockedMemoryLimitExceeded,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidSyscallParameters,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MSyncError = <span class="tok-kw">error</span>{
    UnmappedMemory,
    PermissionDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">msync</span>(memory: []<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, flags: <span class="tok-type">i32</span>) <a href="std.posix.html#std.posix.MSyncError">MSyncError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">msync</a>(memory.ptr, memory.len, flags))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnmappedMemory,<span class="tok-comment"> // Unsuccessful, provided pointer does not point mapped memory
        </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid parameters.
        </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AccessError = <span class="tok-kw">error</span>{
    PermissionDenied,
    FileNotFound,
    NameTooLong,
    InputOutput,
    SystemResources,
    BadPathName,
    FileBusy,
    SymLinkLoop,
    ReadOnlyFileSystem,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// check user's permissions for a file</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// * On Windows, asserts `path` is valid [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// * On WASI, invalid UTF-8 passed to `path` causes `error.InvalidUtf8`.</span>
<span class="tok-comment">/// * On other platforms, `path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// On Windows, `mode` is ignored. This is a POSIX API that is only partially supported by</span>
<span class="tok-comment">/// Windows. See `fs` for the cross-platform file system API.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">access</span>(path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> path_w = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        _ = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetFileAttributesW">GetFileAttributesW</a>(path_w.span().ptr);
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.faccessat">faccessat</a>(<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a>, path, mode, <span class="tok-number">0</span>);
    }
    <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(path);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.accessZ">accessZ</a>(&amp;path_c, mode);
}

<span class="tok-comment">/// Same as `access` except `path` is null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessZ</span>(path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> path_w = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        _ = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetFileAttributesW">GetFileAttributesW</a>(path_w.span().ptr);
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.access">access</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(path, <span class="tok-number">0</span>), mode);
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">access</a>(path, mode))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .TXTBSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Check user's permissions for a file, based on an open directory handle.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// * On Windows, asserts `path` is valid [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// * On WASI, invalid UTF-8 passed to `path` causes `error.InvalidUtf8`.</span>
<span class="tok-comment">/// * On other platforms, `path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// On Windows, `mode` is ignored. This is a POSIX API that is only partially supported by</span>
<span class="tok-comment">/// Windows. See `fs` for the cross-platform file system API.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">faccessat</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <span class="tok-type">u32</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(dirfd, path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.faccessatW">faccessatW</a>(dirfd, path_w.span().ptr);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> resolved: <a href="std.posix.RelativePathWasi.html">RelativePathWasi</a> = .{ .dir_fd = dirfd, .relative_path = path };

        <span class="tok-kw">const</span> st = blk: {
            <span class="tok-kw">break</span> :blk <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.fstatat_wasi">fstatat_wasi</a>(dirfd, path, .{
                .SYMLINK_FOLLOW = (flags &amp; <a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">SYMLINK_NOFOLLOW</a>) == <span class="tok-number">0</span>,
            });
        } <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };

        <span class="tok-kw">if</span> (mode != <a href="std.posix.html#std.posix.F_OK">F_OK</a>) {
            <span class="tok-kw">var</span> directory: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.fdstat_t.html">fdstat_t</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">if</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_fdstat_get">fd_fdstat_get</a>(resolved.dir_fd, &amp;directory) != .SUCCESS) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied;
            }

            <span class="tok-kw">var</span> rights: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.rights_t.html">rights_t</a> = .{};
            <span class="tok-kw">if</span> (mode &amp; <a href="std.posix.html#std.posix.R_OK">R_OK</a> != <span class="tok-number">0</span>) {
                <span class="tok-kw">if</span> (st.filetype == .DIRECTORY) {
                    rights.FD_READDIR = <span class="tok-null">true</span>;
                } <span class="tok-kw">else</span> {
                    rights.FD_READ = <span class="tok-null">true</span>;
                }
            }
            <span class="tok-kw">if</span> (mode &amp; <a href="std.posix.html#std.posix.W_OK">W_OK</a> != <span class="tok-number">0</span>) {
                rights.FD_WRITE = <span class="tok-null">true</span>;
            }<span class="tok-comment">
            // No validation for X_OK

            // https://github.com/ziglang/zig/issues/18882
            </span><span class="tok-kw">const</span> rights_int: <span class="tok-type">u64</span> = <span class="tok-builtin">@bitCast</span>(rights);
            <span class="tok-kw">const</span> inheriting_int: <span class="tok-type">u64</span> = <span class="tok-builtin">@bitCast</span>(directory.fs_rights_inheriting);
            <span class="tok-kw">if</span> ((rights_int &amp; inheriting_int) != rights_int) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied;
            }
        }
        <span class="tok-kw">return</span>;
    }
    <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(path);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.faccessatZ">faccessatZ</a>(dirfd, &amp;path_c, mode, flags);
}

<span class="tok-comment">/// Same as `faccessat` except the path parameter is null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">faccessatZ</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <span class="tok-type">u32</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(dirfd, path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.faccessatW">faccessatW</a>(dirfd, path_w.span().ptr);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.faccessat">faccessat</a>(dirfd, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(path, <span class="tok-number">0</span>), mode, flags);
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">faccessat</a>(dirfd, path, mode, flags))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .TXTBSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Same as `faccessat` except asserts the target is Windows and the path parameter</span>
<span class="tok-comment">/// is NtDll-prefixed, null-terminated, WTF-16 encoded.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">faccessatW</span>(dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (sub_path_w[<span class="tok-number">0</span>] == <span class="tok-str">'.'</span> <span class="tok-kw">and</span> sub_path_w[<span class="tok-number">1</span>] == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span>;
    }
    <span class="tok-kw">if</span> (sub_path_w[<span class="tok-number">0</span>] == <span class="tok-str">'.'</span> <span class="tok-kw">and</span> sub_path_w[<span class="tok-number">1</span>] == <span class="tok-str">'.'</span> <span class="tok-kw">and</span> sub_path_w[<span class="tok-number">2</span>] == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">const</span> path_len_bytes = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u16</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sub_path_w, <span class="tok-number">0</span>).len * <span class="tok-number">2</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
    <span class="tok-kw">var</span> nt_name = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.UNICODE_STRING.html">UNICODE_STRING</a>{
        .Length = path_len_bytes,
        .MaximumLength = path_len_bytes,
        .Buffer = <span class="tok-builtin">@constCast</span>(sub_path_w),
    };
    <span class="tok-kw">var</span> attr = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.OBJECT_ATTRIBUTES.html">OBJECT_ATTRIBUTES</a>{
        .Length = <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.OBJECT_ATTRIBUTES.html">OBJECT_ATTRIBUTES</a>),
        .RootDirectory = <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(sub_path_w)) <span class="tok-null">null</span> <span class="tok-kw">else</span> dirfd,
        .Attributes = <span class="tok-number">0</span>,<span class="tok-comment"> // Note we do not use OBJ_CASE_INSENSITIVE here.
        </span>.ObjectName = &amp;nt_name,
        .SecurityDescriptor = <span class="tok-null">null</span>,
        .SecurityQualityOfService = <span class="tok-null">null</span>,
    };
    <span class="tok-kw">var</span> basic_info: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_BASIC_INFORMATION.html">FILE_BASIC_INFORMATION</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtQueryAttributesFile">NtQueryAttributesFile</a>(&amp;attr, &amp;basic_info)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .OBJECT_NAME_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .OBJECT_PATH_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .OBJECT_NAME_INVALID =&gt; <span class="tok-kw">unreachable</span>,
        .INVALID_PARAMETER =&gt; <span class="tok-kw">unreachable</span>,
        .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .OBJECT_PATH_SYNTAX_BAD =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; |rc| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedStatus">unexpectedStatus</a>(rc),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PipeError = <span class="tok-kw">error</span>{
    SystemFdQuotaExceeded,
    ProcessFdQuotaExceeded,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Creates a unidirectional data channel that can be used for interprocess communication.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pipe</span>() <a href="std.posix.html#std.posix.PipeError">PipeError</a>![<span class="tok-number">2</span>]<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">var</span> fds: [<span class="tok-number">2</span>]<a href="std.posix.html#std.posix.fd_t">fd_t</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">pipe</a>(&amp;fds))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> fds,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid parameters to pipe()
        </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid fds pointer
        </span>.NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pipe2</span>(flags: <a href="std.posix.html#std.posix.O">O</a>) <a href="std.posix.html#std.posix.PipeError">PipeError</a>![<span class="tok-number">2</span>]<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@TypeOf</span>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">pipe2</a>) != <span class="tok-type">void</span>) {
        <span class="tok-kw">var</span> fds: [<span class="tok-number">2</span>]<a href="std.posix.html#std.posix.fd_t">fd_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">pipe2</a>(&amp;fds, flags))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> fds,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid flags
            </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid fds pointer
            </span>.NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
            .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">const</span> fds: [<span class="tok-number">2</span>]<a href="std.posix.html#std.posix.fd_t">fd_t</a> = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.pipe">pipe</a>();
    <span class="tok-kw">errdefer</span> {
        <a href="std.posix.html#std.posix.close">close</a>(fds[<span class="tok-number">0</span>]);
        <a href="std.posix.html#std.posix.close">close</a>(fds[<span class="tok-number">1</span>]);
    }<span class="tok-comment">

    // https://github.com/ziglang/zig/issues/18882
    </span><span class="tok-kw">if</span> (<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(flags)) == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> fds;<span class="tok-comment">

    // CLOEXEC is special, it's a file descriptor flag and must be set using
    // F.SETFD.
    </span><span class="tok-kw">if</span> (flags.CLOEXEC) {
        <span class="tok-kw">for</span> (fds) |fd| {
            <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">fcntl</a>(fd, <a href="std.posix.html#std.posix.F">F</a>.<a href="#">SETFD</a>, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <a href="std.posix.html#std.posix.FD_CLOEXEC">FD_CLOEXEC</a>)))) {
                .SUCCESS =&gt; {},
                .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid flags
                </span>.BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition
                </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
        }
    }

    <span class="tok-kw">const</span> new_flags: <span class="tok-type">u32</span> = f: {
        <span class="tok-kw">var</span> new_flags = flags;
        new_flags.CLOEXEC = <span class="tok-null">false</span>;
        <span class="tok-kw">break</span> :f <span class="tok-builtin">@bitCast</span>(new_flags);
    };<span class="tok-comment">
    // Set every other flag affecting the file status using F.SETFL.
    </span><span class="tok-kw">if</span> (new_flags != <span class="tok-number">0</span>) {
        <span class="tok-kw">for</span> (fds) |fd| {
            <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">fcntl</a>(fd, <a href="std.posix.html#std.posix.F">F</a>.<a href="#">SETFL</a>, new_flags))) {
                .SUCCESS =&gt; {},
                .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid flags
                </span>.BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition
                </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
        }
    }

    <span class="tok-kw">return</span> fds;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SysCtlError = <span class="tok-kw">error</span>{
    PermissionDenied,
    SystemResources,
    NameTooLong,
    UnknownName,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sysctl</span>(
    name: []<span class="tok-kw">const</span> <span class="tok-type">c_int</span>,
    oldp: ?*<span class="tok-type">anyopaque</span>,
    oldlenp: ?*<span class="tok-type">usize</span>,
    newp: ?*<span class="tok-type">anyopaque</span>,
    newlen: <span class="tok-type">usize</span>,
) <a href="std.posix.html#std.posix.SysCtlError">SysCtlError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;sysctl not supported on WASI&quot;</span>);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .haiku) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;sysctl not supported on Haiku&quot;</span>);
    }

    <span class="tok-kw">const</span> name_len = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">c_uint</span>, name.len) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">sysctl</a>(name.ptr, name_len, oldp, oldlenp, newp, newlen))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownName,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sysctlbynameZ</span>(
    name: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    oldp: ?*<span class="tok-type">anyopaque</span>,
    oldlenp: ?*<span class="tok-type">usize</span>,
    newp: ?*<span class="tok-type">anyopaque</span>,
    newlen: <span class="tok-type">usize</span>,
) <a href="std.posix.html#std.posix.SysCtlError">SysCtlError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;sysctl not supported on WASI&quot;</span>);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .haiku) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;sysctl not supported on Haiku&quot;</span>);
    }

    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">sysctlbyname</a>(name, oldp, oldlenp, newp, newlen))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownName,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gettimeofday</span>(tv: ?*<a href="std.posix.html#std.posix.timeval">timeval</a>, tz: ?*<a href="std.posix.html#std.posix.timezone">timezone</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">gettimeofday</a>(tv, tz))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SeekError = <span class="tok-kw">error</span>{
    Unseekable,

    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to seek on it.</span>
    AccessDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Repositions read/write file offset relative to the beginning.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lseek_SET</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .linux <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a> <span class="tok-kw">and</span> <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) == <span class="tok-number">4</span>) {
        <span class="tok-kw">var</span> result: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">llseek</a>(fd, offset, &amp;result, <a href="std.posix.html#std.posix.SEEK">SEEK</a>.<a href="#">SET</a>))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SetFilePointerEx_BEGIN">SetFilePointerEx_BEGIN</a>(fd, offset);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> new_offset: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.filesize_t">filesize_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_seek">fd_seek</a>(fd, <span class="tok-builtin">@bitCast</span>(offset), .SET, &amp;new_offset)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">const</span> lseek_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">lseek64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">lseek</a>;
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(lseek_sym(fd, <span class="tok-builtin">@bitCast</span>(offset), <a href="std.posix.html#std.posix.SEEK">SEEK</a>.<a href="#">SET</a>))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
        </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Repositions read/write file offset relative to the current offset.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lseek_CUR</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, offset: <span class="tok-type">i64</span>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .linux <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a> <span class="tok-kw">and</span> <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) == <span class="tok-number">4</span>) {
        <span class="tok-kw">var</span> result: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">llseek</a>(fd, <span class="tok-builtin">@bitCast</span>(offset), &amp;result, <a href="std.posix.html#std.posix.SEEK">SEEK</a>.<a href="#">CUR</a>))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SetFilePointerEx_CURRENT">SetFilePointerEx_CURRENT</a>(fd, offset);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> new_offset: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.filesize_t">filesize_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_seek">fd_seek</a>(fd, offset, .CUR, &amp;new_offset)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">const</span> lseek_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">lseek64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">lseek</a>;
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(lseek_sym(fd, <span class="tok-builtin">@bitCast</span>(offset), <a href="std.posix.html#std.posix.SEEK">SEEK</a>.<a href="#">CUR</a>))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
        </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Repositions read/write file offset relative to the end.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lseek_END</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, offset: <span class="tok-type">i64</span>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .linux <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a> <span class="tok-kw">and</span> <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) == <span class="tok-number">4</span>) {
        <span class="tok-kw">var</span> result: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">llseek</a>(fd, <span class="tok-builtin">@bitCast</span>(offset), &amp;result, <a href="std.posix.html#std.posix.SEEK">SEEK</a>.<a href="#">END</a>))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SetFilePointerEx_END">SetFilePointerEx_END</a>(fd, offset);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> new_offset: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.filesize_t">filesize_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_seek">fd_seek</a>(fd, offset, .END, &amp;new_offset)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">const</span> lseek_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">lseek64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">lseek</a>;
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(lseek_sym(fd, <span class="tok-builtin">@bitCast</span>(offset), <a href="std.posix.html#std.posix.SEEK">SEEK</a>.<a href="#">END</a>))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
        </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Returns the read/write file offset relative to the beginning.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lseek_CUR_get</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">u64</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .linux <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a> <span class="tok-kw">and</span> <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) == <span class="tok-number">4</span>) {
        <span class="tok-kw">var</span> result: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">llseek</a>(fd, <span class="tok-number">0</span>, &amp;result, <a href="std.posix.html#std.posix.SEEK">SEEK</a>.<a href="#">CUR</a>))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> result,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SetFilePointerEx_CURRENT_get">SetFilePointerEx_CURRENT_get</a>(fd);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> new_offset: <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.filesize_t">filesize_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_seek">fd_seek</a>(fd, <span class="tok-number">0</span>, .CUR, &amp;new_offset)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> new_offset,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">const</span> lseek_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">lseek64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">lseek</a>;
    <span class="tok-kw">const</span> rc = lseek_sym(fd, <span class="tok-number">0</span>, <a href="std.posix.html#std.posix.SEEK">SEEK</a>.<a href="#">CUR</a>);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(rc),
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
        </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FcntlError = <span class="tok-kw">error</span>{
    PermissionDenied,
    FileBusy,
    ProcessFdQuotaExceeded,
    Locked,
    DeadLock,
    LockedRegionLimitExceeded,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fcntl</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, cmd: <span class="tok-type">i32</span>, arg: <span class="tok-type">usize</span>) <a href="std.posix.html#std.posix.FcntlError">FcntlError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fcntl</a>(fd, cmd, arg);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .AGAIN, .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Locked,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileBusy,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid parameters
            </span>.PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
            .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid parameter
            </span>.DEADLK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeadLock,
            .NOLCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LockedRegionLimitExceeded,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FlockError = <span class="tok-kw">error</span>{
    WouldBlock,

    <span class="tok-comment">/// The kernel ran out of memory for allocating file locks</span>
    SystemResources,

    <span class="tok-comment">/// The underlying filesystem does not support file locks</span>
    FileLocksNotSupported,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Depending on the operating system `flock` may or may not interact with</span>
<span class="tok-comment">/// `fcntl` locks made by other processes.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">flock</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, operation: <span class="tok-type">i32</span>) <a href="std.posix.html#std.posix.FlockError">FlockError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">flock</a>(fd, operation);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // invalid parameters
            </span>.NOLCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,<span class="tok-comment"> // TODO: integrate with async instead of just returning an error
            </span>.OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileLocksNotSupported,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RealPathError = <span class="tok-kw">error</span>{
    FileNotFound,
    AccessDenied,
    NameTooLong,
    NotSupported,
    NotDir,
    SymLinkLoop,
    InputOutput,
    FileTooBig,
    IsDir,
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    NoDevice,
    SystemResources,
    NoSpaceLeft,
    FileSystem,
    BadPathName,
    DeviceBusy,

    SharingViolation,
    PipeBusy,

    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,

    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,

    PathAlreadyExists,

    <span class="tok-comment">/// On Windows, antivirus software is enabled by default. It can be</span>
    <span class="tok-comment">/// disabled, but Windows Update sometimes ignores the user's preference</span>
    <span class="tok-comment">/// and re-enables it. When enabled, antivirus software on Windows</span>
    <span class="tok-comment">/// intercepts file system operations and makes them significantly slower</span>
    <span class="tok-comment">/// in addition to possibly failing with this error code.</span>
    AntivirusInterference,

    <span class="tok-comment">/// On Windows, the volume does not contain a recognized file system. File</span>
    <span class="tok-comment">/// system drivers might not be loaded, or the volume may be corrupt.</span>
    UnrecognizedVolume,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Return the canonicalized absolute pathname.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Expands all symbolic links and resolves references to `.`, `..`, and</span>
<span class="tok-comment">/// extra `/` characters in `pathname`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// On Windows, `pathname` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// On other platforms, `pathname` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The return value is a slice of `out_buffer`, but not necessarily from the beginning.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See also `realpathZ` and `realpathW`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// * On Windows, the result is encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// * On other platforms, the result is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Calling this function is usually a bug.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpath</span>(pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> pathname_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, pathname);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.realpathW">realpathW</a>(pathname_w.span(), out_buffer);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;WASI does not support os.realpath&quot;</span>);
    }
    <span class="tok-kw">const</span> pathname_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(pathname);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.realpathZ">realpathZ</a>(&amp;pathname_c, out_buffer);
}

<span class="tok-comment">/// Same as `realpath` except `pathname` is null-terminated.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Calling this function is usually a bug.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathZ</span>(pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> pathname_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, pathname);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.realpathW">realpathW</a>(pathname_w.span(), out_buffer);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.realpath">realpath</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(pathname, <span class="tok-number">0</span>), out_buffer);
    }
    <span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> flags: <a href="std.posix.html#std.posix.O">O</a> = <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
            .linux =&gt; .{
                .NONBLOCK = <span class="tok-null">true</span>,
                .CLOEXEC = <span class="tok-null">true</span>,
                .PATH = <span class="tok-null">true</span>,
            },
            <span class="tok-kw">else</span> =&gt; .{
                .NONBLOCK = <span class="tok-null">true</span>,
                .CLOEXEC = <span class="tok-null">true</span>,
            },
        };
        <span class="tok-kw">const</span> fd = <a href="std.posix.html#std.posix.openZ">openZ</a>(pathname, flags, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not asking for write permissions
            </span><span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // WASI-only
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        <span class="tok-kw">defer</span> <a href="std.posix.html#std.posix.close">close</a>(fd);

        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.getFdPath">getFdPath</a>(fd, out_buffer);
    }
    <span class="tok-kw">const</span> result_path = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.realpath">realpath</a>(pathname, out_buffer) <span class="tok-kw">orelse</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.posix.html#std.posix.E">E</a>, <span class="tok-builtin">@enumFromInt</span>(<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c._errno">_errno</a>().*))) {
        .SUCCESS =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotSupported,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    };
    <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(result_path, <span class="tok-number">0</span>);
}

<span class="tok-comment">/// Same as `realpath` except `pathname` is WTF16LE-encoded.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The result is encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Calling this function is usually a bug.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathW</span>(pathname: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> w = <a href="std.os.windows.html">windows</a>;

    <span class="tok-kw">const</span> dir = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().fd;
    <span class="tok-kw">const</span> access_mask = w.GENERIC_READ | w.SYNCHRONIZE;
    <span class="tok-kw">const</span> share_access = w.FILE_SHARE_READ | w.FILE_SHARE_WRITE | w.FILE_SHARE_DELETE;
    <span class="tok-kw">const</span> creation = w.FILE_OPEN;
    <span class="tok-kw">const</span> h_file = blk: {
        <span class="tok-kw">const</span> res = w.OpenFile(pathname, .{
            .dir = dir,
            .access_mask = access_mask,
            .share_access = share_access,
            .creation = creation,
            .filter = .any,
        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        <span class="tok-kw">break</span> :blk res;
    };
    <span class="tok-kw">defer</span> w.CloseHandle(h_file);

    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.getFdPath">getFdPath</a>(h_file, out_buffer);
}

<span class="tok-comment">/// Spurious wakeups are possible and no precision of timing is guaranteed.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nanosleep</span>(seconds: <span class="tok-type">u64</span>, nanoseconds: <span class="tok-type">u64</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> req = <a href="std.posix.html#std.posix.timespec">timespec</a>{
        .sec = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">isize</span>, seconds) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">isize</span>),
        .nsec = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">isize</span>, nanoseconds) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">isize</span>),
    };
    <span class="tok-kw">var</span> rem: <a href="std.posix.html#std.posix.timespec">timespec</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">nanosleep</a>(&amp;req, &amp;rem))) {
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; {<span class="tok-comment">
                // Sometimes Darwin returns EINVAL for no reason.
                // We treat it as a spurious wakeup.
                </span><span class="tok-kw">return</span>;
            },
            .INTR =&gt; {
                req = rem;
                <span class="tok-kw">continue</span>;
            },<span class="tok-comment">
            // This prong handles success as well as unexpected errors.
            </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span>,
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dl_iterate_phdr</span>(
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> Error: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> callback: <span class="tok-kw">fn</span> (info: *<a href="std.posix.html#std.posix.dl_phdr_info">dl_phdr_info</a>, size: <span class="tok-type">usize</span>, context: <span class="tok-builtin">@TypeOf</span>(context)) Error!<span class="tok-type">void</span>,
) Error!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> Context = <span class="tok-builtin">@TypeOf</span>(context);
    <span class="tok-kw">const</span> elf = <a href="std.html">std</a>.<a href="std.elf.html">elf</a>;
    <span class="tok-kw">const</span> dl = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dynamic_library.zig&quot;</span>);

    <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.object_format">object_format</a>) {
        .elf, .c =&gt; {},
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;dl_iterate_phdr is not available for this target&quot;</span>),
    }

    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.system">system</a>.<a href="#">dl_iterate_phdr</a>(<span class="tok-kw">struct</span> {
            <span class="tok-kw">fn</span> <span class="tok-fn">callbackC</span>(info: *<a href="std.posix.html#std.posix.dl_phdr_info">dl_phdr_info</a>, size: <span class="tok-type">usize</span>, data: ?*<span class="tok-type">anyopaque</span>) <span class="tok-kw">callconv</span>(.c) <span class="tok-type">c_int</span> {
                <span class="tok-kw">const</span> context_ptr: *<span class="tok-kw">const</span> Context = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(data));
                callback(info, size, context_ptr.*) <span class="tok-kw">catch</span> |err| <span class="tok-kw">return</span> <span class="tok-builtin">@intFromError</span>(err);
                <span class="tok-kw">return</span> <span class="tok-number">0</span>;
            }
        }.callbackC, <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@constCast</span>(&amp;context)))) {
            <span class="tok-number">0</span> =&gt; <span class="tok-kw">return</span>,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(Error, <span class="tok-builtin">@errorCast</span>(<span class="tok-builtin">@errorFromInt</span>(<span class="tok-builtin">@as</span>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">anyerror</span>)), <span class="tok-builtin">@intCast</span>(err))))),
        }
    }

    <span class="tok-kw">const</span> elf_base = <a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.html#std.process.getBaseAddress">getBaseAddress</a>();
    <span class="tok-kw">const</span> ehdr: *elf.Ehdr = <span class="tok-builtin">@ptrFromInt</span>(elf_base);<span class="tok-comment">
    // Make sure the base address points to an ELF image.
    </span><a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, ehdr.e_ident[<span class="tok-number">0</span>..<span class="tok-number">4</span>], elf.MAGIC));
    <span class="tok-kw">const</span> n_phdr = ehdr.e_phnum;
    <span class="tok-kw">const</span> phdrs = (<span class="tok-builtin">@as</span>([*]elf.Phdr, <span class="tok-builtin">@ptrFromInt</span>(elf_base + ehdr.e_phoff)))[<span class="tok-number">0</span>..n_phdr];

    <span class="tok-kw">var</span> it = dl.linkmap_iterator(phdrs) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;<span class="tok-comment">

    // The executable has no dynamic link segment, create a single entry for
    // the whole ELF image.
    </span><span class="tok-kw">if</span> (it.end()) {<span class="tok-comment">
        // Find the base address for the ELF image, if this is a PIE the value
        // is non-zero.
        </span><span class="tok-kw">const</span> base_address = <span class="tok-kw">for</span> (phdrs) |*phdr| {
            <span class="tok-kw">if</span> (phdr.p_type == elf.PT_PHDR) {
                <span class="tok-kw">break</span> <span class="tok-builtin">@intFromPtr</span>(phdrs.ptr) - phdr.p_vaddr;<span class="tok-comment">
                // We could try computing the difference between _DYNAMIC and
                // the p_vaddr of the PT_DYNAMIC section, but using the phdr is
                // good enough (Is it?).
            </span>}
        } <span class="tok-kw">else</span> <span class="tok-kw">unreachable</span>;

        <span class="tok-kw">var</span> info = <a href="std.posix.html#std.posix.dl_phdr_info">dl_phdr_info</a>{
            .addr = base_address,
            .name = <span class="tok-str">&quot;/proc/self/exe&quot;</span>,
            .phdr = phdrs.ptr,
            .phnum = ehdr.e_phnum,
        };

        <span class="tok-kw">return</span> callback(&amp;info, <span class="tok-builtin">@sizeOf</span>(<a href="std.posix.html#std.posix.dl_phdr_info">dl_phdr_info</a>), context);
    }<span class="tok-comment">

    // Last return value from the callback function.
    </span><span class="tok-kw">while</span> (it.next()) |entry| {
        <span class="tok-kw">var</span> phdr: [*]elf.Phdr = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> phnum: <span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;

        <span class="tok-kw">if</span> (entry.l_addr != <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> elf_header: *elf.Ehdr = <span class="tok-builtin">@ptrFromInt</span>(entry.l_addr);
            phdr = <span class="tok-builtin">@ptrFromInt</span>(entry.l_addr + elf_header.e_phoff);
            phnum = elf_header.e_phnum;
        } <span class="tok-kw">else</span> {<span class="tok-comment">
            // This is the running ELF image
            </span>phdr = <span class="tok-builtin">@ptrFromInt</span>(elf_base + ehdr.e_phoff);
            phnum = ehdr.e_phnum;
        }

        <span class="tok-kw">var</span> info = <a href="std.posix.html#std.posix.dl_phdr_info">dl_phdr_info</a>{
            .addr = entry.l_addr,
            .name = entry.l_name,
            .phdr = phdr,
            .phnum = phnum,
        };

        <span class="tok-kw">try</span> callback(&amp;info, <span class="tok-builtin">@sizeOf</span>(<a href="std.posix.html#std.posix.dl_phdr_info">dl_phdr_info</a>), context);
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ClockGetTimeError = <span class="tok-kw">error</span>{UnsupportedClock} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clock_gettime</span>(clock_id: <a href="std.posix.html#std.posix.clockid_t">clockid_t</a>) <a href="std.posix.html#std.posix.ClockGetTimeError">ClockGetTimeError</a>!<a href="std.posix.html#std.posix.timespec">timespec</a> {
    <span class="tok-kw">var</span> tp: <a href="std.posix.html#std.posix.timespec">timespec</a> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Windows does not support POSIX; use Windows-specific API or cross-platform std.time API&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> ts: <a href="std.posix.html#std.posix.timestamp_t">timestamp_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.system">system</a>.<a href="#">clock_time_get</a>(clock_id, <span class="tok-number">1</span>, &amp;ts)) {
            .SUCCESS =&gt; {
                tp = .{
                    .sec = <span class="tok-builtin">@intCast</span>(ts / <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a>),
                    .nsec = <span class="tok-builtin">@intCast</span>(ts % <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a>),
                };
            },
            .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedClock,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
        <span class="tok-kw">return</span> tp;
    }

    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">clock_gettime</a>(clock_id, &amp;tp))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> tp,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedClock,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clock_getres</span>(clock_id: <a href="std.posix.html#std.posix.clockid_t">clockid_t</a>, res: *<a href="std.posix.html#std.posix.timespec">timespec</a>) <a href="std.posix.html#std.posix.ClockGetTimeError">ClockGetTimeError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> ts: <a href="std.posix.html#std.posix.timestamp_t">timestamp_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.system">system</a>.<a href="#">clock_res_get</a>(<span class="tok-builtin">@bitCast</span>(clock_id), &amp;ts)) {
            .SUCCESS =&gt; res.* = .{
                .sec = <span class="tok-builtin">@intCast</span>(ts / <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a>),
                .nsec = <span class="tok-builtin">@intCast</span>(ts % <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a>),
            },
            .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedClock,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">clock_getres</a>(clock_id, res))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedClock,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SchedGetAffinityError = <span class="tok-kw">error</span>{PermissionDenied} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sched_getaffinity</span>(pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>) <a href="std.posix.html#std.posix.SchedGetAffinityError">SchedGetAffinityError</a>!<a href="std.posix.html#std.posix.cpu_set_t">cpu_set_t</a> {
    <span class="tok-kw">var</span> set: <a href="std.posix.html#std.posix.cpu_set_t">cpu_set_t</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">sched_getaffinity</a>(pid, <span class="tok-builtin">@sizeOf</span>(<a href="std.posix.html#std.posix.cpu_set_t">cpu_set_t</a>), &amp;set))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> set,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .SRCH =&gt; <span class="tok-kw">unreachable</span>,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SigaltstackError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The supplied stack size was less than MINSIGSTKSZ.</span>
    SizeTooSmall,

    <span class="tok-comment">/// Attempted to change the signal stack while it was active.</span>
    PermissionDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sigaltstack</span>(ss: ?*<a href="std.posix.html#std.posix.stack_t">stack_t</a>, old_ss: ?*<a href="std.posix.html#std.posix.stack_t">stack_t</a>) <a href="std.posix.html#std.posix.SigaltstackError">SigaltstackError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">sigaltstack</a>(ss, old_ss))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SizeTooSmall,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Examine and change a signal action.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sigaction</span>(sig: <span class="tok-type">u6</span>, <span class="tok-kw">noalias</span> act: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.Sigaction">Sigaction</a>, <span class="tok-kw">noalias</span> oact: ?*<a href="std.posix.html#std.posix.Sigaction">Sigaction</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">sigaction</a>(sig, act, oact))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,<span class="tok-comment">
        // EINVAL means the signal is either invalid or some signal that cannot have its action
        // changed. For POSIX, this means SIGKILL/SIGSTOP. For e.g. Solaris, this also includes the
        // non-standard SIGWAITING, SIGCANCEL, and SIGLWP. Either way, programmer error.
        </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
}

<span class="tok-comment">/// Sets the thread signal mask.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sigprocmask</span>(flags: <span class="tok-type">u32</span>, <span class="tok-kw">noalias</span> set: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sigset_t">sigset_t</a>, <span class="tok-kw">noalias</span> oldset: ?*<a href="std.posix.html#std.posix.sigset_t">sigset_t</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">sigprocmask</a>(<span class="tok-builtin">@bitCast</span>(flags), set, oldset))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FutimensError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// times is NULL, or both nsec values are UTIME_NOW, and either:</span>
    <span class="tok-comment">/// *  the effective user ID of the caller does not match the  owner</span>
    <span class="tok-comment">///    of  the  file,  the  caller does not have write access to the</span>
    <span class="tok-comment">///    file, and the caller is not privileged (Linux: does not  have</span>
    <span class="tok-comment">///    either  the  CAP_FOWNER  or the CAP_DAC_OVERRIDE capability);</span>
    <span class="tok-comment">///    or,</span>
    <span class="tok-comment">/// *  the file is marked immutable (see chattr(1)).</span>
    AccessDenied,

    <span class="tok-comment">/// The caller attempted to change one or both timestamps to a value</span>
    <span class="tok-comment">/// other than the current time, or to change one of the  timestamps</span>
    <span class="tok-comment">/// to the current time while leaving the other timestamp unchanged,</span>
    <span class="tok-comment">/// (i.e., times is not NULL, neither nsec  field  is  UTIME_NOW,</span>
    <span class="tok-comment">/// and neither nsec field is UTIME_OMIT) and either:</span>
    <span class="tok-comment">/// *  the  caller's  effective  user ID does not match the owner of</span>
    <span class="tok-comment">///    file, and the caller is not privileged (Linux: does not  have</span>
    <span class="tok-comment">///    the CAP_FOWNER capability); or,</span>
    <span class="tok-comment">/// *  the file is marked append-only or immutable (see chattr(1)).</span>
    PermissionDenied,

    ReadOnlyFileSystem,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">futimens</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, times: ?*<span class="tok-kw">const</span> [<span class="tok-number">2</span>]<a href="std.posix.html#std.posix.timespec">timespec</a>) <a href="std.posix.html#std.posix.FutimensError">FutimensError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {<span class="tok-comment">
        // TODO WASI encodes `wasi.fstflags` to signify magic values
        // similar to UTIME_NOW and UTIME_OMIT. Currently, we ignore
        // this here, but we should really handle it somehow.
        </span><span class="tok-kw">const</span> error_code = blk: {
            <span class="tok-kw">if</span> (times) |times_arr| {
                <span class="tok-kw">const</span> atim = times_arr[<span class="tok-number">0</span>].toTimestamp();
                <span class="tok-kw">const</span> mtim = times_arr[<span class="tok-number">1</span>].toTimestamp();
                <span class="tok-kw">break</span> :blk <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_filestat_set_times">fd_filestat_set_times</a>(fd, atim, mtim, .{
                    .ATIM = <span class="tok-null">true</span>,
                    .MTIM = <span class="tok-null">true</span>,
                });
            }

            <span class="tok-kw">break</span> :blk <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_filestat_set_times">fd_filestat_set_times</a>(fd, <span class="tok-number">0</span>, <span class="tok-number">0</span>, .{
                .ATIM_NOW = <span class="tok-null">true</span>,
                .MTIM_NOW = <span class="tok-null">true</span>,
            });
        };
        <span class="tok-kw">switch</span> (error_code) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }

    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">futimens</a>(fd, times))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
        </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .ROFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadOnlyFileSystem,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetHostNameError = <span class="tok-kw">error</span>{PermissionDenied} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gethostname</span>(name_buffer: *[<a href="std.posix.html#std.posix.HOST_NAME_MAX">HOST_NAME_MAX</a>]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.GetHostNameError">GetHostNameError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">gethostname</a>(name_buffer, name_buffer.len))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(name_buffer, <span class="tok-number">0</span>),
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .NAMETOOLONG =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // HOST_NAME_MAX prevents this
            </span>.PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .linux) {
        <span class="tok-kw">const</span> uts = <a href="std.posix.html#std.posix.uname">uname</a>();
        <span class="tok-kw">const</span> hostname = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;uts.nodename, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> result = name_buffer[<span class="tok-number">0</span>..hostname.len];
        <span class="tok-builtin">@memcpy</span>(result, hostname);
        <span class="tok-kw">return</span> result;
    }

    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;TODO implement gethostname for this OS&quot;</span>);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">uname</span>() <a href="std.posix.html#std.posix.utsname">utsname</a> {
    <span class="tok-kw">var</span> uts: <a href="std.posix.html#std.posix.utsname">utsname</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">uname</a>(&amp;uts))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> uts,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">res_mkquery</span>(
    op: <span class="tok-type">u4</span>,
    dname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    class: <span class="tok-type">u8</span>,
    ty: <span class="tok-type">u8</span>,
    data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    newrr: ?[*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    buf: []<span class="tok-type">u8</span>,
) <span class="tok-type">usize</span> {
    _ = data;
    _ = newrr;<span class="tok-comment">
    // This implementation is ported from musl libc.
    // A more idiomatic &quot;ziggy&quot; implementation would be welcome.
    </span><span class="tok-kw">var</span> name = dname;
    <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.endsWith">endsWith</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>)) name.len -= <span class="tok-number">1</span>;
    <a href="std.debug.html#std.debug.assert">assert</a>(name.len &lt;= <span class="tok-number">253</span>);
    <span class="tok-kw">const</span> n = <span class="tok-number">17</span> + name.len + <span class="tok-builtin">@intFromBool</span>(name.len != <span class="tok-number">0</span>);<span class="tok-comment">

    // Construct query template - ID will be filled later
    </span><span class="tok-kw">var</span> q: [<span class="tok-number">280</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-builtin">@memset</span>(q[<span class="tok-number">0</span>..n], <span class="tok-number">0</span>);
    q[<span class="tok-number">2</span>] = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, op) * <span class="tok-number">8</span> + <span class="tok-number">1</span>;
    q[<span class="tok-number">5</span>] = <span class="tok-number">1</span>;
    <span class="tok-builtin">@memcpy</span>(q[<span class="tok-number">13</span>..][<span class="tok-number">0</span>..name.len], name);
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">13</span>;
    <span class="tok-kw">var</span> j: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">while</span> (q[i] != <span class="tok-number">0</span>) : (i = j + <span class="tok-number">1</span>) {
        j = i;
        <span class="tok-kw">while</span> (q[j] != <span class="tok-number">0</span> <span class="tok-kw">and</span> q[j] != <span class="tok-str">'.'</span>) : (j += <span class="tok-number">1</span>) {}<span class="tok-comment">
        // TODO determine the circumstances for this and whether or
        // not this should be an error.
        </span><span class="tok-kw">if</span> (j - i - <span class="tok-number">1</span> &gt; <span class="tok-number">62</span>) <span class="tok-kw">unreachable</span>;
        q[i - <span class="tok-number">1</span>] = <span class="tok-builtin">@intCast</span>(j - i);
    }
    q[i + <span class="tok-number">1</span>] = ty;
    q[i + <span class="tok-number">3</span>] = class;<span class="tok-comment">

    // Make a reasonably unpredictable id
    </span><span class="tok-kw">const</span> ts = <a href="std.posix.html#std.posix.clock_gettime">clock_gettime</a>(.REALTIME) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">const</span> UInt = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-builtin">@TypeOf</span>(ts.nsec)));
    <span class="tok-kw">const</span> unsec: UInt = <span class="tok-builtin">@bitCast</span>(ts.nsec);
    <span class="tok-kw">const</span> id: <span class="tok-type">u32</span> = <span class="tok-builtin">@truncate</span>(unsec + unsec / <span class="tok-number">65536</span>);
    q[<span class="tok-number">0</span>] = <span class="tok-builtin">@truncate</span>(id / <span class="tok-number">256</span>);
    q[<span class="tok-number">1</span>] = <span class="tok-builtin">@truncate</span>(id);

    <span class="tok-builtin">@memcpy</span>(buf[<span class="tok-number">0</span>..n], q[<span class="tok-number">0</span>..n]);
    <span class="tok-kw">return</span> n;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SendError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// (For UNIX domain sockets, which are identified by pathname) Write permission is  denied</span>
    <span class="tok-comment">/// on  the destination socket file, or search permission is denied for one of the</span>
    <span class="tok-comment">/// directories the path prefix.  (See path_resolution(7).)</span>
    <span class="tok-comment">/// (For UDP sockets) An attempt was made to send to a network/broadcast address as  though</span>
    <span class="tok-comment">/// it was a unicast address.</span>
    AccessDenied,

    <span class="tok-comment">/// The socket is marked nonblocking and the requested operation would block, and</span>
    <span class="tok-comment">/// there is no global event loop configured.</span>
    <span class="tok-comment">/// It's also possible to get this error under the following condition:</span>
    <span class="tok-comment">/// (Internet  domain datagram sockets) The socket referred to by sockfd had not previously</span>
    <span class="tok-comment">/// been bound to an address and, upon attempting to bind it to an ephemeral port,  it  was</span>
    <span class="tok-comment">/// determined that all port numbers in the ephemeral port range are currently in use.  See</span>
    <span class="tok-comment">/// the discussion of /proc/sys/net/ipv4/ip_local_port_range in ip(7).</span>
    WouldBlock,

    <span class="tok-comment">/// Another Fast Open is already in progress.</span>
    FastOpenAlreadyInProgress,

    <span class="tok-comment">/// Connection reset by peer.</span>
    ConnectionResetByPeer,

    <span class="tok-comment">/// The  socket  type requires that message be sent atomically, and the size of the message</span>
    <span class="tok-comment">/// to be sent made this impossible. The message is not transmitted.</span>
    MessageTooBig,

    <span class="tok-comment">/// The output queue for a network interface was full.  This generally indicates  that  the</span>
    <span class="tok-comment">/// interface  has  stopped sending, but may be caused by transient congestion.  (Normally,</span>
    <span class="tok-comment">/// this does not occur in Linux.  Packets are just silently dropped when  a  device  queue</span>
    <span class="tok-comment">/// overflows.)</span>
    <span class="tok-comment">/// This is also caused when there is not enough kernel memory available.</span>
    SystemResources,

    <span class="tok-comment">/// The  local  end  has been shut down on a connection oriented socket.  In this case, the</span>
    <span class="tok-comment">/// process will also receive a SIGPIPE unless MSG.NOSIGNAL is set.</span>
    BrokenPipe,

    FileDescriptorNotASocket,

    <span class="tok-comment">/// Network is unreachable.</span>
    NetworkUnreachable,

    <span class="tok-comment">/// The local network interface used to reach the destination is down.</span>
    NetworkSubsystemFailed,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SendMsgError = <a href="std.posix.html#std.posix.SendError">SendError</a> || <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The passed address didn't have the correct address family in its sa_family field.</span>
    AddressFamilyNotSupported,

    <span class="tok-comment">/// Returned when socket is AF.UNIX and the given path has a symlink loop.</span>
    SymLinkLoop,

    <span class="tok-comment">/// Returned when socket is AF.UNIX and the given path length exceeds `max_path_bytes` bytes.</span>
    NameTooLong,

    <span class="tok-comment">/// Returned when socket is AF.UNIX and the given path does not point to an existing file.</span>
    FileNotFound,
    NotDir,

    <span class="tok-comment">/// The socket is not connected (connection-oriented sockets only).</span>
    SocketNotConnected,
    AddressNotAvailable,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sendmsg</span>(
    <span class="tok-comment">/// The file descriptor of the sending socket.</span>
    sockfd: <a href="std.posix.html#std.posix.socket_t">socket_t</a>,
    <span class="tok-comment">/// Message header and iovecs</span>
    msg: *<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.msghdr_const">msghdr_const</a>,
    flags: <span class="tok-type">u32</span>,
) <a href="std.posix.html#std.posix.SendMsgError">SendMsgError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">sendmsg</a>(sockfd, msg, flags);
        <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
            <span class="tok-kw">if</span> (rc == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a>) {
                <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                    .WSAEACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                    .WSAEADDRNOTAVAIL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressNotAvailable,
                    .WSAECONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
                    .WSAEMSGSIZE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MessageTooBig,
                    .WSAENOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                    .WSAENOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
                    .WSAEAFNOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
                    .WSAEDESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // A destination address is required.
                    </span>.WSAEFAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The lpBuffers, lpTo, lpOverlapped, lpNumberOfBytesSent, or lpCompletionRoutine parameters are not part of the user address space, or the lpTo parameter is too small.
                    </span>.WSAEHOSTUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,<span class="tok-comment">
                    // TODO: WSAEINPROGRESS, WSAEINTR
                    </span>.WSAEINVAL =&gt; <span class="tok-kw">unreachable</span>,
                    .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                    .WSAENETRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
                    .WSAENETUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
                    .WSAENOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
                    .WSAESHUTDOWN =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The socket has been shut down; it is not possible to WSASendTo on a socket after shutdown has been invoked with how set to SD_SEND or SD_BOTH.
                    </span>.WSAEWOULDBLOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
                    .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // A successful WSAStartup call must occur before using this function.
                    </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
                }
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc);
            }
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),

                .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
                .ALREADY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FastOpenAlreadyInProgress,
                .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
                </span>.CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
                .DESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The socket is not connection-mode, and no peer address is set.
                </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // An invalid user space address was specified for an argument.
                </span>.INTR =&gt; <span class="tok-kw">continue</span>,
                .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid argument passed.
                </span>.ISCONN =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // connection-mode socket was connected already but a recipient was specified
                </span>.MSGSIZE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MessageTooBig,
                .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                .NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The file descriptor sockfd does not refer to a socket.
                </span>.OPNOTSUPP =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Some bit in the flags argument is inappropriate for the socket type.
                </span>.PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
                .AFNOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
                .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
                .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
                .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
                .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
                .HOSTUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
                .NETUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
                .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
                .NETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SendToError = <a href="std.posix.html#std.posix.SendMsgError">SendMsgError</a> || <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The destination address is not reachable by the bound address.</span>
    UnreachableAddress,
    <span class="tok-comment">/// The destination address is not listening.</span>
    ConnectionRefused,
};

<span class="tok-comment">/// Transmit a message to another socket.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The `sendto` call may be used only when the socket is in a connected state (so that the intended</span>
<span class="tok-comment">/// recipient  is  known). The  following call</span>
<span class="tok-comment">///</span>
<span class="tok-comment">///     send(sockfd, buf, len, flags);</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// is equivalent to</span>
<span class="tok-comment">///</span>
<span class="tok-comment">///     sendto(sockfd, buf, len, flags, NULL, 0);</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// If  sendto()  is used on a connection-mode (`SOCK.STREAM`, `SOCK.SEQPACKET`) socket, the arguments</span>
<span class="tok-comment">/// `dest_addr` and `addrlen` are asserted to be `null` and `0` respectively, and asserted</span>
<span class="tok-comment">/// that the socket was actually connected.</span>
<span class="tok-comment">/// Otherwise, the address of the target is given by `dest_addr` with `addrlen` specifying  its  size.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// If the message is too long to pass atomically through the underlying protocol,</span>
<span class="tok-comment">/// `SendError.MessageTooBig` is returned, and the message is not transmitted.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// There is no  indication  of  failure  to  deliver.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// When the message does not fit into the send buffer of  the  socket,  `sendto`  normally  blocks,</span>
<span class="tok-comment">/// unless  the socket has been placed in nonblocking I/O mode.  In nonblocking mode it would fail</span>
<span class="tok-comment">/// with `SendError.WouldBlock`.  The `select` call may be used  to  determine when it is</span>
<span class="tok-comment">/// possible to send more data.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sendto</span>(
    <span class="tok-comment">/// The file descriptor of the sending socket.</span>
    sockfd: <a href="std.posix.html#std.posix.socket_t">socket_t</a>,
    <span class="tok-comment">/// Message to send.</span>
    buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <span class="tok-type">u32</span>,
    dest_addr: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sockaddr">sockaddr</a>,
    addrlen: <a href="std.posix.html#std.posix.socklen_t">socklen_t</a>,
) <a href="std.posix.html#std.posix.SendToError">SendToError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sendto">sendto</a>(sockfd, buf.ptr, buf.len, flags, dest_addr, addrlen)) {
            <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a> =&gt; <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                .WSAEACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                .WSAEADDRNOTAVAIL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressNotAvailable,
                .WSAECONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
                .WSAEMSGSIZE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MessageTooBig,
                .WSAENOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                .WSAENOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
                .WSAEAFNOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
                .WSAEDESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // A destination address is required.
                </span>.WSAEFAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The lpBuffers, lpTo, lpOverlapped, lpNumberOfBytesSent, or lpCompletionRoutine parameters are not part of the user address space, or the lpTo parameter is too small.
                </span>.WSAEHOSTUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,<span class="tok-comment">
                // TODO: WSAEINPROGRESS, WSAEINTR
                </span>.WSAEINVAL =&gt; <span class="tok-kw">unreachable</span>,
                .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                .WSAENETRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
                .WSAENETUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
                .WSAENOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
                .WSAESHUTDOWN =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The socket has been shut down; it is not possible to WSASendTo on a socket after shutdown has been invoked with how set to SD_SEND or SD_BOTH.
                </span>.WSAEWOULDBLOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
                .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // A successful WSAStartup call must occur before using this function.
                </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
            },
            <span class="tok-kw">else</span> =&gt; |rc| <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        }
    }
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">sendto</a>(sockfd, buf.ptr, buf.len, flags, dest_addr, addrlen);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),

            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
            .ALREADY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FastOpenAlreadyInProgress,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.CONNREFUSED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionRefused,
            .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
            .DESTADDRREQ =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The socket is not connection-mode, and no peer address is set.
            </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // An invalid user space address was specified for an argument.
            </span>.INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnreachableAddress,
            .ISCONN =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // connection-mode socket was connected already but a recipient was specified
            </span>.MSGSIZE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MessageTooBig,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The file descriptor sockfd does not refer to a socket.
            </span>.OPNOTSUPP =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Some bit in the flags argument is inappropriate for the socket type.
            </span>.PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
            .AFNOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
            .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
            .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
            .HOSTUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
            .NETUNREACH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkUnreachable,
            .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
            .NETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-comment">/// Transmit a message to another socket.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The `send` call may be used only when the socket is in a connected state (so that the intended</span>
<span class="tok-comment">/// recipient  is  known).   The  only  difference  between `send` and `write` is the presence of</span>
<span class="tok-comment">/// flags.  With a zero flags argument, `send` is equivalent to  `write`.   Also,  the  following</span>
<span class="tok-comment">/// call</span>
<span class="tok-comment">///</span>
<span class="tok-comment">///     send(sockfd, buf, len, flags);</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// is equivalent to</span>
<span class="tok-comment">///</span>
<span class="tok-comment">///     sendto(sockfd, buf, len, flags, NULL, 0);</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// There is no  indication  of  failure  to  deliver.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// When the message does not fit into the send buffer of  the  socket,  `send`  normally  blocks,</span>
<span class="tok-comment">/// unless  the socket has been placed in nonblocking I/O mode.  In nonblocking mode it would fail</span>
<span class="tok-comment">/// with `SendError.WouldBlock`.  The `select` call may be used  to  determine when it is</span>
<span class="tok-comment">/// possible to send more data.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">send</span>(
    <span class="tok-comment">/// The file descriptor of the sending socket.</span>
    sockfd: <a href="std.posix.html#std.posix.socket_t">socket_t</a>,
    buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <span class="tok-type">u32</span>,
) <a href="std.posix.html#std.posix.SendError">SendError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.sendto">sendto</a>(sockfd, buf, flags, <span class="tok-null">null</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.AddressFamilyNotSupported =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.SymLinkLoop =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.NotDir =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.NetworkUnreachable =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.AddressNotAvailable =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.SocketNotConnected =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.UnreachableAddress =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">error</span>.ConnectionRefused =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SendFileError = <a href="std.posix.html#std.posix.PReadError">PReadError</a> || <a href="std.posix.html#std.posix.WriteError">WriteError</a> || <a href="std.posix.html#std.posix.SendError">SendError</a>;

<span class="tok-comment">/// Transfer data between file descriptors, with optional headers and trailers.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Returns the number of bytes written, which can be zero.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The `sendfile` call copies `in_len` bytes from one file descriptor to another. When possible,</span>
<span class="tok-comment">/// this is done within the operating system kernel, which can provide better performance</span>
<span class="tok-comment">/// characteristics than transferring data from kernel to user space and back, such as with</span>
<span class="tok-comment">/// `read` and `write` calls. When `in_len` is `0`, it means to copy until the end of the input file has been</span>
<span class="tok-comment">/// reached. Note, however, that partial writes are still possible in this case.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `in_fd` must be a file descriptor opened for reading, and `out_fd` must be a file descriptor</span>
<span class="tok-comment">/// opened for writing. They may be any kind of file descriptor; however, if `in_fd` is not a regular</span>
<span class="tok-comment">/// file system file, it may cause this function to fall back to calling `read` and `write`, in which case</span>
<span class="tok-comment">/// atomicity guarantees no longer apply.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Copying begins reading at `in_offset`. The input file descriptor seek position is ignored and not updated.</span>
<span class="tok-comment">/// If the output file descriptor has a seek position, it is updated as bytes are written. When</span>
<span class="tok-comment">/// `in_offset` is past the end of the input file, it successfully reads 0 bytes.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `flags` has different meanings per operating system; refer to the respective man pages.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// These systems support atomically sending everything, including headers and trailers:</span>
<span class="tok-comment">/// * macOS</span>
<span class="tok-comment">/// * FreeBSD</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// These systems support in-kernel data copying, but headers and trailers are not sent atomically:</span>
<span class="tok-comment">/// * Linux</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Other systems fall back to calling `read` / `write`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Linux has a limit on how many bytes may be transferred in one `sendfile` call, which is `0x7ffff000`</span>
<span class="tok-comment">/// on both 64-bit and 32-bit systems. This is due to using a signed C int as the return value, as</span>
<span class="tok-comment">/// well as stuffing the errno codes into the last `4096` values. This is noted on the `sendfile` man page.</span>
<span class="tok-comment">/// The limit on Darwin is `0x7fffffff`, trying to write more than that returns EINVAL.</span>
<span class="tok-comment">/// The corresponding POSIX limit on this is `maxInt(isize)`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sendfile</span>(
    out_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    in_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    in_offset: <span class="tok-type">u64</span>,
    in_len: <span class="tok-type">u64</span>,
    headers: []<span class="tok-kw">const</span> <a href="std.posix.iovec_const.html">iovec_const</a>,
    trailers: []<span class="tok-kw">const</span> <a href="std.posix.iovec_const.html">iovec_const</a>,
    flags: <span class="tok-type">u32</span>,
) <a href="std.posix.html#std.posix.SendFileError">SendFileError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> header_done = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> total_written: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;<span class="tok-comment">

    // Prevents EOVERFLOW.
    </span><span class="tok-kw">const</span> size_t = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <span class="tok-builtin">@typeInfo</span>(<span class="tok-type">usize</span>).int.bits - <span class="tok-number">1</span>);
    <span class="tok-kw">const</span> max_count = <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .linux =&gt; <span class="tok-number">0x7ffff000</span>,
        .macos, .ios, .watchos, .tvos, .visionos =&gt; <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">i32</span>),
        <span class="tok-kw">else</span> =&gt; <a href="std.math.html#std.math.maxInt">maxInt</a>(size_t),
    };

    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .linux =&gt; sf: {
            <span class="tok-kw">if</span> (headers.len != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.writev">writev</a>(out_fd, headers);
                total_written += amt;
                <span class="tok-kw">if</span> (amt &lt; <a href="std.posix.html#std.posix.count_iovec_bytes">count_iovec_bytes</a>(headers)) <span class="tok-kw">return</span> total_written;
                header_done = <span class="tok-null">true</span>;
            }<span class="tok-comment">

            // Here we match BSD behavior, making a zero count value send as many bytes as possible.
            </span><span class="tok-kw">const</span> adjusted_count = <span class="tok-kw">if</span> (in_len == <span class="tok-number">0</span>) max_count <span class="tok-kw">else</span> <span class="tok-builtin">@min</span>(in_len, max_count);

            <span class="tok-kw">const</span> sendfile_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">sendfile64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">sendfile</a>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">var</span> offset: <a href="std.posix.html#std.posix.off_t">off_t</a> = <span class="tok-builtin">@bitCast</span>(in_offset);
                <span class="tok-kw">const</span> rc = sendfile_sym(out_fd, in_fd, &amp;offset, adjusted_count);
                <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                    .SUCCESS =&gt; {
                        <span class="tok-kw">const</span> amt: <span class="tok-type">usize</span> = <span class="tok-builtin">@bitCast</span>(rc);
                        total_written += amt;
                        <span class="tok-kw">if</span> (in_len == <span class="tok-number">0</span> <span class="tok-kw">and</span> amt == <span class="tok-number">0</span>) {<span class="tok-comment">
                            // We have detected EOF from `in_fd`.
                            </span><span class="tok-kw">break</span>;
                        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (amt &lt; in_len) {
                            <span class="tok-kw">return</span> total_written;
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">break</span>;
                        }
                    },

                    .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition.
                    </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Segmentation fault.
                    </span>.OVERFLOW =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // We avoid passing too large of a `count`.
                    </span>.NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,<span class="tok-comment"> // `out_fd` is an unconnected socket

                    </span>.INVAL =&gt; {<span class="tok-comment">
                        // EINVAL could be any of the following situations:
                        // * Descriptor is not valid or locked
                        // * an mmap(2)-like operation is  not  available  for in_fd
                        // * count is negative
                        // * out_fd has the APPEND flag set
                        // Because of the &quot;mmap(2)-like operation&quot; possibility, we fall back to doing read/write
                        // manually.
                        </span><span class="tok-kw">break</span> :sf;
                    },
                    .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
                    .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
                    .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
                    .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                    .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
                    .SPIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
                    <span class="tok-kw">else</span> =&gt; |err| {
                        <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err) <span class="tok-kw">catch</span> {};
                        <span class="tok-kw">break</span> :sf;
                    },
                }
            }

            <span class="tok-kw">if</span> (trailers.len != <span class="tok-number">0</span>) {
                total_written += <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.writev">writev</a>(out_fd, trailers);
            }

            <span class="tok-kw">return</span> total_written;
        },
        .freebsd =&gt; sf: {
            <span class="tok-kw">var</span> hdtr_data: <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.sf_hdtr">sf_hdtr</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">var</span> hdtr: ?*<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.sf_hdtr">sf_hdtr</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (headers.len != <span class="tok-number">0</span> <span class="tok-kw">or</span> trailers.len != <span class="tok-number">0</span>) {<span class="tok-comment">
                // Here we carefully avoid `@intCast` by returning partial writes when
                // too many io vectors are provided.
                </span><span class="tok-kw">const</span> hdr_cnt = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u31</span>, headers.len) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u31</span>);
                <span class="tok-kw">if</span> (headers.len &gt; hdr_cnt) <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.writev">writev</a>(out_fd, headers);

                <span class="tok-kw">const</span> trl_cnt = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u31</span>, trailers.len) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u31</span>);

                hdtr_data = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.sf_hdtr">sf_hdtr</a>{
                    .headers = headers.ptr,
                    .hdr_cnt = hdr_cnt,
                    .trailers = trailers.ptr,
                    .trl_cnt = trl_cnt,
                };
                hdtr = &amp;hdtr_data;
            }

            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">var</span> sbytes: <a href="std.posix.html#std.posix.off_t">off_t</a> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">const</span> err = <a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">sendfile</a>(in_fd, out_fd, <span class="tok-builtin">@bitCast</span>(in_offset), <span class="tok-builtin">@min</span>(in_len, max_count), hdtr, &amp;sbytes, flags));
                <span class="tok-kw">const</span> amt: <span class="tok-type">usize</span> = <span class="tok-builtin">@bitCast</span>(sbytes);
                <span class="tok-kw">switch</span> (err) {
                    .SUCCESS =&gt; <span class="tok-kw">return</span> amt,

                    .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition.
                    </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Segmentation fault.
                    </span>.NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,<span class="tok-comment"> // `out_fd` is an unconnected socket

                    </span>.INVAL, .OPNOTSUPP, .NOTSOCK, .NOSYS =&gt; {<span class="tok-comment">
                        // EINVAL could be any of the following situations:
                        // * The fd argument is not a regular file.
                        // * The s argument is not a SOCK.STREAM type socket.
                        // * The offset argument is negative.
                        // Because of some of these possibilities, we fall back to doing read/write
                        // manually, the same as ENOSYS.
                        </span><span class="tok-kw">break</span> :sf;
                    },

                    .INTR =&gt; <span class="tok-kw">if</span> (amt != <span class="tok-number">0</span>) <span class="tok-kw">return</span> amt <span class="tok-kw">else</span> <span class="tok-kw">continue</span>,

                    .AGAIN =&gt; <span class="tok-kw">if</span> (amt != <span class="tok-number">0</span>) {
                        <span class="tok-kw">return</span> amt;
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock;
                    },

                    .BUSY =&gt; <span class="tok-kw">if</span> (amt != <span class="tok-number">0</span>) {
                        <span class="tok-kw">return</span> amt;
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock;
                    },

                    .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
                    .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                    .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,

                    <span class="tok-kw">else</span> =&gt; {
                        <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err) <span class="tok-kw">catch</span> {};
                        <span class="tok-kw">if</span> (amt != <span class="tok-number">0</span>) {
                            <span class="tok-kw">return</span> amt;
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">break</span> :sf;
                        }
                    },
                }
            }
        },
        .macos, .ios, .tvos, .watchos, .visionos =&gt; sf: {
            <span class="tok-kw">var</span> hdtr_data: <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.sf_hdtr">sf_hdtr</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">var</span> hdtr: ?*<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.sf_hdtr">sf_hdtr</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (headers.len != <span class="tok-number">0</span> <span class="tok-kw">or</span> trailers.len != <span class="tok-number">0</span>) {<span class="tok-comment">
                // Here we carefully avoid `@intCast` by returning partial writes when
                // too many io vectors are provided.
                </span><span class="tok-kw">const</span> hdr_cnt = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u31</span>, headers.len) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u31</span>);
                <span class="tok-kw">if</span> (headers.len &gt; hdr_cnt) <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.writev">writev</a>(out_fd, headers);

                <span class="tok-kw">const</span> trl_cnt = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u31</span>, trailers.len) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u31</span>);

                hdtr_data = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.sf_hdtr">sf_hdtr</a>{
                    .headers = headers.ptr,
                    .hdr_cnt = hdr_cnt,
                    .trailers = trailers.ptr,
                    .trl_cnt = trl_cnt,
                };
                hdtr = &amp;hdtr_data;
            }

            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">var</span> sbytes: <a href="std.posix.html#std.posix.off_t">off_t</a> = <span class="tok-builtin">@min</span>(in_len, max_count);
                <span class="tok-kw">const</span> err = <a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">sendfile</a>(in_fd, out_fd, <span class="tok-builtin">@bitCast</span>(in_offset), &amp;sbytes, hdtr, flags));
                <span class="tok-kw">const</span> amt: <span class="tok-type">usize</span> = <span class="tok-builtin">@bitCast</span>(sbytes);
                <span class="tok-kw">switch</span> (err) {
                    .SUCCESS =&gt; <span class="tok-kw">return</span> amt,

                    .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition.
                    </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Segmentation fault.
                    </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,
                    .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,<span class="tok-comment"> // `out_fd` is an unconnected socket

                    </span>.OPNOTSUPP, .NOTSOCK, .NOSYS =&gt; <span class="tok-kw">break</span> :sf,

                    .INTR =&gt; <span class="tok-kw">if</span> (amt != <span class="tok-number">0</span>) <span class="tok-kw">return</span> amt <span class="tok-kw">else</span> <span class="tok-kw">continue</span>,

                    .AGAIN =&gt; <span class="tok-kw">if</span> (amt != <span class="tok-number">0</span>) {
                        <span class="tok-kw">return</span> amt;
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock;
                    },

                    .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
                    .PIPE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,

                    <span class="tok-kw">else</span> =&gt; {
                        <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err) <span class="tok-kw">catch</span> {};
                        <span class="tok-kw">if</span> (amt != <span class="tok-number">0</span>) {
                            <span class="tok-kw">return</span> amt;
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">break</span> :sf;
                        }
                    },
                }
            }
        },
        <span class="tok-kw">else</span> =&gt; {},<span class="tok-comment"> // fall back to read/write
    </span>}

    <span class="tok-kw">if</span> (headers.len != <span class="tok-number">0</span> <span class="tok-kw">and</span> !header_done) {
        <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.writev">writev</a>(out_fd, headers);
        total_written += amt;
        <span class="tok-kw">if</span> (amt &lt; <a href="std.posix.html#std.posix.count_iovec_bytes">count_iovec_bytes</a>(headers)) <span class="tok-kw">return</span> total_written;
    }

    rw: {
        <span class="tok-kw">var</span> buf: [<span class="tok-number">8</span> * <span class="tok-number">4096</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">
        // Here we match BSD behavior, making a zero count value send as many bytes as possible.
        </span><span class="tok-kw">const</span> adjusted_count = <span class="tok-kw">if</span> (in_len == <span class="tok-number">0</span>) buf.len <span class="tok-kw">else</span> <span class="tok-builtin">@min</span>(buf.len, in_len);
        <span class="tok-kw">const</span> amt_read = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.pread">pread</a>(in_fd, buf[<span class="tok-number">0</span>..adjusted_count], in_offset);
        <span class="tok-kw">if</span> (amt_read == <span class="tok-number">0</span>) {
            <span class="tok-kw">if</span> (in_len == <span class="tok-number">0</span>) {<span class="tok-comment">
                // We have detected EOF from `in_fd`.
                </span><span class="tok-kw">break</span> :rw;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> total_written;
            }
        }
        <span class="tok-kw">const</span> amt_written = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.write">write</a>(out_fd, buf[<span class="tok-number">0</span>..amt_read]);
        total_written += amt_written;
        <span class="tok-kw">if</span> (amt_written &lt; in_len <span class="tok-kw">or</span> in_len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> total_written;
    }

    <span class="tok-kw">if</span> (trailers.len != <span class="tok-number">0</span>) {
        total_written += <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.writev">writev</a>(out_fd, trailers);
    }

    <span class="tok-kw">return</span> total_written;
}

<span class="tok-kw">fn</span> <span class="tok-fn">count_iovec_bytes</span>(iovs: []<span class="tok-kw">const</span> <a href="std.posix.iovec_const.html">iovec_const</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (iovs) |iov| {
        count += iov.len;
    }
    <span class="tok-kw">return</span> count;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> CopyFileRangeError = <span class="tok-kw">error</span>{
    FileTooBig,
    InputOutput,
    <span class="tok-comment">/// `fd_in` is not open for reading; or `fd_out` is not open  for  writing;</span>
    <span class="tok-comment">/// or the  `APPEND`  flag  is  set  for `fd_out`.</span>
    FilesOpenedWithWrongFlags,
    IsDir,
    OutOfMemory,
    NoSpaceLeft,
    Unseekable,
    PermissionDenied,
    SwapFile,
    CorruptedData,
} || <a href="std.posix.html#std.posix.PReadError">PReadError</a> || <a href="std.posix.html#std.posix.PWriteError">PWriteError</a> || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Transfer data between file descriptors at specified offsets.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Returns the number of bytes written, which can less than requested.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The `copy_file_range` call copies `len` bytes from one file descriptor to another. When possible,</span>
<span class="tok-comment">/// this is done within the operating system kernel, which can provide better performance</span>
<span class="tok-comment">/// characteristics than transferring data from kernel to user space and back, such as with</span>
<span class="tok-comment">/// `pread` and `pwrite` calls.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `fd_in` must be a file descriptor opened for reading, and `fd_out` must be a file descriptor</span>
<span class="tok-comment">/// opened for writing. They may be any kind of file descriptor; however, if `fd_in` is not a regular</span>
<span class="tok-comment">/// file system file, it may cause this function to fall back to calling `pread` and `pwrite`, in which case</span>
<span class="tok-comment">/// atomicity guarantees no longer apply.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// If `fd_in` and `fd_out` are the same, source and target ranges must not overlap.</span>
<span class="tok-comment">/// The file descriptor seek positions are ignored and not updated.</span>
<span class="tok-comment">/// When `off_in` is past the end of the input file, it successfully reads 0 bytes.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `flags` has different meanings per operating system; refer to the respective man pages.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// These systems support in-kernel data copying:</span>
<span class="tok-comment">/// * Linux (cross-filesystem from version 5.3)</span>
<span class="tok-comment">/// * FreeBSD 13.0</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Other systems fall back to calling `pread` / `pwrite`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Maximum offsets on Linux and FreeBSD are `maxInt(i64)`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copy_file_range</span>(fd_in: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, off_in: <span class="tok-type">u64</span>, fd_out: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, off_out: <span class="tok-type">u64</span>, len: <span class="tok-type">usize</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.CopyFileRangeError">CopyFileRangeError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> ((<span class="tok-kw">comptime</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">isAtLeast</a>(.freebsd, .{ .major = <span class="tok-number">13</span>, .minor = <span class="tok-number">0</span>, .patch = <span class="tok-number">0</span> }) <span class="tok-kw">orelse</span> <span class="tok-null">false</span>) <span class="tok-kw">or</span>
        (<span class="tok-kw">comptime</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .linux <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.versionCheck">versionCheck</a>(.{ .major = <span class="tok-number">2</span>, .minor = <span class="tok-number">27</span>, .patch = <span class="tok-number">0</span> })))
    {
        <span class="tok-kw">var</span> off_in_copy: <span class="tok-type">i64</span> = <span class="tok-builtin">@bitCast</span>(off_in);
        <span class="tok-kw">var</span> off_out_copy: <span class="tok-type">i64</span> = <span class="tok-builtin">@bitCast</span>(off_out);

        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">copy_file_range</a>(fd_in, &amp;off_in_copy, fd_out, &amp;off_out_copy, len, flags);
            <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .freebsd) {
                <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                    .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
                    .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FilesOpenedWithWrongFlags,
                    .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
                    .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
                    .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
                    .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
                    .INVAL =&gt; <span class="tok-kw">break</span>,<span class="tok-comment"> // these may not be regular files, try fallback
                    </span>.INTEGRITY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CorruptedData,
                    .INTR =&gt; <span class="tok-kw">continue</span>,
                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                }
            } <span class="tok-kw">else</span> {<span class="tok-comment"> // assume linux
                </span><span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                    .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
                    .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FilesOpenedWithWrongFlags,
                    .FBIG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
                    .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
                    .ISDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IsDir,
                    .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
                    .INVAL =&gt; <span class="tok-kw">break</span>,<span class="tok-comment"> // these may not be regular files, try fallback
                    </span>.NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
                    .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unseekable,
                    .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
                    .TXTBSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SwapFile,
                    .XDEV =&gt; <span class="tok-kw">break</span>,<span class="tok-comment"> // support for cross-filesystem copy added in Linux 5.3, use fallback
                    </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                }
            }
        }
    }

    <span class="tok-kw">var</span> buf: [<span class="tok-number">8</span> * <span class="tok-number">4096</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> amt_read = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.pread">pread</a>(fd_in, buf[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(buf.len, len)], off_in);
    <span class="tok-kw">if</span> (amt_read == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.pwrite">pwrite</a>(fd_out, buf[<span class="tok-number">0</span>..amt_read], off_out);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PollError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The network subsystem has failed.</span>
    NetworkSubsystemFailed,

    <span class="tok-comment">/// The kernel had no space to allocate file descriptor tables.</span>
    SystemResources,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">poll</span>(fds: []<a href="std.posix.html#std.posix.pollfd">pollfd</a>, timeout: <span class="tok-type">i32</span>) <a href="std.posix.html#std.posix.PollError">PollError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.poll">poll</a>(fds.ptr, <span class="tok-builtin">@intCast</span>(fds.len), timeout)) {
            <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a> =&gt; <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,
                .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                .WSAENOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,<span class="tok-comment">
                // TODO: handle more errors
                </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
            },
            <span class="tok-kw">else</span> =&gt; |rc| <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        }
    }
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> fds_count = <a href="std.math.html#std.math.cast">cast</a>(<a href="std.posix.html#std.posix.nfds_t">nfds_t</a>, fds.len) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources;
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">poll</a>(fds.ptr, fds_count, timeout);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
    <span class="tok-kw">unreachable</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PPollError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The operation was interrupted by a delivery of a signal before it could complete.</span>
    SignalInterrupt,

    <span class="tok-comment">/// The kernel had no space to allocate file descriptor tables.</span>
    SystemResources,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ppoll</span>(fds: []<a href="std.posix.html#std.posix.pollfd">pollfd</a>, timeout: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.timespec">timespec</a>, mask: ?*<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sigset_t">sigset_t</a>) <a href="std.posix.html#std.posix.PPollError">PPollError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> ts: <a href="std.posix.html#std.posix.timespec">timespec</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> ts_ptr: ?*<a href="std.posix.html#std.posix.timespec">timespec</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (timeout) |timeout_ns| {
        ts_ptr = &amp;ts;
        ts = timeout_ns.*;
    }
    <span class="tok-kw">const</span> fds_count = <a href="std.math.html#std.math.cast">cast</a>(<a href="std.posix.html#std.posix.nfds_t">nfds_t</a>, fds.len) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources;
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">ppoll</a>(fds.ptr, fds_count, ts_ptr, mask);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INTR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SignalInterrupt,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RecvFromError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The socket is marked nonblocking and the requested operation would block, and</span>
    <span class="tok-comment">/// there is no global event loop configured.</span>
    WouldBlock,

    <span class="tok-comment">/// A remote host refused to allow the network connection, typically because it is not</span>
    <span class="tok-comment">/// running the requested service.</span>
    ConnectionRefused,

    <span class="tok-comment">/// Could not allocate kernel memory.</span>
    SystemResources,

    ConnectionResetByPeer,
    ConnectionTimedOut,

    <span class="tok-comment">/// The socket has not been bound.</span>
    SocketNotBound,

    <span class="tok-comment">/// The UDP message was too big for the buffer and part of it has been discarded</span>
    MessageTooBig,

    <span class="tok-comment">/// The network subsystem has failed.</span>
    NetworkSubsystemFailed,

    <span class="tok-comment">/// The socket is not connected (connection-oriented sockets only).</span>
    SocketNotConnected,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">recv</span>(sock: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, buf: []<span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.RecvFromError">RecvFromError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.recvfrom">recvfrom</a>(sock, buf, flags, <span class="tok-null">null</span>, <span class="tok-null">null</span>);
}

<span class="tok-comment">/// If `sockfd` is opened in non blocking mode, the function will</span>
<span class="tok-comment">/// return error.WouldBlock when EAGAIN is received.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">recvfrom</span>(
    sockfd: <a href="std.posix.html#std.posix.socket_t">socket_t</a>,
    buf: []<span class="tok-type">u8</span>,
    flags: <span class="tok-type">u32</span>,
    src_addr: ?*<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>,
    addrlen: ?*<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>,
) <a href="std.posix.html#std.posix.RecvFromError">RecvFromError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">recvfrom</a>(sockfd, buf.ptr, buf.len, flags, src_addr, addrlen);
        <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
            <span class="tok-kw">if</span> (rc == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a>) {
                <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                    .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,
                    .WSAECONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
                    .WSAEINVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotBound,
                    .WSAEMSGSIZE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MessageTooBig,
                    .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                    .WSAENOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
                    .WSAEWOULDBLOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
                    .WSAETIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,<span class="tok-comment">
                    // TODO: handle more errors
                    </span><span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
                }
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc);
            }
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
                .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
                </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,
                .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                .NOTCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotConnected,
                .NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,
                .INTR =&gt; <span class="tok-kw">continue</span>,
                .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldBlock,
                .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                .CONNREFUSED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionRefused,
                .CONNRESET =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionResetByPeer,
                .TIMEDOUT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ConnectionTimedOut,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> DnExpandError = <span class="tok-kw">error</span>{InvalidDnsPacket};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dn_expand</span>(
    msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    comp_dn: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    exp_dn: []<span class="tok-type">u8</span>,
) <a href="std.posix.html#std.posix.DnExpandError">DnExpandError</a>!<span class="tok-type">usize</span> {<span class="tok-comment">
    // This implementation is ported from musl libc.
    // A more idiomatic &quot;ziggy&quot; implementation would be welcome.
    </span><span class="tok-kw">var</span> p = comp_dn.ptr;
    <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>);
    <span class="tok-kw">const</span> end = msg.ptr + msg.len;
    <span class="tok-kw">if</span> (p == end <span class="tok-kw">or</span> exp_dn.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDnsPacket;
    <span class="tok-kw">var</span> dest = exp_dn.ptr;
    <span class="tok-kw">const</span> dend = dest + <span class="tok-builtin">@min</span>(exp_dn.len, <span class="tok-number">254</span>);<span class="tok-comment">
    // detect reference loop using an iteration counter
    </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; msg.len) : (i += <span class="tok-number">2</span>) {<span class="tok-comment">
        // loop invariants: p&lt;end, dest&lt;dend
        </span><span class="tok-kw">if</span> ((p[<span class="tok-number">0</span>] &amp; <span class="tok-number">0xc0</span>) != <span class="tok-number">0</span>) {
            <span class="tok-kw">if</span> (p + <span class="tok-number">1</span> == end) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDnsPacket;
            <span class="tok-kw">const</span> j = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, p[<span class="tok-number">0</span>] &amp; <span class="tok-number">0x3f</span>) &lt;&lt; <span class="tok-number">8</span> | p[<span class="tok-number">1</span>];
            <span class="tok-kw">if</span> (len == <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>)) len = <span class="tok-builtin">@intFromPtr</span>(p) + <span class="tok-number">2</span> - <span class="tok-builtin">@intFromPtr</span>(comp_dn.ptr);
            <span class="tok-kw">if</span> (j &gt;= msg.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDnsPacket;
            p = msg.ptr + j;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (p[<span class="tok-number">0</span>] != <span class="tok-number">0</span>) {
            <span class="tok-kw">if</span> (dest != exp_dn.ptr) {
                dest[<span class="tok-number">0</span>] = <span class="tok-str">'.'</span>;
                dest += <span class="tok-number">1</span>;
            }
            <span class="tok-kw">var</span> j = p[<span class="tok-number">0</span>];
            p += <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (j &gt;= <span class="tok-builtin">@intFromPtr</span>(end) - <span class="tok-builtin">@intFromPtr</span>(p) <span class="tok-kw">or</span> j &gt;= <span class="tok-builtin">@intFromPtr</span>(dend) - <span class="tok-builtin">@intFromPtr</span>(dest)) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDnsPacket;
            }
            <span class="tok-kw">while</span> (j != <span class="tok-number">0</span>) {
                j -= <span class="tok-number">1</span>;
                dest[<span class="tok-number">0</span>] = p[<span class="tok-number">0</span>];
                dest += <span class="tok-number">1</span>;
                p += <span class="tok-number">1</span>;
            }
        } <span class="tok-kw">else</span> {
            dest[<span class="tok-number">0</span>] = <span class="tok-number">0</span>;
            <span class="tok-kw">if</span> (len == <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>)) len = <span class="tok-builtin">@intFromPtr</span>(p) + <span class="tok-number">1</span> - <span class="tok-builtin">@intFromPtr</span>(comp_dn.ptr);
            <span class="tok-kw">return</span> len;
        }
    }
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDnsPacket;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SetSockOptError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The socket is already connected, and a specified option cannot be set while the socket is connected.</span>
    AlreadyConnected,

    <span class="tok-comment">/// The option is not supported by the protocol.</span>
    InvalidProtocolOption,

    <span class="tok-comment">/// The send and receive timeout values are too big to fit into the timeout fields in the socket structure.</span>
    TimeoutTooBig,

    <span class="tok-comment">/// Insufficient resources are available in the system to complete the call.</span>
    SystemResources,<span class="tok-comment">

    // Setting the socket option requires more elevated permissions.
    </span>PermissionDenied,

    OperationNotSupported,
    NetworkSubsystemFailed,
    FileDescriptorNotASocket,
    SocketNotBound,
    NoDevice,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Set a socket's options.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setsockopt</span>(fd: <a href="std.posix.html#std.posix.socket_t">socket_t</a>, level: <span class="tok-type">i32</span>, optname: <span class="tok-type">u32</span>, opt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.SetSockOptError">SetSockOptError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.setsockopt">setsockopt</a>(fd, level, <span class="tok-builtin">@intCast</span>(optname), opt.ptr, <span class="tok-builtin">@intCast</span>(opt.len));
        <span class="tok-kw">if</span> (rc == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.SOCKET_ERROR">SOCKET_ERROR</a>) {
            <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.WSAGetLastError">WSAGetLastError</a>()) {
                .WSANOTINITIALISED =&gt; <span class="tok-kw">unreachable</span>,
                .WSAENETDOWN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NetworkSubsystemFailed,
                .WSAEFAULT =&gt; <span class="tok-kw">unreachable</span>,
                .WSAENOTSOCK =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorNotASocket,
                .WSAEINVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SocketNotBound,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
            }
        }
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">setsockopt</a>(fd, level, optname, opt.ptr, <span class="tok-builtin">@intCast</span>(opt.len)))) {
            .SUCCESS =&gt; {},
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.NOTSOCK =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // always a race condition
            </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .DOM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TimeoutTooBig,
            .ISCONN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AlreadyConnected,
            .NOPROTOOPT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidProtocolOption,
            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .NOBUFS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoDevice,
            .OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OperationNotSupported,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MemFdCreateError = <span class="tok-kw">error</span>{
    SystemFdQuotaExceeded,
    ProcessFdQuotaExceeded,
    OutOfMemory,
    <span class="tok-comment">/// Either the name provided exceeded `NAME_MAX`, or invalid flags were passed.</span>
    NameTooLong,
    SystemOutdated,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">memfd_createZ</span>(name: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.MemFdCreateError">MemFdCreateError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .linux =&gt; {<span class="tok-comment">
            // memfd_create is available only in glibc versions starting with 2.27.
            </span><span class="tok-kw">const</span> use_c = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.versionCheck">versionCheck</a>(.{ .major = <span class="tok-number">2</span>, .minor = <span class="tok-number">27</span>, .patch = <span class="tok-number">0</span> });
            <span class="tok-kw">const</span> sys = <span class="tok-kw">if</span> (use_c) <a href="std.html">std</a>.<a href="std.c.html">c</a> <span class="tok-kw">else</span> <a href="std.os.linux.html">linux</a>;
            <span class="tok-kw">const</span> rc = sys.memfd_create(name, flags);
            <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
                .FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // name has invalid memory
                </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,<span class="tok-comment"> // or, program has a bug and flags are faulty
                </span>.NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
                .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
                .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
        },
        .freebsd =&gt; {
            <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">version_range</a>.<a href="#">semver</a>.<a href="#">max</a>.<a href="#">order</a>(.{ .major = <span class="tok-number">13</span>, .minor = <span class="tok-number">0</span>, .patch = <span class="tok-number">0</span> }) == .lt)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;memfd_create is unavailable on FreeBSD &lt; 13.0&quot;</span>);
            <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">memfd_create</a>(name, flags);
            <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
                .SUCCESS =&gt; <span class="tok-kw">return</span> rc,
                .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // name argument NULL
                </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // name too long or invalid/unsupported flags.
                </span>.MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
                .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
                .NOSYS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemOutdated,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
            }
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;target OS does not support memfd_create()&quot;</span>),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">memfd_create</span>(name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.MemFdCreateError">MemFdCreateError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">var</span> buffer: [<a href="std.posix.html#std.posix.NAME_MAX">NAME_MAX</a> - <span class="tok-str">&quot;memfd:&quot;</span>.len - <span class="tok-number">1</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">if</span> (name.len &gt; buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
    <span class="tok-builtin">@memcpy</span>(buffer[<span class="tok-number">0</span>..name.len], name);
    buffer[name.len] = <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.memfd_createZ">memfd_createZ</a>(&amp;buffer, flags);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getrusage</span>(who: <span class="tok-type">i32</span>) <a href="std.posix.html#std.posix.rusage">rusage</a> {
    <span class="tok-kw">var</span> result: <a href="std.posix.html#std.posix.rusage">rusage</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">getrusage</a>(who, &amp;result);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> result,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TIOCError = <span class="tok-kw">error</span>{NotATerminal};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TermiosGetError = <a href="std.posix.html#std.posix.TIOCError">TIOCError</a> || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tcgetattr</span>(handle: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.TermiosGetError">TermiosGetError</a>!<a href="std.posix.html#std.posix.termios">termios</a> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">var</span> term: <a href="std.posix.html#std.posix.termios">termios</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">tcgetattr</a>(handle, &amp;term))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> term,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .NOTTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotATerminal,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TermiosSetError = <a href="std.posix.html#std.posix.TermiosGetError">TermiosGetError</a> || <span class="tok-kw">error</span>{ProcessOrphaned};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tcsetattr</span>(handle: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, optional_action: <a href="std.posix.TCSA.html">TCSA</a>, termios_p: <a href="std.posix.html#std.posix.termios">termios</a>) <a href="std.posix.html#std.posix.TermiosSetError">TermiosSetError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">tcsetattr</a>(handle, optional_action, &amp;termios_p))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .NOTTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotATerminal,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessOrphaned,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TermioGetPgrpError = <a href="std.posix.html#std.posix.TIOCError">TIOCError</a> || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Returns the process group ID for the TTY associated with the given handle.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tcgetpgrp</span>(handle: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.TermioGetPgrpError">TermioGetPgrpError</a>!<a href="std.posix.html#std.posix.pid_t">pid_t</a> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">var</span> pgrp: <a href="std.posix.html#std.posix.pid_t">pid_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">tcgetpgrp</a>(handle, &amp;pgrp))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> pgrp,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .NOTTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotATerminal,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TermioSetPgrpError = <a href="std.posix.html#std.posix.TermioGetPgrpError">TermioGetPgrpError</a> || <span class="tok-kw">error</span>{NotAPgrpMember};

<span class="tok-comment">/// Sets the controlling process group ID for given TTY.</span>
<span class="tok-comment">/// handle must be valid fd_t to a TTY associated with calling process.</span>
<span class="tok-comment">/// pgrp must be a valid process group, and the calling process must be a member</span>
<span class="tok-comment">/// of that group.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tcsetpgrp</span>(handle: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, pgrp: <a href="std.posix.html#std.posix.pid_t">pid_t</a>) <a href="std.posix.html#std.posix.TermioSetPgrpError">TermioSetPgrpError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">tcsetpgrp</a>(handle, &amp;pgrp))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .INTR =&gt; <span class="tok-kw">continue</span>,
            .NOTTY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotATerminal,
            .PERM =&gt; <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.TermioSetPgrpError">TermioSetPgrpError</a>.<a href="#">NotAPgrpMember</a>,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">signalfd</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, mask: *<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.sigset_t">sigset_t</a>, flags: <span class="tok-type">u32</span>) !<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">signalfd</a>(fd, mask, flags);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        .BADF, .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessResources,
        .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InodeMountFail,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SyncError = <span class="tok-kw">error</span>{
    InputOutput,
    NoSpaceLeft,
    DiskQuota,
    AccessDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Write all pending file contents and metadata modifications to all filesystems.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sync</span>() <span class="tok-type">void</span> {
    <a href="std.posix.html#std.posix.system">system</a>.<a href="#">sync</a>();
}

<span class="tok-comment">/// Write all pending file contents and metadata modifications to the filesystem which contains the specified file.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">syncfs</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.SyncError">SyncError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">syncfs</a>(fd);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .BADF, .INVAL, .ROFS =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Write all pending file contents and metadata modifications for the specified file descriptor to the underlying filesystem.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fsync</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.SyncError">SyncError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.FlushFileBuffers">FlushFileBuffers</a>(fd) != <span class="tok-number">0</span>)
            <span class="tok-kw">return</span>;
        <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetLastError">GetLastError</a>()) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .INVALID_HANDLE =&gt; <span class="tok-kw">unreachable</span>,
            .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,<span class="tok-comment"> // a sync was performed but the system couldn't update the access time
            </span>.UNEXP_NET_ERR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
        }
    }
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fsync</a>(fd);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .BADF, .INVAL, .ROFS =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-comment">/// Write all pending file contents for the specified file descriptor to the underlying filesystem, but not necessarily the metadata.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fdatasync</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.posix.html#std.posix.SyncError">SyncError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.fsync">fsync</a>(fd) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <a href="std.posix.html#std.posix.SyncError">SyncError</a>.<a href="#">AccessDenied</a> =&gt; <span class="tok-kw">return</span>,<span class="tok-comment"> // fdatasync doesn't promise that the access time was synced
            </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
        };
    }
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">fdatasync</a>(fd);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .BADF, .INVAL, .ROFS =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
        .NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoSpaceLeft,
        .DQUOT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DiskQuota,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PrctlError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// Can only occur with PR_SET_SECCOMP/SECCOMP_MODE_FILTER or</span>
    <span class="tok-comment">/// PR_SET_MM/PR_SET_MM_EXE_FILE</span>
    AccessDenied,
    <span class="tok-comment">/// Can only occur with PR_SET_MM/PR_SET_MM_EXE_FILE</span>
    InvalidFileDescriptor,
    InvalidAddress,
    <span class="tok-comment">/// Can only occur with PR_SET_SPECULATION_CTRL, PR_MPX_ENABLE_MANAGEMENT,</span>
    <span class="tok-comment">/// or PR_MPX_DISABLE_MANAGEMENT</span>
    UnsupportedFeature,
    <span class="tok-comment">/// Can only occur with PR_SET_FP_MODE</span>
    OperationNotSupported,
    PermissionDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prctl</span>(option: <a href="std.posix.html#std.posix.PR">PR</a>, args: <span class="tok-kw">anytype</span>) <a href="std.posix.html#std.posix.PrctlError">PrctlError</a>!<span class="tok-type">u31</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(args)) != .@&quot;struct&quot;)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Expected tuple or struct argument, found &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(args)));
    <span class="tok-kw">if</span> (args.len &gt; <span class="tok-number">4</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;prctl takes a maximum of 4 optional arguments&quot;</span>);

    <span class="tok-kw">var</span> buf: [<span class="tok-number">4</span>]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
    {
        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
        <span class="tok-kw">inline</span> <span class="tok-kw">while</span> (i &lt; args.len) : (i += <span class="tok-number">1</span>) buf[i] = args[i];
    }

    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">prctl</a>(<span class="tok-builtin">@intFromEnum</span>(option), buf[<span class="tok-number">0</span>], buf[<span class="tok-number">1</span>], buf[<span class="tok-number">2</span>], buf[<span class="tok-number">3</span>]);
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFileDescriptor,
        .FAULT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidAddress,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .NODEV, .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedFeature,
        .OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OperationNotSupported,
        .PERM, .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .RANGE =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetrlimitError = <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getrlimit</span>(resource: <a href="std.posix.html#std.posix.rlimit_resource">rlimit_resource</a>) <a href="std.posix.html#std.posix.UnexpectedError">GetrlimitError</a>!<a href="std.posix.html#std.posix.rlimit">rlimit</a> {
    <span class="tok-kw">const</span> getrlimit_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">getrlimit64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">getrlimit</a>;

    <span class="tok-kw">var</span> limits: <a href="std.posix.html#std.posix.rlimit">rlimit</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(getrlimit_sym(resource, &amp;limits))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> limits,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // bogus pointer
        </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SetrlimitError = <span class="tok-kw">error</span>{ PermissionDenied, LimitTooBig } || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setrlimit</span>(resource: <a href="std.posix.html#std.posix.rlimit_resource">rlimit_resource</a>, limits: <a href="std.posix.html#std.posix.rlimit">rlimit</a>) <a href="std.posix.html#std.posix.SetrlimitError">SetrlimitError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> setrlimit_sym = <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.lfs64_abi">lfs64_abi</a>) <a href="std.posix.html#std.posix.system">system</a>.<a href="#">setrlimit64</a> <span class="tok-kw">else</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">setrlimit</a>;

    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(setrlimit_sym(resource, &amp;limits))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // bogus pointer
        </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LimitTooBig,<span class="tok-comment"> // this could also mean &quot;invalid resource&quot;, but that would be unreachable
        </span>.PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MincoreError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// A kernel resource was temporarily unavailable.</span>
    SystemResources,
    <span class="tok-comment">/// vec points to an invalid address.</span>
    InvalidAddress,
    <span class="tok-comment">/// addr is not page-aligned.</span>
    InvalidSyscall,
    <span class="tok-comment">/// One of the following:</span>
    <span class="tok-comment">/// * length is greater than user space TASK_SIZE - addr</span>
    <span class="tok-comment">/// * addr + length contains unmapped memory</span>
    OutOfMemory,
    <span class="tok-comment">/// The mincore syscall is not available on this version and configuration</span>
    <span class="tok-comment">/// of this UNIX-like kernel.</span>
    MincoreUnavailable,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Determine whether pages are resident in memory.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mincore</span>(ptr: [*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, length: <span class="tok-type">usize</span>, vec: [*]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.MincoreError">MincoreError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">mincore</a>(ptr, length, vec))) {
        .SUCCESS =&gt; {},
        .AGAIN =&gt; <span class="tok-kw">error</span>.SystemResources,
        .FAULT =&gt; <span class="tok-kw">error</span>.InvalidAddress,
        .INVAL =&gt; <span class="tok-kw">error</span>.InvalidSyscall,
        .NOMEM =&gt; <span class="tok-kw">error</span>.OutOfMemory,
        .NOSYS =&gt; <span class="tok-kw">error</span>.MincoreUnavailable,
        <span class="tok-kw">else</span> =&gt; |err| <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MadviseError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// advice is MADV.REMOVE, but the specified address range is not a shared writable mapping.</span>
    AccessDenied,
    <span class="tok-comment">/// advice is MADV.HWPOISON, but the caller does not have the CAP_SYS_ADMIN capability.</span>
    PermissionDenied,
    <span class="tok-comment">/// A kernel resource was temporarily unavailable.</span>
    SystemResources,
    <span class="tok-comment">/// One of the following:</span>
    <span class="tok-comment">/// * addr is not page-aligned or length is negative</span>
    <span class="tok-comment">/// * advice is not valid</span>
    <span class="tok-comment">/// * advice is MADV.DONTNEED or MADV.REMOVE and the specified address range</span>
    <span class="tok-comment">///   includes locked, Huge TLB pages, or VM_PFNMAP pages.</span>
    <span class="tok-comment">/// * advice is MADV.MERGEABLE or MADV.UNMERGEABLE, but the kernel was not</span>
    <span class="tok-comment">///   configured with CONFIG_KSM.</span>
    <span class="tok-comment">/// * advice is MADV.FREE or MADV.WIPEONFORK but the specified address range</span>
    <span class="tok-comment">///   includes file, Huge TLB, MAP.SHARED, or VM_PFNMAP ranges.</span>
    InvalidSyscall,
    <span class="tok-comment">/// (for MADV.WILLNEED) Paging in this area would exceed the process's</span>
    <span class="tok-comment">/// maximum resident set size.</span>
    WouldExceedMaximumResidentSetSize,
    <span class="tok-comment">/// One of the following:</span>
    <span class="tok-comment">/// * (for MADV.WILLNEED) Not enough memory: paging in failed.</span>
    <span class="tok-comment">/// * Addresses in the specified range are not currently mapped, or</span>
    <span class="tok-comment">///   are outside the address space of the process.</span>
    OutOfMemory,
    <span class="tok-comment">/// The madvise syscall is not available on this version and configuration</span>
    <span class="tok-comment">/// of the Linux kernel.</span>
    MadviseUnavailable,
    <span class="tok-comment">/// The operating system returned an undocumented error code.</span>
    Unexpected,
};

<span class="tok-comment">/// Give advice about use of memory.</span>
<span class="tok-comment">/// This syscall is optional and is sometimes configured to be disabled.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">madvise</span>(ptr: [*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>, length: <span class="tok-type">usize</span>, advice: <span class="tok-type">u32</span>) <a href="std.posix.html#std.posix.MadviseError">MadviseError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">madvise</a>(ptr, length, advice))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // The map exists, but the area maps something that isn't a file.
        </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidSyscall,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WouldExceedMaximumResidentSetSize,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
        .NOSYS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MadviseUnavailable,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PerfEventOpenError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// Returned if the perf_event_attr size value is too small (smaller</span>
    <span class="tok-comment">/// than PERF_ATTR_SIZE_VER0), too big (larger than the page  size),</span>
    <span class="tok-comment">/// or  larger  than the kernel supports and the extra bytes are not</span>
    <span class="tok-comment">/// zero.  When E2BIG is returned, the perf_event_attr size field is</span>
    <span class="tok-comment">/// overwritten by the kernel to be the size of the structure it was</span>
    <span class="tok-comment">/// expecting.</span>
    TooBig,
    <span class="tok-comment">/// Returned when the requested event requires CAP_SYS_ADMIN permis‐</span>
    <span class="tok-comment">/// sions  (or a more permissive perf_event paranoid setting).  Some</span>
    <span class="tok-comment">/// common cases where an unprivileged process  may  encounter  this</span>
    <span class="tok-comment">/// error:  attaching  to a process owned by a different user; moni‐</span>
    <span class="tok-comment">/// toring all processes on a given CPU (i.e.,  specifying  the  pid</span>
    <span class="tok-comment">/// argument  as  -1); and not setting exclude_kernel when the para‐</span>
    <span class="tok-comment">/// noid setting requires it.</span>
    <span class="tok-comment">/// Also:</span>
    <span class="tok-comment">/// Returned on many (but not all) architectures when an unsupported</span>
    <span class="tok-comment">/// exclude_hv,  exclude_idle,  exclude_user, or exclude_kernel set‐</span>
    <span class="tok-comment">/// ting is specified.</span>
    <span class="tok-comment">/// It can also happen, as with EACCES, when the requested event re‐</span>
    <span class="tok-comment">/// quires   CAP_SYS_ADMIN   permissions   (or   a  more  permissive</span>
    <span class="tok-comment">/// perf_event paranoid setting).  This includes  setting  a  break‐</span>
    <span class="tok-comment">/// point on a kernel address, and (since Linux 3.13) setting a ker‐</span>
    <span class="tok-comment">/// nel function-trace tracepoint.</span>
    PermissionDenied,
    <span class="tok-comment">/// Returned if another event already has exclusive  access  to  the</span>
    <span class="tok-comment">/// PMU.</span>
    DeviceBusy,
    <span class="tok-comment">/// Each  opened  event uses one file descriptor.  If a large number</span>
    <span class="tok-comment">/// of events are opened, the per-process limit  on  the  number  of</span>
    <span class="tok-comment">/// open file descriptors will be reached, and no more events can be</span>
    <span class="tok-comment">/// created.</span>
    ProcessResources,
    EventRequiresUnsupportedCpuFeature,
    <span class="tok-comment">/// Returned if  you  try  to  add  more  breakpoint</span>
    <span class="tok-comment">/// events than supported by the hardware.</span>
    TooManyBreakpoints,
    <span class="tok-comment">/// Returned  if PERF_SAMPLE_STACK_USER is set in sample_type and it</span>
    <span class="tok-comment">/// is not supported by hardware.</span>
    SampleStackNotSupported,
    <span class="tok-comment">/// Returned if an event requiring a specific  hardware  feature  is</span>
    <span class="tok-comment">/// requested  but  there is no hardware support.  This includes re‐</span>
    <span class="tok-comment">/// questing low-skid events if not supported, branch tracing if  it</span>
    <span class="tok-comment">/// is not available, sampling if no PMU interrupt is available, and</span>
    <span class="tok-comment">/// branch stacks for software events.</span>
    EventNotSupported,
    <span class="tok-comment">/// Returned  if  PERF_SAMPLE_CALLCHAIN  is   requested   and   sam‐</span>
    <span class="tok-comment">/// ple_max_stack   is   larger   than   the  maximum  specified  in</span>
    <span class="tok-comment">/// /proc/sys/kernel/perf_event_max_stack.</span>
    SampleMaxStackOverflow,
    <span class="tok-comment">/// Returned if attempting to attach to a process that does not  exist.</span>
    ProcessNotFound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">perf_event_open</span>(
    attr: *<a href="std.posix.html#std.posix.system">system</a>.<a href="#">perf_event_attr</a>,
    pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>,
    cpu: <span class="tok-type">i32</span>,
    group_fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    flags: <span class="tok-type">usize</span>,
) <a href="std.posix.html#std.posix.PerfEventOpenError">PerfEventOpenError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .linux) {<span class="tok-comment">
        // There is no syscall wrapper for this function exposed by libcs
        </span><span class="tok-kw">const</span> rc = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.perf_event_open">perf_event_open</a>(attr, pid, cpu, group_fd, flags);
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
            .SUCCESS =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(rc),
            .@&quot;2BIG&quot; =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TooBig,
            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // group_fd file descriptor is not valid.
            </span>.BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeviceBusy,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Segmentation fault.
            </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Bad attr settings.
            </span>.INTR =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Mixed perf and ftrace handling for a uprobe.
            </span>.MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessResources,
            .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EventRequiresUnsupportedCpuFeature,
            .NOENT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid type setting.
            </span>.NOSPC =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TooManyBreakpoints,
            .NOSYS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SampleStackNotSupported,
            .OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EventNotSupported,
            .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SampleMaxStackOverflow,
            .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
            .SRCH =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessNotFound,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TimerFdCreateError = <span class="tok-kw">error</span>{
    AccessDenied,
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    NoDevice,
    SystemResources,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TimerFdGetError = <span class="tok-kw">error</span>{InvalidHandle} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TimerFdSetError = <a href="std.posix.html#std.posix.TimerFdGetError">TimerFdGetError</a> || <span class="tok-kw">error</span>{Canceled};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">timerfd_create</span>(clock_id: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">timerfd_clockid_t</a>, flags: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">TFD</a>) <a href="std.posix.html#std.posix.TimerFdCreateError">TimerFdCreateError</a>!<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">timerfd_create</a>(clock_id, <span class="tok-builtin">@bitCast</span>(flags));
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-builtin">@intCast</span>(rc),
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoDevice,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">timerfd_settime</span>(
    fd: <span class="tok-type">i32</span>,
    flags: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">TFD</a>.<a href="#">TIMER</a>,
    new_value: *<span class="tok-kw">const</span> <a href="std.posix.html#std.posix.system">system</a>.<a href="#">itimerspec</a>,
    old_value: ?*<a href="std.posix.html#std.posix.system">system</a>.<a href="#">itimerspec</a>,
) <a href="std.posix.html#std.posix.TimerFdSetError">TimerFdSetError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">timerfd_settime</a>(fd, <span class="tok-builtin">@bitCast</span>(flags), new_value, old_value);
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; {},
        .BADF =&gt; <span class="tok-kw">error</span>.InvalidHandle,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .CANCELED =&gt; <span class="tok-kw">error</span>.Canceled,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">timerfd_gettime</span>(fd: <span class="tok-type">i32</span>) <a href="std.posix.html#std.posix.TimerFdGetError">TimerFdGetError</a>!<a href="std.posix.html#std.posix.system">system</a>.<a href="#">itimerspec</a> {
    <span class="tok-kw">var</span> curr_value: <a href="std.posix.html#std.posix.system">system</a>.<a href="#">itimerspec</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> rc = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">timerfd_gettime</a>(fd, &amp;curr_value);
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(rc)) {
        .SUCCESS =&gt; <span class="tok-kw">return</span> curr_value,
        .BADF =&gt; <span class="tok-kw">error</span>.InvalidHandle,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PtraceError = <span class="tok-kw">error</span>{
    DeviceBusy,
    InputOutput,
    ProcessNotFound,
    PermissionDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrace</span>(request: <span class="tok-type">u32</span>, pid: <a href="std.posix.html#std.posix.pid_t">pid_t</a>, addr: <span class="tok-type">usize</span>, signal: <span class="tok-type">usize</span>) <a href="std.posix.html#std.posix.PtraceError">PtraceError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows <span class="tok-kw">or</span> <a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported OS&quot;</span>);

    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .linux =&gt; <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.ptrace">ptrace</a>(request, pid, addr, signal, <span class="tok-number">0</span>))) {
            .SUCCESS =&gt; {},
            .SRCH =&gt; <span class="tok-kw">error</span>.ProcessNotFound,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
            .PERM =&gt; <span class="tok-kw">error</span>.PermissionDenied,
            .BUSY =&gt; <span class="tok-kw">error</span>.DeviceBusy,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        },

        .macos, .ios, .tvos, .watchos, .visionos =&gt; <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.darwin.html#std.c.darwin.ptrace">ptrace</a>(
            <span class="tok-builtin">@intCast</span>(request),
            pid,
            <span class="tok-builtin">@ptrFromInt</span>(addr),
            <span class="tok-builtin">@intCast</span>(signal),
        ))) {
            .SUCCESS =&gt; {},
            .SRCH =&gt; <span class="tok-kw">error</span>.ProcessNotFound,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .PERM =&gt; <span class="tok-kw">error</span>.PermissionDenied,
            .BUSY =&gt; <span class="tok-kw">error</span>.DeviceBusy,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        },

        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">ptrace</a>(request, pid, addr, signal))) {
            .SUCCESS =&gt; {},
            .SRCH =&gt; <span class="tok-kw">error</span>.ProcessNotFound,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .PERM =&gt; <span class="tok-kw">error</span>.PermissionDenied,
            .BUSY =&gt; <span class="tok-kw">error</span>.DeviceBusy,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        },
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> NameToFileHandleAtError = <span class="tok-kw">error</span>{
    FileNotFound,
    NotDir,
    OperationNotSupported,
    NameTooLong,
    Unexpected,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">name_to_handle_at</span>(
    dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    handle: *<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.file_handle.html">file_handle</a>,
    mount_id: *<span class="tok-type">i32</span>,
    flags: <span class="tok-type">u32</span>,
) <a href="std.posix.html#std.posix.NameToFileHandleAtError">NameToFileHandleAtError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> pathname_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(pathname);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.name_to_handle_atZ">name_to_handle_atZ</a>(dirfd, &amp;pathname_c, handle, mount_id, flags);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">name_to_handle_atZ</span>(
    dirfd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    pathname_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    handle: *<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.file_handle.html">file_handle</a>,
    mount_id: *<span class="tok-type">i32</span>,
    flags: <span class="tok-type">u32</span>,
) <a href="std.posix.html#std.posix.NameToFileHandleAtError">NameToFileHandleAtError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">name_to_handle_at</a>(dirfd, pathname_z, handle, mount_id, flags))) {
        .SUCCESS =&gt; {},
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // pathname, mount_id, or handle outside accessible address space
        </span>.INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // bad flags, or handle_bytes too big
        </span>.NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OperationNotSupported,
        .OVERFLOW =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> IoCtl_SIOCGIFINDEX_Error = <span class="tok-kw">error</span>{
    FileSystem,
    InterfaceNotFound,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ioctl_SIOCGIFINDEX</span>(fd: <a href="std.posix.html#std.posix.fd_t">fd_t</a>, ifr: *<a href="std.posix.html#std.posix.ifreq">ifreq</a>) <a href="std.posix.html#std.posix.IoCtl_SIOCGIFINDEX_Error">IoCtl_SIOCGIFINDEX_Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">ioctl</a>(fd, <a href="std.posix.html#std.posix.SIOCGIFINDEX">SIOCGIFINDEX</a>, <span class="tok-builtin">@intFromPtr</span>(ifr)))) {
            .SUCCESS =&gt; <span class="tok-kw">return</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Bad parameters.
            </span>.NOTTY =&gt; <span class="tok-kw">unreachable</span>,
            .NXIO =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Always a race condition.
            </span>.FAULT =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Bad pointer parameter.
            </span>.INTR =&gt; <span class="tok-kw">continue</span>,
            .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
            .NODEV =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InterfaceNotFound,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }
    }
}

<span class="tok-kw">const</span> lfs64_abi = <a href="std.posix.html#std.posix.native_os">native_os</a> == .linux <span class="tok-kw">and</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a> <span class="tok-kw">and</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.abi">abi</a>.<a href="#">isGnu</a>() <span class="tok-kw">or</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.abi">abi</a>.<a href="#">isAndroid</a>());

<span class="tok-comment">/// Whether or not `error.Unexpected` will print its value and a stack trace.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// If this happens the fix is to add the error code to the corresponding</span>
<span class="tok-comment">/// switch expression, possibly introduce a new error in the error set, and</span>
<span class="tok-comment">/// send a patch to Zig.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> unexpected_error_tracing = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_llvm <span class="tok-kw">and</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.mode">mode</a> == .Debug;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnexpectedError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The Operating System returned an undocumented error code.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// This error is in theory not possible, but it would be better</span>
    <span class="tok-comment">/// to handle this error than to invoke undefined behavior.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// When this error code is observed, it usually means the Zig Standard</span>
    <span class="tok-comment">/// Library needs a small patch to add the error code to the error set for</span>
    <span class="tok-comment">/// the respective function.</span>
    Unexpected,
};

<span class="tok-comment">/// Call this when you made a syscall or something that sets errno</span>
<span class="tok-comment">/// and you get an unexpected error.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unexpectedErrno</span>(err: <a href="std.posix.html#std.posix.E">E</a>) <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.unexpected_error_tracing">unexpected_error_tracing</a>) {
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;unexpected errno: {d}\n&quot;</span>, .{<span class="tok-builtin">@intFromEnum</span>(err)});
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.dumpCurrentStackTrace">dumpCurrentStackTrace</a>(<span class="tok-null">null</span>);
    }
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected;
}

<span class="tok-comment">/// Used to convert a slice to a null terminated slice on the stack.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toPosixPath</span>(file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{NameTooLong}![<a href="std.posix.html#std.posix.PATH_MAX">PATH_MAX</a> - <span class="tok-number">1</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.runtime_safety">runtime_safety</a>) <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, file_path, <span class="tok-number">0</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">var</span> path_with_null: [<a href="std.posix.html#std.posix.PATH_MAX">PATH_MAX</a> - <span class="tok-number">1</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">
    // &gt;= rather than &gt; to make room for the null byte
    </span><span class="tok-kw">if</span> (file_path.len &gt;= <a href="std.posix.html#std.posix.PATH_MAX">PATH_MAX</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
    <span class="tok-builtin">@memcpy</span>(path_with_null[<span class="tok-number">0</span>..file_path.len], file_path);
    path_with_null[file_path.len] = <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> path_with_null;
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
