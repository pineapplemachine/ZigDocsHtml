<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.bit_set.html" class="active">bit_set</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.bit_set" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.bit_set</span><a href="#src.zig-std.bit_set">[src]</a></h1><div class="tldDocs"><p>This file defines several variants of bit sets.  A bit set
is a densely stored set of integers with a known maximum,
in which each integer gets a single bit.  Bit sets have very
fast presence checks, update operations, and union and intersection
operations.  However, if the number of possible items is very
large and the number of actual items in a given set is usually
small, they may be less memory efficient than an array set.</p>
<p>There are five variants defined here:</p>
<p>IntegerBitSet:
A bit set with static size, which is backed by a single integer.
This set is good for sets with a small size, but may generate
inefficient code for larger sets, especially in debug mode.</p>
<p>ArrayBitSet:
A bit set with static size, which is backed by an array of usize.
This set is good for sets with a larger size, but may use
more bytes than necessary if your set is small.</p>
<p>StaticBitSet:
Picks either IntegerBitSet or ArrayBitSet depending on the requested
size.  The interfaces of these two types match exactly, except for fields.</p>
<p>DynamicBitSet:
A bit set with runtime-known size, backed by an allocated slice
of usize.</p>
<p>DynamicBitSetUnmanaged:
A variant of DynamicBitSet which does not store a pointer to its
allocator, in order to save space.</p>
</div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.bit_set.DynamicBitSetUnmanaged.html">std.bit_set.DynamicBitSetUnmanaged</a></li><li><a href="std.bit_set.DynamicBitSet.html">std.bit_set.DynamicBitSet</a></li><li><a href="std.bit_set.IteratorOptions.html">std.bit_set.IteratorOptions</a></li><li><a href="std.bit_set.Range.html">std.bit_set.Range</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.bit_set.StaticBitSet" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">StaticBitSet</span><a href="#src.zig-std.bit_set.StaticBitSet">[src]</a></h2><div class="tldDocs"><p>Returns the optimal static bit set type for the specified number
of elements: either <code><a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a></code> or <code><a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a></code>,
both of which fulfill the same interface.
The returned type will perform no allocations,
can be copied by value, and does not require deinitialization.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>size: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> StaticBitSet {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">0</span>), <a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<span class="tok-number">0</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">5</span>), <a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<span class="tok-number">5</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>)), <a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>) + <span class="tok-number">1</span>), <a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>) + <span class="tok-number">1</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a>(<span class="tok-type">usize</span>, <span class="tok-number">500</span>), <a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<span class="tok-number">500</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.StaticBitSet">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StaticBitSet</span>(<span class="tok-kw">comptime</span> size: <span class="tok-type">usize</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">if</span> (size &lt;= <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>)) {
        <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(size);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a>(<span class="tok-type">usize</span>, size);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.IntegerBitSet" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">IntegerBitSet</span><a href="#src.zig-std.bit_set.IntegerBitSet">[src]</a></h2><div class="tldDocs"><p>A bit set with static size, which is backed by a single integer.
This set is good for sets with a small size, but may generate
inefficient code for larger sets, especially in debug mode.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>size: <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.bit_set.IntegerBitSet.MaskInt" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">MaskInt</span><a href="#src.zig-std.bit_set.IntegerBitSet.MaskInt">[src]</a></h3><div class="tldDocs"><p>The integer type used to represent a mask in this bit set</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.MaskInt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MaskInt = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, size)</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.ShiftInt" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">ShiftInt</span><a href="#src.zig-std.bit_set.IntegerBitSet.ShiftInt">[src]</a></h3><div class="tldDocs"><p>The integer type used to shift a mask in this bit set</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.ShiftInt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ShiftInt = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>)</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.Iterator" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Iterator</span><a href="#src.zig-std.bit_set.IntegerBitSet.Iterator">[src]</a></h3><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.Iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Iterator</span>(<span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.IntegerBitSet.SingleWordIterator">SingleWordIterator</a>(options.direction);
}</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>mask: <a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a></code></pre><div class="fieldDocs"><p>The bit mask, as a single integer</p>
</div></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.bit_set.IntegerBitSet.bit_length" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">bit_length</span><a href="#src.zig-std.bit_set.IntegerBitSet.bit_length">[src]</a></h3><div class="tldDocs"><p>The number of items in this bit set</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.bit_length">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> bit_length: <span class="tok-type">usize</span> = size</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.bit_set.IntegerBitSet.initEmpty" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initEmpty</span><a href="#src.zig-std.bit_set.IntegerBitSet.initEmpty">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div class="tldDocs"><p>Creates a bit set with no elements present.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.initEmpty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
    <span class="tok-kw">return</span> .{ .mask = <span class="tok-number">0</span> };
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.initFull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initFull</span><a href="#src.zig-std.bit_set.IntegerBitSet.initFull">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>() <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div class="tldDocs"><p>Creates a bit set with all elements present.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.initFull">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>() <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
    <span class="tok-kw">return</span> .{ .mask = ~<span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, <span class="tok-number">0</span>) };
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.bit_set.IntegerBitSet.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of bits in this bit set</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">usize</span> {
    _ = self;
    <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.isSet" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isSet</span><a href="#src.zig-std.bit_set.IntegerBitSet.isSet">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSet</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true if the bit at the specified index
is present in the set, false otherwise.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.isSet">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSet</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>);
    <span class="tok-kw">return</span> (self.mask &amp; <a href="std.bit_set.html#std.bit_set.IntegerBitSet.maskBit">maskBit</a>(index)) != <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.bit_set.IntegerBitSet.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the total number of set bits in this bit set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@popCount</span>(self.mask);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.setValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setValue</span><a href="#src.zig-std.bit_set.IntegerBitSet.setValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setValue</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, index: <span class="tok-type">usize</span>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Changes the value of the specified bit of the bit
set to match the passed boolean.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>value: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.setValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setValue</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, index: <span class="tok-type">usize</span>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>);
    <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a> == <span class="tok-type">u0</span>) <span class="tok-kw">return</span>;
    <span class="tok-kw">const</span> bit = <a href="std.bit_set.html#std.bit_set.IntegerBitSet.maskBit">maskBit</a>(index);
    <span class="tok-kw">const</span> new_bit = bit &amp; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, value);
    self.mask = (self.mask &amp; ~bit) | new_bit;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.set" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">set</span><a href="#src.zig-std.bit_set.IntegerBitSet.set">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Adds a specific bit to the bit set</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.set">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>);
    self.mask |= <a href="std.bit_set.html#std.bit_set.IntegerBitSet.maskBit">maskBit</a>(index);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.setRangeValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setRangeValue</span><a href="#src.zig-std.bit_set.IntegerBitSet.setRangeValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setRangeValue</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, range: <a href="std.bit_set.Range.html">Range</a>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Changes the value of all bits in the specified range to
match the passed boolean.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div><pre><code>range: <a href="std.bit_set.Range.html">Range</a></code></pre></div><div><pre><code>value: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.setRangeValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setRangeValue</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, range: <a href="std.bit_set.Range.html">Range</a>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(range.end &lt;= <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>);
    <a href="std.debug.html#std.debug.assert">assert</a>(range.start &lt;= range.end);
    <span class="tok-kw">if</span> (range.start == range.end) <span class="tok-kw">return</span>;
    <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a> == <span class="tok-type">u0</span>) <span class="tok-kw">return</span>;

    <span class="tok-kw">const</span> start_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(range.start));

    <span class="tok-kw">var</span> mask = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; start_bit;
    <span class="tok-kw">if</span> (range.end != <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>) {
        <span class="tok-kw">const</span> end_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(range.end));
        mask &amp;= <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>)) - <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, end_bit)));
    }
    self.mask &amp;= ~mask;

    mask = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, value) &lt;&lt; start_bit;
    <span class="tok-kw">if</span> (range.end != <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>) {
        <span class="tok-kw">const</span> end_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(range.end));
        mask &amp;= <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, value) &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>)) - <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, end_bit)));
    }
    self.mask |= mask;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.unset" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unset</span><a href="#src.zig-std.bit_set.IntegerBitSet.unset">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unset</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Removes a specific bit from the bit set</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.unset">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unset</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>);<span class="tok-comment">
    // Workaround for #7953
    </span><span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a> == <span class="tok-type">u0</span>) <span class="tok-kw">return</span>;
    self.mask &amp;= ~<a href="std.bit_set.html#std.bit_set.IntegerBitSet.maskBit">maskBit</a>(index);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.toggle" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toggle</span><a href="#src.zig-std.bit_set.IntegerBitSet.toggle">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggle</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Flips a specific bit in the bit set</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.toggle">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggle</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>);
    self.mask ^= <a href="std.bit_set.html#std.bit_set.IntegerBitSet.maskBit">maskBit</a>(index);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.toggleSet" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toggleSet</span><a href="#src.zig-std.bit_set.IntegerBitSet.toggleSet">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleSet</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, toggles: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Flips all bits in this bit set which are present
in the toggles bit set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div><pre><code>toggles: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.toggleSet">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleSet</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, toggles: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">void</span> {
    self.mask ^= toggles.mask;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.toggleAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toggleAll</span><a href="#src.zig-std.bit_set.IntegerBitSet.toggleAll">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleAll</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Flips every bit in the bit set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.toggleAll">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleAll</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">void</span> {
    self.mask = ~self.mask;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.setUnion" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setUnion</span><a href="#src.zig-std.bit_set.IntegerBitSet.setUnion">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Performs a union of two bit sets, and stores the
result in the first one.  Bits in the result are
set if the corresponding bits were set in either input.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.setUnion">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">void</span> {
    self.mask |= other.mask;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.setIntersection" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setIntersection</span><a href="#src.zig-std.bit_set.IntegerBitSet.setIntersection">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIntersection</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Performs an intersection of two bit sets, and stores
the result in the first one.  Bits in the result are
set if the corresponding bits were set in both inputs.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.setIntersection">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIntersection</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">void</span> {
    self.mask &amp;= other.mask;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.findFirstSet" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">findFirstSet</span><a href="#src.zig-std.bit_set.IntegerBitSet.findFirstSet">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findFirstSet</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Finds the index of the first set bit.
If no bits are set, returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.findFirstSet">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findFirstSet</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> mask = self.mask;
    <span class="tok-kw">if</span> (mask == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> <span class="tok-builtin">@ctz</span>(mask);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.toggleFirstSet" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toggleFirstSet</span><a href="#src.zig-std.bit_set.IntegerBitSet.toggleFirstSet">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleFirstSet</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Finds the index of the first set bit, and unsets it.
If no bits are set, returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.toggleFirstSet">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleFirstSet</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> mask = self.mask;
    <span class="tok-kw">if</span> (mask == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> index = <span class="tok-builtin">@ctz</span>(mask);
    self.mask = mask &amp; (mask - <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> index;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.eql" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">eql</span><a href="#src.zig-std.bit_set.IntegerBitSet.eql">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff every corresponding bit in both
bit sets are the same.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.eql">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a> == <span class="tok-number">0</span> <span class="tok-kw">or</span> self.mask == other.mask;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.subsetOf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">subsetOf</span><a href="#src.zig-std.bit_set.IntegerBitSet.subsetOf">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff the first bit set is the subset
of the second one.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.subsetOf">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.intersectWith(other).eql(self);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.supersetOf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">supersetOf</span><a href="#src.zig-std.bit_set.IntegerBitSet.supersetOf">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff the first bit set is the superset
of the second one.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.supersetOf">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> other.subsetOf(self);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.complement" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">complement</span><a href="#src.zig-std.bit_set.IntegerBitSet.complement">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">complement</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns the complement bit sets. Bits in the result
are set if the corresponding bits were not set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.complement">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">complement</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
    <span class="tok-kw">var</span> result = self;
    result.toggleAll();
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.unionWith" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unionWith</span><a href="#src.zig-std.bit_set.IntegerBitSet.unionWith">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unionWith</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns the union of two bit sets. Bits in the
result are set if the corresponding bits were set
in either input.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.unionWith">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unionWith</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
    <span class="tok-kw">var</span> result = self;
    result.setUnion(other);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.intersectWith" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">intersectWith</span><a href="#src.zig-std.bit_set.IntegerBitSet.intersectWith">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intersectWith</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns the intersection of two bit sets. Bits in
the result are set if the corresponding bits were
set in both inputs.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.intersectWith">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intersectWith</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
    <span class="tok-kw">var</span> result = self;
    result.setIntersection(other);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.xorWith" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">xorWith</span><a href="#src.zig-std.bit_set.IntegerBitSet.xorWith">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">xorWith</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns the xor of two bit sets. Bits in the
result are set if the corresponding bits were
not the same in both inputs.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.xorWith">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">xorWith</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
    <span class="tok-kw">var</span> result = self;
    result.toggleSet(other);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.differenceWith" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">differenceWith</span><a href="#src.zig-std.bit_set.IntegerBitSet.differenceWith">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">differenceWith</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns the difference of two bit sets. Bits in
the result are set if set in the first but not
set in the second set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.differenceWith">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">differenceWith</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
    <span class="tok-kw">var</span> result = self;
    result.setIntersection(other.complement());
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.IntegerBitSet.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.bit_set.IntegerBitSet.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, <span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet.Iterator">Iterator</a>(options)</code></pre></div><div class="tldDocs"><p>Iterates through the items in the set, according to the options.
The default options (.{}) will iterate indices of set bits in
ascending order.  Modifications to the underlying bit set may
or may not be observed by the iterator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a></code></pre></div><div><pre><code>options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, <span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet.Iterator">Iterator</a>(options) {
    <span class="tok-kw">return</span> .{
        .bits_remain = <span class="tok-kw">switch</span> (options.kind) {
            .set =&gt; self.mask,
            .unset =&gt; ~self.mask,
        },
    };
}</code></pre></details></div></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> IntegerBitSet {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_c) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">0</span>));
    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">1</span>));
    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">2</span>));
    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">5</span>));
    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">8</span>));
    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">32</span>));
    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">64</span>));
    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">127</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.IntegerBitSet">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">IntegerBitSet</span>(<span class="tok-kw">comptime</span> size: <span class="tok-type">u16</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();<span class="tok-comment">

        // TODO: Make this a comptime field once those are fixed
        </span><span class="tok-comment">/// The number of items in this bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> bit_length: <span class="tok-type">usize</span> = size;

        <span class="tok-comment">/// The integer type used to represent a mask in this bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MaskInt = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, size);

        <span class="tok-comment">/// The integer type used to shift a mask in this bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ShiftInt = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>);

        <span class="tok-comment">/// The bit mask, as a single integer</span>
        mask: <a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>,

        <span class="tok-comment">/// Creates a bit set with no elements present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
            <span class="tok-kw">return</span> .{ .mask = <span class="tok-number">0</span> };
        }

        <span class="tok-comment">/// Creates a bit set with all elements present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>() <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
            <span class="tok-kw">return</span> .{ .mask = ~<span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, <span class="tok-number">0</span>) };
        }

        <span class="tok-comment">/// Returns the number of bits in this bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">usize</span> {
            _ = self;
            <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>;
        }

        <span class="tok-comment">/// Returns true if the bit at the specified index</span>
        <span class="tok-comment">/// is present in the set, false otherwise.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSet</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>);
            <span class="tok-kw">return</span> (self.mask &amp; <a href="std.bit_set.html#std.bit_set.IntegerBitSet.maskBit">maskBit</a>(index)) != <span class="tok-number">0</span>;
        }

        <span class="tok-comment">/// Returns the total number of set bits in this bit set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@popCount</span>(self.mask);
        }

        <span class="tok-comment">/// Changes the value of the specified bit of the bit</span>
        <span class="tok-comment">/// set to match the passed boolean.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setValue</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, index: <span class="tok-type">usize</span>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>);
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a> == <span class="tok-type">u0</span>) <span class="tok-kw">return</span>;
            <span class="tok-kw">const</span> bit = <a href="std.bit_set.html#std.bit_set.IntegerBitSet.maskBit">maskBit</a>(index);
            <span class="tok-kw">const</span> new_bit = bit &amp; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, value);
            self.mask = (self.mask &amp; ~bit) | new_bit;
        }

        <span class="tok-comment">/// Adds a specific bit to the bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>);
            self.mask |= <a href="std.bit_set.html#std.bit_set.IntegerBitSet.maskBit">maskBit</a>(index);
        }

        <span class="tok-comment">/// Changes the value of all bits in the specified range to</span>
        <span class="tok-comment">/// match the passed boolean.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setRangeValue</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, range: <a href="std.bit_set.Range.html">Range</a>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(range.end &lt;= <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(range.start &lt;= range.end);
            <span class="tok-kw">if</span> (range.start == range.end) <span class="tok-kw">return</span>;
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a> == <span class="tok-type">u0</span>) <span class="tok-kw">return</span>;

            <span class="tok-kw">const</span> start_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(range.start));

            <span class="tok-kw">var</span> mask = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; start_bit;
            <span class="tok-kw">if</span> (range.end != <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>) {
                <span class="tok-kw">const</span> end_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(range.end));
                mask &amp;= <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>)) - <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, end_bit)));
            }
            self.mask &amp;= ~mask;

            mask = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, value) &lt;&lt; start_bit;
            <span class="tok-kw">if</span> (range.end != <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>) {
                <span class="tok-kw">const</span> end_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(range.end));
                mask &amp;= <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, value) &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>)) - <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, end_bit)));
            }
            self.mask |= mask;
        }

        <span class="tok-comment">/// Removes a specific bit from the bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unset</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>);<span class="tok-comment">
            // Workaround for #7953
            </span><span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a> == <span class="tok-type">u0</span>) <span class="tok-kw">return</span>;
            self.mask &amp;= ~<a href="std.bit_set.html#std.bit_set.IntegerBitSet.maskBit">maskBit</a>(index);
        }

        <span class="tok-comment">/// Flips a specific bit in the bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggle</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>);
            self.mask ^= <a href="std.bit_set.html#std.bit_set.IntegerBitSet.maskBit">maskBit</a>(index);
        }

        <span class="tok-comment">/// Flips all bits in this bit set which are present</span>
        <span class="tok-comment">/// in the toggles bit set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleSet</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, toggles: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">void</span> {
            self.mask ^= toggles.mask;
        }

        <span class="tok-comment">/// Flips every bit in the bit set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleAll</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">void</span> {
            self.mask = ~self.mask;
        }

        <span class="tok-comment">/// Performs a union of two bit sets, and stores the</span>
        <span class="tok-comment">/// result in the first one.  Bits in the result are</span>
        <span class="tok-comment">/// set if the corresponding bits were set in either input.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">void</span> {
            self.mask |= other.mask;
        }

        <span class="tok-comment">/// Performs an intersection of two bit sets, and stores</span>
        <span class="tok-comment">/// the result in the first one.  Bits in the result are</span>
        <span class="tok-comment">/// set if the corresponding bits were set in both inputs.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIntersection</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">void</span> {
            self.mask &amp;= other.mask;
        }

        <span class="tok-comment">/// Finds the index of the first set bit.</span>
        <span class="tok-comment">/// If no bits are set, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findFirstSet</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> mask = self.mask;
            <span class="tok-kw">if</span> (mask == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> <span class="tok-builtin">@ctz</span>(mask);
        }

        <span class="tok-comment">/// Finds the index of the first set bit, and unsets it.</span>
        <span class="tok-comment">/// If no bits are set, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleFirstSet</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> mask = self.mask;
            <span class="tok-kw">if</span> (mask == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> index = <span class="tok-builtin">@ctz</span>(mask);
            self.mask = mask &amp; (mask - <span class="tok-number">1</span>);
            <span class="tok-kw">return</span> index;
        }

        <span class="tok-comment">/// Returns true iff every corresponding bit in both</span>
        <span class="tok-comment">/// bit sets are the same.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a> == <span class="tok-number">0</span> <span class="tok-kw">or</span> self.mask == other.mask;
        }

        <span class="tok-comment">/// Returns true iff the first bit set is the subset</span>
        <span class="tok-comment">/// of the second one.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.intersectWith(other).eql(self);
        }

        <span class="tok-comment">/// Returns true iff the first bit set is the superset</span>
        <span class="tok-comment">/// of the second one.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> other.subsetOf(self);
        }

        <span class="tok-comment">/// Returns the complement bit sets. Bits in the result</span>
        <span class="tok-comment">/// are set if the corresponding bits were not set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">complement</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.toggleAll();
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns the union of two bit sets. Bits in the</span>
        <span class="tok-comment">/// result are set if the corresponding bits were set</span>
        <span class="tok-comment">/// in either input.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unionWith</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.setUnion(other);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns the intersection of two bit sets. Bits in</span>
        <span class="tok-comment">/// the result are set if the corresponding bits were</span>
        <span class="tok-comment">/// set in both inputs.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intersectWith</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.setIntersection(other);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns the xor of two bit sets. Bits in the</span>
        <span class="tok-comment">/// result are set if the corresponding bits were</span>
        <span class="tok-comment">/// not the same in both inputs.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">xorWith</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.toggleSet(other);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns the difference of two bit sets. Bits in</span>
        <span class="tok-comment">/// the result are set if set in the first but not</span>
        <span class="tok-comment">/// set in the second set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">differenceWith</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.setIntersection(other.complement());
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Iterates through the items in the set, according to the options.</span>
        <span class="tok-comment">/// The default options (.{}) will iterate indices of set bits in</span>
        <span class="tok-comment">/// ascending order.  Modifications to the underlying bit set may</span>
        <span class="tok-comment">/// or may not be observed by the iterator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, <span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet.Iterator">Iterator</a>(options) {
            <span class="tok-kw">return</span> .{
                .bits_remain = <span class="tok-kw">switch</span> (options.kind) {
                    .set =&gt; self.mask,
                    .unset =&gt; ~self.mask,
                },
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Iterator</span>(<span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <span class="tok-type">type</span> {
            <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.IntegerBitSet.SingleWordIterator">SingleWordIterator</a>(options.direction);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">SingleWordIterator</span>(<span class="tok-kw">comptime</span> direction: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>.<a href="std.bit_set.IteratorOptions.Direction.html">Direction</a>) <span class="tok-type">type</span> {
            <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
                <span class="tok-kw">const</span> IterSelf = <span class="tok-builtin">@This</span>();<span class="tok-comment">
                // all bits which have not yet been iterated over
                </span>bits_remain: <a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>,

                <span class="tok-comment">/// Returns the index of the next unvisited set bit</span>
                <span class="tok-comment">/// in the bit set, in ascending order.</span>
                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet.SingleWordIterator">IterSelf</a>) ?<span class="tok-type">usize</span> {
                    <span class="tok-kw">if</span> (self.bits_remain == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;

                    <span class="tok-kw">switch</span> (direction) {
                        .forward =&gt; {
                            <span class="tok-kw">const</span> next_index = <span class="tok-builtin">@ctz</span>(self.bits_remain);
                            self.bits_remain &amp;= self.bits_remain - <span class="tok-number">1</span>;
                            <span class="tok-kw">return</span> next_index;
                        },
                        .reverse =&gt; {
                            <span class="tok-kw">const</span> leading_zeroes = <span class="tok-builtin">@clz</span>(self.bits_remain);
                            <span class="tok-kw">const</span> top_bit = (<span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>) - <span class="tok-number">1</span>) - leading_zeroes;
                            self.bits_remain &amp;= (<span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(top_bit))) - <span class="tok-number">1</span>;
                            <span class="tok-kw">return</span> top_bit;
                        },
                    }
                }
            };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">maskBit</span>(index: <span class="tok-type">usize</span>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a> {
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a> == <span class="tok-type">u0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(index));
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">boolMaskBit</span>(index: <span class="tok-type">usize</span>, value: <span class="tok-type">bool</span>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a> {
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a> == <span class="tok-type">u0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, <span class="tok-builtin">@intFromBool</span>(value)) &lt;&lt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(index));
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.ArrayBitSet" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">ArrayBitSet</span><a href="#src.zig-std.bit_set.ArrayBitSet">[src]</a></h2><div class="tldDocs"><p>A bit set with static size, which is backed by an array of usize.
This set is good for sets with a larger size, but may use
more bytes than necessary if your set is small.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>MaskIntType: <span class="tok-type">type</span></code></pre></div><div><pre><code>size: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.bit_set.ArrayBitSet.ShiftInt" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">ShiftInt</span><a href="#src.zig-std.bit_set.ArrayBitSet.ShiftInt">[src]</a></h3><div class="tldDocs"><p>The integer type used to shift a mask in this bit set</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.ShiftInt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ShiftInt = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>)</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.Iterator" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Iterator</span><a href="#src.zig-std.bit_set.ArrayBitSet.Iterator">[src]</a></h3><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.Iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Iterator</span>(<span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.BitSetIterator">BitSetIterator</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, options);
}</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>masks: [<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a>]<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a></code></pre><div class="fieldDocs"><p>The bit masks, ordered with lower indices first.
Padding bits at the end are undefined.</p>
</div></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.bit_set.ArrayBitSet.bit_length" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">bit_length</span><a href="#src.zig-std.bit_set.ArrayBitSet.bit_length">[src]</a></h3><div class="tldDocs"><p>The number of items in this bit set</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.bit_length">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> bit_length: <span class="tok-type">usize</span> = size</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.MaskInt" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">MaskInt</span><a href="#src.zig-std.bit_set.ArrayBitSet.MaskInt">[src]</a></h3><div class="tldDocs"><p>The integer type used to represent a mask in this bit set</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.MaskInt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MaskInt = MaskIntType</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.last_item_mask" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">last_item_mask</span><a href="#src.zig-std.bit_set.ArrayBitSet.last_item_mask">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.last_item_mask">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> last_item_mask = ~<span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-number">0</span>) &gt;&gt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.last_pad_bits">last_pad_bits</a></code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.bit_set.ArrayBitSet.initEmpty" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initEmpty</span><a href="#src.zig-std.bit_set.ArrayBitSet.initEmpty">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div class="tldDocs"><p>Creates a bit set with no elements present.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.initEmpty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
    <span class="tok-kw">return</span> .{ .masks = [_]<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>{<span class="tok-number">0</span>} ** <a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> };
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.initFull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initFull</span><a href="#src.zig-std.bit_set.ArrayBitSet.initFull">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>() <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div class="tldDocs"><p>Creates a bit set with all elements present.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.initFull">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>() <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
    <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> .{ .masks = .{} };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> .{ .masks = [_]<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>{~<span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-number">0</span>)} ** (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> - <span class="tok-number">1</span>) ++ [_]<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>{<a href="std.bit_set.html#std.bit_set.ArrayBitSet.last_item_mask">last_item_mask</a>} };
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.bit_set.ArrayBitSet.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of bits in this bit set</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">usize</span> {
    _ = self;
    <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.isSet" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isSet</span><a href="#src.zig-std.bit_set.ArrayBitSet.isSet">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSet</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true if the bit at the specified index
is present in the set, false otherwise.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.isSet">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSet</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>);
    <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">false</span>;<span class="tok-comment"> // doesn't compile in this case
    </span><span class="tok-kw">return</span> (self.masks[<a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(index)] &amp; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskBit">maskBit</a>(index)) != <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.bit_set.ArrayBitSet.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the total number of set bits in this bit set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> total: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (self.masks) |mask| {
        total += <span class="tok-builtin">@popCount</span>(mask);
    }
    <span class="tok-kw">return</span> total;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.setValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setValue</span><a href="#src.zig-std.bit_set.ArrayBitSet.setValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setValue</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, index: <span class="tok-type">usize</span>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Changes the value of the specified bit of the bit
set to match the passed boolean.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>value: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.setValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setValue</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, index: <span class="tok-type">usize</span>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>);
    <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;<span class="tok-comment"> // doesn't compile in this case
    </span><span class="tok-kw">const</span> bit = <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskBit">maskBit</a>(index);
    <span class="tok-kw">const</span> mask_index = <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(index);
    <span class="tok-kw">const</span> new_bit = bit &amp; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, value);
    self.masks[mask_index] = (self.masks[mask_index] &amp; ~bit) | new_bit;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.set" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">set</span><a href="#src.zig-std.bit_set.ArrayBitSet.set">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Adds a specific bit to the bit set</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.set">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>);
    <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;<span class="tok-comment"> // doesn't compile in this case
    </span>self.masks[<a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(index)] |= <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskBit">maskBit</a>(index);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.setRangeValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setRangeValue</span><a href="#src.zig-std.bit_set.ArrayBitSet.setRangeValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setRangeValue</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, range: <a href="std.bit_set.Range.html">Range</a>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Changes the value of all bits in the specified range to
match the passed boolean.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div><pre><code>range: <a href="std.bit_set.Range.html">Range</a></code></pre></div><div><pre><code>value: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.setRangeValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setRangeValue</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, range: <a href="std.bit_set.Range.html">Range</a>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(range.end &lt;= <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>);
    <a href="std.debug.html#std.debug.assert">assert</a>(range.start &lt;= range.end);
    <span class="tok-kw">if</span> (range.start == range.end) <span class="tok-kw">return</span>;
    <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;

    <span class="tok-kw">const</span> start_mask_index = <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(range.start);
    <span class="tok-kw">const</span> start_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(range.start));

    <span class="tok-kw">const</span> end_mask_index = <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(range.end);
    <span class="tok-kw">const</span> end_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(range.end));

    <span class="tok-kw">if</span> (start_mask_index == end_mask_index) {
        <span class="tok-kw">var</span> mask1 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; start_bit;
        <span class="tok-kw">var</span> mask2 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &gt;&gt; (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.mask_len">mask_len</a> - <span class="tok-number">1</span>) - (end_bit - <span class="tok-number">1</span>);
        self.masks[start_mask_index] &amp;= ~(mask1 &amp; mask2);

        mask1 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, value) &lt;&lt; start_bit;
        mask2 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, value) &gt;&gt; (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.mask_len">mask_len</a> - <span class="tok-number">1</span>) - (end_bit - <span class="tok-number">1</span>);
        self.masks[start_mask_index] |= mask1 &amp; mask2;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">var</span> bulk_mask_index: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">if</span> (start_bit &gt; <span class="tok-number">0</span>) {
            self.masks[start_mask_index] =
                (self.masks[start_mask_index] &amp; ~(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; start_bit)) |
                (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, value) &lt;&lt; start_bit);
            bulk_mask_index = start_mask_index + <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> {
            bulk_mask_index = start_mask_index;
        }

        <span class="tok-kw">while</span> (bulk_mask_index &lt; end_mask_index) : (bulk_mask_index += <span class="tok-number">1</span>) {
            self.masks[bulk_mask_index] = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, value);
        }

        <span class="tok-kw">if</span> (end_bit &gt; <span class="tok-number">0</span>) {
            self.masks[end_mask_index] =
                (self.masks[end_mask_index] &amp; (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; end_bit)) |
                (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, value) &gt;&gt; ((<span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>) - <span class="tok-number">1</span>) - (end_bit - <span class="tok-number">1</span>)));
        }
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.unset" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unset</span><a href="#src.zig-std.bit_set.ArrayBitSet.unset">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unset</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Removes a specific bit from the bit set</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.unset">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unset</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>);
    <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;<span class="tok-comment"> // doesn't compile in this case
    </span>self.masks[<a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(index)] &amp;= ~<a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskBit">maskBit</a>(index);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.toggle" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toggle</span><a href="#src.zig-std.bit_set.ArrayBitSet.toggle">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggle</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Flips a specific bit in the bit set</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.toggle">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggle</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>);
    <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;<span class="tok-comment"> // doesn't compile in this case
    </span>self.masks[<a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(index)] ^= <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskBit">maskBit</a>(index);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.toggleSet" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toggleSet</span><a href="#src.zig-std.bit_set.ArrayBitSet.toggleSet">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleSet</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, toggles: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Flips all bits in this bit set which are present
in the toggles bit set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div><pre><code>toggles: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.toggleSet">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleSet</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, toggles: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">for</span> (&amp;self.masks, <span class="tok-number">0</span>..) |*mask, i| {
        mask.* ^= toggles.masks[i];
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.toggleAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toggleAll</span><a href="#src.zig-std.bit_set.ArrayBitSet.toggleAll">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleAll</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Flips every bit in the bit set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.toggleAll">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleAll</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">for</span> (&amp;self.masks) |*mask| {
        mask.* = ~mask.*;
    }<span class="tok-comment">

    // Zero the padding bits
    </span><span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> &gt; <span class="tok-number">0</span>) {
        self.masks[<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> - <span class="tok-number">1</span>] &amp;= <a href="std.bit_set.html#std.bit_set.ArrayBitSet.last_item_mask">last_item_mask</a>;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.setUnion" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setUnion</span><a href="#src.zig-std.bit_set.ArrayBitSet.setUnion">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Performs a union of two bit sets, and stores the
result in the first one.  Bits in the result are
set if the corresponding bits were set in either input.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.setUnion">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">for</span> (&amp;self.masks, <span class="tok-number">0</span>..) |*mask, i| {
        mask.* |= other.masks[i];
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.setIntersection" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setIntersection</span><a href="#src.zig-std.bit_set.ArrayBitSet.setIntersection">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIntersection</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Performs an intersection of two bit sets, and stores
the result in the first one.  Bits in the result are
set if the corresponding bits were set in both inputs.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.setIntersection">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIntersection</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">for</span> (&amp;self.masks, <span class="tok-number">0</span>..) |*mask, i| {
        mask.* &amp;= other.masks[i];
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.findFirstSet" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">findFirstSet</span><a href="#src.zig-std.bit_set.ArrayBitSet.findFirstSet">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findFirstSet</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Finds the index of the first set bit.
If no bits are set, returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.findFirstSet">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findFirstSet</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> mask = <span class="tok-kw">for</span> (self.masks) |mask| {
        <span class="tok-kw">if</span> (mask != <span class="tok-number">0</span>) <span class="tok-kw">break</span> mask;
        offset += <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>);
    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> offset + <span class="tok-builtin">@ctz</span>(mask);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.toggleFirstSet" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toggleFirstSet</span><a href="#src.zig-std.bit_set.ArrayBitSet.toggleFirstSet">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleFirstSet</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Finds the index of the first set bit, and unsets it.
If no bits are set, returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.toggleFirstSet">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleFirstSet</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> mask = <span class="tok-kw">for</span> (&amp;self.masks) |*mask| {
        <span class="tok-kw">if</span> (mask.* != <span class="tok-number">0</span>) <span class="tok-kw">break</span> mask;
        offset += <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>);
    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> index = <span class="tok-builtin">@ctz</span>(mask.*);
    mask.* &amp;= (mask.* - <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> offset + index;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.eql" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">eql</span><a href="#src.zig-std.bit_set.ArrayBitSet.eql">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff every corresponding bit in both
bit sets are the same.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.eql">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> <span class="tok-kw">while</span> (i &lt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (self.masks[i] != other.masks[i]) {
            <span class="tok-kw">break</span> <span class="tok-null">false</span>;
        }
    } <span class="tok-kw">else</span> <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.subsetOf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">subsetOf</span><a href="#src.zig-std.bit_set.ArrayBitSet.subsetOf">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff the first bit set is the subset
of the second one.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.subsetOf">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.intersectWith(other).eql(self);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.supersetOf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">supersetOf</span><a href="#src.zig-std.bit_set.ArrayBitSet.supersetOf">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff the first bit set is the superset
of the second one.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.supersetOf">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> other.subsetOf(self);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.complement" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">complement</span><a href="#src.zig-std.bit_set.ArrayBitSet.complement">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">complement</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns the complement bit sets. Bits in the result
are set if the corresponding bits were not set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.complement">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">complement</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
    <span class="tok-kw">var</span> result = self;
    result.toggleAll();
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.unionWith" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unionWith</span><a href="#src.zig-std.bit_set.ArrayBitSet.unionWith">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unionWith</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns the union of two bit sets. Bits in the
result are set if the corresponding bits were set
in either input.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.unionWith">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unionWith</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
    <span class="tok-kw">var</span> result = self;
    result.setUnion(other);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.intersectWith" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">intersectWith</span><a href="#src.zig-std.bit_set.ArrayBitSet.intersectWith">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intersectWith</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns the intersection of two bit sets. Bits in
the result are set if the corresponding bits were
set in both inputs.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.intersectWith">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intersectWith</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
    <span class="tok-kw">var</span> result = self;
    result.setIntersection(other);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.xorWith" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">xorWith</span><a href="#src.zig-std.bit_set.ArrayBitSet.xorWith">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">xorWith</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns the xor of two bit sets. Bits in the
result are set if the corresponding bits were
not the same in both inputs.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.xorWith">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">xorWith</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
    <span class="tok-kw">var</span> result = self;
    result.toggleSet(other);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.differenceWith" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">differenceWith</span><a href="#src.zig-std.bit_set.ArrayBitSet.differenceWith">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">differenceWith</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns the difference of two bit sets. Bits in
the result are set if set in the first but not
set in the second set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.differenceWith">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">differenceWith</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
    <span class="tok-kw">var</span> result = self;
    result.setIntersection(other.complement());
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bit_set.ArrayBitSet.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.bit_set.ArrayBitSet.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, <span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet.Iterator">Iterator</a>(options)</code></pre></div><div class="tldDocs"><p>Iterates through the items in the set, according to the options.
The default options (.{}) will iterate indices of set bits in
ascending order.  Modifications to the underlying bit set may
or may not be observed by the iterator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a></code></pre></div><div><pre><code>options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, <span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet.Iterator">Iterator</a>(options) {
    <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.ArrayBitSet.Iterator">Iterator</a>(options).init(&amp;self.masks, <a href="std.bit_set.html#std.bit_set.ArrayBitSet.last_item_mask">last_item_mask</a>);
}</code></pre></details></div></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> ArrayBitSet {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (.{ <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">31</span>, <span class="tok-number">32</span>, <span class="tok-number">33</span>, <span class="tok-number">63</span>, <span class="tok-number">64</span>, <span class="tok-number">65</span>, <span class="tok-number">254</span>, <span class="tok-number">500</span>, <span class="tok-number">3000</span> }) |size| {
        <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a>(<span class="tok-type">u8</span>, size));
        <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a>(<span class="tok-type">u16</span>, size));
        <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a>(<span class="tok-type">u32</span>, size));
        <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a>(<span class="tok-type">u64</span>, size));
        <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a>(<span class="tok-type">u128</span>, size));
    }
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.ArrayBitSet">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ArrayBitSet</span>(<span class="tok-kw">comptime</span> MaskIntType: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> size: <span class="tok-type">usize</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> mask_info: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a> = <span class="tok-builtin">@typeInfo</span>(MaskIntType);<span class="tok-comment">

    // Make sure the mask int is indeed an int
    </span><span class="tok-kw">if</span> (mask_info != .int) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;ArrayBitSet can only operate on integer masks, but was passed &quot;</span> ++ <span class="tok-builtin">@typeName</span>(MaskIntType));<span class="tok-comment">

    // It must also be unsigned.
    </span><span class="tok-kw">if</span> (mask_info.int.signedness != .unsigned) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;ArrayBitSet requires an unsigned integer mask type, but was passed &quot;</span> ++ <span class="tok-builtin">@typeName</span>(MaskIntType));<span class="tok-comment">

    // And it must not be empty.
    </span><span class="tok-kw">if</span> (MaskIntType == <span class="tok-type">u0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;ArrayBitSet requires a sized integer for its mask int.  u0 does not work.&quot;</span>);

    <span class="tok-kw">const</span> byte_size = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.byte_size_in_bits">byte_size_in_bits</a>;<span class="tok-comment">

    // We use shift and truncate to decompose indices into mask indices and bit indices.
    // This operation requires that the mask has an exact power of two number of bits.
    </span><span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(<span class="tok-builtin">@bitSizeOf</span>(MaskIntType))) {
        <span class="tok-kw">var</span> desired_bits = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.ceilPowerOfTwoAssert">ceilPowerOfTwoAssert</a>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitSizeOf</span>(MaskIntType));
        <span class="tok-kw">if</span> (desired_bits &lt; byte_size) desired_bits = byte_size;
        <span class="tok-kw">const</span> FixedMaskType = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, desired_bits);
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;ArrayBitSet was passed integer type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(MaskIntType) ++
            <span class="tok-str">&quot;, which is not a power of two.  Please round this up to a power of two integer size (i.e. &quot;</span> ++ <span class="tok-builtin">@typeName</span>(FixedMaskType) ++ <span class="tok-str">&quot;).&quot;</span>);
    }<span class="tok-comment">

    // Make sure the integer has no padding bits.
    // Those would be wasteful here and are probably a mistake by the user.
    // This case may be hit with small powers of two, like u4.
    </span><span class="tok-kw">if</span> (<span class="tok-builtin">@bitSizeOf</span>(MaskIntType) != <span class="tok-builtin">@sizeOf</span>(MaskIntType) * byte_size) {
        <span class="tok-kw">var</span> desired_bits = <span class="tok-builtin">@sizeOf</span>(MaskIntType) * byte_size;
        desired_bits = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.ceilPowerOfTwoAssert">ceilPowerOfTwoAssert</a>(<span class="tok-type">usize</span>, desired_bits);
        <span class="tok-kw">const</span> FixedMaskType = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, desired_bits);
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;ArrayBitSet was passed integer type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(MaskIntType) ++
            <span class="tok-str">&quot;, which contains padding bits.  Please round this up to an unpadded integer size (i.e. &quot;</span> ++ <span class="tok-builtin">@typeName</span>(FixedMaskType) ++ <span class="tok-str">&quot;).&quot;</span>);
    }

    <span class="tok-kw">return</span> <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();<span class="tok-comment">

        // TODO: Make this a comptime field once those are fixed
        </span><span class="tok-comment">/// The number of items in this bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> bit_length: <span class="tok-type">usize</span> = size;

        <span class="tok-comment">/// The integer type used to represent a mask in this bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MaskInt = MaskIntType;

        <span class="tok-comment">/// The integer type used to shift a mask in this bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ShiftInt = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>);<span class="tok-comment">

        // bits in one mask
        </span><span class="tok-kw">const</span> mask_len = <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>);<span class="tok-comment">
        // total number of masks
        </span><span class="tok-kw">const</span> num_masks = (size + <a href="std.bit_set.html#std.bit_set.ArrayBitSet.mask_len">mask_len</a> - <span class="tok-number">1</span>) / <a href="std.bit_set.html#std.bit_set.ArrayBitSet.mask_len">mask_len</a>;<span class="tok-comment">
        // padding bits in the last mask (may be 0)
        </span><span class="tok-kw">const</span> last_pad_bits = <a href="std.bit_set.html#std.bit_set.ArrayBitSet.mask_len">mask_len</a> * <a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> - size;<span class="tok-comment">
        // Mask of valid bits in the last mask.
        // All functions will ensure that the invalid
        // bits in the last mask are zero.
        </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> last_item_mask = ~<span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-number">0</span>) &gt;&gt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.last_pad_bits">last_pad_bits</a>;

        <span class="tok-comment">/// The bit masks, ordered with lower indices first.</span>
        <span class="tok-comment">/// Padding bits at the end are undefined.</span>
        masks: [<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a>]<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>,

        <span class="tok-comment">/// Creates a bit set with no elements present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
            <span class="tok-kw">return</span> .{ .masks = [_]<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>{<span class="tok-number">0</span>} ** <a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> };
        }

        <span class="tok-comment">/// Creates a bit set with all elements present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>() <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> .{ .masks = .{} };
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> .{ .masks = [_]<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>{~<span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-number">0</span>)} ** (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> - <span class="tok-number">1</span>) ++ [_]<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>{<a href="std.bit_set.html#std.bit_set.ArrayBitSet.last_item_mask">last_item_mask</a>} };
            }
        }

        <span class="tok-comment">/// Returns the number of bits in this bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">usize</span> {
            _ = self;
            <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>;
        }

        <span class="tok-comment">/// Returns true if the bit at the specified index</span>
        <span class="tok-comment">/// is present in the set, false otherwise.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSet</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>);
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">false</span>;<span class="tok-comment"> // doesn't compile in this case
            </span><span class="tok-kw">return</span> (self.masks[<a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(index)] &amp; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskBit">maskBit</a>(index)) != <span class="tok-number">0</span>;
        }

        <span class="tok-comment">/// Returns the total number of set bits in this bit set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">var</span> total: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (self.masks) |mask| {
                total += <span class="tok-builtin">@popCount</span>(mask);
            }
            <span class="tok-kw">return</span> total;
        }

        <span class="tok-comment">/// Changes the value of the specified bit of the bit</span>
        <span class="tok-comment">/// set to match the passed boolean.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setValue</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, index: <span class="tok-type">usize</span>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>);
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;<span class="tok-comment"> // doesn't compile in this case
            </span><span class="tok-kw">const</span> bit = <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskBit">maskBit</a>(index);
            <span class="tok-kw">const</span> mask_index = <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(index);
            <span class="tok-kw">const</span> new_bit = bit &amp; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, value);
            self.masks[mask_index] = (self.masks[mask_index] &amp; ~bit) | new_bit;
        }

        <span class="tok-comment">/// Adds a specific bit to the bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>);
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;<span class="tok-comment"> // doesn't compile in this case
            </span>self.masks[<a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(index)] |= <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskBit">maskBit</a>(index);
        }

        <span class="tok-comment">/// Changes the value of all bits in the specified range to</span>
        <span class="tok-comment">/// match the passed boolean.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setRangeValue</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, range: <a href="std.bit_set.Range.html">Range</a>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(range.end &lt;= <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(range.start &lt;= range.end);
            <span class="tok-kw">if</span> (range.start == range.end) <span class="tok-kw">return</span>;
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;

            <span class="tok-kw">const</span> start_mask_index = <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(range.start);
            <span class="tok-kw">const</span> start_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(range.start));

            <span class="tok-kw">const</span> end_mask_index = <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(range.end);
            <span class="tok-kw">const</span> end_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(range.end));

            <span class="tok-kw">if</span> (start_mask_index == end_mask_index) {
                <span class="tok-kw">var</span> mask1 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; start_bit;
                <span class="tok-kw">var</span> mask2 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &gt;&gt; (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.mask_len">mask_len</a> - <span class="tok-number">1</span>) - (end_bit - <span class="tok-number">1</span>);
                self.masks[start_mask_index] &amp;= ~(mask1 &amp; mask2);

                mask1 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, value) &lt;&lt; start_bit;
                mask2 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, value) &gt;&gt; (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.mask_len">mask_len</a> - <span class="tok-number">1</span>) - (end_bit - <span class="tok-number">1</span>);
                self.masks[start_mask_index] |= mask1 &amp; mask2;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">var</span> bulk_mask_index: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">if</span> (start_bit &gt; <span class="tok-number">0</span>) {
                    self.masks[start_mask_index] =
                        (self.masks[start_mask_index] &amp; ~(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; start_bit)) |
                        (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, value) &lt;&lt; start_bit);
                    bulk_mask_index = start_mask_index + <span class="tok-number">1</span>;
                } <span class="tok-kw">else</span> {
                    bulk_mask_index = start_mask_index;
                }

                <span class="tok-kw">while</span> (bulk_mask_index &lt; end_mask_index) : (bulk_mask_index += <span class="tok-number">1</span>) {
                    self.masks[bulk_mask_index] = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, value);
                }

                <span class="tok-kw">if</span> (end_bit &gt; <span class="tok-number">0</span>) {
                    self.masks[end_mask_index] =
                        (self.masks[end_mask_index] &amp; (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; end_bit)) |
                        (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, value) &gt;&gt; ((<span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>) - <span class="tok-number">1</span>) - (end_bit - <span class="tok-number">1</span>)));
                }
            }
        }

        <span class="tok-comment">/// Removes a specific bit from the bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unset</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>);
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;<span class="tok-comment"> // doesn't compile in this case
            </span>self.masks[<a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(index)] &amp;= ~<a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskBit">maskBit</a>(index);
        }

        <span class="tok-comment">/// Flips a specific bit in the bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggle</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>);
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;<span class="tok-comment"> // doesn't compile in this case
            </span>self.masks[<a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(index)] ^= <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskBit">maskBit</a>(index);
        }

        <span class="tok-comment">/// Flips all bits in this bit set which are present</span>
        <span class="tok-comment">/// in the toggles bit set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleSet</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, toggles: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">for</span> (&amp;self.masks, <span class="tok-number">0</span>..) |*mask, i| {
                mask.* ^= toggles.masks[i];
            }
        }

        <span class="tok-comment">/// Flips every bit in the bit set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleAll</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">for</span> (&amp;self.masks) |*mask| {
                mask.* = ~mask.*;
            }<span class="tok-comment">

            // Zero the padding bits
            </span><span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> &gt; <span class="tok-number">0</span>) {
                self.masks[<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> - <span class="tok-number">1</span>] &amp;= <a href="std.bit_set.html#std.bit_set.ArrayBitSet.last_item_mask">last_item_mask</a>;
            }
        }

        <span class="tok-comment">/// Performs a union of two bit sets, and stores the</span>
        <span class="tok-comment">/// result in the first one.  Bits in the result are</span>
        <span class="tok-comment">/// set if the corresponding bits were set in either input.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">for</span> (&amp;self.masks, <span class="tok-number">0</span>..) |*mask, i| {
                mask.* |= other.masks[i];
            }
        }

        <span class="tok-comment">/// Performs an intersection of two bit sets, and stores</span>
        <span class="tok-comment">/// the result in the first one.  Bits in the result are</span>
        <span class="tok-comment">/// set if the corresponding bits were set in both inputs.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIntersection</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">for</span> (&amp;self.masks, <span class="tok-number">0</span>..) |*mask, i| {
                mask.* &amp;= other.masks[i];
            }
        }

        <span class="tok-comment">/// Finds the index of the first set bit.</span>
        <span class="tok-comment">/// If no bits are set, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findFirstSet</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">var</span> offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">const</span> mask = <span class="tok-kw">for</span> (self.masks) |mask| {
                <span class="tok-kw">if</span> (mask != <span class="tok-number">0</span>) <span class="tok-kw">break</span> mask;
                offset += <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>);
            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> offset + <span class="tok-builtin">@ctz</span>(mask);
        }

        <span class="tok-comment">/// Finds the index of the first set bit, and unsets it.</span>
        <span class="tok-comment">/// If no bits are set, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleFirstSet</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">var</span> offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">const</span> mask = <span class="tok-kw">for</span> (&amp;self.masks) |*mask| {
                <span class="tok-kw">if</span> (mask.* != <span class="tok-number">0</span>) <span class="tok-kw">break</span> mask;
                offset += <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>);
            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> index = <span class="tok-builtin">@ctz</span>(mask.*);
            mask.* &amp;= (mask.* - <span class="tok-number">1</span>);
            <span class="tok-kw">return</span> offset + index;
        }

        <span class="tok-comment">/// Returns true iff every corresponding bit in both</span>
        <span class="tok-comment">/// bit sets are the same.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">return</span> <span class="tok-kw">while</span> (i &lt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a>) : (i += <span class="tok-number">1</span>) {
                <span class="tok-kw">if</span> (self.masks[i] != other.masks[i]) {
                    <span class="tok-kw">break</span> <span class="tok-null">false</span>;
                }
            } <span class="tok-kw">else</span> <span class="tok-null">true</span>;
        }

        <span class="tok-comment">/// Returns true iff the first bit set is the subset</span>
        <span class="tok-comment">/// of the second one.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.intersectWith(other).eql(self);
        }

        <span class="tok-comment">/// Returns true iff the first bit set is the superset</span>
        <span class="tok-comment">/// of the second one.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> other.subsetOf(self);
        }

        <span class="tok-comment">/// Returns the complement bit sets. Bits in the result</span>
        <span class="tok-comment">/// are set if the corresponding bits were not set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">complement</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.toggleAll();
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns the union of two bit sets. Bits in the</span>
        <span class="tok-comment">/// result are set if the corresponding bits were set</span>
        <span class="tok-comment">/// in either input.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unionWith</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.setUnion(other);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns the intersection of two bit sets. Bits in</span>
        <span class="tok-comment">/// the result are set if the corresponding bits were</span>
        <span class="tok-comment">/// set in both inputs.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intersectWith</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.setIntersection(other);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns the xor of two bit sets. Bits in the</span>
        <span class="tok-comment">/// result are set if the corresponding bits were</span>
        <span class="tok-comment">/// not the same in both inputs.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">xorWith</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.toggleSet(other);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns the difference of two bit sets. Bits in</span>
        <span class="tok-comment">/// the result are set if set in the first but not</span>
        <span class="tok-comment">/// set in the second set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">differenceWith</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.setIntersection(other.complement());
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Iterates through the items in the set, according to the options.</span>
        <span class="tok-comment">/// The default options (.{}) will iterate indices of set bits in</span>
        <span class="tok-comment">/// ascending order.  Modifications to the underlying bit set may</span>
        <span class="tok-comment">/// or may not be observed by the iterator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, <span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet.Iterator">Iterator</a>(options) {
            <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.ArrayBitSet.Iterator">Iterator</a>(options).init(&amp;self.masks, <a href="std.bit_set.html#std.bit_set.ArrayBitSet.last_item_mask">last_item_mask</a>);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Iterator</span>(<span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <span class="tok-type">type</span> {
            <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.BitSetIterator">BitSetIterator</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, options);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">maskBit</span>(index: <span class="tok-type">usize</span>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(index));
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">maskIndex</span>(index: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> index &gt;&gt; <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.ShiftInt">ShiftInt</a>);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">boolMaskBit</span>(index: <span class="tok-type">usize</span>, value: <span class="tok-type">bool</span>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-builtin">@intFromBool</span>(value)) &lt;&lt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(index));
        }
    };
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.bit_set">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! This file defines several variants of bit sets.  A bit set</span>
<span class="tok-comment">//! is a densely stored set of integers with a known maximum,</span>
<span class="tok-comment">//! in which each integer gets a single bit.  Bit sets have very</span>
<span class="tok-comment">//! fast presence checks, update operations, and union and intersection</span>
<span class="tok-comment">//! operations.  However, if the number of possible items is very</span>
<span class="tok-comment">//! large and the number of actual items in a given set is usually</span>
<span class="tok-comment">//! small, they may be less memory efficient than an array set.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! There are five variants defined here:</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! IntegerBitSet:</span>
<span class="tok-comment">//!   A bit set with static size, which is backed by a single integer.</span>
<span class="tok-comment">//!   This set is good for sets with a small size, but may generate</span>
<span class="tok-comment">//!   inefficient code for larger sets, especially in debug mode.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! ArrayBitSet:</span>
<span class="tok-comment">//!   A bit set with static size, which is backed by an array of usize.</span>
<span class="tok-comment">//!   This set is good for sets with a larger size, but may use</span>
<span class="tok-comment">//!   more bytes than necessary if your set is small.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! StaticBitSet:</span>
<span class="tok-comment">//!   Picks either IntegerBitSet or ArrayBitSet depending on the requested</span>
<span class="tok-comment">//!   size.  The interfaces of these two types match exactly, except for fields.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! DynamicBitSet:</span>
<span class="tok-comment">//!   A bit set with runtime-known size, backed by an allocated slice</span>
<span class="tok-comment">//!   of usize.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! DynamicBitSetUnmanaged:</span>
<span class="tok-comment">//!   A variant of DynamicBitSet which does not store a pointer to its</span>
<span class="tok-comment">//!   allocator, in order to save space.</span>

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> Allocator = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);

<span class="tok-comment">/// Returns the optimal static bit set type for the specified number</span>
<span class="tok-comment">/// of elements: either `IntegerBitSet` or `ArrayBitSet`,</span>
<span class="tok-comment">/// both of which fulfill the same interface.</span>
<span class="tok-comment">/// The returned type will perform no allocations,</span>
<span class="tok-comment">/// can be copied by value, and does not require deinitialization.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StaticBitSet</span>(<span class="tok-kw">comptime</span> size: <span class="tok-type">usize</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">if</span> (size &lt;= <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>)) {
        <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(size);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a>(<span class="tok-type">usize</span>, size);
    }
}

<span class="tok-comment">/// A bit set with static size, which is backed by a single integer.</span>
<span class="tok-comment">/// This set is good for sets with a small size, but may generate</span>
<span class="tok-comment">/// inefficient code for larger sets, especially in debug mode.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">IntegerBitSet</span>(<span class="tok-kw">comptime</span> size: <span class="tok-type">u16</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();<span class="tok-comment">

        // TODO: Make this a comptime field once those are fixed
        </span><span class="tok-comment">/// The number of items in this bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> bit_length: <span class="tok-type">usize</span> = size;

        <span class="tok-comment">/// The integer type used to represent a mask in this bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MaskInt = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, size);

        <span class="tok-comment">/// The integer type used to shift a mask in this bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ShiftInt = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>);

        <span class="tok-comment">/// The bit mask, as a single integer</span>
        mask: <a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>,

        <span class="tok-comment">/// Creates a bit set with no elements present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
            <span class="tok-kw">return</span> .{ .mask = <span class="tok-number">0</span> };
        }

        <span class="tok-comment">/// Creates a bit set with all elements present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>() <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
            <span class="tok-kw">return</span> .{ .mask = ~<span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, <span class="tok-number">0</span>) };
        }

        <span class="tok-comment">/// Returns the number of bits in this bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">usize</span> {
            _ = self;
            <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>;
        }

        <span class="tok-comment">/// Returns true if the bit at the specified index</span>
        <span class="tok-comment">/// is present in the set, false otherwise.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSet</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>);
            <span class="tok-kw">return</span> (self.mask &amp; <a href="std.bit_set.html#std.bit_set.IntegerBitSet.maskBit">maskBit</a>(index)) != <span class="tok-number">0</span>;
        }

        <span class="tok-comment">/// Returns the total number of set bits in this bit set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@popCount</span>(self.mask);
        }

        <span class="tok-comment">/// Changes the value of the specified bit of the bit</span>
        <span class="tok-comment">/// set to match the passed boolean.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setValue</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, index: <span class="tok-type">usize</span>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>);
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a> == <span class="tok-type">u0</span>) <span class="tok-kw">return</span>;
            <span class="tok-kw">const</span> bit = <a href="std.bit_set.html#std.bit_set.IntegerBitSet.maskBit">maskBit</a>(index);
            <span class="tok-kw">const</span> new_bit = bit &amp; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, value);
            self.mask = (self.mask &amp; ~bit) | new_bit;
        }

        <span class="tok-comment">/// Adds a specific bit to the bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>);
            self.mask |= <a href="std.bit_set.html#std.bit_set.IntegerBitSet.maskBit">maskBit</a>(index);
        }

        <span class="tok-comment">/// Changes the value of all bits in the specified range to</span>
        <span class="tok-comment">/// match the passed boolean.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setRangeValue</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, range: <a href="std.bit_set.Range.html">Range</a>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(range.end &lt;= <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(range.start &lt;= range.end);
            <span class="tok-kw">if</span> (range.start == range.end) <span class="tok-kw">return</span>;
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a> == <span class="tok-type">u0</span>) <span class="tok-kw">return</span>;

            <span class="tok-kw">const</span> start_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(range.start));

            <span class="tok-kw">var</span> mask = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; start_bit;
            <span class="tok-kw">if</span> (range.end != <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>) {
                <span class="tok-kw">const</span> end_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(range.end));
                mask &amp;= <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>)) - <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, end_bit)));
            }
            self.mask &amp;= ~mask;

            mask = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, value) &lt;&lt; start_bit;
            <span class="tok-kw">if</span> (range.end != <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>) {
                <span class="tok-kw">const</span> end_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(range.end));
                mask &amp;= <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, value) &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>)) - <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, end_bit)));
            }
            self.mask |= mask;
        }

        <span class="tok-comment">/// Removes a specific bit from the bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unset</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>);<span class="tok-comment">
            // Workaround for #7953
            </span><span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a> == <span class="tok-type">u0</span>) <span class="tok-kw">return</span>;
            self.mask &amp;= ~<a href="std.bit_set.html#std.bit_set.IntegerBitSet.maskBit">maskBit</a>(index);
        }

        <span class="tok-comment">/// Flips a specific bit in the bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggle</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a>);
            self.mask ^= <a href="std.bit_set.html#std.bit_set.IntegerBitSet.maskBit">maskBit</a>(index);
        }

        <span class="tok-comment">/// Flips all bits in this bit set which are present</span>
        <span class="tok-comment">/// in the toggles bit set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleSet</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, toggles: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">void</span> {
            self.mask ^= toggles.mask;
        }

        <span class="tok-comment">/// Flips every bit in the bit set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleAll</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">void</span> {
            self.mask = ~self.mask;
        }

        <span class="tok-comment">/// Performs a union of two bit sets, and stores the</span>
        <span class="tok-comment">/// result in the first one.  Bits in the result are</span>
        <span class="tok-comment">/// set if the corresponding bits were set in either input.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">void</span> {
            self.mask |= other.mask;
        }

        <span class="tok-comment">/// Performs an intersection of two bit sets, and stores</span>
        <span class="tok-comment">/// the result in the first one.  Bits in the result are</span>
        <span class="tok-comment">/// set if the corresponding bits were set in both inputs.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIntersection</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">void</span> {
            self.mask &amp;= other.mask;
        }

        <span class="tok-comment">/// Finds the index of the first set bit.</span>
        <span class="tok-comment">/// If no bits are set, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findFirstSet</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> mask = self.mask;
            <span class="tok-kw">if</span> (mask == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> <span class="tok-builtin">@ctz</span>(mask);
        }

        <span class="tok-comment">/// Finds the index of the first set bit, and unsets it.</span>
        <span class="tok-comment">/// If no bits are set, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleFirstSet</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> mask = self.mask;
            <span class="tok-kw">if</span> (mask == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> index = <span class="tok-builtin">@ctz</span>(mask);
            self.mask = mask &amp; (mask - <span class="tok-number">1</span>);
            <span class="tok-kw">return</span> index;
        }

        <span class="tok-comment">/// Returns true iff every corresponding bit in both</span>
        <span class="tok-comment">/// bit sets are the same.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.IntegerBitSet.bit_length">bit_length</a> == <span class="tok-number">0</span> <span class="tok-kw">or</span> self.mask == other.mask;
        }

        <span class="tok-comment">/// Returns true iff the first bit set is the subset</span>
        <span class="tok-comment">/// of the second one.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.intersectWith(other).eql(self);
        }

        <span class="tok-comment">/// Returns true iff the first bit set is the superset</span>
        <span class="tok-comment">/// of the second one.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> other.subsetOf(self);
        }

        <span class="tok-comment">/// Returns the complement bit sets. Bits in the result</span>
        <span class="tok-comment">/// are set if the corresponding bits were not set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">complement</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.toggleAll();
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns the union of two bit sets. Bits in the</span>
        <span class="tok-comment">/// result are set if the corresponding bits were set</span>
        <span class="tok-comment">/// in either input.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unionWith</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.setUnion(other);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns the intersection of two bit sets. Bits in</span>
        <span class="tok-comment">/// the result are set if the corresponding bits were</span>
        <span class="tok-comment">/// set in both inputs.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intersectWith</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.setIntersection(other);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns the xor of two bit sets. Bits in the</span>
        <span class="tok-comment">/// result are set if the corresponding bits were</span>
        <span class="tok-comment">/// not the same in both inputs.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">xorWith</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.toggleSet(other);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns the difference of two bit sets. Bits in</span>
        <span class="tok-comment">/// the result are set if set in the first but not</span>
        <span class="tok-comment">/// set in the second set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">differenceWith</span>(self: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.setIntersection(other.complement());
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Iterates through the items in the set, according to the options.</span>
        <span class="tok-comment">/// The default options (.{}) will iterate indices of set bits in</span>
        <span class="tok-comment">/// ascending order.  Modifications to the underlying bit set may</span>
        <span class="tok-comment">/// or may not be observed by the iterator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.bit_set.html#std.bit_set.IntegerBitSet">Self</a>, <span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet.Iterator">Iterator</a>(options) {
            <span class="tok-kw">return</span> .{
                .bits_remain = <span class="tok-kw">switch</span> (options.kind) {
                    .set =&gt; self.mask,
                    .unset =&gt; ~self.mask,
                },
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Iterator</span>(<span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <span class="tok-type">type</span> {
            <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.IntegerBitSet.SingleWordIterator">SingleWordIterator</a>(options.direction);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">SingleWordIterator</span>(<span class="tok-kw">comptime</span> direction: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>.<a href="std.bit_set.IteratorOptions.Direction.html">Direction</a>) <span class="tok-type">type</span> {
            <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
                <span class="tok-kw">const</span> IterSelf = <span class="tok-builtin">@This</span>();<span class="tok-comment">
                // all bits which have not yet been iterated over
                </span>bits_remain: <a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>,

                <span class="tok-comment">/// Returns the index of the next unvisited set bit</span>
                <span class="tok-comment">/// in the bit set, in ascending order.</span>
                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.bit_set.html#std.bit_set.IntegerBitSet.SingleWordIterator">IterSelf</a>) ?<span class="tok-type">usize</span> {
                    <span class="tok-kw">if</span> (self.bits_remain == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;

                    <span class="tok-kw">switch</span> (direction) {
                        .forward =&gt; {
                            <span class="tok-kw">const</span> next_index = <span class="tok-builtin">@ctz</span>(self.bits_remain);
                            self.bits_remain &amp;= self.bits_remain - <span class="tok-number">1</span>;
                            <span class="tok-kw">return</span> next_index;
                        },
                        .reverse =&gt; {
                            <span class="tok-kw">const</span> leading_zeroes = <span class="tok-builtin">@clz</span>(self.bits_remain);
                            <span class="tok-kw">const</span> top_bit = (<span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>) - <span class="tok-number">1</span>) - leading_zeroes;
                            self.bits_remain &amp;= (<span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(top_bit))) - <span class="tok-number">1</span>;
                            <span class="tok-kw">return</span> top_bit;
                        },
                    }
                }
            };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">maskBit</span>(index: <span class="tok-type">usize</span>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a> {
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a> == <span class="tok-type">u0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(index));
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">boolMaskBit</span>(index: <span class="tok-type">usize</span>, value: <span class="tok-type">bool</span>) <a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a> {
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a> == <span class="tok-type">u0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.MaskInt">MaskInt</a>, <span class="tok-builtin">@intFromBool</span>(value)) &lt;&lt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(index));
        }
    };
}

<span class="tok-comment">/// A bit set with static size, which is backed by an array of usize.</span>
<span class="tok-comment">/// This set is good for sets with a larger size, but may use</span>
<span class="tok-comment">/// more bytes than necessary if your set is small.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ArrayBitSet</span>(<span class="tok-kw">comptime</span> MaskIntType: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> size: <span class="tok-type">usize</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> mask_info: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a> = <span class="tok-builtin">@typeInfo</span>(MaskIntType);<span class="tok-comment">

    // Make sure the mask int is indeed an int
    </span><span class="tok-kw">if</span> (mask_info != .int) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;ArrayBitSet can only operate on integer masks, but was passed &quot;</span> ++ <span class="tok-builtin">@typeName</span>(MaskIntType));<span class="tok-comment">

    // It must also be unsigned.
    </span><span class="tok-kw">if</span> (mask_info.int.signedness != .unsigned) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;ArrayBitSet requires an unsigned integer mask type, but was passed &quot;</span> ++ <span class="tok-builtin">@typeName</span>(MaskIntType));<span class="tok-comment">

    // And it must not be empty.
    </span><span class="tok-kw">if</span> (MaskIntType == <span class="tok-type">u0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;ArrayBitSet requires a sized integer for its mask int.  u0 does not work.&quot;</span>);

    <span class="tok-kw">const</span> byte_size = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.byte_size_in_bits">byte_size_in_bits</a>;<span class="tok-comment">

    // We use shift and truncate to decompose indices into mask indices and bit indices.
    // This operation requires that the mask has an exact power of two number of bits.
    </span><span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(<span class="tok-builtin">@bitSizeOf</span>(MaskIntType))) {
        <span class="tok-kw">var</span> desired_bits = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.ceilPowerOfTwoAssert">ceilPowerOfTwoAssert</a>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitSizeOf</span>(MaskIntType));
        <span class="tok-kw">if</span> (desired_bits &lt; byte_size) desired_bits = byte_size;
        <span class="tok-kw">const</span> FixedMaskType = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, desired_bits);
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;ArrayBitSet was passed integer type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(MaskIntType) ++
            <span class="tok-str">&quot;, which is not a power of two.  Please round this up to a power of two integer size (i.e. &quot;</span> ++ <span class="tok-builtin">@typeName</span>(FixedMaskType) ++ <span class="tok-str">&quot;).&quot;</span>);
    }<span class="tok-comment">

    // Make sure the integer has no padding bits.
    // Those would be wasteful here and are probably a mistake by the user.
    // This case may be hit with small powers of two, like u4.
    </span><span class="tok-kw">if</span> (<span class="tok-builtin">@bitSizeOf</span>(MaskIntType) != <span class="tok-builtin">@sizeOf</span>(MaskIntType) * byte_size) {
        <span class="tok-kw">var</span> desired_bits = <span class="tok-builtin">@sizeOf</span>(MaskIntType) * byte_size;
        desired_bits = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.ceilPowerOfTwoAssert">ceilPowerOfTwoAssert</a>(<span class="tok-type">usize</span>, desired_bits);
        <span class="tok-kw">const</span> FixedMaskType = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, desired_bits);
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;ArrayBitSet was passed integer type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(MaskIntType) ++
            <span class="tok-str">&quot;, which contains padding bits.  Please round this up to an unpadded integer size (i.e. &quot;</span> ++ <span class="tok-builtin">@typeName</span>(FixedMaskType) ++ <span class="tok-str">&quot;).&quot;</span>);
    }

    <span class="tok-kw">return</span> <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();<span class="tok-comment">

        // TODO: Make this a comptime field once those are fixed
        </span><span class="tok-comment">/// The number of items in this bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> bit_length: <span class="tok-type">usize</span> = size;

        <span class="tok-comment">/// The integer type used to represent a mask in this bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MaskInt = MaskIntType;

        <span class="tok-comment">/// The integer type used to shift a mask in this bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ShiftInt = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>);<span class="tok-comment">

        // bits in one mask
        </span><span class="tok-kw">const</span> mask_len = <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>);<span class="tok-comment">
        // total number of masks
        </span><span class="tok-kw">const</span> num_masks = (size + <a href="std.bit_set.html#std.bit_set.ArrayBitSet.mask_len">mask_len</a> - <span class="tok-number">1</span>) / <a href="std.bit_set.html#std.bit_set.ArrayBitSet.mask_len">mask_len</a>;<span class="tok-comment">
        // padding bits in the last mask (may be 0)
        </span><span class="tok-kw">const</span> last_pad_bits = <a href="std.bit_set.html#std.bit_set.ArrayBitSet.mask_len">mask_len</a> * <a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> - size;<span class="tok-comment">
        // Mask of valid bits in the last mask.
        // All functions will ensure that the invalid
        // bits in the last mask are zero.
        </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> last_item_mask = ~<span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-number">0</span>) &gt;&gt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.last_pad_bits">last_pad_bits</a>;

        <span class="tok-comment">/// The bit masks, ordered with lower indices first.</span>
        <span class="tok-comment">/// Padding bits at the end are undefined.</span>
        masks: [<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a>]<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>,

        <span class="tok-comment">/// Creates a bit set with no elements present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
            <span class="tok-kw">return</span> .{ .masks = [_]<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>{<span class="tok-number">0</span>} ** <a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> };
        }

        <span class="tok-comment">/// Creates a bit set with all elements present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>() <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> .{ .masks = .{} };
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> .{ .masks = [_]<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>{~<span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-number">0</span>)} ** (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> - <span class="tok-number">1</span>) ++ [_]<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>{<a href="std.bit_set.html#std.bit_set.ArrayBitSet.last_item_mask">last_item_mask</a>} };
            }
        }

        <span class="tok-comment">/// Returns the number of bits in this bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">usize</span> {
            _ = self;
            <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>;
        }

        <span class="tok-comment">/// Returns true if the bit at the specified index</span>
        <span class="tok-comment">/// is present in the set, false otherwise.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSet</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>);
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">false</span>;<span class="tok-comment"> // doesn't compile in this case
            </span><span class="tok-kw">return</span> (self.masks[<a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(index)] &amp; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskBit">maskBit</a>(index)) != <span class="tok-number">0</span>;
        }

        <span class="tok-comment">/// Returns the total number of set bits in this bit set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">var</span> total: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (self.masks) |mask| {
                total += <span class="tok-builtin">@popCount</span>(mask);
            }
            <span class="tok-kw">return</span> total;
        }

        <span class="tok-comment">/// Changes the value of the specified bit of the bit</span>
        <span class="tok-comment">/// set to match the passed boolean.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setValue</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, index: <span class="tok-type">usize</span>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>);
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;<span class="tok-comment"> // doesn't compile in this case
            </span><span class="tok-kw">const</span> bit = <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskBit">maskBit</a>(index);
            <span class="tok-kw">const</span> mask_index = <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(index);
            <span class="tok-kw">const</span> new_bit = bit &amp; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, value);
            self.masks[mask_index] = (self.masks[mask_index] &amp; ~bit) | new_bit;
        }

        <span class="tok-comment">/// Adds a specific bit to the bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>);
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;<span class="tok-comment"> // doesn't compile in this case
            </span>self.masks[<a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(index)] |= <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskBit">maskBit</a>(index);
        }

        <span class="tok-comment">/// Changes the value of all bits in the specified range to</span>
        <span class="tok-comment">/// match the passed boolean.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setRangeValue</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, range: <a href="std.bit_set.Range.html">Range</a>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(range.end &lt;= <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(range.start &lt;= range.end);
            <span class="tok-kw">if</span> (range.start == range.end) <span class="tok-kw">return</span>;
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;

            <span class="tok-kw">const</span> start_mask_index = <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(range.start);
            <span class="tok-kw">const</span> start_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(range.start));

            <span class="tok-kw">const</span> end_mask_index = <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(range.end);
            <span class="tok-kw">const</span> end_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(range.end));

            <span class="tok-kw">if</span> (start_mask_index == end_mask_index) {
                <span class="tok-kw">var</span> mask1 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; start_bit;
                <span class="tok-kw">var</span> mask2 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &gt;&gt; (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.mask_len">mask_len</a> - <span class="tok-number">1</span>) - (end_bit - <span class="tok-number">1</span>);
                self.masks[start_mask_index] &amp;= ~(mask1 &amp; mask2);

                mask1 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, value) &lt;&lt; start_bit;
                mask2 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, value) &gt;&gt; (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.mask_len">mask_len</a> - <span class="tok-number">1</span>) - (end_bit - <span class="tok-number">1</span>);
                self.masks[start_mask_index] |= mask1 &amp; mask2;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">var</span> bulk_mask_index: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">if</span> (start_bit &gt; <span class="tok-number">0</span>) {
                    self.masks[start_mask_index] =
                        (self.masks[start_mask_index] &amp; ~(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; start_bit)) |
                        (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, value) &lt;&lt; start_bit);
                    bulk_mask_index = start_mask_index + <span class="tok-number">1</span>;
                } <span class="tok-kw">else</span> {
                    bulk_mask_index = start_mask_index;
                }

                <span class="tok-kw">while</span> (bulk_mask_index &lt; end_mask_index) : (bulk_mask_index += <span class="tok-number">1</span>) {
                    self.masks[bulk_mask_index] = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, value);
                }

                <span class="tok-kw">if</span> (end_bit &gt; <span class="tok-number">0</span>) {
                    self.masks[end_mask_index] =
                        (self.masks[end_mask_index] &amp; (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; end_bit)) |
                        (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, value) &gt;&gt; ((<span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>) - <span class="tok-number">1</span>) - (end_bit - <span class="tok-number">1</span>)));
                }
            }
        }

        <span class="tok-comment">/// Removes a specific bit from the bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unset</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>);
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;<span class="tok-comment"> // doesn't compile in this case
            </span>self.masks[<a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(index)] &amp;= ~<a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskBit">maskBit</a>(index);
        }

        <span class="tok-comment">/// Flips a specific bit in the bit set</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggle</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.bit_length">bit_length</a>);
            <span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;<span class="tok-comment"> // doesn't compile in this case
            </span>self.masks[<a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskIndex">maskIndex</a>(index)] ^= <a href="std.bit_set.html#std.bit_set.ArrayBitSet.maskBit">maskBit</a>(index);
        }

        <span class="tok-comment">/// Flips all bits in this bit set which are present</span>
        <span class="tok-comment">/// in the toggles bit set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleSet</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, toggles: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">for</span> (&amp;self.masks, <span class="tok-number">0</span>..) |*mask, i| {
                mask.* ^= toggles.masks[i];
            }
        }

        <span class="tok-comment">/// Flips every bit in the bit set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleAll</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">for</span> (&amp;self.masks) |*mask| {
                mask.* = ~mask.*;
            }<span class="tok-comment">

            // Zero the padding bits
            </span><span class="tok-kw">if</span> (<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> &gt; <span class="tok-number">0</span>) {
                self.masks[<a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a> - <span class="tok-number">1</span>] &amp;= <a href="std.bit_set.html#std.bit_set.ArrayBitSet.last_item_mask">last_item_mask</a>;
            }
        }

        <span class="tok-comment">/// Performs a union of two bit sets, and stores the</span>
        <span class="tok-comment">/// result in the first one.  Bits in the result are</span>
        <span class="tok-comment">/// set if the corresponding bits were set in either input.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">for</span> (&amp;self.masks, <span class="tok-number">0</span>..) |*mask, i| {
                mask.* |= other.masks[i];
            }
        }

        <span class="tok-comment">/// Performs an intersection of two bit sets, and stores</span>
        <span class="tok-comment">/// the result in the first one.  Bits in the result are</span>
        <span class="tok-comment">/// set if the corresponding bits were set in both inputs.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIntersection</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">for</span> (&amp;self.masks, <span class="tok-number">0</span>..) |*mask, i| {
                mask.* &amp;= other.masks[i];
            }
        }

        <span class="tok-comment">/// Finds the index of the first set bit.</span>
        <span class="tok-comment">/// If no bits are set, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findFirstSet</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">var</span> offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">const</span> mask = <span class="tok-kw">for</span> (self.masks) |mask| {
                <span class="tok-kw">if</span> (mask != <span class="tok-number">0</span>) <span class="tok-kw">break</span> mask;
                offset += <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>);
            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> offset + <span class="tok-builtin">@ctz</span>(mask);
        }

        <span class="tok-comment">/// Finds the index of the first set bit, and unsets it.</span>
        <span class="tok-comment">/// If no bits are set, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleFirstSet</span>(self: *<a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">var</span> offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">const</span> mask = <span class="tok-kw">for</span> (&amp;self.masks) |*mask| {
                <span class="tok-kw">if</span> (mask.* != <span class="tok-number">0</span>) <span class="tok-kw">break</span> mask;
                offset += <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>);
            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> index = <span class="tok-builtin">@ctz</span>(mask.*);
            mask.* &amp;= (mask.* - <span class="tok-number">1</span>);
            <span class="tok-kw">return</span> offset + index;
        }

        <span class="tok-comment">/// Returns true iff every corresponding bit in both</span>
        <span class="tok-comment">/// bit sets are the same.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">return</span> <span class="tok-kw">while</span> (i &lt; <a href="std.bit_set.html#std.bit_set.ArrayBitSet.num_masks">num_masks</a>) : (i += <span class="tok-number">1</span>) {
                <span class="tok-kw">if</span> (self.masks[i] != other.masks[i]) {
                    <span class="tok-kw">break</span> <span class="tok-null">false</span>;
                }
            } <span class="tok-kw">else</span> <span class="tok-null">true</span>;
        }

        <span class="tok-comment">/// Returns true iff the first bit set is the subset</span>
        <span class="tok-comment">/// of the second one.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.intersectWith(other).eql(self);
        }

        <span class="tok-comment">/// Returns true iff the first bit set is the superset</span>
        <span class="tok-comment">/// of the second one.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> other.subsetOf(self);
        }

        <span class="tok-comment">/// Returns the complement bit sets. Bits in the result</span>
        <span class="tok-comment">/// are set if the corresponding bits were not set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">complement</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.toggleAll();
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns the union of two bit sets. Bits in the</span>
        <span class="tok-comment">/// result are set if the corresponding bits were set</span>
        <span class="tok-comment">/// in either input.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unionWith</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.setUnion(other);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns the intersection of two bit sets. Bits in</span>
        <span class="tok-comment">/// the result are set if the corresponding bits were</span>
        <span class="tok-comment">/// set in both inputs.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intersectWith</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.setIntersection(other);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns the xor of two bit sets. Bits in the</span>
        <span class="tok-comment">/// result are set if the corresponding bits were</span>
        <span class="tok-comment">/// not the same in both inputs.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">xorWith</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.toggleSet(other);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns the difference of two bit sets. Bits in</span>
        <span class="tok-comment">/// the result are set if set in the first but not</span>
        <span class="tok-comment">/// set in the second set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">differenceWith</span>(self: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, other: <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.setIntersection(other.complement());
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Iterates through the items in the set, according to the options.</span>
        <span class="tok-comment">/// The default options (.{}) will iterate indices of set bits in</span>
        <span class="tok-comment">/// ascending order.  Modifications to the underlying bit set may</span>
        <span class="tok-comment">/// or may not be observed by the iterator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.bit_set.html#std.bit_set.ArrayBitSet">Self</a>, <span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet.Iterator">Iterator</a>(options) {
            <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.ArrayBitSet.Iterator">Iterator</a>(options).init(&amp;self.masks, <a href="std.bit_set.html#std.bit_set.ArrayBitSet.last_item_mask">last_item_mask</a>);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Iterator</span>(<span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <span class="tok-type">type</span> {
            <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.BitSetIterator">BitSetIterator</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, options);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">maskBit</span>(index: <span class="tok-type">usize</span>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(index));
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">maskIndex</span>(index: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> index &gt;&gt; <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.ShiftInt">ShiftInt</a>);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">boolMaskBit</span>(index: <span class="tok-type">usize</span>, value: <span class="tok-type">bool</span>) <a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.MaskInt">MaskInt</a>, <span class="tok-builtin">@intFromBool</span>(value)) &lt;&lt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(index));
        }
    };
}

<span class="tok-comment">/// A bit set with runtime-known size, backed by an allocated slice</span>
<span class="tok-comment">/// of usize.  The allocator must be tracked externally by the user.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> DynamicBitSetUnmanaged = <span class="tok-kw">struct</span> {
    <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

    <span class="tok-comment">/// The integer type used to represent a mask in this bit set</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MaskInt = <span class="tok-type">usize</span>;

    <span class="tok-comment">/// The integer type used to shift a mask in this bit set</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ShiftInt = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>);

    <span class="tok-comment">/// The number of valid items in this bit set</span>
    bit_length: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,

    <span class="tok-comment">/// The bit masks, ordered with lower indices first.</span>
    <span class="tok-comment">/// Padding bits at the end must be zeroed.</span>
    masks: [*]<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a> = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.empty_masks_ptr">empty_masks_ptr</a>,<span class="tok-comment">
    // This pointer is one usize after the actual allocation.
    // That slot holds the size of the true allocation, which
    // is needed by Zig's allocator interface in case a shrink
    // fails.

    // Don't modify this value.  Ideally it would go in const data so
    // modifications would cause a bus error, but the only way
    // to discard a const qualifier is through intFromPtr, which
    // cannot currently round trip at comptime.
    </span><span class="tok-kw">var</span> empty_masks_data = [_]<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>{ <span class="tok-number">0</span>, <span class="tok-null">undefined</span> };
    <span class="tok-kw">const</span> empty_masks_ptr = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.empty_masks_data">empty_masks_data</a>[<span class="tok-number">1</span>..<span class="tok-number">2</span>];

    <span class="tok-comment">/// Creates a bit set with no elements present.</span>
    <span class="tok-comment">/// If bit_length is not zero, deinit must eventually be called.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, bit_length: <span class="tok-type">usize</span>) !<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a> {
        <span class="tok-kw">var</span> self = <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>{};
        <span class="tok-kw">try</span> self.resize(allocator, bit_length, <span class="tok-null">false</span>);
        <span class="tok-kw">return</span> self;
    }

    <span class="tok-comment">/// Creates a bit set with all elements present.</span>
    <span class="tok-comment">/// If bit_length is not zero, deinit must eventually be called.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, bit_length: <span class="tok-type">usize</span>) !<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a> {
        <span class="tok-kw">var</span> self = <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>{};
        <span class="tok-kw">try</span> self.resize(allocator, bit_length, <span class="tok-null">true</span>);
        <span class="tok-kw">return</span> self;
    }

    <span class="tok-comment">/// Resizes to a new bit_length.  If the new length is larger</span>
    <span class="tok-comment">/// than the old length, fills any added bits with `fill`.</span>
    <span class="tok-comment">/// If new_len is not zero, deinit must eventually be called.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>, fill: <span class="tok-type">bool</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> old_len = self.bit_length;

        <span class="tok-kw">const</span> old_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(old_len);
        <span class="tok-kw">const</span> new_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(new_len);

        <span class="tok-kw">const</span> old_allocation = (self.masks - <span class="tok-number">1</span>)[<span class="tok-number">0</span>..(self.masks - <span class="tok-number">1</span>)[<span class="tok-number">0</span>]];

        <span class="tok-kw">if</span> (new_masks == <span class="tok-number">0</span>) {
            <a href="std.debug.html#std.debug.assert">assert</a>(new_len == <span class="tok-number">0</span>);
            allocator.free(old_allocation);
            self.masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.empty_masks_ptr">empty_masks_ptr</a>;
            self.bit_length = <span class="tok-number">0</span>;
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">if</span> (old_allocation.len != new_masks + <span class="tok-number">1</span>) realloc: {<span class="tok-comment">
            // If realloc fails, it may mean one of two things.
            // If we are growing, it means we are out of memory.
            // If we are shrinking, it means the allocator doesn't
            // want to move the allocation.  This means we need to
            // hold on to the extra 8 bytes required to be able to free
            // this allocation properly.
            </span><span class="tok-kw">const</span> new_allocation = allocator.realloc(old_allocation, new_masks + <span class="tok-number">1</span>) <span class="tok-kw">catch</span> |err| {
                <span class="tok-kw">if</span> (new_masks + <span class="tok-number">1</span> &gt; old_allocation.len) <span class="tok-kw">return</span> err;
                <span class="tok-kw">break</span> :realloc;
            };

            new_allocation[<span class="tok-number">0</span>] = new_allocation.len;
            self.masks = new_allocation.ptr + <span class="tok-number">1</span>;
        }<span class="tok-comment">

        // If we increased in size, we need to set any new bits
        // to the fill value.
        </span><span class="tok-kw">if</span> (new_len &gt; old_len) {<span class="tok-comment">
            // set the padding bits in the old last item to 1
            </span><span class="tok-kw">if</span> (fill <span class="tok-kw">and</span> old_masks &gt; <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> old_padding_bits = old_masks * <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - old_len;
                <span class="tok-kw">const</span> old_mask = (~<span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-number">0</span>)) &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(old_padding_bits));
                self.masks[old_masks - <span class="tok-number">1</span>] |= ~old_mask;
            }<span class="tok-comment">

            // fill in any new masks
            </span><span class="tok-kw">if</span> (new_masks &gt; old_masks) {
                <span class="tok-kw">const</span> fill_value = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, fill);
                <span class="tok-builtin">@memset</span>(self.masks[old_masks..new_masks], fill_value);
            }
        }<span class="tok-comment">

        // Zero out the padding bits
        </span><span class="tok-kw">if</span> (new_len &gt; <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> padding_bits = new_masks * <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - new_len;
            <span class="tok-kw">const</span> last_item_mask = (~<span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-number">0</span>)) &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(padding_bits));
            self.masks[new_masks - <span class="tok-number">1</span>] &amp;= last_item_mask;
        }<span class="tok-comment">

        // And finally, save the new length.
        </span>self.bit_length = new_len;
    }

    <span class="tok-comment">/// Deinitializes the array and releases its memory.</span>
    <span class="tok-comment">/// The passed allocator must be the same one used for</span>
    <span class="tok-comment">/// init* or resize in the past.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
        self.resize(allocator, <span class="tok-number">0</span>, <span class="tok-null">false</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-comment">/// Creates a duplicate of this bit set, using the new allocator.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: *<span class="tok-kw">const</span> <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a> {
        <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-kw">var</span> copy = <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>{};
        <span class="tok-kw">try</span> copy.resize(new_allocator, self.bit_length, <span class="tok-null">false</span>);
        <span class="tok-builtin">@memcpy</span>(copy.masks[<span class="tok-number">0</span>..num_masks], self.masks[<span class="tok-number">0</span>..num_masks]);
        <span class="tok-kw">return</span> copy;
    }

    <span class="tok-comment">/// Returns the number of bits in this bit set</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> self.bit_length;
    }

    <span class="tok-comment">/// Returns true if the bit at the specified index</span>
    <span class="tok-comment">/// is present in the set, false otherwise.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSet</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; self.bit_length);
        <span class="tok-kw">return</span> (self.masks[<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(index)] &amp; <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskBit">maskBit</a>(index)) != <span class="tok-number">0</span>;
    }

    <span class="tok-comment">/// Returns the total number of set bits in this bit set.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">const</span> num_masks = (self.bit_length + (<span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - <span class="tok-number">1</span>)) / <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>);
        <span class="tok-kw">var</span> total: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> (self.masks[<span class="tok-number">0</span>..num_masks]) |mask| {<span class="tok-comment">
            // Note: This is where we depend on padding bits being zero
            </span>total += <span class="tok-builtin">@popCount</span>(mask);
        }
        <span class="tok-kw">return</span> total;
    }

    <span class="tok-comment">/// Changes the value of the specified bit of the bit</span>
    <span class="tok-comment">/// set to match the passed boolean.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setValue</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, index: <span class="tok-type">usize</span>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; self.bit_length);
        <span class="tok-kw">const</span> bit = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskBit">maskBit</a>(index);
        <span class="tok-kw">const</span> mask_index = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(index);
        <span class="tok-kw">const</span> new_bit = bit &amp; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, value);
        self.masks[mask_index] = (self.masks[mask_index] &amp; ~bit) | new_bit;
    }

    <span class="tok-comment">/// Adds a specific bit to the bit set</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; self.bit_length);
        self.masks[<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(index)] |= <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskBit">maskBit</a>(index);
    }

    <span class="tok-comment">/// Changes the value of all bits in the specified range to</span>
    <span class="tok-comment">/// match the passed boolean.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setRangeValue</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, range: <a href="std.bit_set.Range.html">Range</a>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(range.end &lt;= self.bit_length);
        <a href="std.debug.html#std.debug.assert">assert</a>(range.start &lt;= range.end);
        <span class="tok-kw">if</span> (range.start == range.end) <span class="tok-kw">return</span>;

        <span class="tok-kw">const</span> start_mask_index = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(range.start);
        <span class="tok-kw">const</span> start_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(range.start));

        <span class="tok-kw">const</span> end_mask_index = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(range.end);
        <span class="tok-kw">const</span> end_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(range.end));

        <span class="tok-kw">if</span> (start_mask_index == end_mask_index) {
            <span class="tok-kw">var</span> mask1 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; start_bit;
            <span class="tok-kw">var</span> mask2 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &gt;&gt; (<span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - <span class="tok-number">1</span>) - (end_bit - <span class="tok-number">1</span>);
            self.masks[start_mask_index] &amp;= ~(mask1 &amp; mask2);

            mask1 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, value) &lt;&lt; start_bit;
            mask2 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, value) &gt;&gt; (<span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - <span class="tok-number">1</span>) - (end_bit - <span class="tok-number">1</span>);
            self.masks[start_mask_index] |= mask1 &amp; mask2;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">var</span> bulk_mask_index: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">if</span> (start_bit &gt; <span class="tok-number">0</span>) {
                self.masks[start_mask_index] =
                    (self.masks[start_mask_index] &amp; ~(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; start_bit)) |
                    (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, value) &lt;&lt; start_bit);
                bulk_mask_index = start_mask_index + <span class="tok-number">1</span>;
            } <span class="tok-kw">else</span> {
                bulk_mask_index = start_mask_index;
            }

            <span class="tok-kw">while</span> (bulk_mask_index &lt; end_mask_index) : (bulk_mask_index += <span class="tok-number">1</span>) {
                self.masks[bulk_mask_index] = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, value);
            }

            <span class="tok-kw">if</span> (end_bit &gt; <span class="tok-number">0</span>) {
                self.masks[end_mask_index] =
                    (self.masks[end_mask_index] &amp; (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; end_bit)) |
                    (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, value) &gt;&gt; ((<span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - <span class="tok-number">1</span>) - (end_bit - <span class="tok-number">1</span>)));
            }
        }
    }

    <span class="tok-comment">/// Removes a specific bit from the bit set</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unset</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; self.bit_length);
        self.masks[<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(index)] &amp;= ~<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskBit">maskBit</a>(index);
    }

    <span class="tok-comment">/// Set all bits to 0.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unsetAll</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> masks_len = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-builtin">@memset</span>(self.masks[<span class="tok-number">0</span>..masks_len], <span class="tok-number">0</span>);
    }

    <span class="tok-comment">/// Set all bits to 1.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setAll</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> masks_len = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-builtin">@memset</span>(self.masks[<span class="tok-number">0</span>..masks_len], <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>));
    }

    <span class="tok-comment">/// Flips a specific bit in the bit set</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggle</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; self.bit_length);
        self.masks[<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(index)] ^= <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskBit">maskBit</a>(index);
    }

    <span class="tok-comment">/// Flips all bits in this bit set which are present</span>
    <span class="tok-comment">/// in the toggles bit set.  Both sets must have the</span>
    <span class="tok-comment">/// same bit_length.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleSet</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, toggles: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(toggles.bit_length == self.bit_length);
        <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-kw">for</span> (self.masks[<span class="tok-number">0</span>..num_masks], <span class="tok-number">0</span>..) |*mask, i| {
            mask.* ^= toggles.masks[i];
        }
    }

    <span class="tok-comment">/// Flips every bit in the bit set.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleAll</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> bit_length = self.bit_length;<span class="tok-comment">
        // avoid underflow if bit_length is zero
        </span><span class="tok-kw">if</span> (bit_length == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;

        <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-kw">for</span> (self.masks[<span class="tok-number">0</span>..num_masks]) |*mask| {
            mask.* = ~mask.*;
        }

        <span class="tok-kw">const</span> padding_bits = num_masks * <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - bit_length;
        <span class="tok-kw">const</span> last_item_mask = (~<span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-number">0</span>)) &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(padding_bits));
        self.masks[num_masks - <span class="tok-number">1</span>] &amp;= last_item_mask;
    }

    <span class="tok-comment">/// Performs a union of two bit sets, and stores the</span>
    <span class="tok-comment">/// result in the first one.  Bits in the result are</span>
    <span class="tok-comment">/// set if the corresponding bits were set in either input.</span>
    <span class="tok-comment">/// The two sets must both be the same bit_length.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(other.bit_length == self.bit_length);
        <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-kw">for</span> (self.masks[<span class="tok-number">0</span>..num_masks], <span class="tok-number">0</span>..) |*mask, i| {
            mask.* |= other.masks[i];
        }
    }

    <span class="tok-comment">/// Performs an intersection of two bit sets, and stores</span>
    <span class="tok-comment">/// the result in the first one.  Bits in the result are</span>
    <span class="tok-comment">/// set if the corresponding bits were set in both inputs.</span>
    <span class="tok-comment">/// The two sets must both be the same bit_length.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIntersection</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(other.bit_length == self.bit_length);
        <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-kw">for</span> (self.masks[<span class="tok-number">0</span>..num_masks], <span class="tok-number">0</span>..) |*mask, i| {
            mask.* &amp;= other.masks[i];
        }
    }

    <span class="tok-comment">/// Finds the index of the first set bit.</span>
    <span class="tok-comment">/// If no bits are set, returns null.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findFirstSet</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) ?<span class="tok-type">usize</span> {
        <span class="tok-kw">var</span> offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> mask = self.masks;
        <span class="tok-kw">while</span> (offset &lt; self.bit_length) {
            <span class="tok-kw">if</span> (mask[<span class="tok-number">0</span>] != <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            mask += <span class="tok-number">1</span>;
            offset += <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>);
        } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        <span class="tok-kw">return</span> offset + <span class="tok-builtin">@ctz</span>(mask[<span class="tok-number">0</span>]);
    }

    <span class="tok-comment">/// Finds the index of the first set bit, and unsets it.</span>
    <span class="tok-comment">/// If no bits are set, returns null.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleFirstSet</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) ?<span class="tok-type">usize</span> {
        <span class="tok-kw">var</span> offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> mask = self.masks;
        <span class="tok-kw">while</span> (offset &lt; self.bit_length) {
            <span class="tok-kw">if</span> (mask[<span class="tok-number">0</span>] != <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            mask += <span class="tok-number">1</span>;
            offset += <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>);
        } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        <span class="tok-kw">const</span> index = <span class="tok-builtin">@ctz</span>(mask[<span class="tok-number">0</span>]);
        mask[<span class="tok-number">0</span>] &amp;= (mask[<span class="tok-number">0</span>] - <span class="tok-number">1</span>);
        <span class="tok-kw">return</span> offset + index;
    }

    <span class="tok-comment">/// Returns true iff every corresponding bit in both</span>
    <span class="tok-comment">/// bit sets are the same.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">if</span> (self.bit_length != other.bit_length) {
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }
        <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">return</span> <span class="tok-kw">while</span> (i &lt; num_masks) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">if</span> (self.masks[i] != other.masks[i]) {
                <span class="tok-kw">break</span> <span class="tok-null">false</span>;
            }
        } <span class="tok-kw">else</span> <span class="tok-null">true</span>;
    }

    <span class="tok-comment">/// Returns true iff the first bit set is the subset</span>
    <span class="tok-comment">/// of the second one.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">if</span> (self.bit_length != other.bit_length) {
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }
        <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">return</span> <span class="tok-kw">while</span> (i &lt; num_masks) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">if</span> (self.masks[i] &amp; other.masks[i] != self.masks[i]) {
                <span class="tok-kw">break</span> <span class="tok-null">false</span>;
            }
        } <span class="tok-kw">else</span> <span class="tok-null">true</span>;
    }

    <span class="tok-comment">/// Returns true iff the first bit set is the superset</span>
    <span class="tok-comment">/// of the second one.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">if</span> (self.bit_length != other.bit_length) {
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }
        <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">return</span> <span class="tok-kw">while</span> (i &lt; num_masks) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">if</span> (self.masks[i] &amp; other.masks[i] != other.masks[i]) {
                <span class="tok-kw">break</span> <span class="tok-null">false</span>;
            }
        } <span class="tok-kw">else</span> <span class="tok-null">true</span>;
    }

    <span class="tok-comment">/// Iterates through the items in the set, according to the options.</span>
    <span class="tok-comment">/// The default options (.{}) will iterate indices of set bits in</span>
    <span class="tok-comment">/// ascending order.  Modifications to the underlying bit set may</span>
    <span class="tok-comment">/// or may not be observed by the iterator.  Resizing the underlying</span>
    <span class="tok-comment">/// bit set invalidates the iterator.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, <span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.Iterator">Iterator</a>(options) {
        <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-kw">const</span> padding_bits = num_masks * <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - self.bit_length;
        <span class="tok-kw">const</span> last_item_mask = (~<span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-number">0</span>)) &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(padding_bits));
        <span class="tok-kw">return</span> <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.Iterator">Iterator</a>(options).init(self.masks[<span class="tok-number">0</span>..num_masks], last_item_mask);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Iterator</span>(<span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <span class="tok-type">type</span> {
        <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.BitSetIterator">BitSetIterator</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, options);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">maskBit</span>(index: <span class="tok-type">usize</span>) <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(index));
    }
    <span class="tok-kw">fn</span> <span class="tok-fn">maskIndex</span>(index: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> index &gt;&gt; <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>);
    }
    <span class="tok-kw">fn</span> <span class="tok-fn">boolMaskBit</span>(index: <span class="tok-type">usize</span>, value: <span class="tok-type">bool</span>) <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-builtin">@intFromBool</span>(value)) &lt;&lt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(index));
    }
    <span class="tok-kw">fn</span> <span class="tok-fn">numMasks</span>(bit_length: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> (bit_length + (<span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - <span class="tok-number">1</span>)) / <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>);
    }
};

<span class="tok-comment">/// A bit set with runtime-known size, backed by an allocated slice</span>
<span class="tok-comment">/// of usize.  Thin wrapper around DynamicBitSetUnmanaged which keeps</span>
<span class="tok-comment">/// track of the allocator instance.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> DynamicBitSet = <span class="tok-kw">struct</span> {
    <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

    <span class="tok-comment">/// The integer type used to represent a mask in this bit set</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MaskInt = <span class="tok-type">usize</span>;

    <span class="tok-comment">/// The integer type used to shift a mask in this bit set</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ShiftInt = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(<a href="std.bit_set.DynamicBitSet.html#std.bit_set.DynamicBitSet.MaskInt">MaskInt</a>);

    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    unmanaged: <a href="std.bit_set.DynamicBitSetUnmanaged.html">DynamicBitSetUnmanaged</a> = .{},

    <span class="tok-comment">/// Creates a bit set with no elements present.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, bit_length: <span class="tok-type">usize</span>) !<a href="std.bit_set.DynamicBitSet.html">Self</a> {
        <span class="tok-kw">return</span> <a href="std.bit_set.DynamicBitSet.html">Self</a>{
            .unmanaged = <span class="tok-kw">try</span> <a href="std.bit_set.DynamicBitSetUnmanaged.html">DynamicBitSetUnmanaged</a>.<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.initEmpty">initEmpty</a>(allocator, bit_length),
            .allocator = allocator,
        };
    }

    <span class="tok-comment">/// Creates a bit set with all elements present.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, bit_length: <span class="tok-type">usize</span>) !<a href="std.bit_set.DynamicBitSet.html">Self</a> {
        <span class="tok-kw">return</span> <a href="std.bit_set.DynamicBitSet.html">Self</a>{
            .unmanaged = <span class="tok-kw">try</span> <a href="std.bit_set.DynamicBitSetUnmanaged.html">DynamicBitSetUnmanaged</a>.<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.initFull">initFull</a>(allocator, bit_length),
            .allocator = allocator,
        };
    }

    <span class="tok-comment">/// Resizes to a new length.  If the new length is larger</span>
    <span class="tok-comment">/// than the old length, fills any added bits with `fill`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<span class="tok-builtin">@This</span>(), new_len: <span class="tok-type">usize</span>, fill: <span class="tok-type">bool</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> self.unmanaged.resize(self.allocator, new_len, fill);
    }

    <span class="tok-comment">/// Deinitializes the array and releases its memory.</span>
    <span class="tok-comment">/// The passed allocator must be the same one used for</span>
    <span class="tok-comment">/// init* or resize in the past.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.bit_set.DynamicBitSet.html">Self</a>) <span class="tok-type">void</span> {
        self.unmanaged.deinit(self.allocator);
    }

    <span class="tok-comment">/// Creates a duplicate of this bit set, using the new allocator.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: *<span class="tok-kw">const</span> <a href="std.bit_set.DynamicBitSet.html">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.bit_set.DynamicBitSet.html">Self</a> {
        <span class="tok-kw">return</span> <a href="std.bit_set.DynamicBitSet.html">Self</a>{
            .unmanaged = <span class="tok-kw">try</span> self.unmanaged.clone(new_allocator),
            .allocator = new_allocator,
        };
    }

    <span class="tok-comment">/// Returns the number of bits in this bit set</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.bit_set.DynamicBitSet.html">Self</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> self.unmanaged.capacity();
    }

    <span class="tok-comment">/// Returns true if the bit at the specified index</span>
    <span class="tok-comment">/// is present in the set, false otherwise.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSet</span>(self: <a href="std.bit_set.DynamicBitSet.html">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self.unmanaged.isSet(index);
    }

    <span class="tok-comment">/// Returns the total number of set bits in this bit set.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.bit_set.DynamicBitSet.html">Self</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> self.unmanaged.count();
    }

    <span class="tok-comment">/// Changes the value of the specified bit of the bit</span>
    <span class="tok-comment">/// set to match the passed boolean.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setValue</span>(self: *<a href="std.bit_set.DynamicBitSet.html">Self</a>, index: <span class="tok-type">usize</span>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
        self.unmanaged.setValue(index, value);
    }

    <span class="tok-comment">/// Adds a specific bit to the bit set</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.bit_set.DynamicBitSet.html">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        self.unmanaged.set(index);
    }

    <span class="tok-comment">/// Changes the value of all bits in the specified range to</span>
    <span class="tok-comment">/// match the passed boolean.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setRangeValue</span>(self: *<a href="std.bit_set.DynamicBitSet.html">Self</a>, range: <a href="std.bit_set.Range.html">Range</a>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
        self.unmanaged.setRangeValue(range, value);
    }

    <span class="tok-comment">/// Removes a specific bit from the bit set</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unset</span>(self: *<a href="std.bit_set.DynamicBitSet.html">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        self.unmanaged.unset(index);
    }

    <span class="tok-comment">/// Flips a specific bit in the bit set</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggle</span>(self: *<a href="std.bit_set.DynamicBitSet.html">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        self.unmanaged.toggle(index);
    }

    <span class="tok-comment">/// Flips all bits in this bit set which are present</span>
    <span class="tok-comment">/// in the toggles bit set.  Both sets must have the</span>
    <span class="tok-comment">/// same bit_length.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleSet</span>(self: *<a href="std.bit_set.DynamicBitSet.html">Self</a>, toggles: <a href="std.bit_set.DynamicBitSet.html">Self</a>) <span class="tok-type">void</span> {
        self.unmanaged.toggleSet(toggles.unmanaged);
    }

    <span class="tok-comment">/// Flips every bit in the bit set.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleAll</span>(self: *<a href="std.bit_set.DynamicBitSet.html">Self</a>) <span class="tok-type">void</span> {
        self.unmanaged.toggleAll();
    }

    <span class="tok-comment">/// Performs a union of two bit sets, and stores the</span>
    <span class="tok-comment">/// result in the first one.  Bits in the result are</span>
    <span class="tok-comment">/// set if the corresponding bits were set in either input.</span>
    <span class="tok-comment">/// The two sets must both be the same bit_length.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(self: *<a href="std.bit_set.DynamicBitSet.html">Self</a>, other: <a href="std.bit_set.DynamicBitSet.html">Self</a>) <span class="tok-type">void</span> {
        self.unmanaged.setUnion(other.unmanaged);
    }

    <span class="tok-comment">/// Performs an intersection of two bit sets, and stores</span>
    <span class="tok-comment">/// the result in the first one.  Bits in the result are</span>
    <span class="tok-comment">/// set if the corresponding bits were set in both inputs.</span>
    <span class="tok-comment">/// The two sets must both be the same bit_length.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIntersection</span>(self: *<a href="std.bit_set.DynamicBitSet.html">Self</a>, other: <a href="std.bit_set.DynamicBitSet.html">Self</a>) <span class="tok-type">void</span> {
        self.unmanaged.setIntersection(other.unmanaged);
    }

    <span class="tok-comment">/// Finds the index of the first set bit.</span>
    <span class="tok-comment">/// If no bits are set, returns null.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findFirstSet</span>(self: <a href="std.bit_set.DynamicBitSet.html">Self</a>) ?<span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> self.unmanaged.findFirstSet();
    }

    <span class="tok-comment">/// Finds the index of the first set bit, and unsets it.</span>
    <span class="tok-comment">/// If no bits are set, returns null.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleFirstSet</span>(self: *<a href="std.bit_set.DynamicBitSet.html">Self</a>) ?<span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> self.unmanaged.toggleFirstSet();
    }

    <span class="tok-comment">/// Returns true iff every corresponding bit in both</span>
    <span class="tok-comment">/// bit sets are the same.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.bit_set.DynamicBitSet.html">Self</a>, other: <a href="std.bit_set.DynamicBitSet.html">Self</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self.unmanaged.eql(other.unmanaged);
    }

    <span class="tok-comment">/// Iterates through the items in the set, according to the options.</span>
    <span class="tok-comment">/// The default options (.{}) will iterate indices of set bits in</span>
    <span class="tok-comment">/// ascending order.  Modifications to the underlying bit set may</span>
    <span class="tok-comment">/// or may not be observed by the iterator.  Resizing the underlying</span>
    <span class="tok-comment">/// bit set invalidates the iterator.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.bit_set.DynamicBitSet.html">Self</a>, <span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.Iterator">Iterator</a>(options) {
        <span class="tok-kw">return</span> self.unmanaged.iterator(options);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.bit_set.DynamicBitSetUnmanaged.html">DynamicBitSetUnmanaged</a>.<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.Iterator">Iterator</a>;
};

<span class="tok-comment">/// Options for configuring an iterator over a bit set</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> IteratorOptions = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// determines which bits should be visited</span>
    kind: <a href="std.bit_set.IteratorOptions.Type.html">Type</a> = .set,
    <span class="tok-comment">/// determines the order in which bit indices should be visited</span>
    direction: <a href="std.bit_set.IteratorOptions.Direction.html">Direction</a> = .forward,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Type = <span class="tok-kw">enum</span> {
        <span class="tok-comment">/// visit indexes of set bits</span>
        set,
        <span class="tok-comment">/// visit indexes of unset bits</span>
        unset,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Direction = <span class="tok-kw">enum</span> {
        <span class="tok-comment">/// visit indices in ascending order</span>
        forward,
        <span class="tok-comment">/// visit indices in descending order.</span>
        <span class="tok-comment">/// Note that this may be slightly more expensive than forward iteration.</span>
        reverse,
    };
};<span class="tok-comment">

// The iterator is reusable between several bit set types
</span><span class="tok-kw">fn</span> <span class="tok-fn">BitSetIterator</span>(<span class="tok-kw">comptime</span> MaskInt: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> ShiftInt = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(MaskInt);
    <span class="tok-kw">const</span> kind = options.kind;
    <span class="tok-kw">const</span> direction = options.direction;
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();<span class="tok-comment">

        // all bits which have not yet been iterated over
        </span>bits_remain: MaskInt,<span class="tok-comment">
        // all words which have not yet been iterated over
        </span>words_remain: []<span class="tok-kw">const</span> MaskInt,<span class="tok-comment">
        // the offset of the current word
        </span>bit_offset: <span class="tok-type">usize</span>,<span class="tok-comment">
        // the mask of the last word
        </span>last_word_mask: MaskInt,

        <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(masks: []<span class="tok-kw">const</span> MaskInt, last_word_mask: MaskInt) <a href="std.bit_set.html#std.bit_set.BitSetIterator">Self</a> {
            <span class="tok-kw">if</span> (masks.len == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.BitSetIterator">Self</a>{
                    .bits_remain = <span class="tok-number">0</span>,
                    .words_remain = &amp;[_]MaskInt{},
                    .last_word_mask = last_word_mask,
                    .bit_offset = <span class="tok-number">0</span>,
                };
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">var</span> result = <a href="std.bit_set.html#std.bit_set.BitSetIterator">Self</a>{
                    .bits_remain = <span class="tok-number">0</span>,
                    .words_remain = masks,
                    .last_word_mask = last_word_mask,
                    .bit_offset = <span class="tok-kw">if</span> (direction == .forward) <span class="tok-number">0</span> <span class="tok-kw">else</span> (masks.len - <span class="tok-number">1</span>) * <span class="tok-builtin">@bitSizeOf</span>(MaskInt),
                };
                result.nextWord(<span class="tok-null">true</span>);
                <span class="tok-kw">return</span> result;
            }
        }

        <span class="tok-comment">/// Returns the index of the next unvisited set bit</span>
        <span class="tok-comment">/// in the bit set, in ascending order.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.bit_set.html#std.bit_set.BitSetIterator">Self</a>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">while</span> (self.bits_remain == <span class="tok-number">0</span>) {
                <span class="tok-kw">if</span> (self.words_remain.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                self.nextWord(<span class="tok-null">false</span>);
                <span class="tok-kw">switch</span> (direction) {
                    .forward =&gt; self.bit_offset += <span class="tok-builtin">@bitSizeOf</span>(MaskInt),
                    .reverse =&gt; self.bit_offset -= <span class="tok-builtin">@bitSizeOf</span>(MaskInt),
                }
            }

            <span class="tok-kw">switch</span> (direction) {
                .forward =&gt; {
                    <span class="tok-kw">const</span> next_index = <span class="tok-builtin">@ctz</span>(self.bits_remain) + self.bit_offset;
                    self.bits_remain &amp;= self.bits_remain - <span class="tok-number">1</span>;
                    <span class="tok-kw">return</span> next_index;
                },
                .reverse =&gt; {
                    <span class="tok-kw">const</span> leading_zeroes = <span class="tok-builtin">@clz</span>(self.bits_remain);
                    <span class="tok-kw">const</span> top_bit = (<span class="tok-builtin">@bitSizeOf</span>(MaskInt) - <span class="tok-number">1</span>) - leading_zeroes;
                    <span class="tok-kw">const</span> no_top_bit_mask = (<span class="tok-builtin">@as</span>(MaskInt, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(ShiftInt, <span class="tok-builtin">@intCast</span>(top_bit))) - <span class="tok-number">1</span>;
                    self.bits_remain &amp;= no_top_bit_mask;
                    <span class="tok-kw">return</span> top_bit + self.bit_offset;
                },
            }
        }<span class="tok-comment">

        // Load the next word.  Don't call this if there
        // isn't a next word.  If the next word is the
        // last word, mask off the padding bits so we
        // don't visit them.
        </span><span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextWord</span>(self: *<a href="std.bit_set.html#std.bit_set.BitSetIterator">Self</a>, <span class="tok-kw">comptime</span> is_first_word: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">var</span> word = <span class="tok-kw">switch</span> (direction) {
                .forward =&gt; self.words_remain[<span class="tok-number">0</span>],
                .reverse =&gt; self.words_remain[self.words_remain.len - <span class="tok-number">1</span>],
            };
            <span class="tok-kw">switch</span> (kind) {
                .set =&gt; {},
                .unset =&gt; {
                    word = ~word;
                    <span class="tok-kw">if</span> ((direction == .reverse <span class="tok-kw">and</span> is_first_word) <span class="tok-kw">or</span>
                        (direction == .forward <span class="tok-kw">and</span> self.words_remain.len == <span class="tok-number">1</span>))
                    {
                        word &amp;= self.last_word_mask;
                    }
                },
            }
            <span class="tok-kw">switch</span> (direction) {
                .forward =&gt; self.words_remain = self.words_remain[<span class="tok-number">1</span>..],
                .reverse =&gt; self.words_remain.len -= <span class="tok-number">1</span>,
            }
            self.bits_remain = word;
        }
    };
}

<span class="tok-comment">/// A range of indices within a bitset.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Range = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// The index of the first bit of interest.</span>
    start: <span class="tok-type">usize</span>,
    <span class="tok-comment">/// The index immediately after the last bit of interest.</span>
    end: <span class="tok-type">usize</span>,
};<span class="tok-comment">

// ---------------- Tests -----------------

</span><span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;

<span class="tok-kw">fn</span> <span class="tok-fn">testEql</span>(empty: <span class="tok-kw">anytype</span>, full: <span class="tok-kw">anytype</span>, len: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.eql(full));
    <span class="tok-kw">switch</span> (len) {
        <span class="tok-number">0</span> =&gt; {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.eql(full));
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.eql(empty));
        },
        <span class="tok-kw">else</span> =&gt; {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!empty.eql(full));
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!full.eql(empty));
        },
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">testSubsetOf</span>(empty: <span class="tok-kw">anytype</span>, full: <span class="tok-kw">anytype</span>, even: <span class="tok-kw">anytype</span>, odd: <span class="tok-kw">anytype</span>, len: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.subsetOf(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.subsetOf(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.subsetOf(full));
    <span class="tok-kw">switch</span> (len) {
        <span class="tok-number">0</span> =&gt; {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(even.subsetOf(odd));
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(odd.subsetOf(even));
        },
        <span class="tok-number">1</span> =&gt; {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!even.subsetOf(odd));
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(odd.subsetOf(even));
        },
        <span class="tok-kw">else</span> =&gt; {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!even.subsetOf(odd));
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!odd.subsetOf(even));
        },
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">testSupersetOf</span>(empty: <span class="tok-kw">anytype</span>, full: <span class="tok-kw">anytype</span>, even: <span class="tok-kw">anytype</span>, odd: <span class="tok-kw">anytype</span>, len: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.supersetOf(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.supersetOf(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.supersetOf(empty));
    <span class="tok-kw">switch</span> (len) {
        <span class="tok-number">0</span> =&gt; {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(even.supersetOf(odd));
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(odd.supersetOf(even));
        },
        <span class="tok-number">1</span> =&gt; {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(even.supersetOf(odd));
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!odd.supersetOf(even));
        },
        <span class="tok-kw">else</span> =&gt; {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!even.supersetOf(odd));
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!odd.supersetOf(even));
        },
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">testBitSet</span>(a: <span class="tok-kw">anytype</span>, b: <span class="tok-kw">anytype</span>, len: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(len, a.capacity());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(len, b.capacity());

    {
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; len) : (i += <span class="tok-number">1</span>) {
            a.setValue(i, i &amp; <span class="tok-number">1</span> == <span class="tok-number">0</span>);
            b.setValue(i, i &amp; <span class="tok-number">2</span> == <span class="tok-number">0</span>);
        }
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>((len + <span class="tok-number">1</span>) / <span class="tok-number">2</span>, a.count());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>((len + <span class="tok-number">3</span>) / <span class="tok-number">4</span> + (len + <span class="tok-number">2</span>) / <span class="tok-number">4</span>, b.count());

    {
        <span class="tok-kw">var</span> iter = a.iterator(.{});
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; len) : (i += <span class="tok-number">2</span>) {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, i), iter.next());
        }
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), iter.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), iter.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), iter.next());
    }
    a.toggleAll();
    {
        <span class="tok-kw">var</span> iter = a.iterator(.{});
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
        <span class="tok-kw">while</span> (i &lt; len) : (i += <span class="tok-number">2</span>) {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, i), iter.next());
        }
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), iter.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), iter.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), iter.next());
    }

    {
        <span class="tok-kw">var</span> iter = b.iterator(.{ .kind = .unset });
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">2</span>;
        <span class="tok-kw">while</span> (i &lt; len) : (i += <span class="tok-number">4</span>) {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, i), iter.next());
            <span class="tok-kw">if</span> (i + <span class="tok-number">1</span> &lt; len) {
                <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, i + <span class="tok-number">1</span>), iter.next());
            }
        }
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), iter.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), iter.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), iter.next());
    }

    {
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; len) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(i &amp; <span class="tok-number">1</span> != <span class="tok-number">0</span>, a.isSet(i));
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(i &amp; <span class="tok-number">2</span> == <span class="tok-number">0</span>, b.isSet(i));
        }
    }

    a.setUnion(b.*);
    {
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; len) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(i &amp; <span class="tok-number">1</span> != <span class="tok-number">0</span> <span class="tok-kw">or</span> i &amp; <span class="tok-number">2</span> == <span class="tok-number">0</span>, a.isSet(i));
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(i &amp; <span class="tok-number">2</span> == <span class="tok-number">0</span>, b.isSet(i));
        }

        i = len;
        <span class="tok-kw">var</span> set = a.iterator(.{ .direction = .reverse });
        <span class="tok-kw">var</span> unset = a.iterator(.{ .kind = .unset, .direction = .reverse });
        <span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) {
            i -= <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (i &amp; <span class="tok-number">1</span> != <span class="tok-number">0</span> <span class="tok-kw">or</span> i &amp; <span class="tok-number">2</span> == <span class="tok-number">0</span>) {
                <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, i), set.next());
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, i), unset.next());
            }
        }
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), set.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), set.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), set.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), unset.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), unset.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), unset.next());
    }

    a.toggleSet(b.*);
    {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(len / <span class="tok-number">4</span>, a.count());

        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; len) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(i &amp; <span class="tok-number">1</span> != <span class="tok-number">0</span> <span class="tok-kw">and</span> i &amp; <span class="tok-number">2</span> != <span class="tok-number">0</span>, a.isSet(i));
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(i &amp; <span class="tok-number">2</span> == <span class="tok-number">0</span>, b.isSet(i));
            <span class="tok-kw">if</span> (i &amp; <span class="tok-number">1</span> == <span class="tok-number">0</span>) {
                a.set(i);
            } <span class="tok-kw">else</span> {
                a.unset(i);
            }
        }
    }

    a.setIntersection(b.*);
    {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>((len + <span class="tok-number">3</span>) / <span class="tok-number">4</span>, a.count());

        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; len) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(i &amp; <span class="tok-number">1</span> == <span class="tok-number">0</span> <span class="tok-kw">and</span> i &amp; <span class="tok-number">2</span> == <span class="tok-number">0</span>, a.isSet(i));
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(i &amp; <span class="tok-number">2</span> == <span class="tok-number">0</span>, b.isSet(i));
        }
    }

    a.toggleSet(a.*);
    {
        <span class="tok-kw">var</span> iter = a.iterator(.{});
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), iter.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), iter.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), iter.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), a.count());
    }
    {
        <span class="tok-kw">var</span> iter = a.iterator(.{ .direction = .reverse });
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), iter.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), iter.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), iter.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), a.count());
    }

    <span class="tok-kw">const</span> test_bits = [_]<span class="tok-type">usize</span>{
        <span class="tok-number">0</span>,  <span class="tok-number">1</span>,  <span class="tok-number">2</span>,   <span class="tok-number">3</span>,   <span class="tok-number">4</span>,   <span class="tok-number">5</span>,    <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">9</span>, <span class="tok-number">10</span>, <span class="tok-number">11</span>, <span class="tok-number">22</span>, <span class="tok-number">31</span>, <span class="tok-number">32</span>, <span class="tok-number">63</span>, <span class="tok-number">64</span>,
        <span class="tok-number">66</span>, <span class="tok-number">95</span>, <span class="tok-number">127</span>, <span class="tok-number">160</span>, <span class="tok-number">192</span>, <span class="tok-number">1000</span>,
    };
    <span class="tok-kw">for</span> (test_bits) |i| {
        <span class="tok-kw">if</span> (i &lt; a.capacity()) {
            a.set(i);
        }
    }

    <span class="tok-kw">for</span> (test_bits) |i| {
        <span class="tok-kw">if</span> (i &lt; a.capacity()) {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, i), a.findFirstSet());
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, i), a.toggleFirstSet());
        }
    }
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), a.findFirstSet());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), a.toggleFirstSet());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), a.findFirstSet());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), a.toggleFirstSet());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), a.count());

    a.setRangeValue(.{ .start = <span class="tok-number">0</span>, .end = len }, <span class="tok-null">false</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), a.count());

    a.setRangeValue(.{ .start = <span class="tok-number">0</span>, .end = len }, <span class="tok-null">true</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(len, a.count());

    a.setRangeValue(.{ .start = <span class="tok-number">0</span>, .end = len }, <span class="tok-null">false</span>);
    a.setRangeValue(.{ .start = <span class="tok-number">0</span>, .end = <span class="tok-number">0</span> }, <span class="tok-null">true</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), a.count());

    a.setRangeValue(.{ .start = len, .end = len }, <span class="tok-null">true</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), a.count());

    <span class="tok-kw">if</span> (len &gt;= <span class="tok-number">1</span>) {
        a.setRangeValue(.{ .start = <span class="tok-number">0</span>, .end = len }, <span class="tok-null">false</span>);
        a.setRangeValue(.{ .start = <span class="tok-number">0</span>, .end = <span class="tok-number">1</span> }, <span class="tok-null">true</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>), a.count());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(a.isSet(<span class="tok-number">0</span>));

        a.setRangeValue(.{ .start = <span class="tok-number">0</span>, .end = len }, <span class="tok-null">false</span>);
        a.setRangeValue(.{ .start = <span class="tok-number">0</span>, .end = len - <span class="tok-number">1</span> }, <span class="tok-null">true</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(len - <span class="tok-number">1</span>, a.count());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!a.isSet(len - <span class="tok-number">1</span>));

        a.setRangeValue(.{ .start = <span class="tok-number">0</span>, .end = len }, <span class="tok-null">false</span>);
        a.setRangeValue(.{ .start = <span class="tok-number">1</span>, .end = len }, <span class="tok-null">true</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, len - <span class="tok-number">1</span>), a.count());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!a.isSet(<span class="tok-number">0</span>));

        a.setRangeValue(.{ .start = <span class="tok-number">0</span>, .end = len }, <span class="tok-null">false</span>);
        a.setRangeValue(.{ .start = len - <span class="tok-number">1</span>, .end = len }, <span class="tok-null">true</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>), a.count());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(a.isSet(len - <span class="tok-number">1</span>));

        <span class="tok-kw">if</span> (len &gt;= <span class="tok-number">4</span>) {
            a.setRangeValue(.{ .start = <span class="tok-number">0</span>, .end = len }, <span class="tok-null">false</span>);
            a.setRangeValue(.{ .start = <span class="tok-number">1</span>, .end = len - <span class="tok-number">2</span> }, <span class="tok-null">true</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, len - <span class="tok-number">3</span>), a.count());
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!a.isSet(<span class="tok-number">0</span>));
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(a.isSet(<span class="tok-number">1</span>));
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(a.isSet(len - <span class="tok-number">3</span>));
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!a.isSet(len - <span class="tok-number">2</span>));
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!a.isSet(len - <span class="tok-number">1</span>));
        }
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">fillEven</span>(set: <span class="tok-kw">anytype</span>, len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; len) : (i += <span class="tok-number">1</span>) {
        set.setValue(i, i &amp; <span class="tok-number">1</span> == <span class="tok-number">0</span>);
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">fillOdd</span>(set: <span class="tok-kw">anytype</span>, len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; len) : (i += <span class="tok-number">1</span>) {
        set.setValue(i, i &amp; <span class="tok-number">1</span> == <span class="tok-number">1</span>);
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">testPureBitSet</span>(<span class="tok-kw">comptime</span> Set: <span class="tok-type">type</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> empty = Set.initEmpty();
    <span class="tok-kw">const</span> full = Set.initFull();

    <span class="tok-kw">const</span> even = even: {
        <span class="tok-kw">var</span> bit_set = Set.initEmpty();
        <a href="std.bit_set.html#std.bit_set.fillEven">fillEven</a>(&amp;bit_set, Set.bit_length);
        <span class="tok-kw">break</span> :even bit_set;
    };

    <span class="tok-kw">const</span> odd = odd: {
        <span class="tok-kw">var</span> bit_set = Set.initEmpty();
        <a href="std.bit_set.html#std.bit_set.fillOdd">fillOdd</a>(&amp;bit_set, Set.bit_length);
        <span class="tok-kw">break</span> :odd bit_set;
    };

    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testSubsetOf">testSubsetOf</a>(empty, full, even, odd, Set.bit_length);
    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testSupersetOf">testSupersetOf</a>(empty, full, even, odd, Set.bit_length);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.complement().eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.complement().eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(even.complement().eql(odd));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(odd.complement().eql(even));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.unionWith(empty).eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.unionWith(full).eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.unionWith(full).eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.unionWith(empty).eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(even.unionWith(odd).eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(odd.unionWith(even).eql(full));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.intersectWith(empty).eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.intersectWith(full).eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.intersectWith(full).eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.intersectWith(empty).eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(even.intersectWith(odd).eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(odd.intersectWith(even).eql(empty));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.xorWith(empty).eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.xorWith(full).eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.xorWith(full).eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.xorWith(empty).eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(even.xorWith(odd).eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(odd.xorWith(even).eql(full));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.differenceWith(empty).eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.differenceWith(full).eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.differenceWith(full).eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.differenceWith(empty).eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.differenceWith(odd).eql(even));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.differenceWith(even).eql(odd));
}

<span class="tok-kw">fn</span> <span class="tok-fn">testStaticBitSet</span>(<span class="tok-kw">comptime</span> Set: <span class="tok-type">type</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a = Set.initEmpty();
    <span class="tok-kw">var</span> b = Set.initFull();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), a.count());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, Set.bit_length), b.count());

    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testEql">testEql</a>(a, b, Set.bit_length);
    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testBitSet">testBitSet</a>(&amp;a, &amp;b, Set.bit_length);

    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testPureBitSet">testPureBitSet</a>(Set);
}

<span class="tok-kw">test</span> IntegerBitSet {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_c) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">0</span>));
    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">1</span>));
    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">2</span>));
    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">5</span>));
    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">8</span>));
    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">32</span>));
    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">64</span>));
    <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">127</span>));
}

<span class="tok-kw">test</span> ArrayBitSet {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (.{ <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">31</span>, <span class="tok-number">32</span>, <span class="tok-number">33</span>, <span class="tok-number">63</span>, <span class="tok-number">64</span>, <span class="tok-number">65</span>, <span class="tok-number">254</span>, <span class="tok-number">500</span>, <span class="tok-number">3000</span> }) |size| {
        <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a>(<span class="tok-type">u8</span>, size));
        <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a>(<span class="tok-type">u16</span>, size));
        <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a>(<span class="tok-type">u32</span>, size));
        <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a>(<span class="tok-type">u64</span>, size));
        <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testStaticBitSet">testStaticBitSet</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a>(<span class="tok-type">u128</span>, size));
    }
}

<span class="tok-kw">test</span> DynamicBitSetUnmanaged {
    <span class="tok-kw">const</span> allocator = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;
    <span class="tok-kw">var</span> a = <span class="tok-kw">try</span> <a href="std.bit_set.DynamicBitSetUnmanaged.html">DynamicBitSetUnmanaged</a>.<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.initEmpty">initEmpty</a>(allocator, <span class="tok-number">300</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), a.count());
    a.deinit(allocator);

    a = <span class="tok-kw">try</span> <a href="std.bit_set.DynamicBitSetUnmanaged.html">DynamicBitSetUnmanaged</a>.<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.initEmpty">initEmpty</a>(allocator, <span class="tok-number">0</span>);
    <span class="tok-kw">defer</span> a.deinit(allocator);
    <span class="tok-kw">for</span> ([_]<span class="tok-type">usize</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">31</span>, <span class="tok-number">32</span>, <span class="tok-number">33</span>, <span class="tok-number">0</span>, <span class="tok-number">65</span>, <span class="tok-number">64</span>, <span class="tok-number">63</span>, <span class="tok-number">500</span>, <span class="tok-number">254</span>, <span class="tok-number">3000</span> }) |size| {
        <span class="tok-kw">const</span> old_len = a.capacity();

        <span class="tok-kw">var</span> empty = <span class="tok-kw">try</span> a.clone(allocator);
        <span class="tok-kw">defer</span> empty.deinit(allocator);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(old_len, empty.capacity());
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; old_len) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.isSet(i), empty.isSet(i));
        }

        a.toggleSet(a);<span class="tok-comment"> // zero a
        </span>empty.toggleSet(empty);

        <span class="tok-kw">try</span> a.resize(allocator, size, <span class="tok-null">true</span>);
        <span class="tok-kw">try</span> empty.resize(allocator, size, <span class="tok-null">false</span>);

        <span class="tok-kw">if</span> (size &gt; old_len) {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(size - old_len, a.count());
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), a.count());
        }
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), empty.count());

        <span class="tok-kw">var</span> full = <span class="tok-kw">try</span> <a href="std.bit_set.DynamicBitSetUnmanaged.html">DynamicBitSetUnmanaged</a>.<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.initFull">initFull</a>(allocator, size);
        <span class="tok-kw">defer</span> full.deinit(allocator);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, size), full.count());

        <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testEql">testEql</a>(empty, full, size);
        {
            <span class="tok-kw">var</span> even = <span class="tok-kw">try</span> <a href="std.bit_set.DynamicBitSetUnmanaged.html">DynamicBitSetUnmanaged</a>.<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.initEmpty">initEmpty</a>(allocator, size);
            <span class="tok-kw">defer</span> even.deinit(allocator);
            <a href="std.bit_set.html#std.bit_set.fillEven">fillEven</a>(&amp;even, size);

            <span class="tok-kw">var</span> odd = <span class="tok-kw">try</span> <a href="std.bit_set.DynamicBitSetUnmanaged.html">DynamicBitSetUnmanaged</a>.<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.initEmpty">initEmpty</a>(allocator, size);
            <span class="tok-kw">defer</span> odd.deinit(allocator);
            <a href="std.bit_set.html#std.bit_set.fillOdd">fillOdd</a>(&amp;odd, size);

            <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testSubsetOf">testSubsetOf</a>(empty, full, even, odd, size);
            <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testSupersetOf">testSupersetOf</a>(empty, full, even, odd, size);
        }
        <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testBitSet">testBitSet</a>(&amp;a, &amp;full, size);
    }
}

<span class="tok-kw">test</span> DynamicBitSet {
    <span class="tok-kw">const</span> allocator = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;
    <span class="tok-kw">var</span> a = <span class="tok-kw">try</span> <a href="std.bit_set.DynamicBitSet.html">DynamicBitSet</a>.<a href="std.bit_set.DynamicBitSet.html#std.bit_set.DynamicBitSet.initEmpty">initEmpty</a>(allocator, <span class="tok-number">300</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), a.count());
    a.deinit();

    a = <span class="tok-kw">try</span> <a href="std.bit_set.DynamicBitSet.html">DynamicBitSet</a>.<a href="std.bit_set.DynamicBitSet.html#std.bit_set.DynamicBitSet.initEmpty">initEmpty</a>(allocator, <span class="tok-number">0</span>);
    <span class="tok-kw">defer</span> a.deinit();
    <span class="tok-kw">for</span> ([_]<span class="tok-type">usize</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">31</span>, <span class="tok-number">32</span>, <span class="tok-number">33</span>, <span class="tok-number">0</span>, <span class="tok-number">65</span>, <span class="tok-number">64</span>, <span class="tok-number">63</span>, <span class="tok-number">500</span>, <span class="tok-number">254</span>, <span class="tok-number">3000</span> }) |size| {
        <span class="tok-kw">const</span> old_len = a.capacity();

        <span class="tok-kw">var</span> tmp = <span class="tok-kw">try</span> a.clone(allocator);
        <span class="tok-kw">defer</span> tmp.deinit();
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(old_len, tmp.capacity());
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; old_len) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.isSet(i), tmp.isSet(i));
        }

        a.toggleSet(a);<span class="tok-comment"> // zero a
        </span>tmp.toggleSet(tmp);<span class="tok-comment"> // zero tmp

        </span><span class="tok-kw">try</span> a.resize(size, <span class="tok-null">true</span>);
        <span class="tok-kw">try</span> tmp.resize(size, <span class="tok-null">false</span>);

        <span class="tok-kw">if</span> (size &gt; old_len) {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(size - old_len, a.count());
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), a.count());
        }
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), tmp.count());

        <span class="tok-kw">var</span> b = <span class="tok-kw">try</span> <a href="std.bit_set.DynamicBitSet.html">DynamicBitSet</a>.<a href="std.bit_set.DynamicBitSet.html#std.bit_set.DynamicBitSet.initFull">initFull</a>(allocator, size);
        <span class="tok-kw">defer</span> b.deinit();
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, size), b.count());

        <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testEql">testEql</a>(tmp, b, size);
        <span class="tok-kw">try</span> <a href="std.bit_set.html#std.bit_set.testBitSet">testBitSet</a>(&amp;a, &amp;b, size);
    }
}

<span class="tok-kw">test</span> StaticBitSet {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">0</span>), <a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<span class="tok-number">0</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">5</span>), <a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<span class="tok-number">5</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>)), <a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>) + <span class="tok-number">1</span>), <a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>) + <span class="tok-number">1</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a>(<span class="tok-type">usize</span>, <span class="tok-number">500</span>), <a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<span class="tok-number">500</span>));
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
