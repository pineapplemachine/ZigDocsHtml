<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">json</a></li><li><a href="std.json.scanner.html" class="">scanner</a></li><li><a href="std.json.scanner.Scanner.html" class="active">Scanner</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.json.scanner.Scanner" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.json.scanner.Scanner</span><a href="#src.zig-std.json.scanner.Scanner">[src]</a></h1><div class="tldDocs"><p>The lowest level parsing API in this package;
supports streaming input with a low memory footprint.
The memory requirement is <code>O(d)</code> where d is the nesting depth of <code>[]</code> or <code>{}</code> containers in the input.
Specifically <code>d/8</code> bytes are required for this purpose,
with some extra buffer according to the implementation of <code><a href="std.array_list.html#std.array_list.ArrayList">std.ArrayList</a></code>.</p>
<p>This scanner can emit partial tokens; see <code><a href="std.json.scanner.Token.html">std.json.Token</a></code>.
The input to this class is a sequence of input buffers that you must supply one at a time.
Call <code>feedInput()</code> with the first buffer, then call <code>next()</code> repeatedly until <code>error.BufferUnderrun</code> is returned.
Then call <code>feedInput()</code> again and so forth.
Call <code>endInput()</code> when the last input buffer has been given to <code>feedInput()</code>, either immediately after calling <code>feedInput()</code>,
or when <code>error.BufferUnderrun</code> requests more data and there is no more.
Be sure to call <code>next()</code> after calling <code>endInput()</code> until <code>Token.end_of_document</code> has been returned.</p>
</div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>state: <a href="std.json.scanner.Scanner.State.html">State</a> = .value</code></pre></div><div><pre><code>string_is_object_key: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre></div><div><pre><code>stack: <a href="std.BitStack.html">BitStack</a></code></pre></div><div><pre><code>value_start: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span></code></pre></div><div><pre><code>utf16_code_units: [<span class="tok-number">2</span>]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span></code></pre></div><div><pre><code>input: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;&quot;</span></code></pre></div><div><pre><code>cursor: <span class="tok-type">usize</span> = <span class="tok-number">0</span></code></pre></div><div><pre><code>is_end_of_input: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre></div><div><pre><code>diagnostics: ?*<a href="std.json.scanner.Diagnostics.html">Diagnostics</a> = <span class="tok-null">null</span></code></pre></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.json.scanner.Scanner.NextError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">NextError</span><a href="#src.zig-std.json.scanner.Scanner.NextError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>BufferUnderrun</dt></div><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>SyntaxError <a href="std.json.scanner.html#std.json.scanner.Error">Error</a></dt></div><div><dt>UnexpectedEndOfInput <a href="std.json.scanner.html#std.json.scanner.Error">Error</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.NextError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> NextError = <a href="std.json.scanner.html#std.json.scanner.Error">Error</a> || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || <span class="tok-kw">error</span>{BufferUnderrun}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.Scanner.AllocError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">AllocError</span><a href="#src.zig-std.json.scanner.Scanner.AllocError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>SyntaxError <a href="std.json.scanner.html#std.json.scanner.Error">Error</a></dt></div><div><dt>UnexpectedEndOfInput <a href="std.json.scanner.html#std.json.scanner.Error">Error</a></dt></div><div><dt>ValueTooLong</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.AllocError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AllocError = <a href="std.json.scanner.html#std.json.scanner.Error">Error</a> || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || <span class="tok-kw">error</span>{ValueTooLong}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.Scanner.PeekError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">PeekError</span><a href="#src.zig-std.json.scanner.Scanner.PeekError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>BufferUnderrun</dt></div><div><dt>SyntaxError <a href="std.json.scanner.html#std.json.scanner.Error">Error</a></dt></div><div><dt>UnexpectedEndOfInput <a href="std.json.scanner.html#std.json.scanner.Error">Error</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.PeekError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PeekError = <a href="std.json.scanner.html#std.json.scanner.Error">Error</a> || <span class="tok-kw">error</span>{BufferUnderrun}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.Scanner.SkipError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SkipError</span><a href="#src.zig-std.json.scanner.Scanner.SkipError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>SyntaxError <a href="std.json.scanner.html#std.json.scanner.Error">Error</a></dt></div><div><dt>UnexpectedEndOfInput <a href="std.json.scanner.html#std.json.scanner.Error">Error</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.SkipError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SkipError = <a href="std.json.scanner.html#std.json.scanner.Error">Error</a> || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.Scanner.AllocIntoArrayListError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">AllocIntoArrayListError</span><a href="#src.zig-std.json.scanner.Scanner.AllocIntoArrayListError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>BufferUnderrun</dt></div><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>SyntaxError <a href="std.json.scanner.html#std.json.scanner.Error">Error</a></dt></div><div><dt>UnexpectedEndOfInput <a href="std.json.scanner.html#std.json.scanner.Error">Error</a></dt></div><div><dt>ValueTooLong <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.AllocError">AllocError</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.AllocIntoArrayListError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AllocIntoArrayListError = <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.AllocError">AllocError</a> || <span class="tok-kw">error</span>{BufferUnderrun}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.json.scanner.Scanner.initStreaming" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initStreaming</span><a href="#src.zig-std.json.scanner.Scanner.initStreaming">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initStreaming</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-builtin">@This</span>()</code></pre></div><div class="tldDocs"><p>The allocator is only used to track <code>[]</code> and <code>{}</code> nesting levels.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.initStreaming">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initStreaming</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-builtin">@This</span>() {
    <span class="tok-kw">return</span> .{
        .stack = <a href="std.BitStack.html">BitStack</a>.<a href="std.BitStack.html#std.BitStack.init">init</a>(allocator),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.Scanner.initCompleteInput" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initCompleteInput</span><a href="#src.zig-std.json.scanner.Scanner.initCompleteInput">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initCompleteInput</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, complete_input: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-builtin">@This</span>()</code></pre></div><div class="tldDocs"><p>Use this if your input is a single slice.
This is effectively equivalent to:</p>
<pre><code>initStreaming(allocator);
feedInput(complete_input);
endInput();
</code></pre>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>complete_input: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.initCompleteInput">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initCompleteInput</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, complete_input: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-builtin">@This</span>() {
    <span class="tok-kw">return</span> .{
        .stack = <a href="std.BitStack.html">BitStack</a>.<a href="std.BitStack.html#std.BitStack.init">init</a>(allocator),
        .input = complete_input,
        .is_end_of_input = <span class="tok-null">true</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.Scanner.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.json.scanner.Scanner.deinit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.deinit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
    self.stack.deinit();
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.Scanner.enableDiagnostics" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">enableDiagnostics</span><a href="#src.zig-std.json.scanner.Scanner.enableDiagnostics">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">enableDiagnostics</span>(self: *<span class="tok-builtin">@This</span>(), diagnostics: *<a href="std.json.scanner.Diagnostics.html">Diagnostics</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>diagnostics: *<a href="std.json.scanner.Diagnostics.html">Diagnostics</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.enableDiagnostics">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">enableDiagnostics</span>(self: *<span class="tok-builtin">@This</span>(), diagnostics: *<a href="std.json.scanner.Diagnostics.html">Diagnostics</a>) <span class="tok-type">void</span> {
    diagnostics.cursor_pointer = &amp;self.cursor;
    self.diagnostics = diagnostics;
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.Scanner.feedInput" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">feedInput</span><a href="#src.zig-std.json.scanner.Scanner.feedInput">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">feedInput</span>(self: *<span class="tok-builtin">@This</span>(), input: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Call this whenever you get <code>error.BufferUnderrun</code> from <code>next()</code>.
When there is no more input to provide, call <code>endInput()</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>input: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.feedInput">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">feedInput</span>(self: *<span class="tok-builtin">@This</span>(), input: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.cursor == self.input.len);<span class="tok-comment"> // Not done with the last input slice.
    </span><span class="tok-kw">if</span> (self.diagnostics) |diag| {
        diag.total_bytes_before_current_input += self.input.len;<span class="tok-comment">
        // This usually goes &quot;negative&quot; to measure how far before the beginning
        // of the new buffer the current line started.
        </span>diag.line_start_cursor -%= self.cursor;
    }
    self.input = input;
    self.cursor = <span class="tok-number">0</span>;
    self.value_start = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.Scanner.endInput" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">endInput</span><a href="#src.zig-std.json.scanner.Scanner.endInput">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endInput</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Call this when you will no longer call <code>feedInput()</code> anymore.
This can be called either immediately after the last <code>feedInput()</code>,
or at any time afterward, such as when getting <code>error.BufferUnderrun</code> from <code>next()</code>.
Don't forget to call <code>next*()</code> after <code>endInput()</code> until you get <code>.end_of_document</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.endInput">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endInput</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
    self.is_end_of_input = <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.Scanner.nextAlloc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">nextAlloc</span><a href="#src.zig-std.json.scanner.Scanner.nextAlloc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextAlloc</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.AllocError">AllocError</a>!<a href="std.json.scanner.Token.html">Token</a></code></pre></div><div class="tldDocs"><p>Equivalent to <code>nextAllocMax(allocator, when, default_max_value_len);</code>
This function is only available after <code>endInput()</code> (or <code>initCompleteInput()</code>) has been called.
See also <code>std.json.Token</code> for documentation of <code>nextAlloc*()</code> function behavior.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.nextAlloc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextAlloc</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.AllocError">AllocError</a>!<a href="std.json.scanner.Token.html">Token</a> {
    <span class="tok-kw">return</span> self.nextAllocMax(allocator, when, <a href="std.json.scanner.html#std.json.scanner.default_max_value_len">default_max_value_len</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.Scanner.nextAllocMax" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">nextAllocMax</span><a href="#src.zig-std.json.scanner.Scanner.nextAllocMax">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextAllocMax</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>, max_value_len: <span class="tok-type">usize</span>) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.AllocError">AllocError</a>!<a href="std.json.scanner.Token.html">Token</a></code></pre></div><div class="tldDocs"><p>This function is only available after <code>endInput()</code> (or <code>initCompleteInput()</code>) has been called.
See also <code>std.json.Token</code> for documentation of <code>nextAlloc*()</code> function behavior.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a></code></pre></div><div><pre><code>max_value_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.nextAllocMax">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextAllocMax</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>, max_value_len: <span class="tok-type">usize</span>) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.AllocError">AllocError</a>!<a href="std.json.scanner.Token.html">Token</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.is_end_of_input);<span class="tok-comment"> // This function is not available in streaming mode.
    </span><span class="tok-kw">const</span> token_type = self.peekNextTokenType() <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
        <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">switch</span> (token_type) {
        .number, .string =&gt; {
            <span class="tok-kw">var</span> value_list = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(allocator);
            <span class="tok-kw">errdefer</span> {
                value_list.deinit();
            }
            <span class="tok-kw">if</span> (self.allocNextIntoArrayListMax(&amp;value_list, when, max_value_len) <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
                <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,
            }) |slice| {
                <span class="tok-kw">return</span> <span class="tok-kw">if</span> (token_type == .number)
                    <a href="std.json.scanner.Token.html">Token</a>{ .number = slice }
                <span class="tok-kw">else</span>
                    <a href="std.json.scanner.Token.html">Token</a>{ .string = slice };
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> <span class="tok-kw">if</span> (token_type == .number)
                    <a href="std.json.scanner.Token.html">Token</a>{ .allocated_number = <span class="tok-kw">try</span> value_list.toOwnedSlice() }
                <span class="tok-kw">else</span>
                    <a href="std.json.scanner.Token.html">Token</a>{ .allocated_string = <span class="tok-kw">try</span> value_list.toOwnedSlice() };
            }
        },<span class="tok-comment">

        // Simple tokens never alloc.
        </span>.object_begin,
        .object_end,
        .array_begin,
        .array_end,
        .<span class="tok-null">true</span>,
        .<span class="tok-null">false</span>,
        .<span class="tok-null">null</span>,
        .end_of_document,
        =&gt; <span class="tok-kw">return</span> self.next() <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
            <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,
        },
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.Scanner.allocNextIntoArrayList" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">allocNextIntoArrayList</span><a href="#src.zig-std.json.scanner.Scanner.allocNextIntoArrayList">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocNextIntoArrayList</span>(self: *<span class="tok-builtin">@This</span>(), value_list: *<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>), when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.AllocIntoArrayListError">AllocIntoArrayListError</a>!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Equivalent to <code>allocNextIntoArrayListMax(value_list, when, default_max_value_len);</code></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>value_list: *<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>)</code></pre></div><div><pre><code>when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.allocNextIntoArrayList">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocNextIntoArrayList</span>(self: *<span class="tok-builtin">@This</span>(), value_list: *<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>), when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.AllocIntoArrayListError">AllocIntoArrayListError</a>!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> self.allocNextIntoArrayListMax(value_list, when, <a href="std.json.scanner.html#std.json.scanner.default_max_value_len">default_max_value_len</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.Scanner.allocNextIntoArrayListMax" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">allocNextIntoArrayListMax</span><a href="#src.zig-std.json.scanner.Scanner.allocNextIntoArrayListMax">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocNextIntoArrayListMax</span>(self: *<span class="tok-builtin">@This</span>(), value_list: *<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>), when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>, max_value_len: <span class="tok-type">usize</span>) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.AllocIntoArrayListError">AllocIntoArrayListError</a>!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>The next token type must be either <code>.number</code> or <code>.string</code>. See <code>peekNextTokenType()</code>.
When allocation is not necessary with <code>.alloc_if_needed</code>,
this method returns the content slice from the input buffer, and <code>value_list</code> is not touched.
When allocation is necessary or with <code>.alloc_always</code>, this method concatenates partial tokens into the given <code>value_list</code>,
and returns <code>null</code> once the final <code>.number</code> or <code>.string</code> token has been written into it.
In case of an <code>error.BufferUnderrun</code>, partial values will be left in the given value_list.
The given <code>value_list</code> is never reset by this method, so an <code>error.BufferUnderrun</code> situation
can be resumed by passing the same array list in again.
This method does not indicate whether the token content being returned is for a <code>.number</code> or <code>.string</code> token type;
the caller of this method is expected to know which type of token is being processed.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>value_list: *<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>)</code></pre></div><div><pre><code>when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a></code></pre></div><div><pre><code>max_value_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.allocNextIntoArrayListMax">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocNextIntoArrayListMax</span>(self: *<span class="tok-builtin">@This</span>(), value_list: *<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>), when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>, max_value_len: <span class="tok-type">usize</span>) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.AllocIntoArrayListError">AllocIntoArrayListError</a>!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> token = <span class="tok-kw">try</span> self.next();
        <span class="tok-kw">switch</span> (token) {<span class="tok-comment">
            // Accumulate partial values.
            </span>.partial_number, .partial_string =&gt; |slice| {
                <span class="tok-kw">try</span> <a href="std.json.scanner.html#std.json.scanner.appendSlice">appendSlice</a>(value_list, slice, max_value_len);
            },
            .partial_string_escaped_1 =&gt; |buf| {
                <span class="tok-kw">try</span> <a href="std.json.scanner.html#std.json.scanner.appendSlice">appendSlice</a>(value_list, buf[<span class="tok-number">0</span>..], max_value_len);
            },
            .partial_string_escaped_2 =&gt; |buf| {
                <span class="tok-kw">try</span> <a href="std.json.scanner.html#std.json.scanner.appendSlice">appendSlice</a>(value_list, buf[<span class="tok-number">0</span>..], max_value_len);
            },
            .partial_string_escaped_3 =&gt; |buf| {
                <span class="tok-kw">try</span> <a href="std.json.scanner.html#std.json.scanner.appendSlice">appendSlice</a>(value_list, buf[<span class="tok-number">0</span>..], max_value_len);
            },
            .partial_string_escaped_4 =&gt; |buf| {
                <span class="tok-kw">try</span> <a href="std.json.scanner.html#std.json.scanner.appendSlice">appendSlice</a>(value_list, buf[<span class="tok-number">0</span>..], max_value_len);
            },<span class="tok-comment">

            // Return complete values.
            </span>.number =&gt; |slice| {
                <span class="tok-kw">if</span> (when == .alloc_if_needed <span class="tok-kw">and</span> value_list.items.len == <span class="tok-number">0</span>) {<span class="tok-comment">
                    // No alloc necessary.
                    </span><span class="tok-kw">return</span> slice;
                }
                <span class="tok-kw">try</span> <a href="std.json.scanner.html#std.json.scanner.appendSlice">appendSlice</a>(value_list, slice, max_value_len);<span class="tok-comment">
                // The token is complete.
                </span><span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
            .string =&gt; |slice| {
                <span class="tok-kw">if</span> (when == .alloc_if_needed <span class="tok-kw">and</span> value_list.items.len == <span class="tok-number">0</span>) {<span class="tok-comment">
                    // No alloc necessary.
                    </span><span class="tok-kw">return</span> slice;
                }
                <span class="tok-kw">try</span> <a href="std.json.scanner.html#std.json.scanner.appendSlice">appendSlice</a>(value_list, slice, max_value_len);<span class="tok-comment">
                // The token is complete.
                </span><span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },

            .object_begin,
            .object_end,
            .array_begin,
            .array_end,
            .<span class="tok-null">true</span>,
            .<span class="tok-null">false</span>,
            .<span class="tok-null">null</span>,
            .end_of_document,
            =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Only .number and .string token types are allowed here. Check peekNextTokenType() before calling this.

            </span>.allocated_number, .allocated_string =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.Scanner.skipValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">skipValue</span><a href="#src.zig-std.json.scanner.Scanner.skipValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipValue</span>(self: *<span class="tok-builtin">@This</span>()) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.SkipError">SkipError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>This function is only available after <code>endInput()</code> (or <code>initCompleteInput()</code>) has been called.
If the next token type is <code>.object_begin</code> or <code>.array_begin</code>,
this function calls <code>next()</code> repeatedly until the corresponding <code>.object_end</code> or <code>.array_end</code> is found.
If the next token type is <code>.number</code> or <code>.string</code>,
this function calls <code>next()</code> repeatedly until the (non <code>.partial_*</code>) <code>.number</code> or <code>.string</code> token is found.
If the next token type is <code>.true</code>, <code>.false</code>, or <code>.null</code>, this function calls <code>next()</code> once.
The next token type must not be <code>.object_end</code>, <code>.array_end</code>, or <code>.end_of_document</code>;
see <code>peekNextTokenType()</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.skipValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipValue</span>(self: *<span class="tok-builtin">@This</span>()) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.SkipError">SkipError</a>!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.is_end_of_input);<span class="tok-comment"> // This function is not available in streaming mode.
    </span><span class="tok-kw">switch</span> (self.peekNextTokenType() <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
        <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,
    }) {
        .object_begin, .array_begin =&gt; {
            self.skipUntilStackHeight(self.stackHeight()) <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
                <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,
            };
        },
        .number, .string =&gt; {
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">switch</span> (self.next() <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,
                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,
                }) {
                    .partial_number,
                    .partial_string,
                    .partial_string_escaped_1,
                    .partial_string_escaped_2,
                    .partial_string_escaped_3,
                    .partial_string_escaped_4,
                    =&gt; <span class="tok-kw">continue</span>,

                    .number, .string =&gt; <span class="tok-kw">break</span>,

                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                }
            }
        },
        .<span class="tok-null">true</span>, .<span class="tok-null">false</span>, .<span class="tok-null">null</span> =&gt; {
            _ = self.next() <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
                <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,
            };
        },

        .object_end, .array_end, .end_of_document =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Attempt to skip a non-value token.
    </span>}
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.Scanner.skipUntilStackHeight" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">skipUntilStackHeight</span><a href="#src.zig-std.json.scanner.Scanner.skipUntilStackHeight">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipUntilStackHeight</span>(self: *<span class="tok-builtin">@This</span>(), terminal_stack_height: <span class="tok-type">usize</span>) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.NextError">NextError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Skip tokens until an <code>.object_end</code> or <code>.array_end</code> token results in a <code>stackHeight()</code> equal the given stack height.
Unlike <code>skipValue()</code>, this function is available in streaming mode.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>terminal_stack_height: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.skipUntilStackHeight">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipUntilStackHeight</span>(self: *<span class="tok-builtin">@This</span>(), terminal_stack_height: <span class="tok-type">usize</span>) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.NextError">NextError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.next()) {
            .object_end, .array_end =&gt; {
                <span class="tok-kw">if</span> (self.stackHeight() == terminal_stack_height) <span class="tok-kw">break</span>;
            },
            .end_of_document =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.Scanner.stackHeight" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">stackHeight</span><a href="#src.zig-std.json.scanner.Scanner.stackHeight">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stackHeight</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>The depth of <code>{}</code> or <code>[]</code> nesting levels at the current position.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.stackHeight">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stackHeight</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.stack.bit_len;
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.Scanner.ensureTotalStackCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalStackCapacity</span><a href="#src.zig-std.json.scanner.Scanner.ensureTotalStackCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalStackCapacity</span>(self: *<span class="tok-builtin">@This</span>(), height: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Pre allocate memory to hold the given number of nesting levels.
<code>stackHeight()</code> up to the given number will not cause allocations.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>height: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.ensureTotalStackCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalStackCapacity</span>(self: *<span class="tok-builtin">@This</span>(), height: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.stack.ensureTotalCapacity(height);
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.Scanner.next" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">next</span><a href="#src.zig-std.json.scanner.Scanner.next">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<span class="tok-builtin">@This</span>()) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.NextError">NextError</a>!<a href="std.json.scanner.Token.html">Token</a></code></pre></div><div class="tldDocs"><p>See <code>std.json.Token</code> for documentation of this function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.next">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<span class="tok-builtin">@This</span>()) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.NextError">NextError</a>!<a href="std.json.scanner.Token.html">Token</a> {
    state_loop: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (self.state) {
            .value =&gt; {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {<span class="tok-comment">
                    // Object, Array
                    </span><span class="tok-str">'{'</span> =&gt; {
                        <span class="tok-kw">try</span> self.stack.push(<a href="std.json.scanner.html#std.json.scanner.OBJECT_MODE">OBJECT_MODE</a>);
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .object_start;
                        <span class="tok-kw">return</span> .object_begin;
                    },
                    <span class="tok-str">'['</span> =&gt; {
                        <span class="tok-kw">try</span> self.stack.push(<a href="std.json.scanner.html#std.json.scanner.ARRAY_MODE">ARRAY_MODE</a>);
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .array_start;
                        <span class="tok-kw">return</span> .array_begin;
                    },<span class="tok-comment">

                    // String
                    </span><span class="tok-str">'&quot;'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.value_start = self.cursor;
                        self.state = .string;
                        <span class="tok-kw">continue</span> :state_loop;
                    },<span class="tok-comment">

                    // Number
                    </span><span class="tok-str">'1'</span>...<span class="tok-str">'9'</span> =&gt; {
                        self.value_start = self.cursor;
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .number_int;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-str">'0'</span> =&gt; {
                        self.value_start = self.cursor;
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .number_leading_zero;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-str">'-'</span> =&gt; {
                        self.value_start = self.cursor;
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .number_minus;
                        <span class="tok-kw">continue</span> :state_loop;
                    },<span class="tok-comment">

                    // literal values
                    </span><span class="tok-str">'t'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .literal_t;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-str">'f'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .literal_f;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-str">'n'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .literal_n;
                        <span class="tok-kw">continue</span> :state_loop;
                    },

                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },

            .post_value =&gt; {
                <span class="tok-kw">if</span> (<span class="tok-kw">try</span> self.skipWhitespaceCheckEnd()) <span class="tok-kw">return</span> .end_of_document;

                <span class="tok-kw">const</span> c = self.input[self.cursor];
                <span class="tok-kw">if</span> (self.string_is_object_key) {
                    self.string_is_object_key = <span class="tok-null">false</span>;
                    <span class="tok-kw">switch</span> (c) {
                        <span class="tok-str">':'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .value;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                }

                <span class="tok-kw">switch</span> (c) {
                    <span class="tok-str">'}'</span> =&gt; {
                        <span class="tok-kw">if</span> (self.stack.pop() != <a href="std.json.scanner.html#std.json.scanner.OBJECT_MODE">OBJECT_MODE</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError;
                        self.cursor += <span class="tok-number">1</span>;<span class="tok-comment">
                        // stay in .post_value state.
                        </span><span class="tok-kw">return</span> .object_end;
                    },
                    <span class="tok-str">']'</span> =&gt; {
                        <span class="tok-kw">if</span> (self.stack.pop() != <a href="std.json.scanner.html#std.json.scanner.ARRAY_MODE">ARRAY_MODE</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError;
                        self.cursor += <span class="tok-number">1</span>;<span class="tok-comment">
                        // stay in .post_value state.
                        </span><span class="tok-kw">return</span> .array_end;
                    },
                    <span class="tok-str">','</span> =&gt; {
                        <span class="tok-kw">switch</span> (self.stack.peek()) {
                            <a href="std.json.scanner.html#std.json.scanner.OBJECT_MODE">OBJECT_MODE</a> =&gt; {
                                self.state = .object_post_comma;
                            },
                            <a href="std.json.scanner.html#std.json.scanner.ARRAY_MODE">ARRAY_MODE</a> =&gt; {
                                self.state = .value;
                            },
                        }
                        self.cursor += <span class="tok-number">1</span>;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },

            .object_start =&gt; {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {
                    <span class="tok-str">'&quot;'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.value_start = self.cursor;
                        self.state = .string;
                        self.string_is_object_key = <span class="tok-null">true</span>;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-str">'}'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        _ = self.stack.pop();
                        self.state = .post_value;
                        <span class="tok-kw">return</span> .object_end;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },
            .object_post_comma =&gt; {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {
                    <span class="tok-str">'&quot;'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.value_start = self.cursor;
                        self.state = .string;
                        self.string_is_object_key = <span class="tok-null">true</span>;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },

            .array_start =&gt; {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {
                    <span class="tok-str">']'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        _ = self.stack.pop();
                        self.state = .post_value;
                        <span class="tok-kw">return</span> .array_end;
                    },
                    <span class="tok-kw">else</span> =&gt; {
                        self.state = .value;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                }
            },

            .number_minus =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">false</span>);
                <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                    <span class="tok-str">'0'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .number_leading_zero;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-str">'1'</span>...<span class="tok-str">'9'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .number_int;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },
            .number_leading_zero =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">true</span>);
                <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                    <span class="tok-str">'.'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .number_post_dot;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-str">'e'</span>, <span class="tok-str">'E'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .number_post_e;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; {
                        self.state = .post_value;
                        <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .number = self.takeValueSlice() };
                    },
                }
            },
            .number_int =&gt; {
                <span class="tok-kw">while</span> (self.cursor &lt; self.input.len) : (self.cursor += <span class="tok-number">1</span>) {
                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; <span class="tok-kw">continue</span>,
                        <span class="tok-str">'.'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .number_post_dot;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-str">'e'</span>, <span class="tok-str">'E'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .number_post_e;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; {
                            self.state = .post_value;
                            <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .number = self.takeValueSlice() };
                        },
                    }
                }
                <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">true</span>);
            },
            .number_post_dot =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">false</span>);
                <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                    <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .number_frac;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },
            .number_frac =&gt; {
                <span class="tok-kw">while</span> (self.cursor &lt; self.input.len) : (self.cursor += <span class="tok-number">1</span>) {
                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; <span class="tok-kw">continue</span>,
                        <span class="tok-str">'e'</span>, <span class="tok-str">'E'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .number_post_e;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; {
                            self.state = .post_value;
                            <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .number = self.takeValueSlice() };
                        },
                    }
                }
                <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">true</span>);
            },
            .number_post_e =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">false</span>);
                <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                    <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .number_exp;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-str">'+'</span>, <span class="tok-str">'-'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .number_post_e_sign;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },
            .number_post_e_sign =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">false</span>);
                <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                    <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .number_exp;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },
            .number_exp =&gt; {
                <span class="tok-kw">while</span> (self.cursor &lt; self.input.len) : (self.cursor += <span class="tok-number">1</span>) {
                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; <span class="tok-kw">continue</span>,
                        <span class="tok-kw">else</span> =&gt; {
                            self.state = .post_value;
                            <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .number = self.takeValueSlice() };
                        },
                    }
                }
                <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">true</span>);
            },

            .string =&gt; {
                <span class="tok-kw">while</span> (self.cursor &lt; self.input.len) : (self.cursor += <span class="tok-number">1</span>) {
                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                        <span class="tok-number">0</span>...<span class="tok-number">0x1f</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Bare ASCII control code in string.

                        // ASCII plain text.
                        </span><span class="tok-number">0x20</span>...(<span class="tok-str">'&quot;'</span> - <span class="tok-number">1</span>), (<span class="tok-str">'&quot;'</span> + <span class="tok-number">1</span>)...(<span class="tok-str">'\\'</span> - <span class="tok-number">1</span>), (<span class="tok-str">'\\'</span> + <span class="tok-number">1</span>)...<span class="tok-number">0x7F</span> =&gt; <span class="tok-kw">continue</span>,<span class="tok-comment">

                        // Special characters.
                        </span><span class="tok-str">'&quot;'</span> =&gt; {
                            <span class="tok-kw">const</span> result = <a href="std.json.scanner.Token.html">Token</a>{ .string = self.takeValueSlice() };
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .post_value;
                            <span class="tok-kw">return</span> result;
                        },
                        <span class="tok-str">'\\'</span> =&gt; {
                            <span class="tok-kw">const</span> slice = self.takeValueSlice();
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .string_backslash;
                            <span class="tok-kw">if</span> (slice.len &gt; <span class="tok-number">0</span>) <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .partial_string = slice };
                            <span class="tok-kw">continue</span> :state_loop;
                        },<span class="tok-comment">

                        // UTF-8 validation.
                        // See http://unicode.org/mail-arch/unicode-ml/y2003-m02/att-0467/01-The_Algorithm_to_Valide_an_UTF-8_String
                        </span><span class="tok-number">0xC2</span>...<span class="tok-number">0xDF</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .string_utf8_last_byte;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-number">0xE0</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .string_utf8_second_to_last_byte_guard_against_overlong;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-number">0xE1</span>...<span class="tok-number">0xEC</span>, <span class="tok-number">0xEE</span>...<span class="tok-number">0xEF</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .string_utf8_second_to_last_byte;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-number">0xED</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .string_utf8_second_to_last_byte_guard_against_surrogate_half;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-number">0xF0</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .string_utf8_third_to_last_byte_guard_against_overlong;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-number">0xF1</span>...<span class="tok-number">0xF3</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .string_utf8_third_to_last_byte;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-number">0xF4</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .string_utf8_third_to_last_byte_guard_against_too_large;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-number">0x80</span>...<span class="tok-number">0xC1</span>, <span class="tok-number">0xF5</span>...<span class="tok-number">0xFF</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Invalid UTF-8.
                    </span>}
                }
                <span class="tok-kw">if</span> (self.is_end_of_input) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfInput;
                <span class="tok-kw">const</span> slice = self.takeValueSlice();
                <span class="tok-kw">if</span> (slice.len &gt; <span class="tok-number">0</span>) <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .partial_string = slice };
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BufferUnderrun;
            },
            .string_backslash =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                    <span class="tok-str">'&quot;'</span>, <span class="tok-str">'\\'</span>, <span class="tok-str">'/'</span> =&gt; {<span class="tok-comment">
                        // Since these characters now represent themselves literally,
                        // we can simply begin the next plaintext slice here.
                        </span>self.value_start = self.cursor;
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .string;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-str">'b'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.value_start = self.cursor;
                        self.state = .string;
                        <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .partial_string_escaped_1 = [_]<span class="tok-type">u8</span>{<span class="tok-number">0x08</span>} };
                    },
                    <span class="tok-str">'f'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.value_start = self.cursor;
                        self.state = .string;
                        <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .partial_string_escaped_1 = [_]<span class="tok-type">u8</span>{<span class="tok-number">0x0c</span>} };
                    },
                    <span class="tok-str">'n'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.value_start = self.cursor;
                        self.state = .string;
                        <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .partial_string_escaped_1 = [_]<span class="tok-type">u8</span>{<span class="tok-str">'\n'</span>} };
                    },
                    <span class="tok-str">'r'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.value_start = self.cursor;
                        self.state = .string;
                        <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .partial_string_escaped_1 = [_]<span class="tok-type">u8</span>{<span class="tok-str">'\r'</span>} };
                    },
                    <span class="tok-str">'t'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.value_start = self.cursor;
                        self.state = .string;
                        <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .partial_string_escaped_1 = [_]<span class="tok-type">u8</span>{<span class="tok-str">'\t'</span>} };
                    },
                    <span class="tok-str">'u'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .string_backslash_u;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },
            .string_backslash_u =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                <span class="tok-kw">const</span> c = self.input[self.cursor];
                <span class="tok-kw">switch</span> (c) {
                    <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {
                        self.utf16_code_units[<span class="tok-number">0</span>] = <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'0'</span>) &lt;&lt; <span class="tok-number">12</span>;
                    },
                    <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {
                        self.utf16_code_units[<span class="tok-number">0</span>] = <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">12</span>;
                    },
                    <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {
                        self.utf16_code_units[<span class="tok-number">0</span>] = <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">12</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
                self.cursor += <span class="tok-number">1</span>;
                self.state = .string_backslash_u_1;
                <span class="tok-kw">continue</span> :state_loop;
            },
            .string_backslash_u_1 =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                <span class="tok-kw">const</span> c = self.input[self.cursor];
                <span class="tok-kw">switch</span> (c) {
                    <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {
                        self.utf16_code_units[<span class="tok-number">0</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'0'</span>) &lt;&lt; <span class="tok-number">8</span>;
                    },
                    <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {
                        self.utf16_code_units[<span class="tok-number">0</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">8</span>;
                    },
                    <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {
                        self.utf16_code_units[<span class="tok-number">0</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">8</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
                self.cursor += <span class="tok-number">1</span>;
                self.state = .string_backslash_u_2;
                <span class="tok-kw">continue</span> :state_loop;
            },
            .string_backslash_u_2 =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                <span class="tok-kw">const</span> c = self.input[self.cursor];
                <span class="tok-kw">switch</span> (c) {
                    <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {
                        self.utf16_code_units[<span class="tok-number">0</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'0'</span>) &lt;&lt; <span class="tok-number">4</span>;
                    },
                    <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {
                        self.utf16_code_units[<span class="tok-number">0</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">4</span>;
                    },
                    <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {
                        self.utf16_code_units[<span class="tok-number">0</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">4</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
                self.cursor += <span class="tok-number">1</span>;
                self.state = .string_backslash_u_3;
                <span class="tok-kw">continue</span> :state_loop;
            },
            .string_backslash_u_3 =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                <span class="tok-kw">const</span> c = self.input[self.cursor];
                <span class="tok-kw">switch</span> (c) {
                    <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {
                        self.utf16_code_units[<span class="tok-number">0</span>] |= c - <span class="tok-str">'0'</span>;
                    },
                    <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {
                        self.utf16_code_units[<span class="tok-number">0</span>] |= c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>;
                    },
                    <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {
                        self.utf16_code_units[<span class="tok-number">0</span>] |= c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
                self.cursor += <span class="tok-number">1</span>;
                <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf16IsHighSurrogate">utf16IsHighSurrogate</a>(self.utf16_code_units[<span class="tok-number">0</span>])) {
                    self.state = .string_surrogate_half;
                    <span class="tok-kw">continue</span> :state_loop;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf16IsLowSurrogate">utf16IsLowSurrogate</a>(self.utf16_code_units[<span class="tok-number">0</span>])) {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError;<span class="tok-comment"> // Unexpected low surrogate half.
                </span>} <span class="tok-kw">else</span> {
                    self.value_start = self.cursor;
                    self.state = .string;
                    <span class="tok-kw">return</span> <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.partialStringCodepoint">partialStringCodepoint</a>(self.utf16_code_units[<span class="tok-number">0</span>]);
                }
            },
            .string_surrogate_half =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                    <span class="tok-str">'\\'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .string_surrogate_half_backslash;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Expected low surrogate half.
                </span>}
            },
            .string_surrogate_half_backslash =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                    <span class="tok-str">'u'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .string_surrogate_half_backslash_u;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Expected low surrogate half.
                </span>}
            },
            .string_surrogate_half_backslash_u =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                    <span class="tok-str">'D'</span>, <span class="tok-str">'d'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.utf16_code_units[<span class="tok-number">1</span>] = <span class="tok-number">0xD</span> &lt;&lt; <span class="tok-number">12</span>;
                        self.state = .string_surrogate_half_backslash_u_1;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Expected low surrogate half.
                </span>}
            },
            .string_surrogate_half_backslash_u_1 =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                <span class="tok-kw">const</span> c = self.input[self.cursor];
                <span class="tok-kw">switch</span> (c) {
                    <span class="tok-str">'C'</span>...<span class="tok-str">'F'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.utf16_code_units[<span class="tok-number">1</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">8</span>;
                        self.state = .string_surrogate_half_backslash_u_2;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-str">'c'</span>...<span class="tok-str">'f'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.utf16_code_units[<span class="tok-number">1</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">8</span>;
                        self.state = .string_surrogate_half_backslash_u_2;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Expected low surrogate half.
                </span>}
            },
            .string_surrogate_half_backslash_u_2 =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                <span class="tok-kw">const</span> c = self.input[self.cursor];
                <span class="tok-kw">switch</span> (c) {
                    <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.utf16_code_units[<span class="tok-number">1</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'0'</span>) &lt;&lt; <span class="tok-number">4</span>;
                        self.state = .string_surrogate_half_backslash_u_3;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.utf16_code_units[<span class="tok-number">1</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">4</span>;
                        self.state = .string_surrogate_half_backslash_u_3;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.utf16_code_units[<span class="tok-number">1</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">4</span>;
                        self.state = .string_surrogate_half_backslash_u_3;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },
            .string_surrogate_half_backslash_u_3 =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                <span class="tok-kw">const</span> c = self.input[self.cursor];
                <span class="tok-kw">switch</span> (c) {
                    <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {
                        self.utf16_code_units[<span class="tok-number">1</span>] |= c - <span class="tok-str">'0'</span>;
                    },
                    <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {
                        self.utf16_code_units[<span class="tok-number">1</span>] |= c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>;
                    },
                    <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {
                        self.utf16_code_units[<span class="tok-number">1</span>] |= c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
                self.cursor += <span class="tok-number">1</span>;
                self.value_start = self.cursor;
                self.state = .string;
                <span class="tok-kw">const</span> code_point = <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf16DecodeSurrogatePair">utf16DecodeSurrogatePair</a>(&amp;self.utf16_code_units) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
                <span class="tok-kw">return</span> <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.partialStringCodepoint">partialStringCodepoint</a>(code_point);
            },

            .string_utf8_last_byte =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                    <span class="tok-number">0x80</span>...<span class="tok-number">0xBF</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .string;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Invalid UTF-8.
                </span>}
            },
            .string_utf8_second_to_last_byte =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                    <span class="tok-number">0x80</span>...<span class="tok-number">0xBF</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .string_utf8_last_byte;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Invalid UTF-8.
                </span>}
            },
            .string_utf8_second_to_last_byte_guard_against_overlong =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                    <span class="tok-number">0xA0</span>...<span class="tok-number">0xBF</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .string_utf8_last_byte;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Invalid UTF-8.
                </span>}
            },
            .string_utf8_second_to_last_byte_guard_against_surrogate_half =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                    <span class="tok-number">0x80</span>...<span class="tok-number">0x9F</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .string_utf8_last_byte;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Invalid UTF-8.
                </span>}
            },
            .string_utf8_third_to_last_byte =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                    <span class="tok-number">0x80</span>...<span class="tok-number">0xBF</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .string_utf8_second_to_last_byte;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Invalid UTF-8.
                </span>}
            },
            .string_utf8_third_to_last_byte_guard_against_overlong =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                    <span class="tok-number">0x90</span>...<span class="tok-number">0xBF</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .string_utf8_second_to_last_byte;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Invalid UTF-8.
                </span>}
            },
            .string_utf8_third_to_last_byte_guard_against_too_large =&gt; {
                <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                    <span class="tok-number">0x80</span>...<span class="tok-number">0x8F</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .string_utf8_second_to_last_byte;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Invalid UTF-8.
                </span>}
            },

            .literal_t =&gt; {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {
                    <span class="tok-str">'r'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .literal_tr;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },
            .literal_tr =&gt; {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {
                    <span class="tok-str">'u'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .literal_tru;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },
            .literal_tru =&gt; {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {
                    <span class="tok-str">'e'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .post_value;
                        <span class="tok-kw">return</span> .<span class="tok-null">true</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },
            .literal_f =&gt; {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {
                    <span class="tok-str">'a'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .literal_fa;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },
            .literal_fa =&gt; {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {
                    <span class="tok-str">'l'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .literal_fal;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },
            .literal_fal =&gt; {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {
                    <span class="tok-str">'s'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .literal_fals;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },
            .literal_fals =&gt; {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {
                    <span class="tok-str">'e'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .post_value;
                        <span class="tok-kw">return</span> .<span class="tok-null">false</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },
            .literal_n =&gt; {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {
                    <span class="tok-str">'u'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .literal_nu;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },
            .literal_nu =&gt; {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {
                    <span class="tok-str">'l'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .literal_nul;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },
            .literal_nul =&gt; {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {
                    <span class="tok-str">'l'</span> =&gt; {
                        self.cursor += <span class="tok-number">1</span>;
                        self.state = .post_value;
                        <span class="tok-kw">return</span> .<span class="tok-null">null</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },
        }
        <span class="tok-kw">unreachable</span>;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.Scanner.peekNextTokenType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">peekNextTokenType</span><a href="#src.zig-std.json.scanner.Scanner.peekNextTokenType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peekNextTokenType</span>(self: *<span class="tok-builtin">@This</span>()) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.PeekError">PeekError</a>!<a href="std.json.scanner.TokenType.html">TokenType</a></code></pre></div><div class="tldDocs"><p>Seeks ahead in the input until the first byte of the next token (or the end of the input)
determines which type of token will be returned from the next <code>next*()</code> call.
This function is idempotent, only advancing past commas, colons, and inter-token whitespace.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Scanner.peekNextTokenType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peekNextTokenType</span>(self: *<span class="tok-builtin">@This</span>()) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.PeekError">PeekError</a>!<a href="std.json.scanner.TokenType.html">TokenType</a> {
    state_loop: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (self.state) {
            .value =&gt; {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {
                    <span class="tok-str">'{'</span> =&gt; <span class="tok-kw">return</span> .object_begin,
                    <span class="tok-str">'['</span> =&gt; <span class="tok-kw">return</span> .array_begin,
                    <span class="tok-str">'&quot;'</span> =&gt; <span class="tok-kw">return</span> .string,
                    <span class="tok-str">'-'</span>, <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; <span class="tok-kw">return</span> .number,
                    <span class="tok-str">'t'</span> =&gt; <span class="tok-kw">return</span> .<span class="tok-null">true</span>,
                    <span class="tok-str">'f'</span> =&gt; <span class="tok-kw">return</span> .<span class="tok-null">false</span>,
                    <span class="tok-str">'n'</span> =&gt; <span class="tok-kw">return</span> .<span class="tok-null">null</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },

            .post_value =&gt; {
                <span class="tok-kw">if</span> (<span class="tok-kw">try</span> self.skipWhitespaceCheckEnd()) <span class="tok-kw">return</span> .end_of_document;

                <span class="tok-kw">const</span> c = self.input[self.cursor];
                <span class="tok-kw">if</span> (self.string_is_object_key) {
                    self.string_is_object_key = <span class="tok-null">false</span>;
                    <span class="tok-kw">switch</span> (c) {
                        <span class="tok-str">':'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .value;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                }

                <span class="tok-kw">switch</span> (c) {
                    <span class="tok-str">'}'</span> =&gt; <span class="tok-kw">return</span> .object_end,
                    <span class="tok-str">']'</span> =&gt; <span class="tok-kw">return</span> .array_end,
                    <span class="tok-str">','</span> =&gt; {
                        <span class="tok-kw">switch</span> (self.stack.peek()) {
                            <a href="std.json.scanner.html#std.json.scanner.OBJECT_MODE">OBJECT_MODE</a> =&gt; {
                                self.state = .object_post_comma;
                            },
                            <a href="std.json.scanner.html#std.json.scanner.ARRAY_MODE">ARRAY_MODE</a> =&gt; {
                                self.state = .value;
                            },
                        }
                        self.cursor += <span class="tok-number">1</span>;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },

            .object_start =&gt; {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {
                    <span class="tok-str">'&quot;'</span> =&gt; <span class="tok-kw">return</span> .string,
                    <span class="tok-str">'}'</span> =&gt; <span class="tok-kw">return</span> .object_end,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },
            .object_post_comma =&gt; {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {
                    <span class="tok-str">'&quot;'</span> =&gt; <span class="tok-kw">return</span> .string,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                }
            },

            .array_start =&gt; {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {
                    <span class="tok-str">']'</span> =&gt; <span class="tok-kw">return</span> .array_end,
                    <span class="tok-kw">else</span> =&gt; {
                        self.state = .value;
                        <span class="tok-kw">continue</span> :state_loop;
                    },
                }
            },

            .number_minus,
            .number_leading_zero,
            .number_int,
            .number_post_dot,
            .number_frac,
            .number_post_e,
            .number_post_e_sign,
            .number_exp,
            =&gt; <span class="tok-kw">return</span> .number,

            .string,
            .string_backslash,
            .string_backslash_u,
            .string_backslash_u_1,
            .string_backslash_u_2,
            .string_backslash_u_3,
            .string_surrogate_half,
            .string_surrogate_half_backslash,
            .string_surrogate_half_backslash_u,
            .string_surrogate_half_backslash_u_1,
            .string_surrogate_half_backslash_u_2,
            .string_surrogate_half_backslash_u_3,
            =&gt; <span class="tok-kw">return</span> .string,

            .string_utf8_last_byte,
            .string_utf8_second_to_last_byte,
            .string_utf8_second_to_last_byte_guard_against_overlong,
            .string_utf8_second_to_last_byte_guard_against_surrogate_half,
            .string_utf8_third_to_last_byte,
            .string_utf8_third_to_last_byte_guard_against_overlong,
            .string_utf8_third_to_last_byte_guard_against_too_large,
            =&gt; <span class="tok-kw">return</span> .string,

            .literal_t,
            .literal_tr,
            .literal_tru,
            =&gt; <span class="tok-kw">return</span> .<span class="tok-null">true</span>,
            .literal_f,
            .literal_fa,
            .literal_fal,
            .literal_fals,
            =&gt; <span class="tok-kw">return</span> .<span class="tok-null">false</span>,
            .literal_n,
            .literal_nu,
            .literal_nul,
            =&gt; <span class="tok-kw">return</span> .<span class="tok-null">null</span>,
        }
        <span class="tok-kw">unreachable</span>;
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.json.scanner.Scanner">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Scanner = <span class="tok-kw">struct</span> {
    state: <a href="std.json.scanner.Scanner.State.html">State</a> = .value,
    string_is_object_key: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    stack: <a href="std.BitStack.html">BitStack</a>,
    value_start: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>,
    utf16_code_units: [<span class="tok-number">2</span>]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>,

    input: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;&quot;</span>,
    cursor: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
    is_end_of_input: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    diagnostics: ?*<a href="std.json.scanner.Diagnostics.html">Diagnostics</a> = <span class="tok-null">null</span>,

    <span class="tok-comment">/// The allocator is only used to track `[]` and `{}` nesting levels.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initStreaming</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-builtin">@This</span>() {
        <span class="tok-kw">return</span> .{
            .stack = <a href="std.BitStack.html">BitStack</a>.<a href="std.BitStack.html#std.BitStack.init">init</a>(allocator),
        };
    }
    <span class="tok-comment">/// Use this if your input is a single slice.</span>
    <span class="tok-comment">/// This is effectively equivalent to:</span>
    <span class="tok-comment">/// ```</span>
    <span class="tok-comment">/// initStreaming(allocator);</span>
    <span class="tok-comment">/// feedInput(complete_input);</span>
    <span class="tok-comment">/// endInput();</span>
    <span class="tok-comment">/// ```</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initCompleteInput</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, complete_input: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-builtin">@This</span>() {
        <span class="tok-kw">return</span> .{
            .stack = <a href="std.BitStack.html">BitStack</a>.<a href="std.BitStack.html#std.BitStack.init">init</a>(allocator),
            .input = complete_input,
            .is_end_of_input = <span class="tok-null">true</span>,
        };
    }
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
        self.stack.deinit();
        self.* = <span class="tok-null">undefined</span>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">enableDiagnostics</span>(self: *<span class="tok-builtin">@This</span>(), diagnostics: *<a href="std.json.scanner.Diagnostics.html">Diagnostics</a>) <span class="tok-type">void</span> {
        diagnostics.cursor_pointer = &amp;self.cursor;
        self.diagnostics = diagnostics;
    }

    <span class="tok-comment">/// Call this whenever you get `error.BufferUnderrun` from `next()`.</span>
    <span class="tok-comment">/// When there is no more input to provide, call `endInput()`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">feedInput</span>(self: *<span class="tok-builtin">@This</span>(), input: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.cursor == self.input.len);<span class="tok-comment"> // Not done with the last input slice.
        </span><span class="tok-kw">if</span> (self.diagnostics) |diag| {
            diag.total_bytes_before_current_input += self.input.len;<span class="tok-comment">
            // This usually goes &quot;negative&quot; to measure how far before the beginning
            // of the new buffer the current line started.
            </span>diag.line_start_cursor -%= self.cursor;
        }
        self.input = input;
        self.cursor = <span class="tok-number">0</span>;
        self.value_start = <span class="tok-number">0</span>;
    }
    <span class="tok-comment">/// Call this when you will no longer call `feedInput()` anymore.</span>
    <span class="tok-comment">/// This can be called either immediately after the last `feedInput()`,</span>
    <span class="tok-comment">/// or at any time afterward, such as when getting `error.BufferUnderrun` from `next()`.</span>
    <span class="tok-comment">/// Don't forget to call `next*()` after `endInput()` until you get `.end_of_document`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endInput</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
        self.is_end_of_input = <span class="tok-null">true</span>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> NextError = <a href="std.json.scanner.html#std.json.scanner.Error">Error</a> || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || <span class="tok-kw">error</span>{BufferUnderrun};
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AllocError = <a href="std.json.scanner.html#std.json.scanner.Error">Error</a> || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || <span class="tok-kw">error</span>{ValueTooLong};
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PeekError = <a href="std.json.scanner.html#std.json.scanner.Error">Error</a> || <span class="tok-kw">error</span>{BufferUnderrun};
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SkipError = <a href="std.json.scanner.html#std.json.scanner.Error">Error</a> || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>;
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AllocIntoArrayListError = <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.AllocError">AllocError</a> || <span class="tok-kw">error</span>{BufferUnderrun};

    <span class="tok-comment">/// Equivalent to `nextAllocMax(allocator, when, default_max_value_len);`</span>
    <span class="tok-comment">/// This function is only available after `endInput()` (or `initCompleteInput()`) has been called.</span>
    <span class="tok-comment">/// See also `std.json.Token` for documentation of `nextAlloc*()` function behavior.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextAlloc</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.AllocError">AllocError</a>!<a href="std.json.scanner.Token.html">Token</a> {
        <span class="tok-kw">return</span> self.nextAllocMax(allocator, when, <a href="std.json.scanner.html#std.json.scanner.default_max_value_len">default_max_value_len</a>);
    }

    <span class="tok-comment">/// This function is only available after `endInput()` (or `initCompleteInput()`) has been called.</span>
    <span class="tok-comment">/// See also `std.json.Token` for documentation of `nextAlloc*()` function behavior.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextAllocMax</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>, max_value_len: <span class="tok-type">usize</span>) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.AllocError">AllocError</a>!<a href="std.json.scanner.Token.html">Token</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.is_end_of_input);<span class="tok-comment"> // This function is not available in streaming mode.
        </span><span class="tok-kw">const</span> token_type = self.peekNextTokenType() <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
            <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,
        };
        <span class="tok-kw">switch</span> (token_type) {
            .number, .string =&gt; {
                <span class="tok-kw">var</span> value_list = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(allocator);
                <span class="tok-kw">errdefer</span> {
                    value_list.deinit();
                }
                <span class="tok-kw">if</span> (self.allocNextIntoArrayListMax(&amp;value_list, when, max_value_len) <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,
                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,
                }) |slice| {
                    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (token_type == .number)
                        <a href="std.json.scanner.Token.html">Token</a>{ .number = slice }
                    <span class="tok-kw">else</span>
                        <a href="std.json.scanner.Token.html">Token</a>{ .string = slice };
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (token_type == .number)
                        <a href="std.json.scanner.Token.html">Token</a>{ .allocated_number = <span class="tok-kw">try</span> value_list.toOwnedSlice() }
                    <span class="tok-kw">else</span>
                        <a href="std.json.scanner.Token.html">Token</a>{ .allocated_string = <span class="tok-kw">try</span> value_list.toOwnedSlice() };
                }
            },<span class="tok-comment">

            // Simple tokens never alloc.
            </span>.object_begin,
            .object_end,
            .array_begin,
            .array_end,
            .<span class="tok-null">true</span>,
            .<span class="tok-null">false</span>,
            .<span class="tok-null">null</span>,
            .end_of_document,
            =&gt; <span class="tok-kw">return</span> self.next() <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
                <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,
            },
        }
    }

    <span class="tok-comment">/// Equivalent to `allocNextIntoArrayListMax(value_list, when, default_max_value_len);`</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocNextIntoArrayList</span>(self: *<span class="tok-builtin">@This</span>(), value_list: *<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>), when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.AllocIntoArrayListError">AllocIntoArrayListError</a>!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">return</span> self.allocNextIntoArrayListMax(value_list, when, <a href="std.json.scanner.html#std.json.scanner.default_max_value_len">default_max_value_len</a>);
    }
    <span class="tok-comment">/// The next token type must be either `.number` or `.string`. See `peekNextTokenType()`.</span>
    <span class="tok-comment">/// When allocation is not necessary with `.alloc_if_needed`,</span>
    <span class="tok-comment">/// this method returns the content slice from the input buffer, and `value_list` is not touched.</span>
    <span class="tok-comment">/// When allocation is necessary or with `.alloc_always`, this method concatenates partial tokens into the given `value_list`,</span>
    <span class="tok-comment">/// and returns `null` once the final `.number` or `.string` token has been written into it.</span>
    <span class="tok-comment">/// In case of an `error.BufferUnderrun`, partial values will be left in the given value_list.</span>
    <span class="tok-comment">/// The given `value_list` is never reset by this method, so an `error.BufferUnderrun` situation</span>
    <span class="tok-comment">/// can be resumed by passing the same array list in again.</span>
    <span class="tok-comment">/// This method does not indicate whether the token content being returned is for a `.number` or `.string` token type;</span>
    <span class="tok-comment">/// the caller of this method is expected to know which type of token is being processed.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocNextIntoArrayListMax</span>(self: *<span class="tok-builtin">@This</span>(), value_list: *<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>), when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>, max_value_len: <span class="tok-type">usize</span>) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.AllocIntoArrayListError">AllocIntoArrayListError</a>!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">const</span> token = <span class="tok-kw">try</span> self.next();
            <span class="tok-kw">switch</span> (token) {<span class="tok-comment">
                // Accumulate partial values.
                </span>.partial_number, .partial_string =&gt; |slice| {
                    <span class="tok-kw">try</span> <a href="std.json.scanner.html#std.json.scanner.appendSlice">appendSlice</a>(value_list, slice, max_value_len);
                },
                .partial_string_escaped_1 =&gt; |buf| {
                    <span class="tok-kw">try</span> <a href="std.json.scanner.html#std.json.scanner.appendSlice">appendSlice</a>(value_list, buf[<span class="tok-number">0</span>..], max_value_len);
                },
                .partial_string_escaped_2 =&gt; |buf| {
                    <span class="tok-kw">try</span> <a href="std.json.scanner.html#std.json.scanner.appendSlice">appendSlice</a>(value_list, buf[<span class="tok-number">0</span>..], max_value_len);
                },
                .partial_string_escaped_3 =&gt; |buf| {
                    <span class="tok-kw">try</span> <a href="std.json.scanner.html#std.json.scanner.appendSlice">appendSlice</a>(value_list, buf[<span class="tok-number">0</span>..], max_value_len);
                },
                .partial_string_escaped_4 =&gt; |buf| {
                    <span class="tok-kw">try</span> <a href="std.json.scanner.html#std.json.scanner.appendSlice">appendSlice</a>(value_list, buf[<span class="tok-number">0</span>..], max_value_len);
                },<span class="tok-comment">

                // Return complete values.
                </span>.number =&gt; |slice| {
                    <span class="tok-kw">if</span> (when == .alloc_if_needed <span class="tok-kw">and</span> value_list.items.len == <span class="tok-number">0</span>) {<span class="tok-comment">
                        // No alloc necessary.
                        </span><span class="tok-kw">return</span> slice;
                    }
                    <span class="tok-kw">try</span> <a href="std.json.scanner.html#std.json.scanner.appendSlice">appendSlice</a>(value_list, slice, max_value_len);<span class="tok-comment">
                    // The token is complete.
                    </span><span class="tok-kw">return</span> <span class="tok-null">null</span>;
                },
                .string =&gt; |slice| {
                    <span class="tok-kw">if</span> (when == .alloc_if_needed <span class="tok-kw">and</span> value_list.items.len == <span class="tok-number">0</span>) {<span class="tok-comment">
                        // No alloc necessary.
                        </span><span class="tok-kw">return</span> slice;
                    }
                    <span class="tok-kw">try</span> <a href="std.json.scanner.html#std.json.scanner.appendSlice">appendSlice</a>(value_list, slice, max_value_len);<span class="tok-comment">
                    // The token is complete.
                    </span><span class="tok-kw">return</span> <span class="tok-null">null</span>;
                },

                .object_begin,
                .object_end,
                .array_begin,
                .array_end,
                .<span class="tok-null">true</span>,
                .<span class="tok-null">false</span>,
                .<span class="tok-null">null</span>,
                .end_of_document,
                =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Only .number and .string token types are allowed here. Check peekNextTokenType() before calling this.

                </span>.allocated_number, .allocated_string =&gt; <span class="tok-kw">unreachable</span>,
            }
        }
    }

    <span class="tok-comment">/// This function is only available after `endInput()` (or `initCompleteInput()`) has been called.</span>
    <span class="tok-comment">/// If the next token type is `.object_begin` or `.array_begin`,</span>
    <span class="tok-comment">/// this function calls `next()` repeatedly until the corresponding `.object_end` or `.array_end` is found.</span>
    <span class="tok-comment">/// If the next token type is `.number` or `.string`,</span>
    <span class="tok-comment">/// this function calls `next()` repeatedly until the (non `.partial_*`) `.number` or `.string` token is found.</span>
    <span class="tok-comment">/// If the next token type is `.true`, `.false`, or `.null`, this function calls `next()` once.</span>
    <span class="tok-comment">/// The next token type must not be `.object_end`, `.array_end`, or `.end_of_document`;</span>
    <span class="tok-comment">/// see `peekNextTokenType()`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipValue</span>(self: *<span class="tok-builtin">@This</span>()) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.SkipError">SkipError</a>!<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.is_end_of_input);<span class="tok-comment"> // This function is not available in streaming mode.
        </span><span class="tok-kw">switch</span> (self.peekNextTokenType() <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
            <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,
        }) {
            .object_begin, .array_begin =&gt; {
                self.skipUntilStackHeight(self.stackHeight()) <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,
                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,
                };
            },
            .number, .string =&gt; {
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                    <span class="tok-kw">switch</span> (self.next() <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
                        <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,
                        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,
                    }) {
                        .partial_number,
                        .partial_string,
                        .partial_string_escaped_1,
                        .partial_string_escaped_2,
                        .partial_string_escaped_3,
                        .partial_string_escaped_4,
                        =&gt; <span class="tok-kw">continue</span>,

                        .number, .string =&gt; <span class="tok-kw">break</span>,

                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                    }
                }
            },
            .<span class="tok-null">true</span>, .<span class="tok-null">false</span>, .<span class="tok-null">null</span> =&gt; {
                _ = self.next() <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,
                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,
                };
            },

            .object_end, .array_end, .end_of_document =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Attempt to skip a non-value token.
        </span>}
    }

    <span class="tok-comment">/// Skip tokens until an `.object_end` or `.array_end` token results in a `stackHeight()` equal the given stack height.</span>
    <span class="tok-comment">/// Unlike `skipValue()`, this function is available in streaming mode.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipUntilStackHeight</span>(self: *<span class="tok-builtin">@This</span>(), terminal_stack_height: <span class="tok-type">usize</span>) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.NextError">NextError</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.next()) {
                .object_end, .array_end =&gt; {
                    <span class="tok-kw">if</span> (self.stackHeight() == terminal_stack_height) <span class="tok-kw">break</span>;
                },
                .end_of_document =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,
            }
        }
    }

    <span class="tok-comment">/// The depth of `{}` or `[]` nesting levels at the current position.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stackHeight</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> self.stack.bit_len;
    }

    <span class="tok-comment">/// Pre allocate memory to hold the given number of nesting levels.</span>
    <span class="tok-comment">/// `stackHeight()` up to the given number will not cause allocations.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalStackCapacity</span>(self: *<span class="tok-builtin">@This</span>(), height: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> self.stack.ensureTotalCapacity(height);
    }

    <span class="tok-comment">/// See `std.json.Token` for documentation of this function.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<span class="tok-builtin">@This</span>()) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.NextError">NextError</a>!<a href="std.json.scanner.Token.html">Token</a> {
        state_loop: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">switch</span> (self.state) {
                .value =&gt; {
                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {<span class="tok-comment">
                        // Object, Array
                        </span><span class="tok-str">'{'</span> =&gt; {
                            <span class="tok-kw">try</span> self.stack.push(<a href="std.json.scanner.html#std.json.scanner.OBJECT_MODE">OBJECT_MODE</a>);
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .object_start;
                            <span class="tok-kw">return</span> .object_begin;
                        },
                        <span class="tok-str">'['</span> =&gt; {
                            <span class="tok-kw">try</span> self.stack.push(<a href="std.json.scanner.html#std.json.scanner.ARRAY_MODE">ARRAY_MODE</a>);
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .array_start;
                            <span class="tok-kw">return</span> .array_begin;
                        },<span class="tok-comment">

                        // String
                        </span><span class="tok-str">'&quot;'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.value_start = self.cursor;
                            self.state = .string;
                            <span class="tok-kw">continue</span> :state_loop;
                        },<span class="tok-comment">

                        // Number
                        </span><span class="tok-str">'1'</span>...<span class="tok-str">'9'</span> =&gt; {
                            self.value_start = self.cursor;
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .number_int;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-str">'0'</span> =&gt; {
                            self.value_start = self.cursor;
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .number_leading_zero;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-str">'-'</span> =&gt; {
                            self.value_start = self.cursor;
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .number_minus;
                            <span class="tok-kw">continue</span> :state_loop;
                        },<span class="tok-comment">

                        // literal values
                        </span><span class="tok-str">'t'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .literal_t;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-str">'f'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .literal_f;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-str">'n'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .literal_n;
                            <span class="tok-kw">continue</span> :state_loop;
                        },

                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },

                .post_value =&gt; {
                    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> self.skipWhitespaceCheckEnd()) <span class="tok-kw">return</span> .end_of_document;

                    <span class="tok-kw">const</span> c = self.input[self.cursor];
                    <span class="tok-kw">if</span> (self.string_is_object_key) {
                        self.string_is_object_key = <span class="tok-null">false</span>;
                        <span class="tok-kw">switch</span> (c) {
                            <span class="tok-str">':'</span> =&gt; {
                                self.cursor += <span class="tok-number">1</span>;
                                self.state = .value;
                                <span class="tok-kw">continue</span> :state_loop;
                            },
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                        }
                    }

                    <span class="tok-kw">switch</span> (c) {
                        <span class="tok-str">'}'</span> =&gt; {
                            <span class="tok-kw">if</span> (self.stack.pop() != <a href="std.json.scanner.html#std.json.scanner.OBJECT_MODE">OBJECT_MODE</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError;
                            self.cursor += <span class="tok-number">1</span>;<span class="tok-comment">
                            // stay in .post_value state.
                            </span><span class="tok-kw">return</span> .object_end;
                        },
                        <span class="tok-str">']'</span> =&gt; {
                            <span class="tok-kw">if</span> (self.stack.pop() != <a href="std.json.scanner.html#std.json.scanner.ARRAY_MODE">ARRAY_MODE</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError;
                            self.cursor += <span class="tok-number">1</span>;<span class="tok-comment">
                            // stay in .post_value state.
                            </span><span class="tok-kw">return</span> .array_end;
                        },
                        <span class="tok-str">','</span> =&gt; {
                            <span class="tok-kw">switch</span> (self.stack.peek()) {
                                <a href="std.json.scanner.html#std.json.scanner.OBJECT_MODE">OBJECT_MODE</a> =&gt; {
                                    self.state = .object_post_comma;
                                },
                                <a href="std.json.scanner.html#std.json.scanner.ARRAY_MODE">ARRAY_MODE</a> =&gt; {
                                    self.state = .value;
                                },
                            }
                            self.cursor += <span class="tok-number">1</span>;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },

                .object_start =&gt; {
                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {
                        <span class="tok-str">'&quot;'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.value_start = self.cursor;
                            self.state = .string;
                            self.string_is_object_key = <span class="tok-null">true</span>;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-str">'}'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            _ = self.stack.pop();
                            self.state = .post_value;
                            <span class="tok-kw">return</span> .object_end;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },
                .object_post_comma =&gt; {
                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {
                        <span class="tok-str">'&quot;'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.value_start = self.cursor;
                            self.state = .string;
                            self.string_is_object_key = <span class="tok-null">true</span>;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },

                .array_start =&gt; {
                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {
                        <span class="tok-str">']'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            _ = self.stack.pop();
                            self.state = .post_value;
                            <span class="tok-kw">return</span> .array_end;
                        },
                        <span class="tok-kw">else</span> =&gt; {
                            self.state = .value;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                    }
                },

                .number_minus =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">false</span>);
                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                        <span class="tok-str">'0'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .number_leading_zero;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-str">'1'</span>...<span class="tok-str">'9'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .number_int;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },
                .number_leading_zero =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">true</span>);
                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                        <span class="tok-str">'.'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .number_post_dot;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-str">'e'</span>, <span class="tok-str">'E'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .number_post_e;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; {
                            self.state = .post_value;
                            <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .number = self.takeValueSlice() };
                        },
                    }
                },
                .number_int =&gt; {
                    <span class="tok-kw">while</span> (self.cursor &lt; self.input.len) : (self.cursor += <span class="tok-number">1</span>) {
                        <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                            <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; <span class="tok-kw">continue</span>,
                            <span class="tok-str">'.'</span> =&gt; {
                                self.cursor += <span class="tok-number">1</span>;
                                self.state = .number_post_dot;
                                <span class="tok-kw">continue</span> :state_loop;
                            },
                            <span class="tok-str">'e'</span>, <span class="tok-str">'E'</span> =&gt; {
                                self.cursor += <span class="tok-number">1</span>;
                                self.state = .number_post_e;
                                <span class="tok-kw">continue</span> :state_loop;
                            },
                            <span class="tok-kw">else</span> =&gt; {
                                self.state = .post_value;
                                <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .number = self.takeValueSlice() };
                            },
                        }
                    }
                    <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">true</span>);
                },
                .number_post_dot =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">false</span>);
                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .number_frac;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },
                .number_frac =&gt; {
                    <span class="tok-kw">while</span> (self.cursor &lt; self.input.len) : (self.cursor += <span class="tok-number">1</span>) {
                        <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                            <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; <span class="tok-kw">continue</span>,
                            <span class="tok-str">'e'</span>, <span class="tok-str">'E'</span> =&gt; {
                                self.cursor += <span class="tok-number">1</span>;
                                self.state = .number_post_e;
                                <span class="tok-kw">continue</span> :state_loop;
                            },
                            <span class="tok-kw">else</span> =&gt; {
                                self.state = .post_value;
                                <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .number = self.takeValueSlice() };
                            },
                        }
                    }
                    <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">true</span>);
                },
                .number_post_e =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">false</span>);
                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .number_exp;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-str">'+'</span>, <span class="tok-str">'-'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .number_post_e_sign;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },
                .number_post_e_sign =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">false</span>);
                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .number_exp;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },
                .number_exp =&gt; {
                    <span class="tok-kw">while</span> (self.cursor &lt; self.input.len) : (self.cursor += <span class="tok-number">1</span>) {
                        <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                            <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; <span class="tok-kw">continue</span>,
                            <span class="tok-kw">else</span> =&gt; {
                                self.state = .post_value;
                                <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .number = self.takeValueSlice() };
                            },
                        }
                    }
                    <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">true</span>);
                },

                .string =&gt; {
                    <span class="tok-kw">while</span> (self.cursor &lt; self.input.len) : (self.cursor += <span class="tok-number">1</span>) {
                        <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                            <span class="tok-number">0</span>...<span class="tok-number">0x1f</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Bare ASCII control code in string.

                            // ASCII plain text.
                            </span><span class="tok-number">0x20</span>...(<span class="tok-str">'&quot;'</span> - <span class="tok-number">1</span>), (<span class="tok-str">'&quot;'</span> + <span class="tok-number">1</span>)...(<span class="tok-str">'\\'</span> - <span class="tok-number">1</span>), (<span class="tok-str">'\\'</span> + <span class="tok-number">1</span>)...<span class="tok-number">0x7F</span> =&gt; <span class="tok-kw">continue</span>,<span class="tok-comment">

                            // Special characters.
                            </span><span class="tok-str">'&quot;'</span> =&gt; {
                                <span class="tok-kw">const</span> result = <a href="std.json.scanner.Token.html">Token</a>{ .string = self.takeValueSlice() };
                                self.cursor += <span class="tok-number">1</span>;
                                self.state = .post_value;
                                <span class="tok-kw">return</span> result;
                            },
                            <span class="tok-str">'\\'</span> =&gt; {
                                <span class="tok-kw">const</span> slice = self.takeValueSlice();
                                self.cursor += <span class="tok-number">1</span>;
                                self.state = .string_backslash;
                                <span class="tok-kw">if</span> (slice.len &gt; <span class="tok-number">0</span>) <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .partial_string = slice };
                                <span class="tok-kw">continue</span> :state_loop;
                            },<span class="tok-comment">

                            // UTF-8 validation.
                            // See http://unicode.org/mail-arch/unicode-ml/y2003-m02/att-0467/01-The_Algorithm_to_Valide_an_UTF-8_String
                            </span><span class="tok-number">0xC2</span>...<span class="tok-number">0xDF</span> =&gt; {
                                self.cursor += <span class="tok-number">1</span>;
                                self.state = .string_utf8_last_byte;
                                <span class="tok-kw">continue</span> :state_loop;
                            },
                            <span class="tok-number">0xE0</span> =&gt; {
                                self.cursor += <span class="tok-number">1</span>;
                                self.state = .string_utf8_second_to_last_byte_guard_against_overlong;
                                <span class="tok-kw">continue</span> :state_loop;
                            },
                            <span class="tok-number">0xE1</span>...<span class="tok-number">0xEC</span>, <span class="tok-number">0xEE</span>...<span class="tok-number">0xEF</span> =&gt; {
                                self.cursor += <span class="tok-number">1</span>;
                                self.state = .string_utf8_second_to_last_byte;
                                <span class="tok-kw">continue</span> :state_loop;
                            },
                            <span class="tok-number">0xED</span> =&gt; {
                                self.cursor += <span class="tok-number">1</span>;
                                self.state = .string_utf8_second_to_last_byte_guard_against_surrogate_half;
                                <span class="tok-kw">continue</span> :state_loop;
                            },
                            <span class="tok-number">0xF0</span> =&gt; {
                                self.cursor += <span class="tok-number">1</span>;
                                self.state = .string_utf8_third_to_last_byte_guard_against_overlong;
                                <span class="tok-kw">continue</span> :state_loop;
                            },
                            <span class="tok-number">0xF1</span>...<span class="tok-number">0xF3</span> =&gt; {
                                self.cursor += <span class="tok-number">1</span>;
                                self.state = .string_utf8_third_to_last_byte;
                                <span class="tok-kw">continue</span> :state_loop;
                            },
                            <span class="tok-number">0xF4</span> =&gt; {
                                self.cursor += <span class="tok-number">1</span>;
                                self.state = .string_utf8_third_to_last_byte_guard_against_too_large;
                                <span class="tok-kw">continue</span> :state_loop;
                            },
                            <span class="tok-number">0x80</span>...<span class="tok-number">0xC1</span>, <span class="tok-number">0xF5</span>...<span class="tok-number">0xFF</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Invalid UTF-8.
                        </span>}
                    }
                    <span class="tok-kw">if</span> (self.is_end_of_input) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfInput;
                    <span class="tok-kw">const</span> slice = self.takeValueSlice();
                    <span class="tok-kw">if</span> (slice.len &gt; <span class="tok-number">0</span>) <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .partial_string = slice };
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BufferUnderrun;
                },
                .string_backslash =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                        <span class="tok-str">'&quot;'</span>, <span class="tok-str">'\\'</span>, <span class="tok-str">'/'</span> =&gt; {<span class="tok-comment">
                            // Since these characters now represent themselves literally,
                            // we can simply begin the next plaintext slice here.
                            </span>self.value_start = self.cursor;
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .string;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-str">'b'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.value_start = self.cursor;
                            self.state = .string;
                            <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .partial_string_escaped_1 = [_]<span class="tok-type">u8</span>{<span class="tok-number">0x08</span>} };
                        },
                        <span class="tok-str">'f'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.value_start = self.cursor;
                            self.state = .string;
                            <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .partial_string_escaped_1 = [_]<span class="tok-type">u8</span>{<span class="tok-number">0x0c</span>} };
                        },
                        <span class="tok-str">'n'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.value_start = self.cursor;
                            self.state = .string;
                            <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .partial_string_escaped_1 = [_]<span class="tok-type">u8</span>{<span class="tok-str">'\n'</span>} };
                        },
                        <span class="tok-str">'r'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.value_start = self.cursor;
                            self.state = .string;
                            <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .partial_string_escaped_1 = [_]<span class="tok-type">u8</span>{<span class="tok-str">'\r'</span>} };
                        },
                        <span class="tok-str">'t'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.value_start = self.cursor;
                            self.state = .string;
                            <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .partial_string_escaped_1 = [_]<span class="tok-type">u8</span>{<span class="tok-str">'\t'</span>} };
                        },
                        <span class="tok-str">'u'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .string_backslash_u;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },
                .string_backslash_u =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                    <span class="tok-kw">const</span> c = self.input[self.cursor];
                    <span class="tok-kw">switch</span> (c) {
                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {
                            self.utf16_code_units[<span class="tok-number">0</span>] = <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'0'</span>) &lt;&lt; <span class="tok-number">12</span>;
                        },
                        <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {
                            self.utf16_code_units[<span class="tok-number">0</span>] = <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">12</span>;
                        },
                        <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {
                            self.utf16_code_units[<span class="tok-number">0</span>] = <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">12</span>;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                    self.cursor += <span class="tok-number">1</span>;
                    self.state = .string_backslash_u_1;
                    <span class="tok-kw">continue</span> :state_loop;
                },
                .string_backslash_u_1 =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                    <span class="tok-kw">const</span> c = self.input[self.cursor];
                    <span class="tok-kw">switch</span> (c) {
                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {
                            self.utf16_code_units[<span class="tok-number">0</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'0'</span>) &lt;&lt; <span class="tok-number">8</span>;
                        },
                        <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {
                            self.utf16_code_units[<span class="tok-number">0</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">8</span>;
                        },
                        <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {
                            self.utf16_code_units[<span class="tok-number">0</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">8</span>;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                    self.cursor += <span class="tok-number">1</span>;
                    self.state = .string_backslash_u_2;
                    <span class="tok-kw">continue</span> :state_loop;
                },
                .string_backslash_u_2 =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                    <span class="tok-kw">const</span> c = self.input[self.cursor];
                    <span class="tok-kw">switch</span> (c) {
                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {
                            self.utf16_code_units[<span class="tok-number">0</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'0'</span>) &lt;&lt; <span class="tok-number">4</span>;
                        },
                        <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {
                            self.utf16_code_units[<span class="tok-number">0</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">4</span>;
                        },
                        <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {
                            self.utf16_code_units[<span class="tok-number">0</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">4</span>;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                    self.cursor += <span class="tok-number">1</span>;
                    self.state = .string_backslash_u_3;
                    <span class="tok-kw">continue</span> :state_loop;
                },
                .string_backslash_u_3 =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                    <span class="tok-kw">const</span> c = self.input[self.cursor];
                    <span class="tok-kw">switch</span> (c) {
                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {
                            self.utf16_code_units[<span class="tok-number">0</span>] |= c - <span class="tok-str">'0'</span>;
                        },
                        <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {
                            self.utf16_code_units[<span class="tok-number">0</span>] |= c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>;
                        },
                        <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {
                            self.utf16_code_units[<span class="tok-number">0</span>] |= c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                    self.cursor += <span class="tok-number">1</span>;
                    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf16IsHighSurrogate">utf16IsHighSurrogate</a>(self.utf16_code_units[<span class="tok-number">0</span>])) {
                        self.state = .string_surrogate_half;
                        <span class="tok-kw">continue</span> :state_loop;
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf16IsLowSurrogate">utf16IsLowSurrogate</a>(self.utf16_code_units[<span class="tok-number">0</span>])) {
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError;<span class="tok-comment"> // Unexpected low surrogate half.
                    </span>} <span class="tok-kw">else</span> {
                        self.value_start = self.cursor;
                        self.state = .string;
                        <span class="tok-kw">return</span> <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.partialStringCodepoint">partialStringCodepoint</a>(self.utf16_code_units[<span class="tok-number">0</span>]);
                    }
                },
                .string_surrogate_half =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                        <span class="tok-str">'\\'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .string_surrogate_half_backslash;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Expected low surrogate half.
                    </span>}
                },
                .string_surrogate_half_backslash =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                        <span class="tok-str">'u'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .string_surrogate_half_backslash_u;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Expected low surrogate half.
                    </span>}
                },
                .string_surrogate_half_backslash_u =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                        <span class="tok-str">'D'</span>, <span class="tok-str">'d'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.utf16_code_units[<span class="tok-number">1</span>] = <span class="tok-number">0xD</span> &lt;&lt; <span class="tok-number">12</span>;
                            self.state = .string_surrogate_half_backslash_u_1;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Expected low surrogate half.
                    </span>}
                },
                .string_surrogate_half_backslash_u_1 =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                    <span class="tok-kw">const</span> c = self.input[self.cursor];
                    <span class="tok-kw">switch</span> (c) {
                        <span class="tok-str">'C'</span>...<span class="tok-str">'F'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.utf16_code_units[<span class="tok-number">1</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">8</span>;
                            self.state = .string_surrogate_half_backslash_u_2;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-str">'c'</span>...<span class="tok-str">'f'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.utf16_code_units[<span class="tok-number">1</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">8</span>;
                            self.state = .string_surrogate_half_backslash_u_2;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Expected low surrogate half.
                    </span>}
                },
                .string_surrogate_half_backslash_u_2 =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                    <span class="tok-kw">const</span> c = self.input[self.cursor];
                    <span class="tok-kw">switch</span> (c) {
                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.utf16_code_units[<span class="tok-number">1</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'0'</span>) &lt;&lt; <span class="tok-number">4</span>;
                            self.state = .string_surrogate_half_backslash_u_3;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.utf16_code_units[<span class="tok-number">1</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">4</span>;
                            self.state = .string_surrogate_half_backslash_u_3;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.utf16_code_units[<span class="tok-number">1</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">4</span>;
                            self.state = .string_surrogate_half_backslash_u_3;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },
                .string_surrogate_half_backslash_u_3 =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                    <span class="tok-kw">const</span> c = self.input[self.cursor];
                    <span class="tok-kw">switch</span> (c) {
                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {
                            self.utf16_code_units[<span class="tok-number">1</span>] |= c - <span class="tok-str">'0'</span>;
                        },
                        <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {
                            self.utf16_code_units[<span class="tok-number">1</span>] |= c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>;
                        },
                        <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {
                            self.utf16_code_units[<span class="tok-number">1</span>] |= c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                    self.cursor += <span class="tok-number">1</span>;
                    self.value_start = self.cursor;
                    self.state = .string;
                    <span class="tok-kw">const</span> code_point = <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf16DecodeSurrogatePair">utf16DecodeSurrogatePair</a>(&amp;self.utf16_code_units) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
                    <span class="tok-kw">return</span> <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.partialStringCodepoint">partialStringCodepoint</a>(code_point);
                },

                .string_utf8_last_byte =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                        <span class="tok-number">0x80</span>...<span class="tok-number">0xBF</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .string;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Invalid UTF-8.
                    </span>}
                },
                .string_utf8_second_to_last_byte =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                        <span class="tok-number">0x80</span>...<span class="tok-number">0xBF</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .string_utf8_last_byte;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Invalid UTF-8.
                    </span>}
                },
                .string_utf8_second_to_last_byte_guard_against_overlong =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                        <span class="tok-number">0xA0</span>...<span class="tok-number">0xBF</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .string_utf8_last_byte;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Invalid UTF-8.
                    </span>}
                },
                .string_utf8_second_to_last_byte_guard_against_surrogate_half =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                        <span class="tok-number">0x80</span>...<span class="tok-number">0x9F</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .string_utf8_last_byte;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Invalid UTF-8.
                    </span>}
                },
                .string_utf8_third_to_last_byte =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                        <span class="tok-number">0x80</span>...<span class="tok-number">0xBF</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .string_utf8_second_to_last_byte;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Invalid UTF-8.
                    </span>}
                },
                .string_utf8_third_to_last_byte_guard_against_overlong =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                        <span class="tok-number">0x90</span>...<span class="tok-number">0xBF</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .string_utf8_second_to_last_byte;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Invalid UTF-8.
                    </span>}
                },
                .string_utf8_third_to_last_byte_guard_against_too_large =&gt; {
                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInString();
                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {
                        <span class="tok-number">0x80</span>...<span class="tok-number">0x8F</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .string_utf8_second_to_last_byte;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,<span class="tok-comment"> // Invalid UTF-8.
                    </span>}
                },

                .literal_t =&gt; {
                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {
                        <span class="tok-str">'r'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .literal_tr;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },
                .literal_tr =&gt; {
                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {
                        <span class="tok-str">'u'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .literal_tru;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },
                .literal_tru =&gt; {
                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {
                        <span class="tok-str">'e'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .post_value;
                            <span class="tok-kw">return</span> .<span class="tok-null">true</span>;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },
                .literal_f =&gt; {
                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {
                        <span class="tok-str">'a'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .literal_fa;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },
                .literal_fa =&gt; {
                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {
                        <span class="tok-str">'l'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .literal_fal;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },
                .literal_fal =&gt; {
                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {
                        <span class="tok-str">'s'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .literal_fals;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },
                .literal_fals =&gt; {
                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {
                        <span class="tok-str">'e'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .post_value;
                            <span class="tok-kw">return</span> .<span class="tok-null">false</span>;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },
                .literal_n =&gt; {
                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {
                        <span class="tok-str">'u'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .literal_nu;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },
                .literal_nu =&gt; {
                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {
                        <span class="tok-str">'l'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .literal_nul;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },
                .literal_nul =&gt; {
                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {
                        <span class="tok-str">'l'</span> =&gt; {
                            self.cursor += <span class="tok-number">1</span>;
                            self.state = .post_value;
                            <span class="tok-kw">return</span> .<span class="tok-null">null</span>;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },
            }
            <span class="tok-kw">unreachable</span>;
        }
    }

    <span class="tok-comment">/// Seeks ahead in the input until the first byte of the next token (or the end of the input)</span>
    <span class="tok-comment">/// determines which type of token will be returned from the next `next*()` call.</span>
    <span class="tok-comment">/// This function is idempotent, only advancing past commas, colons, and inter-token whitespace.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peekNextTokenType</span>(self: *<span class="tok-builtin">@This</span>()) <a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.PeekError">PeekError</a>!<a href="std.json.scanner.TokenType.html">TokenType</a> {
        state_loop: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">switch</span> (self.state) {
                .value =&gt; {
                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {
                        <span class="tok-str">'{'</span> =&gt; <span class="tok-kw">return</span> .object_begin,
                        <span class="tok-str">'['</span> =&gt; <span class="tok-kw">return</span> .array_begin,
                        <span class="tok-str">'&quot;'</span> =&gt; <span class="tok-kw">return</span> .string,
                        <span class="tok-str">'-'</span>, <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; <span class="tok-kw">return</span> .number,
                        <span class="tok-str">'t'</span> =&gt; <span class="tok-kw">return</span> .<span class="tok-null">true</span>,
                        <span class="tok-str">'f'</span> =&gt; <span class="tok-kw">return</span> .<span class="tok-null">false</span>,
                        <span class="tok-str">'n'</span> =&gt; <span class="tok-kw">return</span> .<span class="tok-null">null</span>,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },

                .post_value =&gt; {
                    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> self.skipWhitespaceCheckEnd()) <span class="tok-kw">return</span> .end_of_document;

                    <span class="tok-kw">const</span> c = self.input[self.cursor];
                    <span class="tok-kw">if</span> (self.string_is_object_key) {
                        self.string_is_object_key = <span class="tok-null">false</span>;
                        <span class="tok-kw">switch</span> (c) {
                            <span class="tok-str">':'</span> =&gt; {
                                self.cursor += <span class="tok-number">1</span>;
                                self.state = .value;
                                <span class="tok-kw">continue</span> :state_loop;
                            },
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                        }
                    }

                    <span class="tok-kw">switch</span> (c) {
                        <span class="tok-str">'}'</span> =&gt; <span class="tok-kw">return</span> .object_end,
                        <span class="tok-str">']'</span> =&gt; <span class="tok-kw">return</span> .array_end,
                        <span class="tok-str">','</span> =&gt; {
                            <span class="tok-kw">switch</span> (self.stack.peek()) {
                                <a href="std.json.scanner.html#std.json.scanner.OBJECT_MODE">OBJECT_MODE</a> =&gt; {
                                    self.state = .object_post_comma;
                                },
                                <a href="std.json.scanner.html#std.json.scanner.ARRAY_MODE">ARRAY_MODE</a> =&gt; {
                                    self.state = .value;
                                },
                            }
                            self.cursor += <span class="tok-number">1</span>;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },

                .object_start =&gt; {
                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {
                        <span class="tok-str">'&quot;'</span> =&gt; <span class="tok-kw">return</span> .string,
                        <span class="tok-str">'}'</span> =&gt; <span class="tok-kw">return</span> .object_end,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },
                .object_post_comma =&gt; {
                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {
                        <span class="tok-str">'&quot;'</span> =&gt; <span class="tok-kw">return</span> .string,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,
                    }
                },

                .array_start =&gt; {
                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {
                        <span class="tok-str">']'</span> =&gt; <span class="tok-kw">return</span> .array_end,
                        <span class="tok-kw">else</span> =&gt; {
                            self.state = .value;
                            <span class="tok-kw">continue</span> :state_loop;
                        },
                    }
                },

                .number_minus,
                .number_leading_zero,
                .number_int,
                .number_post_dot,
                .number_frac,
                .number_post_e,
                .number_post_e_sign,
                .number_exp,
                =&gt; <span class="tok-kw">return</span> .number,

                .string,
                .string_backslash,
                .string_backslash_u,
                .string_backslash_u_1,
                .string_backslash_u_2,
                .string_backslash_u_3,
                .string_surrogate_half,
                .string_surrogate_half_backslash,
                .string_surrogate_half_backslash_u,
                .string_surrogate_half_backslash_u_1,
                .string_surrogate_half_backslash_u_2,
                .string_surrogate_half_backslash_u_3,
                =&gt; <span class="tok-kw">return</span> .string,

                .string_utf8_last_byte,
                .string_utf8_second_to_last_byte,
                .string_utf8_second_to_last_byte_guard_against_overlong,
                .string_utf8_second_to_last_byte_guard_against_surrogate_half,
                .string_utf8_third_to_last_byte,
                .string_utf8_third_to_last_byte_guard_against_overlong,
                .string_utf8_third_to_last_byte_guard_against_too_large,
                =&gt; <span class="tok-kw">return</span> .string,

                .literal_t,
                .literal_tr,
                .literal_tru,
                =&gt; <span class="tok-kw">return</span> .<span class="tok-null">true</span>,
                .literal_f,
                .literal_fa,
                .literal_fal,
                .literal_fals,
                =&gt; <span class="tok-kw">return</span> .<span class="tok-null">false</span>,
                .literal_n,
                .literal_nu,
                .literal_nul,
                =&gt; <span class="tok-kw">return</span> .<span class="tok-null">null</span>,
            }
            <span class="tok-kw">unreachable</span>;
        }
    }

    <span class="tok-kw">const</span> State = <span class="tok-kw">enum</span> {
        value,
        post_value,

        object_start,
        object_post_comma,

        array_start,

        number_minus,
        number_leading_zero,
        number_int,
        number_post_dot,
        number_frac,
        number_post_e,
        number_post_e_sign,
        number_exp,

        string,
        string_backslash,
        string_backslash_u,
        string_backslash_u_1,
        string_backslash_u_2,
        string_backslash_u_3,
        string_surrogate_half,
        string_surrogate_half_backslash,
        string_surrogate_half_backslash_u,
        string_surrogate_half_backslash_u_1,
        string_surrogate_half_backslash_u_2,
        string_surrogate_half_backslash_u_3,<span class="tok-comment">

        // From http://unicode.org/mail-arch/unicode-ml/y2003-m02/att-0467/01-The_Algorithm_to_Valide_an_UTF-8_String
        </span>string_utf8_last_byte,<span class="tok-comment"> // State A
        </span>string_utf8_second_to_last_byte,<span class="tok-comment"> // State B
        </span>string_utf8_second_to_last_byte_guard_against_overlong,<span class="tok-comment"> // State C
        </span>string_utf8_second_to_last_byte_guard_against_surrogate_half,<span class="tok-comment"> // State D
        </span>string_utf8_third_to_last_byte,<span class="tok-comment"> // State E
        </span>string_utf8_third_to_last_byte_guard_against_overlong,<span class="tok-comment"> // State F
        </span>string_utf8_third_to_last_byte_guard_against_too_large,<span class="tok-comment"> // State G

        </span>literal_t,
        literal_tr,
        literal_tru,
        literal_f,
        literal_fa,
        literal_fal,
        literal_fals,
        literal_n,
        literal_nu,
        literal_nul,
    };

    <span class="tok-kw">fn</span> <span class="tok-fn">expectByte</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) !<span class="tok-type">u8</span> {
        <span class="tok-kw">if</span> (self.cursor &lt; self.input.len) {
            <span class="tok-kw">return</span> self.input[self.cursor];
        }<span class="tok-comment">
        // No byte.
        </span><span class="tok-kw">if</span> (self.is_end_of_input) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfInput;
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BufferUnderrun;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">skipWhitespace</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
        <span class="tok-kw">while</span> (self.cursor &lt; self.input.len) : (self.cursor += <span class="tok-number">1</span>) {
            <span class="tok-kw">switch</span> (self.input[self.cursor]) {<span class="tok-comment">
                // Whitespace
                </span><span class="tok-str">' '</span>, <span class="tok-str">'\t'</span>, <span class="tok-str">'\r'</span> =&gt; <span class="tok-kw">continue</span>,
                <span class="tok-str">'\n'</span> =&gt; {
                    <span class="tok-kw">if</span> (self.diagnostics) |diag| {
                        diag.line_number += <span class="tok-number">1</span>;<span class="tok-comment">
                        // This will count the newline itself,
                        // which means a straight-forward subtraction will give a 1-based column number.
                        </span>diag.line_start_cursor = self.cursor;
                    }
                    <span class="tok-kw">continue</span>;
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span>,
            }
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">skipWhitespaceExpectByte</span>(self: *<span class="tok-builtin">@This</span>()) !<span class="tok-type">u8</span> {
        self.skipWhitespace();
        <span class="tok-kw">return</span> self.expectByte();
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">skipWhitespaceCheckEnd</span>(self: *<span class="tok-builtin">@This</span>()) !<span class="tok-type">bool</span> {
        self.skipWhitespace();
        <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) {<span class="tok-comment">
            // End of buffer.
            </span><span class="tok-kw">if</span> (self.is_end_of_input) {<span class="tok-comment">
                // End of everything.
                </span><span class="tok-kw">if</span> (self.stackHeight() == <span class="tok-number">0</span>) {<span class="tok-comment">
                    // We did it!
                    </span><span class="tok-kw">return</span> <span class="tok-null">true</span>;
                }
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfInput;
            }
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BufferUnderrun;
        }
        <span class="tok-kw">if</span> (self.stackHeight() == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError;
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">takeValueSlice</span>(self: *<span class="tok-builtin">@This</span>()) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">const</span> slice = self.input[self.value_start..self.cursor];
        self.value_start = self.cursor;
        <span class="tok-kw">return</span> slice;
    }
    <span class="tok-kw">fn</span> <span class="tok-fn">takeValueSliceMinusTrailingOffset</span>(self: *<span class="tok-builtin">@This</span>(), trailing_negative_offset: <span class="tok-type">usize</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {<span class="tok-comment">
        // Check if the escape sequence started before the current input buffer.
        // (The algebra here is awkward to avoid unsigned underflow,
        //  but it's just making sure the slice on the next line isn't UB.)
        </span><span class="tok-kw">if</span> (self.cursor &lt;= self.value_start + trailing_negative_offset) <span class="tok-kw">return</span> <span class="tok-str">&quot;&quot;</span>;
        <span class="tok-kw">const</span> slice = self.input[self.value_start .. self.cursor - trailing_negative_offset];<span class="tok-comment">
        // When trailing_negative_offset is non-zero, setting self.value_start doesn't matter,
        // because we always set it again while emitting the .partial_string_escaped_*.
        </span>self.value_start = self.cursor;
        <span class="tok-kw">return</span> slice;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">endOfBufferInNumber</span>(self: *<span class="tok-builtin">@This</span>(), allow_end: <span class="tok-type">bool</span>) !<a href="std.json.scanner.Token.html">Token</a> {
        <span class="tok-kw">const</span> slice = self.takeValueSlice();
        <span class="tok-kw">if</span> (self.is_end_of_input) {
            <span class="tok-kw">if</span> (!allow_end) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfInput;
            self.state = .post_value;
            <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .number = slice };
        }
        <span class="tok-kw">if</span> (slice.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BufferUnderrun;
        <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .partial_number = slice };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">endOfBufferInString</span>(self: *<span class="tok-builtin">@This</span>()) !<a href="std.json.scanner.Token.html">Token</a> {
        <span class="tok-kw">if</span> (self.is_end_of_input) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfInput;
        <span class="tok-kw">const</span> slice = self.takeValueSliceMinusTrailingOffset(<span class="tok-kw">switch</span> (self.state) {<span class="tok-comment">
            // Don't include the escape sequence in the partial string.
            </span>.string_backslash =&gt; <span class="tok-number">1</span>,
            .string_backslash_u =&gt; <span class="tok-number">2</span>,
            .string_backslash_u_1 =&gt; <span class="tok-number">3</span>,
            .string_backslash_u_2 =&gt; <span class="tok-number">4</span>,
            .string_backslash_u_3 =&gt; <span class="tok-number">5</span>,
            .string_surrogate_half =&gt; <span class="tok-number">6</span>,
            .string_surrogate_half_backslash =&gt; <span class="tok-number">7</span>,
            .string_surrogate_half_backslash_u =&gt; <span class="tok-number">8</span>,
            .string_surrogate_half_backslash_u_1 =&gt; <span class="tok-number">9</span>,
            .string_surrogate_half_backslash_u_2 =&gt; <span class="tok-number">10</span>,
            .string_surrogate_half_backslash_u_3 =&gt; <span class="tok-number">11</span>,<span class="tok-comment">

            // Include everything up to the cursor otherwise.
            </span>.string,
            .string_utf8_last_byte,
            .string_utf8_second_to_last_byte,
            .string_utf8_second_to_last_byte_guard_against_overlong,
            .string_utf8_second_to_last_byte_guard_against_surrogate_half,
            .string_utf8_third_to_last_byte,
            .string_utf8_third_to_last_byte_guard_against_overlong,
            .string_utf8_third_to_last_byte_guard_against_too_large,
            =&gt; <span class="tok-number">0</span>,

            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        });
        <span class="tok-kw">if</span> (slice.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BufferUnderrun;
        <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .partial_string = slice };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">partialStringCodepoint</span>(code_point: <span class="tok-type">u21</span>) <a href="std.json.scanner.Token.html">Token</a> {
        <span class="tok-kw">var</span> buf: [<span class="tok-number">4</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">switch</span> (<a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8Encode">utf8Encode</a>(code_point, &amp;buf) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>) {
            <span class="tok-number">1</span> =&gt; <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .partial_string_escaped_1 = buf[<span class="tok-number">0</span>..<span class="tok-number">1</span>].* },
            <span class="tok-number">2</span> =&gt; <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .partial_string_escaped_2 = buf[<span class="tok-number">0</span>..<span class="tok-number">2</span>].* },
            <span class="tok-number">3</span> =&gt; <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .partial_string_escaped_3 = buf[<span class="tok-number">0</span>..<span class="tok-number">3</span>].* },
            <span class="tok-number">4</span> =&gt; <span class="tok-kw">return</span> <a href="std.json.scanner.Token.html">Token</a>{ .partial_string_escaped_4 = buf[<span class="tok-number">0</span>..<span class="tok-number">4</span>].* },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
