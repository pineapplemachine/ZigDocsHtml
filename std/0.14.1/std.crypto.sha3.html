<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">crypto</a></li><li><a href="std.crypto.sha3.html" class="active">sha3</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.crypto.sha3" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.crypto.sha3</span><a href="#src.zig-std.crypto.sha3">[src]</a></h1><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.crypto.sha3.NistLengthEncoding.html">std.crypto.sha3.NistLengthEncoding</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.crypto.sha3.Sha3_224" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Sha3_224</span><a href="#src.zig-std.crypto.sha3.Sha3_224">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.Sha3_224">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Sha3_224 = <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Keccak</a>(<span class="tok-number">1600</span>, <span class="tok-number">224</span>, <span class="tok-number">0x06</span>, <span class="tok-number">24</span>)</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.Sha3_256" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Sha3_256</span><a href="#src.zig-std.crypto.sha3.Sha3_256">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.Sha3_256">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Sha3_256 = <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Keccak</a>(<span class="tok-number">1600</span>, <span class="tok-number">256</span>, <span class="tok-number">0x06</span>, <span class="tok-number">24</span>)</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.Sha3_384" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Sha3_384</span><a href="#src.zig-std.crypto.sha3.Sha3_384">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.Sha3_384">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Sha3_384 = <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Keccak</a>(<span class="tok-number">1600</span>, <span class="tok-number">384</span>, <span class="tok-number">0x06</span>, <span class="tok-number">24</span>)</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.Sha3_512" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Sha3_512</span><a href="#src.zig-std.crypto.sha3.Sha3_512">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.Sha3_512">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Sha3_512 = <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Keccak</a>(<span class="tok-number">1600</span>, <span class="tok-number">512</span>, <span class="tok-number">0x06</span>, <span class="tok-number">24</span>)</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.Keccak256" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Keccak256</span><a href="#src.zig-std.crypto.sha3.Keccak256">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.Keccak256">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Keccak256 = <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Keccak</a>(<span class="tok-number">1600</span>, <span class="tok-number">256</span>, <span class="tok-number">0x01</span>, <span class="tok-number">24</span>)</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.Keccak512" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Keccak512</span><a href="#src.zig-std.crypto.sha3.Keccak512">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.Keccak512">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Keccak512 = <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Keccak</a>(<span class="tok-number">1600</span>, <span class="tok-number">512</span>, <span class="tok-number">0x01</span>, <span class="tok-number">24</span>)</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.Shake128" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Shake128</span><a href="#src.zig-std.crypto.sha3.Shake128">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.Shake128">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Shake128 = <a href="std.crypto.sha3.html#std.crypto.sha3.Shake">Shake</a>(<span class="tok-number">128</span>)</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.Shake256" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Shake256</span><a href="#src.zig-std.crypto.sha3.Shake256">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.Shake256">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Shake256 = <a href="std.crypto.sha3.html#std.crypto.sha3.Shake">Shake</a>(<span class="tok-number">256</span>)</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.CShake128" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">CShake128</span><a href="#src.zig-std.crypto.sha3.CShake128">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.CShake128">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CShake128 = <a href="std.crypto.sha3.html#std.crypto.sha3.CShake">CShake</a>(<span class="tok-number">128</span>, <span class="tok-null">null</span>)</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.CShake256" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">CShake256</span><a href="#src.zig-std.crypto.sha3.CShake256">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.CShake256">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CShake256 = <a href="std.crypto.sha3.html#std.crypto.sha3.CShake">CShake</a>(<span class="tok-number">256</span>, <span class="tok-null">null</span>)</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.KMac128" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">KMac128</span><a href="#src.zig-std.crypto.sha3.KMac128">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.KMac128">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KMac128 = <a href="std.crypto.sha3.html#std.crypto.sha3.KMac">KMac</a>(<span class="tok-number">128</span>)</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.KMac256" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">KMac256</span><a href="#src.zig-std.crypto.sha3.KMac256">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.KMac256">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KMac256 = <a href="std.crypto.sha3.html#std.crypto.sha3.KMac">KMac</a>(<span class="tok-number">256</span>)</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.TupleHash128" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">TupleHash128</span><a href="#src.zig-std.crypto.sha3.TupleHash128">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.TupleHash128">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TupleHash128 = <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHash">TupleHash</a>(<span class="tok-number">128</span>)</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.TupleHash256" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">TupleHash256</span><a href="#src.zig-std.crypto.sha3.TupleHash256">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.TupleHash256">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TupleHash256 = <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHash">TupleHash</a>(<span class="tok-number">256</span>)</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.TurboShake128" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">TurboShake128</span><a href="#src.zig-std.crypto.sha3.TurboShake128">[src]</a></h2><div class="tldDocs"><p>TurboSHAKE128 is a XOF (a secure hash function with a variable output length), with a 128 bit security level.
It is based on the same permutation as SHA3 and SHAKE128, but which much higher performance.
The delimiter is 0x1f by default, but can be changed for context-separation.
For a protocol that uses both KangarooTwelve and TurboSHAKE128, it is recommended to avoid using 0x06, 0x07 or 0x0b for the delimiter.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>delim: ?<span class="tok-type">u7</span></code></pre></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>st: State</code></pre></div><div><pre><code>buf: [State.rate]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span></code></pre></div><div><pre><code>offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span></code></pre></div><div><pre><code>padded: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.TurboShake128">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">TurboShake128</span>(delim: ?<span class="tok-type">u7</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.TurboShake">TurboShake</a>(<span class="tok-number">128</span>, delim);
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.TurboShake256" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">TurboShake256</span><a href="#src.zig-std.crypto.sha3.TurboShake256">[src]</a></h2><div class="tldDocs"><p>TurboSHAKE256 is a XOF (a secure hash function with a variable output length), with a 256 bit security level.
It is based on the same permutation as SHA3 and SHAKE256, but which much higher performance.
The delimiter is 0x1f by default, but can be changed for context-separation.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>delim: ?<span class="tok-type">u7</span></code></pre></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>st: State</code></pre></div><div><pre><code>buf: [State.rate]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span></code></pre></div><div><pre><code>offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span></code></pre></div><div><pre><code>padded: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.TurboShake256">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">TurboShake256</span>(<span class="tok-kw">comptime</span> delim: ?<span class="tok-type">u7</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.TurboShake">TurboShake</a>(<span class="tok-number">256</span>, delim);
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.Keccak" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Keccak</span><a href="#src.zig-std.crypto.sha3.Keccak">[src]</a></h2><div class="tldDocs"><p>A generic Keccak hash function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>f: <span class="tok-type">u11</span></code></pre></div><div><pre><code>output_bits: <span class="tok-type">u11</span></code></pre></div><div><pre><code>default_delim: <span class="tok-type">u8</span></code></pre></div><div><pre><code>rounds: <span class="tok-type">u5</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.crypto.sha3.Keccak.Options.html">std.crypto.sha3.Keccak.Options</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.crypto.sha3.Keccak.Writer" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Writer</span><a href="#src.zig-std.crypto.sha3.Keccak.Writer">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.Keccak.Writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.Error">Error</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.write">write</a>)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>st: State</code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.crypto.sha3.Keccak.digest_length" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">digest_length</span><a href="#src.zig-std.crypto.sha3.Keccak.digest_length">[src]</a></h3><div class="tldDocs"><p>The output length, in bytes.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.Keccak.digest_length">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> digest_length = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">comptime_int</span>, output_bits, <span class="tok-number">8</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span></code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.Keccak.block_length" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">block_length</span><a href="#src.zig-std.crypto.sha3.Keccak.block_length">[src]</a></h3><div class="tldDocs"><p>The block length, or rate, in bytes.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.Keccak.block_length">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> block_length = State.rate</code></pre></details></div></div></div></div><div class="sectErrSets"><h3 class="sectionHeader">Error Sets</h3><div class="listErrSets"><div class="decl"><h3 id="std.crypto.sha3.Keccak.Error" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">Error</span><a href="#src.zig-std.crypto.sha3.Keccak.Error">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.Keccak.Error">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.crypto.sha3.Keccak.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.crypto.sha3.Keccak.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(options: <a href="std.crypto.sha3.Keccak.Options.html">Options</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a></code></pre></div><div class="tldDocs"><p>Initialize a Keccak hash function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>options: <a href="std.crypto.sha3.Keccak.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.Keccak.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(options: <a href="std.crypto.sha3.Keccak.Options.html">Options</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a> {
    <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>{ .st = .{ .delim = options.delim } };
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.Keccak.hash" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">hash</span><a href="#src.zig-std.crypto.sha3.Keccak.hash">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out: *[<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.digest_length">digest_length</a>]<span class="tok-type">u8</span>, options: <a href="std.crypto.sha3.Keccak.Options.html">Options</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Hash a slice of bytes.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>out: *[<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.digest_length">digest_length</a>]<span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.crypto.sha3.Keccak.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.Keccak.hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out: *[<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.digest_length">digest_length</a>]<span class="tok-type">u8</span>, options: <a href="std.crypto.sha3.Keccak.Options.html">Options</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> st = <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>.<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.init">init</a>(options);
    st.update(bytes);
    st.final(out);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.Keccak.update" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">update</span><a href="#src.zig-std.crypto.sha3.Keccak.update">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Absorb a slice of bytes into the state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.Keccak.update">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    self.st.absorb(bytes);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.Keccak.final" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">final</span><a href="#src.zig-std.crypto.sha3.Keccak.final">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>, out: *[<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.digest_length">digest_length</a>]<span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Return the hash of the absorbed bytes.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a></code></pre></div><div><pre><code>out: *[<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.digest_length">digest_length</a>]<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.Keccak.final">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>, out: *[<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.digest_length">digest_length</a>]<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    self.st.pad();
    self.st.squeeze(out[<span class="tok-number">0</span>..]);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.Keccak.writer" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writer</span><a href="#src.zig-std.crypto.sha3.Keccak.writer">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.Writer">Writer</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.Keccak.writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.Writer">Writer</a> {
    <span class="tok-kw">return</span> .{ .context = self };
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.Keccak">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Keccak</span>(<span class="tok-kw">comptime</span> f: <span class="tok-type">u11</span>, <span class="tok-kw">comptime</span> output_bits: <span class="tok-type">u11</span>, <span class="tok-kw">comptime</span> default_delim: <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> rounds: <span class="tok-type">u5</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(output_bits &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> output_bits * <span class="tok-number">2</span> &lt; f <span class="tok-kw">and</span> output_bits % <span class="tok-number">8</span> == <span class="tok-number">0</span>);<span class="tok-comment"> // invalid output length

    </span><span class="tok-kw">const</span> State = <a href="std.crypto.keccak_p.html#std.crypto.keccak_p.State">KeccakState</a>(f, output_bits * <span class="tok-number">2</span>, rounds);

    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        st: State,

        <span class="tok-comment">/// The output length, in bytes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> digest_length = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">comptime_int</span>, output_bits, <span class="tok-number">8</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
        <span class="tok-comment">/// The block length, or rate, in bytes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> block_length = State.rate;
        <span class="tok-comment">/// The delimiter can be overwritten in the options.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Options = <span class="tok-kw">struct</span> { delim: <span class="tok-type">u8</span> = default_delim };

        <span class="tok-comment">/// Initialize a Keccak hash function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(options: <a href="std.crypto.sha3.Keccak.Options.html">Options</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a> {
            <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>{ .st = .{ .delim = options.delim } };
        }

        <span class="tok-comment">/// Hash a slice of bytes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out: *[<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.digest_length">digest_length</a>]<span class="tok-type">u8</span>, options: <a href="std.crypto.sha3.Keccak.Options.html">Options</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">var</span> st = <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>.<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.init">init</a>(options);
            st.update(bytes);
            st.final(out);
        }

        <span class="tok-comment">/// Absorb a slice of bytes into the state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            self.st.absorb(bytes);
        }

        <span class="tok-comment">/// Return the hash of the absorbed bytes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>, out: *[<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.digest_length">digest_length</a>]<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            self.st.pad();
            self.st.squeeze(out[<span class="tok-number">0</span>..]);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{};
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.Error">Error</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.write">write</a>);

        <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.Error">Error</a>!<span class="tok-type">usize</span> {
            self.update(bytes);
            <span class="tok-kw">return</span> bytes.len;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.Writer">Writer</a> {
            <span class="tok-kw">return</span> .{ .context = self };
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.Shake" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Shake</span><a href="#src.zig-std.crypto.sha3.Shake">[src]</a></h2><div class="tldDocs"><p>The SHAKE extendable output hash function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>security_level: <span class="tok-type">u11</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.crypto.sha3.ShakeLike.Options.html">std.crypto.sha3.ShakeLike.Options</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.Writer" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Writer</span><a href="#src.zig-std.crypto.sha3.ShakeLike.Writer">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.Writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike.Error">Error</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike.write">write</a>)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>st: State</code></pre></div><div><pre><code>buf: [State.rate]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span></code></pre></div><div><pre><code>offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span></code></pre></div><div><pre><code>padded: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.digest_length" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">digest_length</span><a href="#src.zig-std.crypto.sha3.ShakeLike.digest_length">[src]</a></h3><div class="tldDocs"><p>The recommended output length, in bytes.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.digest_length">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> digest_length = security_level / <span class="tok-number">8</span> * <span class="tok-number">2</span></code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.block_length" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">block_length</span><a href="#src.zig-std.crypto.sha3.ShakeLike.block_length">[src]</a></h3><div class="tldDocs"><p>The block length, or rate, in bytes.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.block_length">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> block_length = State.rate</code></pre></details></div></div></div></div><div class="sectErrSets"><h3 class="sectionHeader">Error Sets</h3><div class="listErrSets"><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.Error" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">Error</span><a href="#src.zig-std.crypto.sha3.ShakeLike.Error">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.Error">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.crypto.sha3.ShakeLike.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(options: <a href="std.crypto.sha3.ShakeLike.Options.html">Options</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a></code></pre></div><div class="tldDocs"><p>Initialize a SHAKE extensible hash function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>options: <a href="std.crypto.sha3.ShakeLike.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(options: <a href="std.crypto.sha3.ShakeLike.Options.html">Options</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a> {
    <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>{ .st = .{ .delim = options.delim } };
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.hash" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">hash</span><a href="#src.zig-std.crypto.sha3.ShakeLike.hash">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out: []<span class="tok-type">u8</span>, options: <a href="std.crypto.sha3.ShakeLike.Options.html">Options</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Hash a slice of bytes.
<code>out</code> can be any length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>out: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.crypto.sha3.ShakeLike.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out: []<span class="tok-type">u8</span>, options: <a href="std.crypto.sha3.ShakeLike.Options.html">Options</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> st = <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>.<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike.init">init</a>(options);
    st.update(bytes);
    st.squeeze(out);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.update" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">update</span><a href="#src.zig-std.crypto.sha3.ShakeLike.update">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Absorb a slice of bytes into the state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.update">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    self.st.absorb(bytes);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.squeeze" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">squeeze</span><a href="#src.zig-std.crypto.sha3.ShakeLike.squeeze">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">squeeze</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>, out_: []<span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Squeeze a slice of bytes from the state.
<code>out</code> can be any length, and the function can be called multiple times.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a></code></pre></div><div><pre><code>out_: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.squeeze">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">squeeze</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>, out_: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!self.padded) {
        self.st.pad();
        self.padded = <span class="tok-null">true</span>;
    }
    <span class="tok-kw">var</span> out = out_;
    <span class="tok-kw">if</span> (self.offset &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> left = self.buf.len - self.offset;
        <span class="tok-kw">if</span> (left &gt; <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> n = <span class="tok-builtin">@min</span>(left, out.len);
            <span class="tok-builtin">@memcpy</span>(out[<span class="tok-number">0</span>..n], self.buf[self.offset..][<span class="tok-number">0</span>..n]);
            out = out[n..];
            self.offset += n;
            <span class="tok-kw">if</span> (out.len == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span>;
            }
        }
    }
    <span class="tok-kw">const</span> full_blocks = out[<span class="tok-number">0</span> .. out.len - out.len % State.rate];
    <span class="tok-kw">if</span> (full_blocks.len &gt; <span class="tok-number">0</span>) {
        self.st.squeeze(full_blocks);
        out = out[full_blocks.len..];
    }
    <span class="tok-kw">if</span> (out.len &gt; <span class="tok-number">0</span>) {
        self.st.squeeze(self.buf[<span class="tok-number">0</span>..]);
        <span class="tok-builtin">@memcpy</span>(out[<span class="tok-number">0</span>..], self.buf[<span class="tok-number">0</span>..out.len]);
        self.offset = out.len;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.final" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">final</span><a href="#src.zig-std.crypto.sha3.ShakeLike.final">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Return the hash of the absorbed bytes.
<code>out</code> can be of any length, but the function must not be called multiple times (use <code>squeeze</code> for that purpose instead).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a></code></pre></div><div><pre><code>out: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.final">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    self.squeeze(out);
    self.st.st.clear(<span class="tok-number">0</span>, State.rate);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.fillBlock" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fillBlock</span><a href="#src.zig-std.crypto.sha3.ShakeLike.fillBlock">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fillBlock</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Align the input to a block boundary.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.fillBlock">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fillBlock</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>) <span class="tok-type">void</span> {
    self.st.fillBlock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.writer" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writer</span><a href="#src.zig-std.crypto.sha3.ShakeLike.writer">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike.Writer">Writer</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike.Writer">Writer</a> {
    <span class="tok-kw">return</span> .{ .context = self };
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.Shake">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Shake</span>(<span class="tok-kw">comptime</span> security_level: <span class="tok-type">u11</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">ShakeLike</a>(security_level, <span class="tok-number">0x1f</span>, <span class="tok-number">24</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.TurboShake" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">TurboShake</span><a href="#src.zig-std.crypto.sha3.TurboShake">[src]</a></h2><div class="tldDocs"><p>The TurboSHAKE extendable output hash function.
It is based on the same permutation as SHA3 and SHAKE, but which much higher performance.
The delimiter is 0x1f by default, but can be changed for context-separation.
<a href="https://eprint.iacr.org/2023/342">https://eprint.iacr.org/2023/342</a></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>security_level: <span class="tok-type">u11</span></code></pre></div><div><pre><code>delim: ?<span class="tok-type">u7</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.crypto.sha3.ShakeLike.Options.html">std.crypto.sha3.ShakeLike.Options</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.Writer" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Writer</span><a href="#src.zig-std.crypto.sha3.ShakeLike.Writer">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.Writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike.Error">Error</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike.write">write</a>)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>st: State</code></pre></div><div><pre><code>buf: [State.rate]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span></code></pre></div><div><pre><code>offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span></code></pre></div><div><pre><code>padded: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.digest_length" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">digest_length</span><a href="#src.zig-std.crypto.sha3.ShakeLike.digest_length">[src]</a></h3><div class="tldDocs"><p>The recommended output length, in bytes.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.digest_length">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> digest_length = security_level / <span class="tok-number">8</span> * <span class="tok-number">2</span></code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.block_length" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">block_length</span><a href="#src.zig-std.crypto.sha3.ShakeLike.block_length">[src]</a></h3><div class="tldDocs"><p>The block length, or rate, in bytes.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.block_length">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> block_length = State.rate</code></pre></details></div></div></div></div><div class="sectErrSets"><h3 class="sectionHeader">Error Sets</h3><div class="listErrSets"><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.Error" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">Error</span><a href="#src.zig-std.crypto.sha3.ShakeLike.Error">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.Error">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.crypto.sha3.ShakeLike.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(options: <a href="std.crypto.sha3.ShakeLike.Options.html">Options</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a></code></pre></div><div class="tldDocs"><p>Initialize a SHAKE extensible hash function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>options: <a href="std.crypto.sha3.ShakeLike.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(options: <a href="std.crypto.sha3.ShakeLike.Options.html">Options</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a> {
    <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>{ .st = .{ .delim = options.delim } };
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.hash" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">hash</span><a href="#src.zig-std.crypto.sha3.ShakeLike.hash">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out: []<span class="tok-type">u8</span>, options: <a href="std.crypto.sha3.ShakeLike.Options.html">Options</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Hash a slice of bytes.
<code>out</code> can be any length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>out: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.crypto.sha3.ShakeLike.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out: []<span class="tok-type">u8</span>, options: <a href="std.crypto.sha3.ShakeLike.Options.html">Options</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> st = <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>.<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike.init">init</a>(options);
    st.update(bytes);
    st.squeeze(out);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.update" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">update</span><a href="#src.zig-std.crypto.sha3.ShakeLike.update">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Absorb a slice of bytes into the state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.update">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    self.st.absorb(bytes);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.squeeze" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">squeeze</span><a href="#src.zig-std.crypto.sha3.ShakeLike.squeeze">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">squeeze</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>, out_: []<span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Squeeze a slice of bytes from the state.
<code>out</code> can be any length, and the function can be called multiple times.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a></code></pre></div><div><pre><code>out_: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.squeeze">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">squeeze</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>, out_: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!self.padded) {
        self.st.pad();
        self.padded = <span class="tok-null">true</span>;
    }
    <span class="tok-kw">var</span> out = out_;
    <span class="tok-kw">if</span> (self.offset &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> left = self.buf.len - self.offset;
        <span class="tok-kw">if</span> (left &gt; <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> n = <span class="tok-builtin">@min</span>(left, out.len);
            <span class="tok-builtin">@memcpy</span>(out[<span class="tok-number">0</span>..n], self.buf[self.offset..][<span class="tok-number">0</span>..n]);
            out = out[n..];
            self.offset += n;
            <span class="tok-kw">if</span> (out.len == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span>;
            }
        }
    }
    <span class="tok-kw">const</span> full_blocks = out[<span class="tok-number">0</span> .. out.len - out.len % State.rate];
    <span class="tok-kw">if</span> (full_blocks.len &gt; <span class="tok-number">0</span>) {
        self.st.squeeze(full_blocks);
        out = out[full_blocks.len..];
    }
    <span class="tok-kw">if</span> (out.len &gt; <span class="tok-number">0</span>) {
        self.st.squeeze(self.buf[<span class="tok-number">0</span>..]);
        <span class="tok-builtin">@memcpy</span>(out[<span class="tok-number">0</span>..], self.buf[<span class="tok-number">0</span>..out.len]);
        self.offset = out.len;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.final" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">final</span><a href="#src.zig-std.crypto.sha3.ShakeLike.final">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Return the hash of the absorbed bytes.
<code>out</code> can be of any length, but the function must not be called multiple times (use <code>squeeze</code> for that purpose instead).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a></code></pre></div><div><pre><code>out: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.final">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    self.squeeze(out);
    self.st.st.clear(<span class="tok-number">0</span>, State.rate);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.fillBlock" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fillBlock</span><a href="#src.zig-std.crypto.sha3.ShakeLike.fillBlock">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fillBlock</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Align the input to a block boundary.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.fillBlock">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fillBlock</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>) <span class="tok-type">void</span> {
    self.st.fillBlock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.ShakeLike.writer" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writer</span><a href="#src.zig-std.crypto.sha3.ShakeLike.writer">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike.Writer">Writer</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.ShakeLike.writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike.Writer">Writer</a> {
    <span class="tok-kw">return</span> .{ .context = self };
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.TurboShake">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">TurboShake</span>(<span class="tok-kw">comptime</span> security_level: <span class="tok-type">u11</span>, <span class="tok-kw">comptime</span> delim: ?<span class="tok-type">u7</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(security_level &lt;= <span class="tok-number">256</span>);
    <span class="tok-kw">const</span> d = delim <span class="tok-kw">orelse</span> <span class="tok-number">0x1f</span>;
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(d &gt;= <span class="tok-number">0x01</span>);<span class="tok-comment"> // delimiter must be &gt;= 1
    </span><span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">ShakeLike</a>(security_level, d, <span class="tok-number">12</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.CShake" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">CShake</span><a href="#src.zig-std.crypto.sha3.CShake">[src]</a></h2><div class="tldDocs"><p>The cSHAKE extendable output hash function.
cSHAKE is similar to SHAKE, but in addition to the input message, it also takes an optional context (aka customization string).</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>security_level: <span class="tok-type">u11</span></code></pre></div><div><pre><code>fname: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.crypto.sha3.CShakeLike.Options.html">std.crypto.sha3.CShakeLike.Options</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.crypto.sha3.CShakeLike.Writer" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Writer</span><a href="#src.zig-std.crypto.sha3.CShakeLike.Writer">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.CShakeLike.Writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.Error">Error</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.write">write</a>)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>shaker: <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.Shaker">Shaker</a></code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.crypto.sha3.CShakeLike.digest_length" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">digest_length</span><a href="#src.zig-std.crypto.sha3.CShakeLike.digest_length">[src]</a></h3><div class="tldDocs"><p>The recommended output length, in bytes.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.CShakeLike.digest_length">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> digest_length = <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.Shaker">Shaker</a>.<a href="#">digest_length</a></code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.CShakeLike.block_length" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">block_length</span><a href="#src.zig-std.crypto.sha3.CShakeLike.block_length">[src]</a></h3><div class="tldDocs"><p>The block length, or rate, in bytes.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.CShakeLike.block_length">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> block_length = <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.Shaker">Shaker</a>.<a href="#">block_length</a></code></pre></details></div></div></div></div><div class="sectErrSets"><h3 class="sectionHeader">Error Sets</h3><div class="listErrSets"><div class="decl"><h3 id="std.crypto.sha3.CShakeLike.Error" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">Error</span><a href="#src.zig-std.crypto.sha3.CShakeLike.Error">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.CShakeLike.Error">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.crypto.sha3.CShakeLike.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.crypto.sha3.CShakeLike.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(options: <a href="std.crypto.sha3.CShakeLike.Options.html">Options</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a></code></pre></div><div class="tldDocs"><p>Initialize a SHAKE extensible hash function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>options: <a href="std.crypto.sha3.CShakeLike.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.CShakeLike.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(options: <a href="std.crypto.sha3.CShakeLike.Options.html">Options</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a> {
    <span class="tok-kw">if</span> (fname == <span class="tok-null">null</span> <span class="tok-kw">and</span> options.context == <span class="tok-null">null</span>) {
        <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>{ .shaker = <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.Shaker">Shaker</a>.<a href="#">init</a>(.{ .delim = <span class="tok-number">0x1f</span> }) };
    }
    <span class="tok-kw">var</span> shaker = <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.Shaker">Shaker</a>.<a href="#">init</a>(.{});
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.Shaker">Shaker</a>.<a href="#">block_length</a> % <span class="tok-number">8</span> == <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> encoded_rate_len = <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.left, <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.block_length">block_length</a> / <span class="tok-number">8</span>);
    shaker.update(encoded_rate_len.slice());
    <span class="tok-kw">const</span> encoded_zero = <span class="tok-kw">comptime</span> <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.left, <span class="tok-number">0</span>);
    <span class="tok-kw">if</span> (fname) |name| {
        <span class="tok-kw">const</span> encoded_fname_len = <span class="tok-kw">comptime</span> <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.left, name.len);
        <span class="tok-kw">const</span> encoded_fname = <span class="tok-kw">comptime</span> encoded_fname_len.slice() ++ name;
        shaker.update(encoded_fname);
    } <span class="tok-kw">else</span> {
        shaker.update(encoded_zero.slice());
    }
    <span class="tok-kw">if</span> (options.context) |context| {
        <span class="tok-kw">const</span> encoded_context_len = <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.left, context.len);
        shaker.update(encoded_context_len.slice());
        shaker.update(context);
    } <span class="tok-kw">else</span> {
        shaker.update(encoded_zero.slice());
    }
    shaker.st.fillBlock();
    <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>{ .shaker = shaker };
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.CShakeLike.hash" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">hash</span><a href="#src.zig-std.crypto.sha3.CShakeLike.hash">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out: []<span class="tok-type">u8</span>, options: <a href="std.crypto.sha3.CShakeLike.Options.html">Options</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Hash a slice of bytes.
<code>out</code> can be any length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>out: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.crypto.sha3.CShakeLike.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.CShakeLike.hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out: []<span class="tok-type">u8</span>, options: <a href="std.crypto.sha3.CShakeLike.Options.html">Options</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> st = <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>.<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.init">init</a>(options);
    st.update(bytes);
    st.squeeze(out);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.CShakeLike.update" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">update</span><a href="#src.zig-std.crypto.sha3.CShakeLike.update">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Absorb a slice of bytes into the state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.CShakeLike.update">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    self.shaker.update(bytes);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.CShakeLike.squeeze" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">squeeze</span><a href="#src.zig-std.crypto.sha3.CShakeLike.squeeze">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">squeeze</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Squeeze a slice of bytes from the state.
<code>out</code> can be any length, and the function can be called multiple times.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a></code></pre></div><div><pre><code>out: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.CShakeLike.squeeze">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">squeeze</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    self.shaker.squeeze(out);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.CShakeLike.final" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">final</span><a href="#src.zig-std.crypto.sha3.CShakeLike.final">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Return the hash of the absorbed bytes.
<code>out</code> can be of any length, but the function must not be called multiple times (use <code>squeeze</code> for that purpose instead).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a></code></pre></div><div><pre><code>out: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.CShakeLike.final">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    self.shaker.final(out);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.CShakeLike.fillBlock" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fillBlock</span><a href="#src.zig-std.crypto.sha3.CShakeLike.fillBlock">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fillBlock</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Align the input to a block boundary.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.CShakeLike.fillBlock">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fillBlock</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>) <span class="tok-type">void</span> {
    self.shaker.fillBlock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.CShakeLike.writer" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writer</span><a href="#src.zig-std.crypto.sha3.CShakeLike.writer">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.Writer">Writer</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.CShakeLike.writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.Writer">Writer</a> {
    <span class="tok-kw">return</span> .{ .context = self };
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.CShake">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">CShake</span>(<span class="tok-kw">comptime</span> security_level: <span class="tok-type">u11</span>, <span class="tok-kw">comptime</span> fname: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">CShakeLike</a>(security_level, <span class="tok-number">0x04</span>, <span class="tok-number">24</span>, fname);
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.KMac" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">KMac</span><a href="#src.zig-std.crypto.sha3.KMac">[src]</a></h2><div class="tldDocs"><p>The KMAC extendable output authentication function.
KMAC is a keyed version of the cSHAKE function, with an optional context.
It can be used as an SHA-3 based alternative to HMAC, as well as a generic keyed XoF (extendable output function).</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>security_level: <span class="tok-type">u11</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.crypto.sha3.KMacLike.Options.html">std.crypto.sha3.KMacLike.Options</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.crypto.sha3.KMacLike.Writer" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Writer</span><a href="#src.zig-std.crypto.sha3.KMacLike.Writer">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.KMacLike.Writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike.Error">Error</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike.write">write</a>)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>cshaker: CShaker</code></pre></div><div><pre><code>xof_mode: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.crypto.sha3.KMacLike.mac_length" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">mac_length</span><a href="#src.zig-std.crypto.sha3.KMacLike.mac_length">[src]</a></h3><div class="tldDocs"><p>The recommended output length, in bytes.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.KMacLike.mac_length">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> mac_length = CShaker.digest_length</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.KMacLike.mac_length_min" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">mac_length_min</span><a href="#src.zig-std.crypto.sha3.KMacLike.mac_length_min">[src]</a></h3><div class="tldDocs"><p>The minimum output length, in bytes.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.KMacLike.mac_length_min">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> mac_length_min = <span class="tok-number">4</span></code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.KMacLike.key_length" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">key_length</span><a href="#src.zig-std.crypto.sha3.KMacLike.key_length">[src]</a></h3><div class="tldDocs"><p>The recommended key length, in bytes.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.KMacLike.key_length">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> key_length = security_level / <span class="tok-number">8</span></code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.KMacLike.key_length_min" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">key_length_min</span><a href="#src.zig-std.crypto.sha3.KMacLike.key_length_min">[src]</a></h3><div class="tldDocs"><p>The minimum key length, in bytes.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.KMacLike.key_length_min">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> key_length_min = <span class="tok-number">0</span></code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.KMacLike.block_length" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">block_length</span><a href="#src.zig-std.crypto.sha3.KMacLike.block_length">[src]</a></h3><div class="tldDocs"><p>The block length, or rate, in bytes.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.KMacLike.block_length">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> block_length = CShaker.block_length</code></pre></details></div></div></div></div><div class="sectErrSets"><h3 class="sectionHeader">Error Sets</h3><div class="listErrSets"><div class="decl"><h3 id="std.crypto.sha3.KMacLike.Error" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">Error</span><a href="#src.zig-std.crypto.sha3.KMacLike.Error">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.KMacLike.Error">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.crypto.sha3.KMacLike.initWithOptions" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initWithOptions</span><a href="#src.zig-std.crypto.sha3.KMacLike.initWithOptions">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initWithOptions</span>(key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.crypto.sha3.KMacLike.Options.html">Options</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a></code></pre></div><div class="tldDocs"><p>Initialize a state for the KMAC function, with an optional context and an arbitrary-long key.
If the context and key are going to be reused, the structure can be initialized once, and cloned for each message.
This is more efficient than reinitializing the state for each message at the cost of a small amount of memory.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.crypto.sha3.KMacLike.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.KMacLike.initWithOptions">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initWithOptions</span>(key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.crypto.sha3.KMacLike.Options.html">Options</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a> {
    <span class="tok-kw">var</span> cshaker = CShaker.init(.{ .context = options.context });
    <span class="tok-kw">const</span> encoded_rate_len = <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.left, <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike.block_length">block_length</a> / <span class="tok-number">8</span>);
    cshaker.update(encoded_rate_len.slice());
    <span class="tok-kw">const</span> encoded_key_len = <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.left, key.len);
    cshaker.update(encoded_key_len.slice());
    cshaker.update(key);
    cshaker.fillBlock();
    <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>{
        .cshaker = cshaker,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.KMacLike.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.crypto.sha3.KMacLike.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a></code></pre></div><div class="tldDocs"><p>Initialize a state for the KMAC function.
If the context and key are going to be reused, the structure can be initialized once, and cloned for each message.
This is more efficient than reinitializing the state for each message at the cost of a small amount of memory.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.KMacLike.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a> {
    <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike.initWithOptions">initWithOptions</a>(key, .{});
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.KMacLike.update" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">update</span><a href="#src.zig-std.crypto.sha3.KMacLike.update">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Add data to the state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a></code></pre></div><div><pre><code>b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.KMacLike.update">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    self.cshaker.update(b);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.KMacLike.final" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">final</span><a href="#src.zig-std.crypto.sha3.KMacLike.final">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Return an authentication tag for the current state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a></code></pre></div><div><pre><code>out: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.KMacLike.final">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> encoded_out_len = <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.right, out.len);
    self.update(encoded_out_len.slice());
    self.cshaker.final(out);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.KMacLike.squeeze" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">squeeze</span><a href="#src.zig-std.crypto.sha3.KMacLike.squeeze">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">squeeze</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Squeeze a slice of bytes from the state.
<code>out</code> can be any length, and the function can be called multiple times.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a></code></pre></div><div><pre><code>out: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.KMacLike.squeeze">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">squeeze</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!self.xof_mode) {
        <span class="tok-kw">const</span> encoded_out_len = <span class="tok-kw">comptime</span> <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.right, <span class="tok-number">0</span>);
        self.update(encoded_out_len.slice());
        self.xof_mode = <span class="tok-null">true</span>;
    }
    self.cshaker.squeeze(out);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.KMacLike.createWithOptions" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">createWithOptions</span><a href="#src.zig-std.crypto.sha3.KMacLike.createWithOptions">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createWithOptions</span>(out: []<span class="tok-type">u8</span>, msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.crypto.sha3.KMacLike.Options.html">Options</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Return an authentication tag for a message and a key, with an optional context.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>out: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.crypto.sha3.KMacLike.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.KMacLike.createWithOptions">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createWithOptions</span>(out: []<span class="tok-type">u8</span>, msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.crypto.sha3.KMacLike.Options.html">Options</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> ctx = <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>.<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike.initWithOptions">initWithOptions</a>(key, options);
    ctx.update(msg);
    ctx.final(out);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.KMacLike.create" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">create</span><a href="#src.zig-std.crypto.sha3.KMacLike.create">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(out: []<span class="tok-type">u8</span>, msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Return an authentication tag for a message and a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>out: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.KMacLike.create">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(out: []<span class="tok-type">u8</span>, msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> ctx = <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>.<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike.init">init</a>(key);
    ctx.update(msg);
    ctx.final(out);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.KMacLike.writer" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writer</span><a href="#src.zig-std.crypto.sha3.KMacLike.writer">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike.Writer">Writer</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.KMacLike.writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike.Writer">Writer</a> {
    <span class="tok-kw">return</span> .{ .context = self };
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.KMac">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">KMac</span>(<span class="tok-kw">comptime</span> security_level: <span class="tok-type">u11</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">KMacLike</a>(security_level, <span class="tok-number">0x04</span>, <span class="tok-number">24</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.sha3.TupleHash" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">TupleHash</span><a href="#src.zig-std.crypto.sha3.TupleHash">[src]</a></h2><div class="tldDocs"><p>The TupleHash extendable output hash function, with domain-separated inputs.
TupleHash is a secure hash function with a variable output length, based on the cSHAKE function.
It is designed for unambiguously hashing tuples of data.</p>
<p>With most hash functions, calling <code>update(&quot;A&quot;)</code> followed by <code>update(&quot;B&quot;)</code>is identical to <code>update(&quot;AB&quot;)</code>.
With TupleHash, this is not the case: <code>update(&quot;A&quot;); update(&quot;B&quot;)</code> is different from <code>update(&quot;AB&quot;)</code>.</p>
<p>Any number of inputs can be hashed, and the output depends on individual inputs and their order.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>security_level: <span class="tok-type">u11</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.crypto.sha3.TupleHashLike.Options.html">std.crypto.sha3.TupleHashLike.Options</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.crypto.sha3.TupleHashLike.Writer" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Writer</span><a href="#src.zig-std.crypto.sha3.TupleHashLike.Writer">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.TupleHashLike.Writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike.Error">Error</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike.write">write</a>)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>cshaker: CShaker</code></pre></div><div><pre><code>xof_mode: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.crypto.sha3.TupleHashLike.digest_length" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">digest_length</span><a href="#src.zig-std.crypto.sha3.TupleHashLike.digest_length">[src]</a></h3><div class="tldDocs"><p>The output length, in bytes.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.TupleHashLike.digest_length">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> digest_length = CShaker.digest_length</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.TupleHashLike.block_length" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">block_length</span><a href="#src.zig-std.crypto.sha3.TupleHashLike.block_length">[src]</a></h3><div class="tldDocs"><p>The block length, or rate, in bytes.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.TupleHashLike.block_length">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> block_length = CShaker.block_length</code></pre></details></div></div></div></div><div class="sectErrSets"><h3 class="sectionHeader">Error Sets</h3><div class="listErrSets"><div class="decl"><h3 id="std.crypto.sha3.TupleHashLike.Error" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">Error</span><a href="#src.zig-std.crypto.sha3.TupleHashLike.Error">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.TupleHashLike.Error">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.crypto.sha3.TupleHashLike.initWithOptions" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initWithOptions</span><a href="#src.zig-std.crypto.sha3.TupleHashLike.initWithOptions">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initWithOptions</span>(options: <a href="std.crypto.sha3.TupleHashLike.Options.html">Options</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a></code></pre></div><div class="tldDocs"><p>Initialize a state for the TupleHash function, with an optional context.
If the context is going to be reused, the structure can be initialized once, and cloned for each message.
This is more efficient than reinitializing the state for each message at the cost of a small amount of memory.</p>
<p>A key can be optionally added to the context to create a keyed TupleHash function, similar to KMAC.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>options: <a href="std.crypto.sha3.TupleHashLike.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.TupleHashLike.initWithOptions">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initWithOptions</span>(options: <a href="std.crypto.sha3.TupleHashLike.Options.html">Options</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a> {
    <span class="tok-kw">const</span> cshaker = CShaker.init(.{ .context = options.context });
    <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a>{
        .cshaker = cshaker,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.TupleHashLike.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.crypto.sha3.TupleHashLike.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>() <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a></code></pre></div><div class="tldDocs"><p>Initialize a state for the MAC function.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.TupleHashLike.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>() <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a> {
    <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike.initWithOptions">initWithOptions</a>(.{});
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.TupleHashLike.update" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">update</span><a href="#src.zig-std.crypto.sha3.TupleHashLike.update">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Add data to the state, separated from previous updates.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a></code></pre></div><div><pre><code>b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.TupleHashLike.update">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> encoded_b_len = <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.left, b.len);
    self.cshaker.update(encoded_b_len.slice());
    self.cshaker.update(b);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.TupleHashLike.final" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">final</span><a href="#src.zig-std.crypto.sha3.TupleHashLike.final">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Return an authentication tag for the current state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a></code></pre></div><div><pre><code>out: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.TupleHashLike.final">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> encoded_out_len = <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.right, out.len);
    self.cshaker.update(encoded_out_len.slice());
    self.cshaker.final(out);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.TupleHashLike.fillBlock" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fillBlock</span><a href="#src.zig-std.crypto.sha3.TupleHashLike.fillBlock">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fillBlock</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Align the input to a block boundary.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.TupleHashLike.fillBlock">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fillBlock</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a>) <span class="tok-type">void</span> {
    self.cshaker.fillBlock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.TupleHashLike.squeeze" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">squeeze</span><a href="#src.zig-std.crypto.sha3.TupleHashLike.squeeze">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">squeeze</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Squeeze a slice of bytes from the state.
<code>out</code> can be any length, and the function can be called multiple times.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a></code></pre></div><div><pre><code>out: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.TupleHashLike.squeeze">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">squeeze</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!self.xof_mode) {
        <span class="tok-kw">const</span> encoded_out_len = <span class="tok-kw">comptime</span> <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.right, <span class="tok-number">0</span>);
        self.update(encoded_out_len.slice());
        self.xof_mode = <span class="tok-null">true</span>;
    }
    self.cshaker.squeeze(out);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.sha3.TupleHashLike.writer" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writer</span><a href="#src.zig-std.crypto.sha3.TupleHashLike.writer">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike.Writer">Writer</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.sha3.TupleHashLike.writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike.Writer">Writer</a> {
    <span class="tok-kw">return</span> .{ .context = self };
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.sha3.TupleHash">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">TupleHash</span>(<span class="tok-kw">comptime</span> security_level: <span class="tok-type">u11</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">TupleHashLike</a>(security_level, <span class="tok-number">0x04</span>, <span class="tok-number">24</span>);
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.crypto.sha3">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> math = <a href="std.html">std</a>.<a href="std.math.html">math</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;

<span class="tok-kw">const</span> KeccakState = <a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>.<a href="std.crypto.core.html">core</a>.<a href="std.crypto.keccak_p.html">keccak</a>.<a href="std.crypto.keccak_p.html#std.crypto.keccak_p.State">State</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Sha3_224 = <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Keccak</a>(<span class="tok-number">1600</span>, <span class="tok-number">224</span>, <span class="tok-number">0x06</span>, <span class="tok-number">24</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Sha3_256 = <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Keccak</a>(<span class="tok-number">1600</span>, <span class="tok-number">256</span>, <span class="tok-number">0x06</span>, <span class="tok-number">24</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Sha3_384 = <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Keccak</a>(<span class="tok-number">1600</span>, <span class="tok-number">384</span>, <span class="tok-number">0x06</span>, <span class="tok-number">24</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Sha3_512 = <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Keccak</a>(<span class="tok-number">1600</span>, <span class="tok-number">512</span>, <span class="tok-number">0x06</span>, <span class="tok-number">24</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Keccak256 = <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Keccak</a>(<span class="tok-number">1600</span>, <span class="tok-number">256</span>, <span class="tok-number">0x01</span>, <span class="tok-number">24</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Keccak512 = <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Keccak</a>(<span class="tok-number">1600</span>, <span class="tok-number">512</span>, <span class="tok-number">0x01</span>, <span class="tok-number">24</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Shake128 = <a href="std.crypto.sha3.html#std.crypto.sha3.Shake">Shake</a>(<span class="tok-number">128</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Shake256 = <a href="std.crypto.sha3.html#std.crypto.sha3.Shake">Shake</a>(<span class="tok-number">256</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> CShake128 = <a href="std.crypto.sha3.html#std.crypto.sha3.CShake">CShake</a>(<span class="tok-number">128</span>, <span class="tok-null">null</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> CShake256 = <a href="std.crypto.sha3.html#std.crypto.sha3.CShake">CShake</a>(<span class="tok-number">256</span>, <span class="tok-null">null</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> KMac128 = <a href="std.crypto.sha3.html#std.crypto.sha3.KMac">KMac</a>(<span class="tok-number">128</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> KMac256 = <a href="std.crypto.sha3.html#std.crypto.sha3.KMac">KMac</a>(<span class="tok-number">256</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TupleHash128 = <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHash">TupleHash</a>(<span class="tok-number">128</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TupleHash256 = <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHash">TupleHash</a>(<span class="tok-number">256</span>);

<span class="tok-comment">/// TurboSHAKE128 is a XOF (a secure hash function with a variable output length), with a 128 bit security level.</span>
<span class="tok-comment">/// It is based on the same permutation as SHA3 and SHAKE128, but which much higher performance.</span>
<span class="tok-comment">/// The delimiter is 0x1f by default, but can be changed for context-separation.</span>
<span class="tok-comment">/// For a protocol that uses both KangarooTwelve and TurboSHAKE128, it is recommended to avoid using 0x06, 0x07 or 0x0b for the delimiter.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">TurboShake128</span>(delim: ?<span class="tok-type">u7</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.TurboShake">TurboShake</a>(<span class="tok-number">128</span>, delim);
}

<span class="tok-comment">/// TurboSHAKE256 is a XOF (a secure hash function with a variable output length), with a 256 bit security level.</span>
<span class="tok-comment">/// It is based on the same permutation as SHA3 and SHAKE256, but which much higher performance.</span>
<span class="tok-comment">/// The delimiter is 0x1f by default, but can be changed for context-separation.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">TurboShake256</span>(<span class="tok-kw">comptime</span> delim: ?<span class="tok-type">u7</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.TurboShake">TurboShake</a>(<span class="tok-number">256</span>, delim);
}

<span class="tok-comment">/// A generic Keccak hash function.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Keccak</span>(<span class="tok-kw">comptime</span> f: <span class="tok-type">u11</span>, <span class="tok-kw">comptime</span> output_bits: <span class="tok-type">u11</span>, <span class="tok-kw">comptime</span> default_delim: <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> rounds: <span class="tok-type">u5</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(output_bits &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> output_bits * <span class="tok-number">2</span> &lt; f <span class="tok-kw">and</span> output_bits % <span class="tok-number">8</span> == <span class="tok-number">0</span>);<span class="tok-comment"> // invalid output length

    </span><span class="tok-kw">const</span> State = <a href="std.crypto.keccak_p.html#std.crypto.keccak_p.State">KeccakState</a>(f, output_bits * <span class="tok-number">2</span>, rounds);

    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        st: State,

        <span class="tok-comment">/// The output length, in bytes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> digest_length = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">comptime_int</span>, output_bits, <span class="tok-number">8</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
        <span class="tok-comment">/// The block length, or rate, in bytes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> block_length = State.rate;
        <span class="tok-comment">/// The delimiter can be overwritten in the options.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Options = <span class="tok-kw">struct</span> { delim: <span class="tok-type">u8</span> = default_delim };

        <span class="tok-comment">/// Initialize a Keccak hash function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(options: <a href="std.crypto.sha3.Keccak.Options.html">Options</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a> {
            <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>{ .st = .{ .delim = options.delim } };
        }

        <span class="tok-comment">/// Hash a slice of bytes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out: *[<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.digest_length">digest_length</a>]<span class="tok-type">u8</span>, options: <a href="std.crypto.sha3.Keccak.Options.html">Options</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">var</span> st = <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>.<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.init">init</a>(options);
            st.update(bytes);
            st.final(out);
        }

        <span class="tok-comment">/// Absorb a slice of bytes into the state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            self.st.absorb(bytes);
        }

        <span class="tok-comment">/// Return the hash of the absorbed bytes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>, out: *[<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.digest_length">digest_length</a>]<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            self.st.pad();
            self.st.squeeze(out[<span class="tok-number">0</span>..]);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{};
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.Error">Error</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.write">write</a>);

        <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.Error">Error</a>!<span class="tok-type">usize</span> {
            self.update(bytes);
            <span class="tok-kw">return</span> bytes.len;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak">Self</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.Keccak.Writer">Writer</a> {
            <span class="tok-kw">return</span> .{ .context = self };
        }
    };
}

<span class="tok-comment">/// The SHAKE extendable output hash function.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Shake</span>(<span class="tok-kw">comptime</span> security_level: <span class="tok-type">u11</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">ShakeLike</a>(security_level, <span class="tok-number">0x1f</span>, <span class="tok-number">24</span>);
}

<span class="tok-comment">/// The TurboSHAKE extendable output hash function.</span>
<span class="tok-comment">/// It is based on the same permutation as SHA3 and SHAKE, but which much higher performance.</span>
<span class="tok-comment">/// The delimiter is 0x1f by default, but can be changed for context-separation.</span>
<span class="tok-comment">/// https://eprint.iacr.org/2023/342</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">TurboShake</span>(<span class="tok-kw">comptime</span> security_level: <span class="tok-type">u11</span>, <span class="tok-kw">comptime</span> delim: ?<span class="tok-type">u7</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(security_level &lt;= <span class="tok-number">256</span>);
    <span class="tok-kw">const</span> d = delim <span class="tok-kw">orelse</span> <span class="tok-number">0x1f</span>;
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(d &gt;= <span class="tok-number">0x01</span>);<span class="tok-comment"> // delimiter must be &gt;= 1
    </span><span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">ShakeLike</a>(security_level, d, <span class="tok-number">12</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">ShakeLike</span>(<span class="tok-kw">comptime</span> security_level: <span class="tok-type">u11</span>, <span class="tok-kw">comptime</span> default_delim: <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> rounds: <span class="tok-type">u5</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> f = <span class="tok-number">1600</span>;
    <span class="tok-kw">const</span> State = <a href="std.crypto.keccak_p.html#std.crypto.keccak_p.State">KeccakState</a>(f, security_level * <span class="tok-number">2</span>, rounds);

    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        st: State,
        buf: [State.rate]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,
        offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
        padded: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

        <span class="tok-comment">/// The recommended output length, in bytes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> digest_length = security_level / <span class="tok-number">8</span> * <span class="tok-number">2</span>;
        <span class="tok-comment">/// The block length, or rate, in bytes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> block_length = State.rate;
        <span class="tok-comment">/// The delimiter can be overwritten in the options.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Options = <span class="tok-kw">struct</span> { delim: <span class="tok-type">u8</span> = default_delim };

        <span class="tok-comment">/// Initialize a SHAKE extensible hash function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(options: <a href="std.crypto.sha3.ShakeLike.Options.html">Options</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a> {
            <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>{ .st = .{ .delim = options.delim } };
        }

        <span class="tok-comment">/// Hash a slice of bytes.</span>
        <span class="tok-comment">/// `out` can be any length.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out: []<span class="tok-type">u8</span>, options: <a href="std.crypto.sha3.ShakeLike.Options.html">Options</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">var</span> st = <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>.<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike.init">init</a>(options);
            st.update(bytes);
            st.squeeze(out);
        }

        <span class="tok-comment">/// Absorb a slice of bytes into the state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            self.st.absorb(bytes);
        }

        <span class="tok-comment">/// Squeeze a slice of bytes from the state.</span>
        <span class="tok-comment">/// `out` can be any length, and the function can be called multiple times.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">squeeze</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>, out_: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (!self.padded) {
                self.st.pad();
                self.padded = <span class="tok-null">true</span>;
            }
            <span class="tok-kw">var</span> out = out_;
            <span class="tok-kw">if</span> (self.offset &gt; <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> left = self.buf.len - self.offset;
                <span class="tok-kw">if</span> (left &gt; <span class="tok-number">0</span>) {
                    <span class="tok-kw">const</span> n = <span class="tok-builtin">@min</span>(left, out.len);
                    <span class="tok-builtin">@memcpy</span>(out[<span class="tok-number">0</span>..n], self.buf[self.offset..][<span class="tok-number">0</span>..n]);
                    out = out[n..];
                    self.offset += n;
                    <span class="tok-kw">if</span> (out.len == <span class="tok-number">0</span>) {
                        <span class="tok-kw">return</span>;
                    }
                }
            }
            <span class="tok-kw">const</span> full_blocks = out[<span class="tok-number">0</span> .. out.len - out.len % State.rate];
            <span class="tok-kw">if</span> (full_blocks.len &gt; <span class="tok-number">0</span>) {
                self.st.squeeze(full_blocks);
                out = out[full_blocks.len..];
            }
            <span class="tok-kw">if</span> (out.len &gt; <span class="tok-number">0</span>) {
                self.st.squeeze(self.buf[<span class="tok-number">0</span>..]);
                <span class="tok-builtin">@memcpy</span>(out[<span class="tok-number">0</span>..], self.buf[<span class="tok-number">0</span>..out.len]);
                self.offset = out.len;
            }
        }

        <span class="tok-comment">/// Return the hash of the absorbed bytes.</span>
        <span class="tok-comment">/// `out` can be of any length, but the function must not be called multiple times (use `squeeze` for that purpose instead).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            self.squeeze(out);
            self.st.st.clear(<span class="tok-number">0</span>, State.rate);
        }

        <span class="tok-comment">/// Align the input to a block boundary.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fillBlock</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>) <span class="tok-type">void</span> {
            self.st.fillBlock();
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{};
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike.Error">Error</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike.write">write</a>);

        <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike.Error">Error</a>!<span class="tok-type">usize</span> {
            self.update(bytes);
            <span class="tok-kw">return</span> bytes.len;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">Self</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike.Writer">Writer</a> {
            <span class="tok-kw">return</span> .{ .context = self };
        }
    };
}

<span class="tok-comment">/// The cSHAKE extendable output hash function.</span>
<span class="tok-comment">/// cSHAKE is similar to SHAKE, but in addition to the input message, it also takes an optional context (aka customization string).</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">CShake</span>(<span class="tok-kw">comptime</span> security_level: <span class="tok-type">u11</span>, <span class="tok-kw">comptime</span> fname: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">CShakeLike</a>(security_level, <span class="tok-number">0x04</span>, <span class="tok-number">24</span>, fname);
}

<span class="tok-kw">fn</span> <span class="tok-fn">CShakeLike</span>(<span class="tok-kw">comptime</span> security_level: <span class="tok-type">u11</span>, <span class="tok-kw">comptime</span> default_delim: <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> rounds: <span class="tok-type">u5</span>, <span class="tok-kw">comptime</span> fname: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Shaker = <a href="std.crypto.sha3.html#std.crypto.sha3.ShakeLike">ShakeLike</a>(security_level, default_delim, rounds);
        shaker: <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.Shaker">Shaker</a>,

        <span class="tok-comment">/// The recommended output length, in bytes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> digest_length = <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.Shaker">Shaker</a>.<a href="#">digest_length</a>;
        <span class="tok-comment">/// The block length, or rate, in bytes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> block_length = <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.Shaker">Shaker</a>.<a href="#">block_length</a>;

        <span class="tok-comment">/// cSHAKE options can include a context string.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Options = <span class="tok-kw">struct</span> { context: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span> };

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// Initialize a SHAKE extensible hash function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(options: <a href="std.crypto.sha3.CShakeLike.Options.html">Options</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a> {
            <span class="tok-kw">if</span> (fname == <span class="tok-null">null</span> <span class="tok-kw">and</span> options.context == <span class="tok-null">null</span>) {
                <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>{ .shaker = <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.Shaker">Shaker</a>.<a href="#">init</a>(.{ .delim = <span class="tok-number">0x1f</span> }) };
            }
            <span class="tok-kw">var</span> shaker = <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.Shaker">Shaker</a>.<a href="#">init</a>(.{});
            <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.Shaker">Shaker</a>.<a href="#">block_length</a> % <span class="tok-number">8</span> == <span class="tok-number">0</span>);
            <span class="tok-kw">const</span> encoded_rate_len = <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.left, <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.block_length">block_length</a> / <span class="tok-number">8</span>);
            shaker.update(encoded_rate_len.slice());
            <span class="tok-kw">const</span> encoded_zero = <span class="tok-kw">comptime</span> <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.left, <span class="tok-number">0</span>);
            <span class="tok-kw">if</span> (fname) |name| {
                <span class="tok-kw">const</span> encoded_fname_len = <span class="tok-kw">comptime</span> <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.left, name.len);
                <span class="tok-kw">const</span> encoded_fname = <span class="tok-kw">comptime</span> encoded_fname_len.slice() ++ name;
                shaker.update(encoded_fname);
            } <span class="tok-kw">else</span> {
                shaker.update(encoded_zero.slice());
            }
            <span class="tok-kw">if</span> (options.context) |context| {
                <span class="tok-kw">const</span> encoded_context_len = <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.left, context.len);
                shaker.update(encoded_context_len.slice());
                shaker.update(context);
            } <span class="tok-kw">else</span> {
                shaker.update(encoded_zero.slice());
            }
            shaker.st.fillBlock();
            <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>{ .shaker = shaker };
        }

        <span class="tok-comment">/// Hash a slice of bytes.</span>
        <span class="tok-comment">/// `out` can be any length.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out: []<span class="tok-type">u8</span>, options: <a href="std.crypto.sha3.CShakeLike.Options.html">Options</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">var</span> st = <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>.<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.init">init</a>(options);
            st.update(bytes);
            st.squeeze(out);
        }

        <span class="tok-comment">/// Absorb a slice of bytes into the state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            self.shaker.update(bytes);
        }

        <span class="tok-comment">/// Squeeze a slice of bytes from the state.</span>
        <span class="tok-comment">/// `out` can be any length, and the function can be called multiple times.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">squeeze</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            self.shaker.squeeze(out);
        }

        <span class="tok-comment">/// Return the hash of the absorbed bytes.</span>
        <span class="tok-comment">/// `out` can be of any length, but the function must not be called multiple times (use `squeeze` for that purpose instead).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            self.shaker.final(out);
        }

        <span class="tok-comment">/// Align the input to a block boundary.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fillBlock</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>) <span class="tok-type">void</span> {
            self.shaker.fillBlock();
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{};
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.Error">Error</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.write">write</a>);

        <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.Error">Error</a>!<span class="tok-type">usize</span> {
            self.update(bytes);
            <span class="tok-kw">return</span> bytes.len;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">Self</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike.Writer">Writer</a> {
            <span class="tok-kw">return</span> .{ .context = self };
        }
    };
}

<span class="tok-comment">/// The KMAC extendable output authentication function.</span>
<span class="tok-comment">/// KMAC is a keyed version of the cSHAKE function, with an optional context.</span>
<span class="tok-comment">/// It can be used as an SHA-3 based alternative to HMAC, as well as a generic keyed XoF (extendable output function).</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">KMac</span>(<span class="tok-kw">comptime</span> security_level: <span class="tok-type">u11</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">KMacLike</a>(security_level, <span class="tok-number">0x04</span>, <span class="tok-number">24</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">KMacLike</span>(<span class="tok-kw">comptime</span> security_level: <span class="tok-type">u11</span>, <span class="tok-kw">comptime</span> default_delim: <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> rounds: <span class="tok-type">u5</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> CShaker = <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">CShakeLike</a>(security_level, default_delim, rounds, <span class="tok-str">&quot;KMAC&quot;</span>);

    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// The recommended output length, in bytes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> mac_length = CShaker.digest_length;
        <span class="tok-comment">/// The minimum output length, in bytes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> mac_length_min = <span class="tok-number">4</span>;
        <span class="tok-comment">/// The recommended key length, in bytes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> key_length = security_level / <span class="tok-number">8</span>;
        <span class="tok-comment">/// The minimum key length, in bytes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> key_length_min = <span class="tok-number">0</span>;
        <span class="tok-comment">/// The block length, or rate, in bytes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> block_length = CShaker.block_length;

        cshaker: CShaker,
        xof_mode: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

        <span class="tok-comment">/// KMAC options can include a context string.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Options = <span class="tok-kw">struct</span> {
            context: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
        };

        <span class="tok-comment">/// Initialize a state for the KMAC function, with an optional context and an arbitrary-long key.</span>
        <span class="tok-comment">/// If the context and key are going to be reused, the structure can be initialized once, and cloned for each message.</span>
        <span class="tok-comment">/// This is more efficient than reinitializing the state for each message at the cost of a small amount of memory.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initWithOptions</span>(key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.crypto.sha3.KMacLike.Options.html">Options</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a> {
            <span class="tok-kw">var</span> cshaker = CShaker.init(.{ .context = options.context });
            <span class="tok-kw">const</span> encoded_rate_len = <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.left, <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike.block_length">block_length</a> / <span class="tok-number">8</span>);
            cshaker.update(encoded_rate_len.slice());
            <span class="tok-kw">const</span> encoded_key_len = <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.left, key.len);
            cshaker.update(encoded_key_len.slice());
            cshaker.update(key);
            cshaker.fillBlock();
            <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>{
                .cshaker = cshaker,
            };
        }

        <span class="tok-comment">/// Initialize a state for the KMAC function.</span>
        <span class="tok-comment">/// If the context and key are going to be reused, the structure can be initialized once, and cloned for each message.</span>
        <span class="tok-comment">/// This is more efficient than reinitializing the state for each message at the cost of a small amount of memory.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a> {
            <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike.initWithOptions">initWithOptions</a>(key, .{});
        }

        <span class="tok-comment">/// Add data to the state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            self.cshaker.update(b);
        }

        <span class="tok-comment">/// Return an authentication tag for the current state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> encoded_out_len = <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.right, out.len);
            self.update(encoded_out_len.slice());
            self.cshaker.final(out);
        }

        <span class="tok-comment">/// Squeeze a slice of bytes from the state.</span>
        <span class="tok-comment">/// `out` can be any length, and the function can be called multiple times.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">squeeze</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (!self.xof_mode) {
                <span class="tok-kw">const</span> encoded_out_len = <span class="tok-kw">comptime</span> <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.right, <span class="tok-number">0</span>);
                self.update(encoded_out_len.slice());
                self.xof_mode = <span class="tok-null">true</span>;
            }
            self.cshaker.squeeze(out);
        }

        <span class="tok-comment">/// Return an authentication tag for a message and a key, with an optional context.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createWithOptions</span>(out: []<span class="tok-type">u8</span>, msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.crypto.sha3.KMacLike.Options.html">Options</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">var</span> ctx = <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>.<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike.initWithOptions">initWithOptions</a>(key, options);
            ctx.update(msg);
            ctx.final(out);
        }

        <span class="tok-comment">/// Return an authentication tag for a message and a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(out: []<span class="tok-type">u8</span>, msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">var</span> ctx = <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>.<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike.init">init</a>(key);
            ctx.update(msg);
            ctx.final(out);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{};
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike.Error">Error</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike.write">write</a>);

        <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike.Error">Error</a>!<span class="tok-type">usize</span> {
            self.update(bytes);
            <span class="tok-kw">return</span> bytes.len;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike">Self</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.KMacLike.Writer">Writer</a> {
            <span class="tok-kw">return</span> .{ .context = self };
        }
    };
}

<span class="tok-comment">/// The TupleHash extendable output hash function, with domain-separated inputs.</span>
<span class="tok-comment">/// TupleHash is a secure hash function with a variable output length, based on the cSHAKE function.</span>
<span class="tok-comment">/// It is designed for unambiguously hashing tuples of data.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// With most hash functions, calling `update(&quot;A&quot;)` followed by `update(&quot;B&quot;)`is identical to `update(&quot;AB&quot;)`.</span>
<span class="tok-comment">/// With TupleHash, this is not the case: `update(&quot;A&quot;); update(&quot;B&quot;)` is different from `update(&quot;AB&quot;)`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Any number of inputs can be hashed, and the output depends on individual inputs and their order.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">TupleHash</span>(<span class="tok-kw">comptime</span> security_level: <span class="tok-type">u11</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">TupleHashLike</a>(security_level, <span class="tok-number">0x04</span>, <span class="tok-number">24</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">TupleHashLike</span>(<span class="tok-kw">comptime</span> security_level: <span class="tok-type">u11</span>, <span class="tok-kw">comptime</span> default_delim: <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> rounds: <span class="tok-type">u5</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> CShaker = <a href="std.crypto.sha3.html#std.crypto.sha3.CShakeLike">CShakeLike</a>(security_level, default_delim, rounds, <span class="tok-str">&quot;TupleHash&quot;</span>);

    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// The output length, in bytes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> digest_length = CShaker.digest_length;
        <span class="tok-comment">/// The block length, or rate, in bytes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> block_length = CShaker.block_length;

        cshaker: CShaker,
        xof_mode: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

        <span class="tok-comment">/// TupleHash options can include a context string.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Options = <span class="tok-kw">struct</span> {
            context: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
        };

        <span class="tok-comment">/// Initialize a state for the TupleHash function, with an optional context.</span>
        <span class="tok-comment">/// If the context is going to be reused, the structure can be initialized once, and cloned for each message.</span>
        <span class="tok-comment">/// This is more efficient than reinitializing the state for each message at the cost of a small amount of memory.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// A key can be optionally added to the context to create a keyed TupleHash function, similar to KMAC.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initWithOptions</span>(options: <a href="std.crypto.sha3.TupleHashLike.Options.html">Options</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a> {
            <span class="tok-kw">const</span> cshaker = CShaker.init(.{ .context = options.context });
            <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a>{
                .cshaker = cshaker,
            };
        }

        <span class="tok-comment">/// Initialize a state for the MAC function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>() <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a> {
            <span class="tok-kw">return</span> <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike.initWithOptions">initWithOptions</a>(.{});
        }

        <span class="tok-comment">/// Add data to the state, separated from previous updates.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> encoded_b_len = <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.left, b.len);
            self.cshaker.update(encoded_b_len.slice());
            self.cshaker.update(b);
        }

        <span class="tok-comment">/// Return an authentication tag for the current state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> encoded_out_len = <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.right, out.len);
            self.cshaker.update(encoded_out_len.slice());
            self.cshaker.final(out);
        }

        <span class="tok-comment">/// Align the input to a block boundary.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fillBlock</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a>) <span class="tok-type">void</span> {
            self.cshaker.fillBlock();
        }

        <span class="tok-comment">/// Squeeze a slice of bytes from the state.</span>
        <span class="tok-comment">/// `out` can be any length, and the function can be called multiple times.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">squeeze</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a>, out: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (!self.xof_mode) {
                <span class="tok-kw">const</span> encoded_out_len = <span class="tok-kw">comptime</span> <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>.<a href="std.crypto.sha3.NistLengthEncoding.html#std.crypto.sha3.NistLengthEncoding.encode">encode</a>(.right, <span class="tok-number">0</span>);
                self.update(encoded_out_len.slice());
                self.xof_mode = <span class="tok-null">true</span>;
            }
            self.cshaker.squeeze(out);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{};
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike.Error">Error</a>, <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike.write">write</a>);

        <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike.Error">Error</a>!<span class="tok-type">usize</span> {
            self.update(bytes);
            <span class="tok-kw">return</span> bytes.len;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike">Self</a>) <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHashLike.Writer">Writer</a> {
            <span class="tok-kw">return</span> .{ .context = self };
        }
    };
}

<span class="tok-comment">/// The NIST SP 800-185 encoded length format.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> NistLengthEncoding = <span class="tok-kw">enum</span> {
    left,
    right,

    <span class="tok-comment">/// A length encoded according to NIST SP 800-185.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Length = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// The size of the encoded value, in bytes.</span>
        len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
        <span class="tok-comment">/// A buffer to store the encoded length.</span>
        buf: [<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) + <span class="tok-number">1</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,

        <span class="tok-comment">/// Return the encoded length as a slice.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">slice</span>(self: *<span class="tok-kw">const</span> <a href="std.crypto.sha3.NistLengthEncoding.Length.html">Length</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
            <span class="tok-kw">return</span> self.buf[<span class="tok-number">0</span>..self.len];
        }
    };

    <span class="tok-comment">/// Encode a length according to NIST SP 800-185.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">encode</span>(<span class="tok-kw">comptime</span> encoding: <a href="std.crypto.sha3.NistLengthEncoding.html">NistLengthEncoding</a>, len: <span class="tok-type">usize</span>) <a href="std.crypto.sha3.NistLengthEncoding.Length.html">Length</a> {
        <span class="tok-kw">const</span> len_bits = <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-builtin">@TypeOf</span>(len)) - <span class="tok-builtin">@clz</span>(len) + <span class="tok-number">3</span>;
        <span class="tok-kw">const</span> len_bytes = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">usize</span>, len_bits, <span class="tok-number">8</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;

        <span class="tok-kw">var</span> res = <a href="std.crypto.sha3.NistLengthEncoding.Length.html">Length</a>{ .len = len_bytes + <span class="tok-number">1</span> };
        <span class="tok-kw">if</span> (encoding == .right) {
            res.buf[len_bytes] = <span class="tok-builtin">@intCast</span>(len_bytes);
        }
        <span class="tok-kw">const</span> end = <span class="tok-kw">if</span> (encoding == .right) len_bytes - <span class="tok-number">1</span> <span class="tok-kw">else</span> len_bytes;
        res.buf[end] = <span class="tok-builtin">@truncate</span>(len &lt;&lt; <span class="tok-number">3</span>);
        <span class="tok-kw">var</span> len_ = len &gt;&gt; <span class="tok-number">5</span>;
        <span class="tok-kw">for</span> (<span class="tok-number">1</span>..len_bytes) |i| {
            res.buf[end - i] = <span class="tok-builtin">@truncate</span>(len_);
            len_ &gt;&gt;= <span class="tok-number">8</span>;
        }
        <span class="tok-kw">if</span> (encoding == .left) {
            res.buf[<span class="tok-number">0</span>] = <span class="tok-builtin">@intCast</span>(len_bytes);
        }
        <span class="tok-kw">return</span> res;
    }
};

<span class="tok-kw">const</span> htest = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;test.zig&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;sha3-224 single&quot;</span> {
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqualHash</a>(<a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_224">Sha3_224</a>, <span class="tok-str">&quot;6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7&quot;</span>, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqualHash</a>(<a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_224">Sha3_224</a>, <span class="tok-str">&quot;e642824c3f8cf24ad09234ee7d3c766fc9a3a5168d0c94ad73b46fdf&quot;</span>, <span class="tok-str">&quot;abc&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqualHash</a>(<a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_224">Sha3_224</a>, <span class="tok-str">&quot;543e6868e1666c1a643630df77367ae5a62a85070a51c14cbf665cbc&quot;</span>, <span class="tok-str">&quot;abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu&quot;</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;sha3-224 streaming&quot;</span> {
    <span class="tok-kw">var</span> h = <a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_224">Sha3_224</a>.<a href="#">init</a>(.{});
    <span class="tok-kw">var</span> out: [<span class="tok-number">28</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

    h.final(out[<span class="tok-number">0</span>..]);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7&quot;</span>, out[<span class="tok-number">0</span>..]);

    h = <a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_224">Sha3_224</a>.<a href="#">init</a>(.{});
    h.update(<span class="tok-str">&quot;abc&quot;</span>);
    h.final(out[<span class="tok-number">0</span>..]);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;e642824c3f8cf24ad09234ee7d3c766fc9a3a5168d0c94ad73b46fdf&quot;</span>, out[<span class="tok-number">0</span>..]);

    h = <a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_224">Sha3_224</a>.<a href="#">init</a>(.{});
    h.update(<span class="tok-str">&quot;a&quot;</span>);
    h.update(<span class="tok-str">&quot;b&quot;</span>);
    h.update(<span class="tok-str">&quot;c&quot;</span>);
    h.final(out[<span class="tok-number">0</span>..]);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;e642824c3f8cf24ad09234ee7d3c766fc9a3a5168d0c94ad73b46fdf&quot;</span>, out[<span class="tok-number">0</span>..]);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;sha3-256 single&quot;</span> {
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqualHash</a>(<a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_256">Sha3_256</a>, <span class="tok-str">&quot;a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a&quot;</span>, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqualHash</a>(<a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_256">Sha3_256</a>, <span class="tok-str">&quot;3a985da74fe225b2045c172d6bd390bd855f086e3e9d525b46bfe24511431532&quot;</span>, <span class="tok-str">&quot;abc&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqualHash</a>(<a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_256">Sha3_256</a>, <span class="tok-str">&quot;916f6061fe879741ca6469b43971dfdb28b1a32dc36cb3254e812be27aad1d18&quot;</span>, <span class="tok-str">&quot;abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu&quot;</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;sha3-256 streaming&quot;</span> {
    <span class="tok-kw">var</span> h = <a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_256">Sha3_256</a>.<a href="#">init</a>(.{});
    <span class="tok-kw">var</span> out: [<span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

    h.final(out[<span class="tok-number">0</span>..]);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a&quot;</span>, out[<span class="tok-number">0</span>..]);

    h = <a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_256">Sha3_256</a>.<a href="#">init</a>(.{});
    h.update(<span class="tok-str">&quot;abc&quot;</span>);
    h.final(out[<span class="tok-number">0</span>..]);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;3a985da74fe225b2045c172d6bd390bd855f086e3e9d525b46bfe24511431532&quot;</span>, out[<span class="tok-number">0</span>..]);

    h = <a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_256">Sha3_256</a>.<a href="#">init</a>(.{});
    h.update(<span class="tok-str">&quot;a&quot;</span>);
    h.update(<span class="tok-str">&quot;b&quot;</span>);
    h.update(<span class="tok-str">&quot;c&quot;</span>);
    h.final(out[<span class="tok-number">0</span>..]);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;3a985da74fe225b2045c172d6bd390bd855f086e3e9d525b46bfe24511431532&quot;</span>, out[<span class="tok-number">0</span>..]);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;sha3-256 aligned final&quot;</span> {
    <span class="tok-kw">var</span> block = [_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_256">Sha3_256</a>.<a href="#">block_length</a>;
    <span class="tok-kw">var</span> out: [<a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_256">Sha3_256</a>.<a href="#">digest_length</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">var</span> h = <a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_256">Sha3_256</a>.<a href="#">init</a>(.{});
    h.update(&amp;block);
    h.final(out[<span class="tok-number">0</span>..]);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;sha3-384 single&quot;</span> {
    <span class="tok-kw">const</span> h1 = <span class="tok-str">&quot;0c63a75b845e4f7d01107d852e4c2485c51a50aaaa94fc61995e71bbee983a2ac3713831264adb47fb6bd1e058d5f004&quot;</span>;
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqualHash</a>(<a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_384">Sha3_384</a>, h1, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">const</span> h2 = <span class="tok-str">&quot;ec01498288516fc926459f58e2c6ad8df9b473cb0fc08c2596da7cf0e49be4b298d88cea927ac7f539f1edf228376d25&quot;</span>;
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqualHash</a>(<a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_384">Sha3_384</a>, h2, <span class="tok-str">&quot;abc&quot;</span>);
    <span class="tok-kw">const</span> h3 = <span class="tok-str">&quot;79407d3b5916b59c3e30b09822974791c313fb9ecc849e406f23592d04f625dc8c709b98b43b3852b337216179aa7fc7&quot;</span>;
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqualHash</a>(<a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_384">Sha3_384</a>, h3, <span class="tok-str">&quot;abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu&quot;</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;sha3-384 streaming&quot;</span> {
    <span class="tok-kw">var</span> h = <a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_384">Sha3_384</a>.<a href="#">init</a>(.{});
    <span class="tok-kw">var</span> out: [<span class="tok-number">48</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">const</span> h1 = <span class="tok-str">&quot;0c63a75b845e4f7d01107d852e4c2485c51a50aaaa94fc61995e71bbee983a2ac3713831264adb47fb6bd1e058d5f004&quot;</span>;
    h.final(out[<span class="tok-number">0</span>..]);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(h1, out[<span class="tok-number">0</span>..]);

    <span class="tok-kw">const</span> h2 = <span class="tok-str">&quot;ec01498288516fc926459f58e2c6ad8df9b473cb0fc08c2596da7cf0e49be4b298d88cea927ac7f539f1edf228376d25&quot;</span>;
    h = <a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_384">Sha3_384</a>.<a href="#">init</a>(.{});
    h.update(<span class="tok-str">&quot;abc&quot;</span>);
    h.final(out[<span class="tok-number">0</span>..]);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(h2, out[<span class="tok-number">0</span>..]);

    h = <a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_384">Sha3_384</a>.<a href="#">init</a>(.{});
    h.update(<span class="tok-str">&quot;a&quot;</span>);
    h.update(<span class="tok-str">&quot;b&quot;</span>);
    h.update(<span class="tok-str">&quot;c&quot;</span>);
    h.final(out[<span class="tok-number">0</span>..]);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(h2, out[<span class="tok-number">0</span>..]);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;sha3-512 single&quot;</span> {
    <span class="tok-kw">const</span> h1 = <span class="tok-str">&quot;a69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26&quot;</span>;
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqualHash</a>(<a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_512">Sha3_512</a>, h1, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">const</span> h2 = <span class="tok-str">&quot;b751850b1a57168a5693cd924b6b096e08f621827444f70d884f5d0240d2712e10e116e9192af3c91a7ec57647e3934057340b4cf408d5a56592f8274eec53f0&quot;</span>;
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqualHash</a>(<a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_512">Sha3_512</a>, h2, <span class="tok-str">&quot;abc&quot;</span>);
    <span class="tok-kw">const</span> h3 = <span class="tok-str">&quot;afebb2ef542e6579c50cad06d2e578f9f8dd6881d7dc824d26360feebf18a4fa73e3261122948efcfd492e74e82e2189ed0fb440d187f382270cb455f21dd185&quot;</span>;
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqualHash</a>(<a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_512">Sha3_512</a>, h3, <span class="tok-str">&quot;abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu&quot;</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;sha3-512 streaming&quot;</span> {
    <span class="tok-kw">var</span> h = <a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_512">Sha3_512</a>.<a href="#">init</a>(.{});
    <span class="tok-kw">var</span> out: [<span class="tok-number">64</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">const</span> h1 = <span class="tok-str">&quot;a69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26&quot;</span>;
    h.final(out[<span class="tok-number">0</span>..]);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(h1, out[<span class="tok-number">0</span>..]);

    <span class="tok-kw">const</span> h2 = <span class="tok-str">&quot;b751850b1a57168a5693cd924b6b096e08f621827444f70d884f5d0240d2712e10e116e9192af3c91a7ec57647e3934057340b4cf408d5a56592f8274eec53f0&quot;</span>;
    h = <a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_512">Sha3_512</a>.<a href="#">init</a>(.{});
    h.update(<span class="tok-str">&quot;abc&quot;</span>);
    h.final(out[<span class="tok-number">0</span>..]);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(h2, out[<span class="tok-number">0</span>..]);

    h = <a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_512">Sha3_512</a>.<a href="#">init</a>(.{});
    h.update(<span class="tok-str">&quot;a&quot;</span>);
    h.update(<span class="tok-str">&quot;b&quot;</span>);
    h.update(<span class="tok-str">&quot;c&quot;</span>);
    h.final(out[<span class="tok-number">0</span>..]);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(h2, out[<span class="tok-number">0</span>..]);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;sha3-512 aligned final&quot;</span> {
    <span class="tok-kw">var</span> block = [_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_512">Sha3_512</a>.<a href="#">block_length</a>;
    <span class="tok-kw">var</span> out: [<a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_512">Sha3_512</a>.<a href="#">digest_length</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">var</span> h = <a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_512">Sha3_512</a>.<a href="#">init</a>(.{});
    h.update(&amp;block);
    h.final(out[<span class="tok-number">0</span>..]);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;keccak-256 single&quot;</span> {
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqualHash</a>(<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak256">Keccak256</a>, <span class="tok-str">&quot;c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470&quot;</span>, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqualHash</a>(<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak256">Keccak256</a>, <span class="tok-str">&quot;4e03657aea45a94fc7d47ba826c8d667c0d1e6e33a64a036ec44f58fa12d6c45&quot;</span>, <span class="tok-str">&quot;abc&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqualHash</a>(<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak256">Keccak256</a>, <span class="tok-str">&quot;f519747ed599024f3882238e5ab43960132572b7345fbeb9a90769dafd21ad67&quot;</span>, <span class="tok-str">&quot;abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu&quot;</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;keccak-512 single&quot;</span> {
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqualHash</a>(<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak512">Keccak512</a>, <span class="tok-str">&quot;0eab42de4c3ceb9235fc91acffe746b29c29a8c366b7c60e4e67c466f36a4304c00fa9caf9d87976ba469bcbe06713b435f091ef2769fb160cdab33d3670680e&quot;</span>, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqualHash</a>(<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak512">Keccak512</a>, <span class="tok-str">&quot;18587dc2ea106b9a1563e32b3312421ca164c7f1f07bc922a9c83d77cea3a1e5d0c69910739025372dc14ac9642629379540c17e2a65b19d77aa511a9d00bb96&quot;</span>, <span class="tok-str">&quot;abc&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqualHash</a>(<a href="std.crypto.sha3.html#std.crypto.sha3.Keccak512">Keccak512</a>, <span class="tok-str">&quot;ac2fb35251825d3aa48468a9948c0a91b8256f6d97d8fa4160faff2dd9dfcc24f3f1db7a983dad13d53439ccac0b37e24037e7b95f80f59f37a2f683c4ba4682&quot;</span>, <span class="tok-str">&quot;abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu&quot;</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;SHAKE-128 single&quot;</span> {
    <span class="tok-kw">var</span> out: [<span class="tok-number">10</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <a href="std.crypto.sha3.html#std.crypto.sha3.Shake128">Shake128</a>.<a href="#">hash</a>(<span class="tok-str">&quot;hello123&quot;</span>, &amp;out, .{});
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;1b85861510bc4d8e467d&quot;</span>, &amp;out);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;SHAKE-128 multisqueeze&quot;</span> {
    <span class="tok-kw">var</span> out: [<span class="tok-number">10</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> h = <a href="std.crypto.sha3.html#std.crypto.sha3.Shake128">Shake128</a>.<a href="#">init</a>(.{});
    h.update(<span class="tok-str">&quot;hello123&quot;</span>);
    h.squeeze(out[<span class="tok-number">0</span>..<span class="tok-number">4</span>]);
    h.squeeze(out[<span class="tok-number">4</span>..]);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;1b85861510bc4d8e467d&quot;</span>, &amp;out);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;SHAKE-128 multisqueeze with multiple blocks&quot;</span> {
    <span class="tok-kw">var</span> out: [<span class="tok-number">100</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> out2: [<span class="tok-number">100</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">var</span> h = <a href="std.crypto.sha3.html#std.crypto.sha3.Shake128">Shake128</a>.<a href="#">init</a>(.{});
    h.update(<span class="tok-str">&quot;hello123&quot;</span>);
    h.squeeze(out[<span class="tok-number">0</span>..<span class="tok-number">50</span>]);
    h.squeeze(out[<span class="tok-number">50</span>..]);

    <span class="tok-kw">var</span> h2 = <a href="std.crypto.sha3.html#std.crypto.sha3.Shake128">Shake128</a>.<a href="#">init</a>(.{});
    h2.update(<span class="tok-str">&quot;hello123&quot;</span>);
    h2.squeeze(&amp;out2);
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;out, &amp;out2);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;SHAKE-256 single&quot;</span> {
    <span class="tok-kw">var</span> out: [<span class="tok-number">10</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <a href="std.crypto.sha3.html#std.crypto.sha3.Shake256">Shake256</a>.<a href="#">hash</a>(<span class="tok-str">&quot;hello123&quot;</span>, &amp;out, .{});
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;ade612ba265f92de4a37&quot;</span>, &amp;out);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;TurboSHAKE-128&quot;</span> {
    <span class="tok-kw">var</span> out: [<span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <a href="std.crypto.sha3.html#std.crypto.sha3.TurboShake">TurboShake</a>(<span class="tok-number">128</span>, <span class="tok-number">0x06</span>).hash(<span class="tok-str">&quot;\xff&quot;</span>, &amp;out, .{});
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;8ec9c66465ed0d4a6c35d13506718d687a25cb05c74cca1e42501abd83874a67&quot;</span>, &amp;out);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;SHA-3 with streaming&quot;</span> {
    <span class="tok-kw">var</span> msg: [<span class="tok-number">613</span>]<span class="tok-type">u8</span> = [<span class="tok-number">613</span>]<span class="tok-type">u8</span>{ <span class="tok-number">0x97</span>, <span class="tok-number">0xd1</span>, <span class="tok-number">0x2d</span>, <span class="tok-number">0x1a</span>, <span class="tok-number">0x16</span>, <span class="tok-number">0x2d</span>, <span class="tok-number">0x36</span>, <span class="tok-number">0x4d</span>, <span class="tok-number">0x20</span>, <span class="tok-number">0x62</span>, <span class="tok-number">0x19</span>, <span class="tok-number">0x0b</span>, <span class="tok-number">0x14</span>, <span class="tok-number">0x93</span>, <span class="tok-number">0xbb</span>, <span class="tok-number">0xf8</span>, <span class="tok-number">0x5b</span>, <span class="tok-number">0xea</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0xc2</span>, <span class="tok-number">0x61</span>, <span class="tok-number">0x8e</span>, <span class="tok-number">0xd6</span>, <span class="tok-number">0x08</span>, <span class="tok-number">0x81</span>, <span class="tok-number">0xa1</span>, <span class="tok-number">0x1d</span>, <span class="tok-number">0x73</span>, <span class="tok-number">0x27</span>, <span class="tok-number">0x48</span>, <span class="tok-number">0xbf</span>, <span class="tok-number">0xa4</span>, <span class="tok-number">0xba</span>, <span class="tok-number">0xb1</span>, <span class="tok-number">0x9a</span>, <span class="tok-number">0x48</span>, <span class="tok-number">0x9c</span>, <span class="tok-number">0xf9</span>, <span class="tok-number">0x9b</span>, <span class="tok-number">0xff</span>, <span class="tok-number">0x34</span>, <span class="tok-number">0x48</span>, <span class="tok-number">0xa9</span>, <span class="tok-number">0x75</span>, <span class="tok-number">0xea</span>, <span class="tok-number">0xc8</span>, <span class="tok-number">0xa3</span>, <span class="tok-number">0x48</span>, <span class="tok-number">0x24</span>, <span class="tok-number">0x9d</span>, <span class="tok-number">0x75</span>, <span class="tok-number">0x27</span>, <span class="tok-number">0x48</span>, <span class="tok-number">0xec</span>, <span class="tok-number">0x03</span>, <span class="tok-number">0xb0</span>, <span class="tok-number">0xbb</span>, <span class="tok-number">0xdf</span>, <span class="tok-number">0x33</span>, <span class="tok-number">0x90</span>, <span class="tok-number">0xe3</span>, <span class="tok-number">0x93</span>, <span class="tok-number">0xed</span>, <span class="tok-number">0x68</span>, <span class="tok-number">0x24</span>, <span class="tok-number">0x39</span>, <span class="tok-number">0x12</span>, <span class="tok-number">0xdf</span>, <span class="tok-number">0xea</span>, <span class="tok-number">0xee</span>, <span class="tok-number">0x8c</span>, <span class="tok-number">0x9f</span>, <span class="tok-number">0x96</span>, <span class="tok-number">0xde</span>, <span class="tok-number">0x42</span>, <span class="tok-number">0x46</span>, <span class="tok-number">0x8c</span>, <span class="tok-number">0x2b</span>, <span class="tok-number">0x17</span>, <span class="tok-number">0x83</span>, <span class="tok-number">0x36</span>, <span class="tok-number">0xfb</span>, <span class="tok-number">0xf4</span>, <span class="tok-number">0xf7</span>, <span class="tok-number">0xff</span>, <span class="tok-number">0x79</span>, <span class="tok-number">0xb9</span>, <span class="tok-number">0x45</span>, <span class="tok-number">0x41</span>, <span class="tok-number">0xc9</span>, <span class="tok-number">0x56</span>, <span class="tok-number">0x1a</span>, <span class="tok-number">0x6b</span>, <span class="tok-number">0x0c</span>, <span class="tok-number">0xa4</span>, <span class="tok-number">0x1a</span>, <span class="tok-number">0xdd</span>, <span class="tok-number">0x6b</span>, <span class="tok-number">0x95</span>, <span class="tok-number">0xe8</span>, <span class="tok-number">0x03</span>, <span class="tok-number">0x0f</span>, <span class="tok-number">0x09</span>, <span class="tok-number">0x29</span>, <span class="tok-number">0x40</span>, <span class="tok-number">0x1b</span>, <span class="tok-number">0xea</span>, <span class="tok-number">0x87</span>, <span class="tok-number">0xfa</span>, <span class="tok-number">0xb9</span>, <span class="tok-number">0x18</span>, <span class="tok-number">0xa9</span>, <span class="tok-number">0x95</span>, <span class="tok-number">0x07</span>, <span class="tok-number">0x7c</span>, <span class="tok-number">0x2f</span>, <span class="tok-number">0x7c</span>, <span class="tok-number">0x33</span>, <span class="tok-number">0xfb</span>, <span class="tok-number">0xc5</span>, <span class="tok-number">0x11</span>, <span class="tok-number">0x5e</span>, <span class="tok-number">0x81</span>, <span class="tok-number">0x0e</span>, <span class="tok-number">0xbc</span>, <span class="tok-number">0xae</span>, <span class="tok-number">0xec</span>, <span class="tok-number">0xb3</span>, <span class="tok-number">0xe1</span>, <span class="tok-number">0x4a</span>, <span class="tok-number">0x26</span>, <span class="tok-number">0x56</span>, <span class="tok-number">0xe8</span>, <span class="tok-number">0x5b</span>, <span class="tok-number">0x11</span>, <span class="tok-number">0x9d</span>, <span class="tok-number">0x37</span>, <span class="tok-number">0x06</span>, <span class="tok-number">0x9b</span>, <span class="tok-number">0x34</span>, <span class="tok-number">0x31</span>, <span class="tok-number">0x6e</span>, <span class="tok-number">0xa3</span>, <span class="tok-number">0xba</span>, <span class="tok-number">0x41</span>, <span class="tok-number">0xbc</span>, <span class="tok-number">0x11</span>, <span class="tok-number">0xd8</span>, <span class="tok-number">0xc5</span>, <span class="tok-number">0x15</span>, <span class="tok-number">0xc9</span>, <span class="tok-number">0x30</span>, <span class="tok-number">0x2c</span>, <span class="tok-number">0x9b</span>, <span class="tok-number">0xb6</span>, <span class="tok-number">0x71</span>, <span class="tok-number">0xd8</span>, <span class="tok-number">0x7c</span>, <span class="tok-number">0xbc</span>, <span class="tok-number">0x38</span>, <span class="tok-number">0x2f</span>, <span class="tok-number">0xd5</span>, <span class="tok-number">0xbd</span>, <span class="tok-number">0x30</span>, <span class="tok-number">0x96</span>, <span class="tok-number">0xd4</span>, <span class="tok-number">0xa3</span>, <span class="tok-number">0x00</span>, <span class="tok-number">0x77</span>, <span class="tok-number">0x9d</span>, <span class="tok-number">0x55</span>, <span class="tok-number">0x4a</span>, <span class="tok-number">0x33</span>, <span class="tok-number">0x53</span>, <span class="tok-number">0xb6</span>, <span class="tok-number">0xb3</span>, <span class="tok-number">0x35</span>, <span class="tok-number">0x1b</span>, <span class="tok-number">0xae</span>, <span class="tok-number">0xe5</span>, <span class="tok-number">0xdc</span>, <span class="tok-number">0x22</span>, <span class="tok-number">0x23</span>, <span class="tok-number">0x85</span>, <span class="tok-number">0x95</span>, <span class="tok-number">0x88</span>, <span class="tok-number">0xf9</span>, <span class="tok-number">0x3b</span>, <span class="tok-number">0xbf</span>, <span class="tok-number">0x74</span>, <span class="tok-number">0x13</span>, <span class="tok-number">0xaa</span>, <span class="tok-number">0xcb</span>, <span class="tok-number">0x0a</span>, <span class="tok-number">0x60</span>, <span class="tok-number">0x79</span>, <span class="tok-number">0x13</span>, <span class="tok-number">0x79</span>, <span class="tok-number">0xc0</span>, <span class="tok-number">0x4a</span>, <span class="tok-number">0x02</span>, <span class="tok-number">0xdb</span>, <span class="tok-number">0x1c</span>, <span class="tok-number">0xc9</span>, <span class="tok-number">0xff</span>, <span class="tok-number">0x60</span>, <span class="tok-number">0x57</span>, <span class="tok-number">0x9a</span>, <span class="tok-number">0x70</span>, <span class="tok-number">0x28</span>, <span class="tok-number">0x58</span>, <span class="tok-number">0x60</span>, <span class="tok-number">0xbc</span>, <span class="tok-number">0x57</span>, <span class="tok-number">0x07</span>, <span class="tok-number">0xc7</span>, <span class="tok-number">0x47</span>, <span class="tok-number">0x1a</span>, <span class="tok-number">0x45</span>, <span class="tok-number">0x71</span>, <span class="tok-number">0x76</span>, <span class="tok-number">0x94</span>, <span class="tok-number">0xfb</span>, <span class="tok-number">0x05</span>, <span class="tok-number">0xad</span>, <span class="tok-number">0xec</span>, <span class="tok-number">0x12</span>, <span class="tok-number">0x29</span>, <span class="tok-number">0x5a</span>, <span class="tok-number">0x44</span>, <span class="tok-number">0x6a</span>, <span class="tok-number">0x81</span>, <span class="tok-number">0xd9</span>, <span class="tok-number">0xc6</span>, <span class="tok-number">0xf0</span>, <span class="tok-number">0xb6</span>, <span class="tok-number">0x9b</span>, <span class="tok-number">0x97</span>, <span class="tok-number">0x83</span>, <span class="tok-number">0x69</span>, <span class="tok-number">0xfb</span>, <span class="tok-number">0xdc</span>, <span class="tok-number">0x0d</span>, <span class="tok-number">0x4a</span>, <span class="tok-number">0x67</span>, <span class="tok-number">0xbc</span>, <span class="tok-number">0x72</span>, <span class="tok-number">0xf5</span>, <span class="tok-number">0x43</span>, <span class="tok-number">0x5e</span>, <span class="tok-number">0x9b</span>, <span class="tok-number">0x13</span>, <span class="tok-number">0xf2</span>, <span class="tok-number">0xe4</span>, <span class="tok-number">0x6d</span>, <span class="tok-number">0x49</span>, <span class="tok-number">0xdb</span>, <span class="tok-number">0x76</span>, <span class="tok-number">0xcb</span>, <span class="tok-number">0x42</span>, <span class="tok-number">0x6a</span>, <span class="tok-number">0x3c</span>, <span class="tok-number">0x9f</span>, <span class="tok-number">0xa1</span>, <span class="tok-number">0xfe</span>, <span class="tok-number">0x5e</span>, <span class="tok-number">0xca</span>, <span class="tok-number">0x0a</span>, <span class="tok-number">0xfc</span>, <span class="tok-number">0xfa</span>, <span class="tok-number">0x39</span>, <span class="tok-number">0x27</span>, <span class="tok-number">0xd1</span>, <span class="tok-number">0x3c</span>, <span class="tok-number">0xcb</span>, <span class="tok-number">0x9a</span>, <span class="tok-number">0xde</span>, <span class="tok-number">0x4c</span>, <span class="tok-number">0x6b</span>, <span class="tok-number">0x09</span>, <span class="tok-number">0x8b</span>, <span class="tok-number">0x49</span>, <span class="tok-number">0xfd</span>, <span class="tok-number">0x1e</span>, <span class="tok-number">0x3d</span>, <span class="tok-number">0x5e</span>, <span class="tok-number">0x67</span>, <span class="tok-number">0x7c</span>, <span class="tok-number">0x57</span>, <span class="tok-number">0xad</span>, <span class="tok-number">0x90</span>, <span class="tok-number">0xcc</span>, <span class="tok-number">0x46</span>, <span class="tok-number">0x5f</span>, <span class="tok-number">0x5c</span>, <span class="tok-number">0xae</span>, <span class="tok-number">0x6a</span>, <span class="tok-number">0x9c</span>, <span class="tok-number">0xb2</span>, <span class="tok-number">0xcd</span>, <span class="tok-number">0x2c</span>, <span class="tok-number">0x89</span>, <span class="tok-number">0x78</span>, <span class="tok-number">0xcf</span>, <span class="tok-number">0xf1</span>, <span class="tok-number">0x49</span>, <span class="tok-number">0x96</span>, <span class="tok-number">0x55</span>, <span class="tok-number">0x1e</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0xef</span>, <span class="tok-number">0x0e</span>, <span class="tok-number">0x1c</span>, <span class="tok-number">0xde</span>, <span class="tok-number">0x6c</span>, <span class="tok-number">0x96</span>, <span class="tok-number">0x51</span>, <span class="tok-number">0x00</span>, <span class="tok-number">0xee</span>, <span class="tok-number">0x9a</span>, <span class="tok-number">0x1f</span>, <span class="tok-number">0x8d</span>, <span class="tok-number">0x61</span>, <span class="tok-number">0xbc</span>, <span class="tok-number">0xeb</span>, <span class="tok-number">0xb1</span>, <span class="tok-number">0xa6</span>, <span class="tok-number">0xa5</span>, <span class="tok-number">0x21</span>, <span class="tok-number">0x8b</span>, <span class="tok-number">0xa7</span>, <span class="tok-number">0xf8</span>, <span class="tok-number">0x25</span>, <span class="tok-number">0x41</span>, <span class="tok-number">0x48</span>, <span class="tok-number">0x62</span>, <span class="tok-number">0x5b</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x6c</span>, <span class="tok-number">0x7c</span>, <span class="tok-number">0x2a</span>, <span class="tok-number">0xe8</span>, <span class="tok-number">0xff</span>, <span class="tok-number">0xf9</span>, <span class="tok-number">0xf9</span>, <span class="tok-number">0x1f</span>, <span class="tok-number">0xe2</span>, <span class="tok-number">0x79</span>, <span class="tok-number">0x2e</span>, <span class="tok-number">0xd1</span>, <span class="tok-number">0xff</span>, <span class="tok-number">0xa3</span>, <span class="tok-number">0x2e</span>, <span class="tok-number">0x1c</span>, <span class="tok-number">0x3a</span>, <span class="tok-number">0x1a</span>, <span class="tok-number">0x5d</span>, <span class="tok-number">0x2b</span>, <span class="tok-number">0x7b</span>, <span class="tok-number">0x87</span>, <span class="tok-number">0x25</span>, <span class="tok-number">0x22</span>, <span class="tok-number">0xa4</span>, <span class="tok-number">0x90</span>, <span class="tok-number">0xea</span>, <span class="tok-number">0x26</span>, <span class="tok-number">0x9d</span>, <span class="tok-number">0xdd</span>, <span class="tok-number">0x13</span>, <span class="tok-number">0x60</span>, <span class="tok-number">0x4c</span>, <span class="tok-number">0x10</span>, <span class="tok-number">0x03</span>, <span class="tok-number">0xf6</span>, <span class="tok-number">0x99</span>, <span class="tok-number">0xd3</span>, <span class="tok-number">0x21</span>, <span class="tok-number">0x0c</span>, <span class="tok-number">0x69</span>, <span class="tok-number">0xc6</span>, <span class="tok-number">0xd8</span>, <span class="tok-number">0xc8</span>, <span class="tok-number">0x9e</span>, <span class="tok-number">0x94</span>, <span class="tok-number">0x89</span>, <span class="tok-number">0x51</span>, <span class="tok-number">0x21</span>, <span class="tok-number">0xe3</span>, <span class="tok-number">0x9a</span>, <span class="tok-number">0xcd</span>, <span class="tok-number">0xda</span>, <span class="tok-number">0x54</span>, <span class="tok-number">0x72</span>, <span class="tok-number">0x64</span>, <span class="tok-number">0xae</span>, <span class="tok-number">0x94</span>, <span class="tok-number">0x79</span>, <span class="tok-number">0x36</span>, <span class="tok-number">0x81</span>, <span class="tok-number">0x44</span>, <span class="tok-number">0x14</span>, <span class="tok-number">0x6d</span>, <span class="tok-number">0x3a</span>, <span class="tok-number">0x0e</span>, <span class="tok-number">0xa6</span>, <span class="tok-number">0x30</span>, <span class="tok-number">0xbf</span>, <span class="tok-number">0x95</span>, <span class="tok-number">0x99</span>, <span class="tok-number">0xa6</span>, <span class="tok-number">0xf5</span>, <span class="tok-number">0x7f</span>, <span class="tok-number">0x4f</span>, <span class="tok-number">0xef</span>, <span class="tok-number">0xc6</span>, <span class="tok-number">0x71</span>, <span class="tok-number">0x2f</span>, <span class="tok-number">0x36</span>, <span class="tok-number">0x13</span>, <span class="tok-number">0x14</span>, <span class="tok-number">0xa2</span>, <span class="tok-number">0x9d</span>, <span class="tok-number">0xc2</span>, <span class="tok-number">0x0c</span>, <span class="tok-number">0x0d</span>, <span class="tok-number">0x4e</span>, <span class="tok-number">0xc0</span>, <span class="tok-number">0x02</span>, <span class="tok-number">0xd3</span>, <span class="tok-number">0x6f</span>, <span class="tok-number">0xee</span>, <span class="tok-number">0x98</span>, <span class="tok-number">0x5e</span>, <span class="tok-number">0x24</span>, <span class="tok-number">0x31</span>, <span class="tok-number">0x74</span>, <span class="tok-number">0x11</span>, <span class="tok-number">0x96</span>, <span class="tok-number">0x6e</span>, <span class="tok-number">0x43</span>, <span class="tok-number">0x57</span>, <span class="tok-number">0xe8</span>, <span class="tok-number">0x8e</span>, <span class="tok-number">0xa0</span>, <span class="tok-number">0x8d</span>, <span class="tok-number">0x3d</span>, <span class="tok-number">0x79</span>, <span class="tok-number">0x38</span>, <span class="tok-number">0x20</span>, <span class="tok-number">0xc2</span>, <span class="tok-number">0x0f</span>, <span class="tok-number">0xb4</span>, <span class="tok-number">0x75</span>, <span class="tok-number">0x99</span>, <span class="tok-number">0x3b</span>, <span class="tok-number">0xb1</span>, <span class="tok-number">0xf0</span>, <span class="tok-number">0xe8</span>, <span class="tok-number">0xe1</span>, <span class="tok-number">0xda</span>, <span class="tok-number">0xf9</span>, <span class="tok-number">0xd4</span>, <span class="tok-number">0xe6</span>, <span class="tok-number">0xd6</span>, <span class="tok-number">0xf4</span>, <span class="tok-number">0x8a</span>, <span class="tok-number">0x32</span>, <span class="tok-number">0x4a</span>, <span class="tok-number">0x4a</span>, <span class="tok-number">0x25</span>, <span class="tok-number">0xa8</span>, <span class="tok-number">0xd9</span>, <span class="tok-number">0x60</span>, <span class="tok-number">0xd6</span>, <span class="tok-number">0x33</span>, <span class="tok-number">0x31</span>, <span class="tok-number">0x97</span>, <span class="tok-number">0xb9</span>, <span class="tok-number">0xb6</span>, <span class="tok-number">0xed</span>, <span class="tok-number">0x5f</span>, <span class="tok-number">0xfc</span>, <span class="tok-number">0x15</span>, <span class="tok-number">0xbd</span>, <span class="tok-number">0x13</span>, <span class="tok-number">0xc0</span>, <span class="tok-number">0x3a</span>, <span class="tok-number">0x3f</span>, <span class="tok-number">0x1f</span>, <span class="tok-number">0x2d</span>, <span class="tok-number">0x09</span>, <span class="tok-number">0x1d</span>, <span class="tok-number">0xeb</span>, <span class="tok-number">0x69</span>, <span class="tok-number">0x6a</span>, <span class="tok-number">0xfe</span>, <span class="tok-number">0xd7</span>, <span class="tok-number">0x95</span>, <span class="tok-number">0x3e</span>, <span class="tok-number">0x8a</span>, <span class="tok-number">0x4e</span>, <span class="tok-number">0xe1</span>, <span class="tok-number">0x6e</span>, <span class="tok-number">0x61</span>, <span class="tok-number">0xb2</span>, <span class="tok-number">0x6c</span>, <span class="tok-number">0xe3</span>, <span class="tok-number">0x2b</span>, <span class="tok-number">0x70</span>, <span class="tok-number">0x60</span>, <span class="tok-number">0x7e</span>, <span class="tok-number">0x8c</span>, <span class="tok-number">0xe4</span>, <span class="tok-number">0xdd</span>, <span class="tok-number">0x27</span>, <span class="tok-number">0x30</span>, <span class="tok-number">0x7e</span>, <span class="tok-number">0x0d</span>, <span class="tok-number">0xc7</span>, <span class="tok-number">0xb7</span>, <span class="tok-number">0x9a</span>, <span class="tok-number">0x1a</span>, <span class="tok-number">0x3c</span>, <span class="tok-number">0xcc</span>, <span class="tok-number">0xa7</span>, <span class="tok-number">0x22</span>, <span class="tok-number">0x77</span>, <span class="tok-number">0x14</span>, <span class="tok-number">0x05</span>, <span class="tok-number">0x50</span>, <span class="tok-number">0x57</span>, <span class="tok-number">0x31</span>, <span class="tok-number">0x1b</span>, <span class="tok-number">0xc8</span>, <span class="tok-number">0xbf</span>, <span class="tok-number">0xce</span>, <span class="tok-number">0x52</span>, <span class="tok-number">0xaf</span>, <span class="tok-number">0x9c</span>, <span class="tok-number">0x8e</span>, <span class="tok-number">0x10</span>, <span class="tok-number">0x2e</span>, <span class="tok-number">0xd2</span>, <span class="tok-number">0x16</span>, <span class="tok-number">0xb6</span>, <span class="tok-number">0x6e</span>, <span class="tok-number">0x43</span>, <span class="tok-number">0x10</span>, <span class="tok-number">0xaf</span>, <span class="tok-number">0x8b</span>, <span class="tok-number">0xde</span>, <span class="tok-number">0x1d</span>, <span class="tok-number">0x60</span>, <span class="tok-number">0xb2</span>, <span class="tok-number">0x7d</span>, <span class="tok-number">0xe6</span>, <span class="tok-number">0x2f</span>, <span class="tok-number">0x08</span>, <span class="tok-number">0x10</span>, <span class="tok-number">0x12</span>, <span class="tok-number">0x7e</span>, <span class="tok-number">0xb4</span>, <span class="tok-number">0x76</span>, <span class="tok-number">0x45</span>, <span class="tok-number">0xb6</span>, <span class="tok-number">0xd8</span>, <span class="tok-number">0x9b</span>, <span class="tok-number">0x26</span>, <span class="tok-number">0x40</span>, <span class="tok-number">0xa1</span>, <span class="tok-number">0x63</span>, <span class="tok-number">0x5c</span>, <span class="tok-number">0x7a</span>, <span class="tok-number">0x2a</span>, <span class="tok-number">0xb1</span>, <span class="tok-number">0x8c</span>, <span class="tok-number">0xd6</span>, <span class="tok-number">0xa4</span>, <span class="tok-number">0x6f</span>, <span class="tok-number">0x5a</span>, <span class="tok-number">0xae</span>, <span class="tok-number">0x33</span>, <span class="tok-number">0x7e</span>, <span class="tok-number">0x6d</span>, <span class="tok-number">0x71</span>, <span class="tok-number">0xf5</span>, <span class="tok-number">0xc8</span>, <span class="tok-number">0x6d</span>, <span class="tok-number">0x80</span>, <span class="tok-number">0x1c</span>, <span class="tok-number">0x35</span>, <span class="tok-number">0xfc</span>, <span class="tok-number">0x3f</span>, <span class="tok-number">0xc1</span>, <span class="tok-number">0xa6</span>, <span class="tok-number">0xc6</span>, <span class="tok-number">0x1a</span>, <span class="tok-number">0x15</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x6d</span>, <span class="tok-number">0x76</span>, <span class="tok-number">0x38</span>, <span class="tok-number">0x32</span>, <span class="tok-number">0x95</span>, <span class="tok-number">0xb2</span>, <span class="tok-number">0x51</span>, <span class="tok-number">0x1a</span>, <span class="tok-number">0xe9</span>, <span class="tok-number">0x3e</span>, <span class="tok-number">0x89</span>, <span class="tok-number">0x9f</span>, <span class="tok-number">0x0c</span>, <span class="tok-number">0x79</span> };
    <span class="tok-kw">var</span> out: [<a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_256">Sha3_256</a>.<a href="#">digest_length</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

    <a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_256">Sha3_256</a>.<a href="#">hash</a>(&amp;msg, &amp;out, .{});
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;5780048dfa381a1d01c747906e4a08711dd34fd712ecd7c6801dd2b38fd81a89&quot;</span>, &amp;out);

    <span class="tok-kw">var</span> h = <a href="std.crypto.sha3.html#std.crypto.sha3.Sha3_256">Sha3_256</a>.<a href="#">init</a>(.{});
    h.update(msg[<span class="tok-number">0</span>..<span class="tok-number">64</span>]);
    h.update(msg[<span class="tok-number">64</span>..<span class="tok-number">613</span>]);
    h.final(&amp;out);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;5780048dfa381a1d01c747906e4a08711dd34fd712ecd7c6801dd2b38fd81a89&quot;</span>, &amp;out);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;cSHAKE-128 with no context nor function name&quot;</span> {
    <span class="tok-kw">var</span> out: [<span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <a href="std.crypto.sha3.html#std.crypto.sha3.CShake128">CShake128</a>.<a href="#">hash</a>(<span class="tok-str">&quot;hello123&quot;</span>, &amp;out, .{});
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;1b85861510bc4d8e467d6f8a92270533cbaa7ba5e06c2d2a502854bac468b8b9&quot;</span>, &amp;out);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;cSHAKE-128 with context&quot;</span> {
    <span class="tok-kw">var</span> out: [<span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <a href="std.crypto.sha3.html#std.crypto.sha3.CShake128">CShake128</a>.<a href="#">hash</a>(<span class="tok-str">&quot;hello123&quot;</span>, &amp;out, .{ .context = <span class="tok-str">&quot;custom&quot;</span> });
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;7509fa13a6bd3e38ad5c6fac042142c233996e40ebffc86c276f108b3b19cc6a&quot;</span>, &amp;out);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;cSHAKE-128 with context and function&quot;</span> {
    <span class="tok-kw">var</span> out: [<span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <a href="std.crypto.sha3.html#std.crypto.sha3.CShake">CShake</a>(<span class="tok-number">128</span>, <span class="tok-str">&quot;function&quot;</span>).hash(<span class="tok-str">&quot;hello123&quot;</span>, &amp;out, .{ .context = <span class="tok-str">&quot;custom&quot;</span> });
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;ad7f4d7db2d96587fcd5047c65d37c368f5366e3afac60bb9b66b0bb95dfb675&quot;</span>, &amp;out);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;cSHAKE-256&quot;</span> {
    <span class="tok-kw">var</span> out: [<span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <a href="std.crypto.sha3.html#std.crypto.sha3.CShake256">CShake256</a>.<a href="#">hash</a>(<span class="tok-str">&quot;hello123&quot;</span>, &amp;out, .{ .context = <span class="tok-str">&quot;custom&quot;</span> });
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;dabe027eb1a6cbe3a0542d0560eb4e6b39146dd72ae1bf89c970a61bd93b1813&quot;</span>, &amp;out);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;KMAC-128 with empty key and message&quot;</span> {
    <span class="tok-kw">var</span> out: [<a href="std.crypto.sha3.html#std.crypto.sha3.KMac128">KMac128</a>.<a href="#">mac_length</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> key = <span class="tok-str">&quot;&quot;</span>;
    <a href="std.crypto.sha3.html#std.crypto.sha3.KMac128">KMac128</a>.<a href="#">create</a>(&amp;out, <span class="tok-str">&quot;&quot;</span>, key);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;5c135c615152fb4d9784dd1155f9b6034e013fd77165c327dfa4d36701983ef7&quot;</span>, &amp;out);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;KMAC-128&quot;</span> {
    <span class="tok-kw">var</span> out: [<a href="std.crypto.sha3.html#std.crypto.sha3.KMac128">KMac128</a>.<a href="#">mac_length</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> key = <span class="tok-str">&quot;A KMAC secret key&quot;</span>;
    <a href="std.crypto.sha3.html#std.crypto.sha3.KMac128">KMac128</a>.<a href="#">create</a>(&amp;out, <span class="tok-str">&quot;hello123&quot;</span>, key);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;1fa1c0d761129a83f9a4299ca137674de8373a3cc437799ae4c129e651627f8e&quot;</span>, &amp;out);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;KMAC-128 with a customization string&quot;</span> {
    <span class="tok-kw">var</span> out: [<a href="std.crypto.sha3.html#std.crypto.sha3.KMac128">KMac128</a>.<a href="#">mac_length</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> key = <span class="tok-str">&quot;A KMAC secret key&quot;</span>;
    <a href="std.crypto.sha3.html#std.crypto.sha3.KMac128">KMac128</a>.<a href="#">createWithOptions</a>(&amp;out, <span class="tok-str">&quot;hello123&quot;</span>, key, .{ .context = <span class="tok-str">&quot;custom&quot;</span> });
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;c58c6d42dc00a27dfa8e7e08f8c9307cecb5d662ddb11b6c36057fc2e0e068ba&quot;</span>, &amp;out);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;KMACXOF-128&quot;</span> {
    <span class="tok-kw">const</span> key = <span class="tok-str">&quot;A KMAC secret key&quot;</span>;
    <span class="tok-kw">var</span> xof = <a href="std.crypto.sha3.html#std.crypto.sha3.KMac128">KMac128</a>.<a href="#">init</a>(key);
    xof.update(<span class="tok-str">&quot;hello123&quot;</span>);
    <span class="tok-kw">var</span> out: [<span class="tok-number">50</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    xof.squeeze(&amp;out);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;628c2fb870d294b3673ac82d9f0d651aae6a5bb8084ea8cd8343cb888d075b9053173200a71f301141069c3c0322527981f7&quot;</span>, &amp;out);
    xof.squeeze(&amp;out);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;7b638e178cfdac5727a4ea7694efaa967a65a1d0034501855acff506b4158d187d5a18d668e67b43f2abf61144b20ed4c09f&quot;</span>, &amp;out);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;KMACXOF-256&quot;</span> {
    <span class="tok-kw">const</span> key = <span class="tok-str">&quot;A KMAC secret key&quot;</span>;
    <span class="tok-kw">var</span> xof = <a href="std.crypto.sha3.html#std.crypto.sha3.KMac256">KMac256</a>.<a href="#">init</a>(key);
    xof.update(<span class="tok-str">&quot;hello123&quot;</span>);
    <span class="tok-kw">var</span> out: [<span class="tok-number">50</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    xof.squeeze(&amp;out);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;23fc644bc2655ba6fde7b7c11f2804f22e8d8c6bd7db856268bf3370ce2362703f6c7e91916a1b8c116e60edfbcb25613054&quot;</span>, &amp;out);
    xof.squeeze(&amp;out);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;ff97251020ff255ee65a1c1f5f78ebe904f61211c39f973f82fbce2b196b9f51c2cb12afe51549a0f1eaf7954e657ba11af3&quot;</span>, &amp;out);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;TupleHash-128&quot;</span> {
    <span class="tok-kw">var</span> st = <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHash128">TupleHash128</a>.<a href="#">init</a>();
    st.update(<span class="tok-str">&quot;hello&quot;</span>);
    st.update(<span class="tok-str">&quot;123&quot;</span>);
    <span class="tok-kw">var</span> out: [<span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    st.final(&amp;out);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;3938d49ade8ec0f0c305ac63497b2d2e8b2f650714f9667cc41816b1c11ffd20&quot;</span>, &amp;out);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;TupleHash-256&quot;</span> {
    <span class="tok-kw">var</span> st = <a href="std.crypto.sha3.html#std.crypto.sha3.TupleHash256">TupleHash256</a>.<a href="#">init</a>();
    st.update(<span class="tok-str">&quot;hello&quot;</span>);
    st.update(<span class="tok-str">&quot;123&quot;</span>);
    <span class="tok-kw">var</span> out: [<span class="tok-number">64</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    st.final(&amp;out);
    <span class="tok-kw">try</span> <a href="std.crypto.sha3.html#std.crypto.sha3.htest">htest</a>.<a href="#">assertEqual</a>(<span class="tok-str">&quot;2dca563c2882f2ba4f46a441a4c5e13fb97150d1436fe99c7e4e43a2d20d0f1cd3d38483bde4a966930606dfa6c61c4ca6400aeedfb474d1bf0d7f6a70968289&quot;</span>, &amp;out);
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
