<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.enums.html" class="active">enums</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.enums" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.enums</span><a href="#src.zig-std.enums">[src]</a></h1><div class="tldDocs"><p>This module contains utilities and data structures for working with enums.</p>
</div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.enums.EnumFieldStruct" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">EnumFieldStruct</span><a href="#src.zig-std.enums.EnumFieldStruct">[src]</a></h2><div class="tldDocs"><p>Returns a struct with a field matching each unique named enum element.
If the enum is extern and has multiple names for the same value, only
the first name is used.  Each field is of type Data and has the provided
default, which may be undefined.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>E: <span class="tok-type">type</span></code></pre></div><div><pre><code>Data: <span class="tok-type">type</span></code></pre></div><div><pre><code>field_default: ?Data</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.enums.EnumFieldStruct">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">EnumFieldStruct</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Data: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> field_default: ?Data) <span class="tok-type">type</span> {
    <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len + <a href="std.enums.html#std.enums.eval_branch_quota_cushion">eval_branch_quota_cushion</a>);
    <span class="tok-kw">var</span> struct_fields: [<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len]<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.StructField.html">StructField</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">for</span> (&amp;struct_fields, <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |*struct_field, enum_field| {
        struct_field.* = .{
            .name = enum_field.name ++ <span class="tok-str">&quot;&quot;</span>,
            .<span class="tok-type">type</span> = Data,
            .default_value_ptr = <span class="tok-kw">if</span> (field_default) |d| <span class="tok-builtin">@as</span>(?*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(&amp;d)) <span class="tok-kw">else</span> <span class="tok-null">null</span>,
            .is_comptime = <span class="tok-null">false</span>,
            .alignment = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Data) &gt; <span class="tok-number">0</span>) <span class="tok-builtin">@alignOf</span>(Data) <span class="tok-kw">else</span> <span class="tok-number">0</span>,
        };
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{ .@&quot;struct&quot; = .{
        .layout = .auto,
        .fields = &amp;struct_fields,
        .decls = &amp;.{},
        .is_tuple = <span class="tok-null">false</span>,
    } });
}</code></pre></details></div></div><div class="decl"><h2 id="std.enums.EnumSet" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">EnumSet</span><a href="#src.zig-std.enums.EnumSet">[src]</a></h2><div class="tldDocs"><p>A set of enum elements, backed by a bitfield.  If the enum
is exhaustive but not dense, a mapping will be constructed from enum values
to dense indices.  This type does no dynamic allocation and
can be copied by value.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>E: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.enums.EnumSet.Iterator.html">std.enums.EnumSet.Iterator</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.enums.EnumSet.Indexer" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Indexer</span><a href="#src.zig-std.enums.EnumSet.Indexer">[src]</a></h3><div class="tldDocs"><p>The indexing rules for converting between keys and indices.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.Indexer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>bits: <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a> = <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a>.<a href="#">initEmpty</a>()</code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.enums.EnumSet.Key" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Key</span><a href="#src.zig-std.enums.EnumSet.Key">[src]</a></h3><div class="tldDocs"><p>The element type for this set.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.Key">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">Key</a></code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.len" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">len</span><a href="#src.zig-std.enums.EnumSet.len">[src]</a></h3><div class="tldDocs"><p>The maximum number of items in this set.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.len">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> len = <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">count</a></code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.enums.EnumSet.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.enums.EnumSet.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <span class="tok-type">bool</span>, <span class="tok-null">false</span>)) <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div class="tldDocs"><p>Initializes the set using a struct of bools</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <span class="tok-type">bool</span>, <span class="tok-null">false</span>)</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <span class="tok-type">bool</span>, <span class="tok-null">false</span>)) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
    <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
    <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumSet">Self</a> = .{};
    <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.is_exhaustive) {
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<a href="std.enums.html#std.enums.EnumSet">Self</a>.<a href="std.enums.html#std.enums.EnumSet.len">len</a>) |i| {
            <span class="tok-kw">const</span> key = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(i);
            <span class="tok-kw">const</span> tag = <span class="tok-builtin">@tagName</span>(key);
            <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(init_values, tag)) {
                result.bits.set(i);
            }
        }
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(E)) |field| {
            <span class="tok-kw">const</span> key = <span class="tok-builtin">@field</span>(E, field.name);
            <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(init_values, field.name)) {
                <span class="tok-kw">const</span> i = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
                result.bits.set(i);
            }
        }
    }
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.initEmpty" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initEmpty</span><a href="#src.zig-std.enums.EnumSet.initEmpty">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns a set containing no keys.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.initEmpty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.enums.html#std.enums.EnumSet">Self</a> {
    <span class="tok-kw">return</span> .{ .bits = <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a>.<a href="#">initEmpty</a>() };
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.initFull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initFull</span><a href="#src.zig-std.enums.EnumSet.initFull">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>() <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns a set containing all possible keys.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.initFull">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>() <a href="std.enums.html#std.enums.EnumSet">Self</a> {
    <span class="tok-kw">return</span> .{ .bits = <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a>.<a href="#">initFull</a>() };
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.initMany" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initMany</span><a href="#src.zig-std.enums.EnumSet.initMany">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initMany</span>(keys: []<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns a set containing multiple keys.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>keys: []<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumSet.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.initMany">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initMany</span>(keys: []<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
    <span class="tok-kw">var</span> set = <a href="std.enums.html#std.enums.EnumSet.initEmpty">initEmpty</a>();
    <span class="tok-kw">for</span> (keys) |key| set.insert(key);
    <span class="tok-kw">return</span> set;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.initOne" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initOne</span><a href="#src.zig-std.enums.EnumSet.initOne">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initOne</span>(key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns a set containing a single key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.initOne">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initOne</span>(key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
    <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.EnumSet.initMany">initMany</a>(&amp;[_]<a href="std.enums.html#std.enums.EnumSet.Key">Key</a>{key});
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.enums.EnumSet.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of keys in the set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.bits.count();
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.enums.EnumSet.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Checks if a key is in the set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.bits.isSet(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.insert" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insert</span><a href="#src.zig-std.enums.EnumSet.insert">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts a key in the set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.insert">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span> {
    self.bits.set(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.enums.EnumSet.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Removes a key from the set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span> {
    self.bits.unset(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.setPresent" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setPresent</span><a href="#src.zig-std.enums.EnumSet.setPresent">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setPresent</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>, present: <span class="tok-type">bool</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Changes the presence of a key in the set to match the passed bool.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a></code></pre></div><div><pre><code>present: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.setPresent">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setPresent</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>, present: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    self.bits.setValue(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key), present);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.toggle" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toggle</span><a href="#src.zig-std.enums.EnumSet.toggle">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggle</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Toggles the presence of a key in the set.  If the key is in
the set, removes it.  Otherwise adds it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.toggle">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggle</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span> {
    self.bits.toggle(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.toggleSet" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toggleSet</span><a href="#src.zig-std.enums.EnumSet.toggleSet">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleSet</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Toggles the presence of all keys in the passed set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.toggleSet">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleSet</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span> {
    self.bits.toggleSet(other.bits);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.toggleAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toggleAll</span><a href="#src.zig-std.enums.EnumSet.toggleAll">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleAll</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Toggles all possible keys in the set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.toggleAll">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleAll</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span> {
    self.bits.toggleAll();
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.setUnion" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setUnion</span><a href="#src.zig-std.enums.EnumSet.setUnion">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Adds all keys in the passed set to this set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.setUnion">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span> {
    self.bits.setUnion(other.bits);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.setIntersection" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setIntersection</span><a href="#src.zig-std.enums.EnumSet.setIntersection">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIntersection</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Removes all keys which are not in the passed set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.setIntersection">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIntersection</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span> {
    self.bits.setIntersection(other.bits);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.eql" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">eql</span><a href="#src.zig-std.enums.EnumSet.eql">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff both sets have the same keys.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.eql">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.bits.eql(other.bits);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.subsetOf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">subsetOf</span><a href="#src.zig-std.enums.EnumSet.subsetOf">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff all the keys in this set are
in the other set. The other set may have keys
not found in this set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.subsetOf">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.bits.subsetOf(other.bits);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.supersetOf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">supersetOf</span><a href="#src.zig-std.enums.EnumSet.supersetOf">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff this set contains all the keys
in the other set. This set may have keys not
found in the other set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.supersetOf">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.bits.supersetOf(other.bits);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.complement" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">complement</span><a href="#src.zig-std.enums.EnumSet.complement">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">complement</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns a set with all the keys not in this set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.complement">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">complement</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
    <span class="tok-kw">return</span> .{ .bits = self.bits.complement() };
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.unionWith" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unionWith</span><a href="#src.zig-std.enums.EnumSet.unionWith">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unionWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns a set with keys that are in either this
set or the other set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.unionWith">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unionWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
    <span class="tok-kw">return</span> .{ .bits = self.bits.unionWith(other.bits) };
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.intersectWith" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">intersectWith</span><a href="#src.zig-std.enums.EnumSet.intersectWith">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intersectWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns a set with keys that are in both this
set and the other set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.intersectWith">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intersectWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
    <span class="tok-kw">return</span> .{ .bits = self.bits.intersectWith(other.bits) };
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.xorWith" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">xorWith</span><a href="#src.zig-std.enums.EnumSet.xorWith">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">xorWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns a set with keys that are in either this
set or the other set, but not both.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.xorWith">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">xorWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
    <span class="tok-kw">return</span> .{ .bits = self.bits.xorWith(other.bits) };
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.differenceWith" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">differenceWith</span><a href="#src.zig-std.enums.EnumSet.differenceWith">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">differenceWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns a set with keys that are in this set
except for keys in the other set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.differenceWith">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">differenceWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
    <span class="tok-kw">return</span> .{ .bits = self.bits.differenceWith(other.bits) };
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.enums.EnumSet.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.EnumSet.Iterator.html">Iterator</a></code></pre></div><div class="tldDocs"><p>Returns an iterator over this set, which iterates in
index order.  Modifications to the set during iteration
may or may not be observed by the iterator, but will
not invalidate it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.EnumSet.Iterator.html">Iterator</a> {
    <span class="tok-kw">return</span> .{ .inner = self.bits.iterator(.{}) };
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.enums.EnumSet">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">EnumSet</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// The indexing rules for converting between keys and indices.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E);
        <span class="tok-comment">/// The element type for this set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">Key</a>;

        <span class="tok-kw">const</span> BitSet = <a href="std.html">std</a>.<a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">count</a>);

        <span class="tok-comment">/// The maximum number of items in this set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> len = <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">count</a>;

        bits: <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a> = <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a>.<a href="#">initEmpty</a>(),

        <span class="tok-comment">/// Initializes the set using a struct of bools</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <span class="tok-type">bool</span>, <span class="tok-null">false</span>)) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
            <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumSet">Self</a> = .{};
            <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.is_exhaustive) {
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<a href="std.enums.html#std.enums.EnumSet">Self</a>.<a href="std.enums.html#std.enums.EnumSet.len">len</a>) |i| {
                    <span class="tok-kw">const</span> key = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(i);
                    <span class="tok-kw">const</span> tag = <span class="tok-builtin">@tagName</span>(key);
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(init_values, tag)) {
                        result.bits.set(i);
                    }
                }
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(E)) |field| {
                    <span class="tok-kw">const</span> key = <span class="tok-builtin">@field</span>(E, field.name);
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(init_values, field.name)) {
                        <span class="tok-kw">const</span> i = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
                        result.bits.set(i);
                    }
                }
            }
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns a set containing no keys.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a>.<a href="#">initEmpty</a>() };
        }

        <span class="tok-comment">/// Returns a set containing all possible keys.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>() <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a>.<a href="#">initFull</a>() };
        }

        <span class="tok-comment">/// Returns a set containing multiple keys.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initMany</span>(keys: []<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">var</span> set = <a href="std.enums.html#std.enums.EnumSet.initEmpty">initEmpty</a>();
            <span class="tok-kw">for</span> (keys) |key| set.insert(key);
            <span class="tok-kw">return</span> set;
        }

        <span class="tok-comment">/// Returns a set containing a single key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initOne</span>(key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.EnumSet.initMany">initMany</a>(&amp;[_]<a href="std.enums.html#std.enums.EnumSet.Key">Key</a>{key});
        }

        <span class="tok-comment">/// Returns the number of keys in the set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.bits.count();
        }

        <span class="tok-comment">/// Checks if a key is in the set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.bits.isSet(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
        }

        <span class="tok-comment">/// Puts a key in the set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span> {
            self.bits.set(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
        }

        <span class="tok-comment">/// Removes a key from the set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span> {
            self.bits.unset(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
        }

        <span class="tok-comment">/// Changes the presence of a key in the set to match the passed bool.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setPresent</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>, present: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
            self.bits.setValue(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key), present);
        }

        <span class="tok-comment">/// Toggles the presence of a key in the set.  If the key is in</span>
        <span class="tok-comment">/// the set, removes it.  Otherwise adds it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggle</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span> {
            self.bits.toggle(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
        }

        <span class="tok-comment">/// Toggles the presence of all keys in the passed set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleSet</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span> {
            self.bits.toggleSet(other.bits);
        }

        <span class="tok-comment">/// Toggles all possible keys in the set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleAll</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span> {
            self.bits.toggleAll();
        }

        <span class="tok-comment">/// Adds all keys in the passed set to this set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span> {
            self.bits.setUnion(other.bits);
        }

        <span class="tok-comment">/// Removes all keys which are not in the passed set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIntersection</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span> {
            self.bits.setIntersection(other.bits);
        }

        <span class="tok-comment">/// Returns true iff both sets have the same keys.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.bits.eql(other.bits);
        }

        <span class="tok-comment">/// Returns true iff all the keys in this set are</span>
        <span class="tok-comment">/// in the other set. The other set may have keys</span>
        <span class="tok-comment">/// not found in this set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.bits.subsetOf(other.bits);
        }

        <span class="tok-comment">/// Returns true iff this set contains all the keys</span>
        <span class="tok-comment">/// in the other set. This set may have keys not</span>
        <span class="tok-comment">/// found in the other set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.bits.supersetOf(other.bits);
        }

        <span class="tok-comment">/// Returns a set with all the keys not in this set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">complement</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = self.bits.complement() };
        }

        <span class="tok-comment">/// Returns a set with keys that are in either this</span>
        <span class="tok-comment">/// set or the other set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unionWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = self.bits.unionWith(other.bits) };
        }

        <span class="tok-comment">/// Returns a set with keys that are in both this</span>
        <span class="tok-comment">/// set and the other set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intersectWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = self.bits.intersectWith(other.bits) };
        }

        <span class="tok-comment">/// Returns a set with keys that are in either this</span>
        <span class="tok-comment">/// set or the other set, but not both.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">xorWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = self.bits.xorWith(other.bits) };
        }

        <span class="tok-comment">/// Returns a set with keys that are in this set</span>
        <span class="tok-comment">/// except for keys in the other set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">differenceWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = self.bits.differenceWith(other.bits) };
        }

        <span class="tok-comment">/// Returns an iterator over this set, which iterates in</span>
        <span class="tok-comment">/// index order.  Modifications to the set during iteration</span>
        <span class="tok-comment">/// may or may not be observed by the iterator, but will</span>
        <span class="tok-comment">/// not invalidate it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.EnumSet.Iterator.html">Iterator</a> {
            <span class="tok-kw">return</span> .{ .inner = self.bits.iterator(.{}) };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {
            inner: <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a>.<a href="#">Iterator</a>(.{}),

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.enums.EnumSet.Iterator.html">Iterator</a>) ?<a href="std.enums.html#std.enums.EnumSet.Key">Key</a> {
                <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.inner.next()) |index|
                    <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(index)
                <span class="tok-kw">else</span>
                    <span class="tok-null">null</span>;
            }
        };
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.enums.EnumMap" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">EnumMap</span><a href="#src.zig-std.enums.EnumMap">[src]</a></h2><div class="tldDocs"><p>A map keyed by an enum, backed by a bitfield and a dense array.
If the enum is exhaustive but not dense, a mapping will be constructed from
enum values to dense indices.  This type does no dynamic
allocation and can be copied by value.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>E: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.enums.EnumMap.Entry.html">std.enums.EnumMap.Entry</a></li><li><a href="std.enums.EnumMap.Iterator.html">std.enums.EnumMap.Iterator</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.enums.EnumMap.Indexer" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Indexer</span><a href="#src.zig-std.enums.EnumMap.Indexer">[src]</a></h3><div class="tldDocs"><p>The index mapping for this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.Indexer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>bits: <a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a> = <a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a>.<a href="#">initEmpty</a>()</code></pre><div class="fieldDocs"><p>Bits determining whether items are in the map</p>
</div></div><div><pre><code>values: [<a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">count</a>]<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> = <span class="tok-null">undefined</span></code></pre><div class="fieldDocs"><p>Values of items in the map.  If the associated
bit is zero, the value is undefined.</p>
</div></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.enums.EnumMap.Key" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Key</span><a href="#src.zig-std.enums.EnumMap.Key">[src]</a></h3><div class="tldDocs"><p>The key type used to index this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.Key">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">Key</a></code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.Value" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Value</span><a href="#src.zig-std.enums.EnumMap.Value">[src]</a></h3><div class="tldDocs"><p>The value type stored in this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.Value">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Value = V</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.len" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">len</span><a href="#src.zig-std.enums.EnumMap.len">[src]</a></h3><div class="tldDocs"><p>The number of possible keys in the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.len">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> len = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">count</a></code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.enums.EnumMap.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.enums.EnumMap.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-builtin">@as</span>(?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-null">null</span>))) <a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div class="tldDocs"><p>Initializes the map using a sparse struct of optionals</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-builtin">@as</span>(?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-null">null</span>))</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-builtin">@as</span>(?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-null">null</span>))) <a href="std.enums.html#std.enums.EnumMap">Self</a> {
    <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
    <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumMap">Self</a> = .{};
    <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.is_exhaustive) {
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<a href="std.enums.html#std.enums.EnumMap">Self</a>.<a href="std.enums.html#std.enums.EnumMap.len">len</a>) |i| {
            <span class="tok-kw">const</span> key = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(i);
            <span class="tok-kw">const</span> tag = <span class="tok-builtin">@tagName</span>(key);
            <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(init_values, tag)) |*v| {
                result.bits.set(i);
                result.values[i] = v.*;
            }
        }
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(E)) |field| {
            <span class="tok-kw">const</span> key = <span class="tok-builtin">@field</span>(E, field.name);
            <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(init_values, field.name)) |*v| {
                <span class="tok-kw">const</span> i = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
                result.bits.set(i);
                result.values[i] = v.*;
            }
        }
    }
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.initFull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initFull</span><a href="#src.zig-std.enums.EnumMap.initFull">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>(value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) <a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div class="tldDocs"><p>Initializes a full mapping with all keys set to value.
Consider using EnumArray instead if the map will remain full.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.initFull">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>(value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) <a href="std.enums.html#std.enums.EnumMap">Self</a> {
    <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumMap">Self</a> = .{
        .bits = <a href="std.enums.html#std.enums.EnumMap">Self</a>.<a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a>.<a href="#">initFull</a>(),
        .values = <span class="tok-null">undefined</span>,
    };
    <span class="tok-builtin">@memset</span>(&amp;result.values, value);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.initFullWith" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initFullWith</span><a href="#src.zig-std.enums.EnumMap.initFullWith">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFullWith</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-null">null</span>)) <a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div class="tldDocs"><p>Initializes a full mapping with supplied values.
Consider using EnumArray instead if the map will remain full.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-null">null</span>)</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.initFullWith">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFullWith</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-null">null</span>)) <a href="std.enums.html#std.enums.EnumMap">Self</a> {
    <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.EnumMap.initFullWithDefault">initFullWithDefault</a>(<span class="tok-null">null</span>, init_values);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.initFullWithDefault" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initFullWithDefault</span><a href="#src.zig-std.enums.EnumMap.initFullWithDefault">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFullWithDefault</span>(<span class="tok-kw">comptime</span> default: ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, default)) <a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div class="tldDocs"><p>Initializes a full mapping with a provided default.
Consider using EnumArray instead if the map will remain full.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>default: ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div><div><pre><code>init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, default)</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.initFullWithDefault">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFullWithDefault</span>(<span class="tok-kw">comptime</span> default: ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, default)) <a href="std.enums.html#std.enums.EnumMap">Self</a> {
    <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
    <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumMap">Self</a> = .{
        .bits = <a href="std.enums.html#std.enums.EnumMap">Self</a>.<a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a>.<a href="#">initFull</a>(),
        .values = <span class="tok-null">undefined</span>,
    };
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<a href="std.enums.html#std.enums.EnumMap">Self</a>.<a href="std.enums.html#std.enums.EnumMap.len">len</a>) |i| {
        <span class="tok-kw">const</span> key = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(i);
        <span class="tok-kw">const</span> tag = <span class="tok-builtin">@tagName</span>(key);
        result.values[i] = <span class="tok-builtin">@field</span>(init_values, tag);
    }
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.enums.EnumMap.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>The number of items in the map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.bits.count();
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.enums.EnumMap.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Checks if the map contains an item.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.bits.isSet(<a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.enums.EnumMap.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div><div class="tldDocs"><p>Gets the value associated with a key.
If the key is not in the map, returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.bits.isSet(index)) self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.getAssertContains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAssertContains</span><a href="#src.zig-std.enums.EnumMap.getAssertContains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAssertContains</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div><div class="tldDocs"><p>Gets the value associated with a key, which must
exist in the map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.getAssertContains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAssertContains</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    <a href="std.debug.html#std.debug.assert">assert</a>(self.bits.isSet(index));
    <span class="tok-kw">return</span> self.values[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.enums.EnumMap.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?*<a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div><div class="tldDocs"><p>Gets the address of the value associated with a key.
If the key is not in the map, returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?*<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.bits.isSet(index)) &amp;self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.getPtrConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrConst</span><a href="#src.zig-std.enums.EnumMap.getPtrConst">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConst</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?*<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div><div class="tldDocs"><p>Gets the address of the const value associated with a key.
If the key is not in the map, returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.getPtrConst">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConst</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?*<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.bits.isSet(index)) &amp;self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.getPtrAssertContains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAssertContains</span><a href="#src.zig-std.enums.EnumMap.getPtrAssertContains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAssertContains</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div><div class="tldDocs"><p>Gets the address of the value associated with a key.
The key must be present in the map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.getPtrAssertContains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAssertContains</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    <a href="std.debug.html#std.debug.assert">assert</a>(self.bits.isSet(index));
    <span class="tok-kw">return</span> &amp;self.values[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.getPtrConstAssertContains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrConstAssertContains</span><a href="#src.zig-std.enums.EnumMap.getPtrConstAssertContains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConstAssertContains</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div><div class="tldDocs"><p>Gets the address of the const value associated with a key.
The key must be present in the map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.getPtrConstAssertContains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConstAssertContains</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    <a href="std.debug.html#std.debug.assert">assert</a>(self.bits.isSet(index));
    <span class="tok-kw">return</span> &amp;self.values[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.enums.EnumMap.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Adds the key to the map with the supplied value.
If the key is already in the map, overwrites the value.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div><div><pre><code>value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    self.bits.set(index);
    self.values[index] = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.putUninitialized" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putUninitialized</span><a href="#src.zig-std.enums.EnumMap.putUninitialized">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putUninitialized</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div><div class="tldDocs"><p>Adds the key to the map with an undefined value.
If the key is already in the map, the value becomes undefined.
A pointer to the value is returned, which should be
used to initialize the value.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.putUninitialized">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putUninitialized</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    self.bits.set(index);
    self.values[index] = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> &amp;self.values[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.enums.EnumMap.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div><div class="tldDocs"><p>Sets the value associated with the key in the map,
and returns the old value.  If the key was not in
the map, returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div><div><pre><code>value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    <span class="tok-kw">const</span> result: ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> = <span class="tok-kw">if</span> (self.bits.isSet(index)) self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
    self.bits.set(index);
    self.values[index] = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.enums.EnumMap.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Removes a key from the map.  If the key was not in the map,
does nothing.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    self.bits.unset(index);
    self.values[index] = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.fetchRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemove</span><a href="#src.zig-std.enums.EnumMap.fetchRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div><div class="tldDocs"><p>Removes a key from the map, and returns the old value.
If the key was not in the map, returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.fetchRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    <span class="tok-kw">const</span> result: ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> = <span class="tok-kw">if</span> (self.bits.isSet(index)) self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
    self.bits.unset(index);
    self.values[index] = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.enums.EnumMap.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>) <a href="std.enums.EnumMap.Iterator.html">Iterator</a></code></pre></div><div class="tldDocs"><p>Returns an iterator over the map, which visits items in index order.
Modifications to the underlying map may or may not be observed by
the iterator, but will not invalidate it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>) <a href="std.enums.EnumMap.Iterator.html">Iterator</a> {
    <span class="tok-kw">return</span> .{
        .inner = self.bits.iterator(.{}),
        .values = &amp;self.values,
    };
}</code></pre></details></div></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> EnumMap {
    <span class="tok-kw">const</span> Ball = <span class="tok-kw">enum</span> { red, green, blue };

    <span class="tok-kw">const</span> some = <a href="std.enums.html#std.enums.EnumMap">EnumMap</a>(Ball, <span class="tok-type">u8</span>).init(.{
        .green = <span class="tok-number">0xff</span>,
        .blue = <span class="tok-number">0x80</span>,
    });
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, some.count());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, some.get(.red));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0xff</span>, some.get(.green));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0x80</span>, some.get(.blue));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.enums.EnumMap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">EnumMap</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// The index mapping for this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E);
        <span class="tok-comment">/// The key type used to index this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">Key</a>;
        <span class="tok-comment">/// The value type stored in this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Value = V;
        <span class="tok-comment">/// The number of possible keys in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> len = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">count</a>;

        <span class="tok-kw">const</span> BitSet = <a href="std.html">std</a>.<a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">count</a>);

        <span class="tok-comment">/// Bits determining whether items are in the map</span>
        bits: <a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a> = <a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a>.<a href="#">initEmpty</a>(),
        <span class="tok-comment">/// Values of items in the map.  If the associated</span>
        <span class="tok-comment">/// bit is zero, the value is undefined.</span>
        values: [<a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">count</a>]<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> = <span class="tok-null">undefined</span>,

        <span class="tok-comment">/// Initializes the map using a sparse struct of optionals</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-builtin">@as</span>(?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-null">null</span>))) <a href="std.enums.html#std.enums.EnumMap">Self</a> {
            <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
            <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumMap">Self</a> = .{};
            <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.is_exhaustive) {
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<a href="std.enums.html#std.enums.EnumMap">Self</a>.<a href="std.enums.html#std.enums.EnumMap.len">len</a>) |i| {
                    <span class="tok-kw">const</span> key = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(i);
                    <span class="tok-kw">const</span> tag = <span class="tok-builtin">@tagName</span>(key);
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(init_values, tag)) |*v| {
                        result.bits.set(i);
                        result.values[i] = v.*;
                    }
                }
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(E)) |field| {
                    <span class="tok-kw">const</span> key = <span class="tok-builtin">@field</span>(E, field.name);
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(init_values, field.name)) |*v| {
                        <span class="tok-kw">const</span> i = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
                        result.bits.set(i);
                        result.values[i] = v.*;
                    }
                }
            }
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Initializes a full mapping with all keys set to value.</span>
        <span class="tok-comment">/// Consider using EnumArray instead if the map will remain full.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>(value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) <a href="std.enums.html#std.enums.EnumMap">Self</a> {
            <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumMap">Self</a> = .{
                .bits = <a href="std.enums.html#std.enums.EnumMap">Self</a>.<a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a>.<a href="#">initFull</a>(),
                .values = <span class="tok-null">undefined</span>,
            };
            <span class="tok-builtin">@memset</span>(&amp;result.values, value);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Initializes a full mapping with supplied values.</span>
        <span class="tok-comment">/// Consider using EnumArray instead if the map will remain full.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFullWith</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-null">null</span>)) <a href="std.enums.html#std.enums.EnumMap">Self</a> {
            <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.EnumMap.initFullWithDefault">initFullWithDefault</a>(<span class="tok-null">null</span>, init_values);
        }

        <span class="tok-comment">/// Initializes a full mapping with a provided default.</span>
        <span class="tok-comment">/// Consider using EnumArray instead if the map will remain full.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFullWithDefault</span>(<span class="tok-kw">comptime</span> default: ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, default)) <a href="std.enums.html#std.enums.EnumMap">Self</a> {
            <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
            <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumMap">Self</a> = .{
                .bits = <a href="std.enums.html#std.enums.EnumMap">Self</a>.<a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a>.<a href="#">initFull</a>(),
                .values = <span class="tok-null">undefined</span>,
            };
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<a href="std.enums.html#std.enums.EnumMap">Self</a>.<a href="std.enums.html#std.enums.EnumMap.len">len</a>) |i| {
                <span class="tok-kw">const</span> key = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(i);
                <span class="tok-kw">const</span> tag = <span class="tok-builtin">@tagName</span>(key);
                result.values[i] = <span class="tok-builtin">@field</span>(init_values, tag);
            }
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// The number of items in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.bits.count();
        }

        <span class="tok-comment">/// Checks if the map contains an item.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.bits.isSet(<a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
        }

        <span class="tok-comment">/// Gets the value associated with a key.</span>
        <span class="tok-comment">/// If the key is not in the map, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.bits.isSet(index)) self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Gets the value associated with a key, which must</span>
        <span class="tok-comment">/// exist in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAssertContains</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <a href="std.debug.html#std.debug.assert">assert</a>(self.bits.isSet(index));
            <span class="tok-kw">return</span> self.values[index];
        }

        <span class="tok-comment">/// Gets the address of the value associated with a key.</span>
        <span class="tok-comment">/// If the key is not in the map, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?*<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.bits.isSet(index)) &amp;self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Gets the address of the const value associated with a key.</span>
        <span class="tok-comment">/// If the key is not in the map, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConst</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?*<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.bits.isSet(index)) &amp;self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Gets the address of the value associated with a key.</span>
        <span class="tok-comment">/// The key must be present in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAssertContains</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <a href="std.debug.html#std.debug.assert">assert</a>(self.bits.isSet(index));
            <span class="tok-kw">return</span> &amp;self.values[index];
        }

        <span class="tok-comment">/// Gets the address of the const value associated with a key.</span>
        <span class="tok-comment">/// The key must be present in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConstAssertContains</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <a href="std.debug.html#std.debug.assert">assert</a>(self.bits.isSet(index));
            <span class="tok-kw">return</span> &amp;self.values[index];
        }

        <span class="tok-comment">/// Adds the key to the map with the supplied value.</span>
        <span class="tok-comment">/// If the key is already in the map, overwrites the value.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            self.bits.set(index);
            self.values[index] = value;
        }

        <span class="tok-comment">/// Adds the key to the map with an undefined value.</span>
        <span class="tok-comment">/// If the key is already in the map, the value becomes undefined.</span>
        <span class="tok-comment">/// A pointer to the value is returned, which should be</span>
        <span class="tok-comment">/// used to initialize the value.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putUninitialized</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            self.bits.set(index);
            self.values[index] = <span class="tok-null">undefined</span>;
            <span class="tok-kw">return</span> &amp;self.values[index];
        }

        <span class="tok-comment">/// Sets the value associated with the key in the map,</span>
        <span class="tok-comment">/// and returns the old value.  If the key was not in</span>
        <span class="tok-comment">/// the map, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <span class="tok-kw">const</span> result: ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> = <span class="tok-kw">if</span> (self.bits.isSet(index)) self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
            self.bits.set(index);
            self.values[index] = value;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Removes a key from the map.  If the key was not in the map,</span>
        <span class="tok-comment">/// does nothing.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            self.bits.unset(index);
            self.values[index] = <span class="tok-null">undefined</span>;
        }

        <span class="tok-comment">/// Removes a key from the map, and returns the old value.</span>
        <span class="tok-comment">/// If the key was not in the map, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <span class="tok-kw">const</span> result: ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> = <span class="tok-kw">if</span> (self.bits.isSet(index)) self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
            self.bits.unset(index);
            self.values[index] = <span class="tok-null">undefined</span>;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns an iterator over the map, which visits items in index order.</span>
        <span class="tok-comment">/// Modifications to the underlying map may or may not be observed by</span>
        <span class="tok-comment">/// the iterator, but will not invalidate it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>) <a href="std.enums.EnumMap.Iterator.html">Iterator</a> {
            <span class="tok-kw">return</span> .{
                .inner = self.bits.iterator(.{}),
                .values = &amp;self.values,
            };
        }

        <span class="tok-comment">/// An entry in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// The key associated with this entry.</span>
            <span class="tok-comment">/// Modifying this key will not change the map.</span>
            key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>,

            <span class="tok-comment">/// A pointer to the value in the map associated</span>
            <span class="tok-comment">/// with this key.  Modifications through this</span>
            <span class="tok-comment">/// pointer will modify the underlying data.</span>
            value: *<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {
            inner: <a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a>.<a href="#">Iterator</a>(.{}),
            values: *[<a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">count</a>]<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.enums.EnumMap.Iterator.html">Iterator</a>) ?<a href="std.enums.EnumMap.Entry.html">Entry</a> {
                <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.inner.next()) |index|
                    <a href="std.enums.EnumMap.Entry.html">Entry</a>{
                        .key = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(index),
                        .value = &amp;self.values[index],
                    }
                <span class="tok-kw">else</span>
                    <span class="tok-null">null</span>;
            }
        };
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.enums.EnumMultiset" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">EnumMultiset</span><a href="#src.zig-std.enums.EnumMultiset">[src]</a></h2><div class="tldDocs"><p>A multiset of enum elements up to a count of usize. Backed
by an EnumArray. This type does no dynamic allocation and can
be copied by value.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>E: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>counts: <a href="std.enums.html#std.enums.EnumArray">EnumArray</a>(E, CountSize)</code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.Entry" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Entry</span><a href="#src.zig-std.enums.BoundedEnumMultiset.Entry">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.Entry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <a href="std.enums.html#std.enums.EnumArray">EnumArray</a>(E, CountSize).Entry</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.Iterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Iterator</span><a href="#src.zig-std.enums.BoundedEnumMultiset.Iterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.Iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.enums.html#std.enums.EnumArray">EnumArray</a>(E, CountSize).Iterator</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.enums.BoundedEnumMultiset.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_counts: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, CountSize, <span class="tok-number">0</span>)) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div class="tldDocs"><p>Initializes the multiset using a struct of counts.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>init_counts: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, CountSize, <span class="tok-number">0</span>)</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_counts: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, CountSize, <span class="tok-number">0</span>)) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
    <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
    <span class="tok-kw">var</span> self = <a href="std.enums.html#std.enums.BoundedEnumMultiset.initWithCount">initWithCount</a>(<span class="tok-number">0</span>);
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
        <span class="tok-kw">const</span> c = <span class="tok-builtin">@field</span>(init_counts, field.name);
        <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
        self.counts.set(key, c);
    }
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.initEmpty" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initEmpty</span><a href="#src.zig-std.enums.BoundedEnumMultiset.initEmpty">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div class="tldDocs"><p>Initializes the multiset with a count of zero.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.initEmpty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
    <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.BoundedEnumMultiset.initWithCount">initWithCount</a>(<span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.initWithCount" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initWithCount</span><a href="#src.zig-std.enums.BoundedEnumMultiset.initWithCount">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initWithCount</span>(<span class="tok-kw">comptime</span> c: CountSize) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div class="tldDocs"><p>Initializes the multiset with all keys at the
same count.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>c: CountSize</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.initWithCount">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initWithCount</span>(<span class="tok-kw">comptime</span> c: CountSize) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
    <span class="tok-kw">return</span> .{
        .counts = <a href="std.enums.html#std.enums.EnumArray">EnumArray</a>(E, CountSize).initDefault(c, .{}),
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.enums.BoundedEnumMultiset.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the total number of key counts in the multiset.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (self.counts.values) |c| {
        sum += c;
    }
    <span class="tok-kw">return</span> sum;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.enums.BoundedEnumMultiset.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Checks if at least one key in multiset.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>key: E</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.counts.get(key) &gt; <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.removeAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeAll</span><a href="#src.zig-std.enums.BoundedEnumMultiset.removeAll">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAll</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Removes all instance of a key from multiset. Same as
setCount(key, 0).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>key: E</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.removeAll">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAll</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.counts.set(key, <span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.addAssertSafe" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addAssertSafe</span><a href="#src.zig-std.enums.BoundedEnumMultiset.addAssertSafe">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAssertSafe</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases the key count by given amount. Caller asserts
operation will not overflow.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>key: E</code></pre></div><div><pre><code>c: CountSize</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.addAssertSafe">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAssertSafe</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-type">void</span> {
    self.counts.getPtr(key).* += c;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.add" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">add</span><a href="#src.zig-std.enums.BoundedEnumMultiset.add">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases the key count by given amount.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>key: E</code></pre></div><div><pre><code>c: CountSize</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.add">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
    self.counts.set(key, <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(CountSize, self.counts.get(key), c));
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.enums.BoundedEnumMultiset.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Decreases the key count by given amount. If amount is
greater than the number of keys in multset, then key count
will be set to zero.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>key: E</code></pre></div><div><pre><code>c: CountSize</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-type">void</span> {
    self.counts.getPtr(key).* -= <span class="tok-builtin">@min</span>(self.getCount(key), c);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.getCount" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getCount</span><a href="#src.zig-std.enums.BoundedEnumMultiset.getCount">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getCount</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E) CountSize</code></pre></div><div class="tldDocs"><p>Returns the count for a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>key: E</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.getCount">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getCount</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E) CountSize {
    <span class="tok-kw">return</span> self.counts.get(key);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.setCount" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setCount</span><a href="#src.zig-std.enums.BoundedEnumMultiset.setCount">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setCount</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Set the count for a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>key: E</code></pre></div><div><pre><code>c: CountSize</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.setCount">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setCount</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-type">void</span> {
    self.counts.set(key, c);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.addSetAssertSafe" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addSetAssertSafe</span><a href="#src.zig-std.enums.BoundedEnumMultiset.addSetAssertSafe">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSetAssertSafe</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases the all key counts by given multiset. Caller
asserts operation will not overflow any key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.addSetAssertSafe">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSetAssertSafe</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
        <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
        self.addAssertSafe(key, other.getCount(key));
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.addSet" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addSet</span><a href="#src.zig-std.enums.BoundedEnumMultiset.addSet">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSet</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases the all key counts by given multiset.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.addSet">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSet</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
        <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
        <span class="tok-kw">try</span> self.add(key, other.getCount(key));
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.removeSet" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeSet</span><a href="#src.zig-std.enums.BoundedEnumMultiset.removeSet">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeSet</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Decreases the all key counts by given multiset. If
the given multiset has more key counts than this,
then that key will have a key count of zero.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.removeSet">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeSet</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
        <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
        self.remove(key, other.getCount(key));
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.eql" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">eql</span><a href="#src.zig-std.enums.BoundedEnumMultiset.eql">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff all key counts are the same as
given multiset.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.eql">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
        <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
        <span class="tok-kw">if</span> (self.getCount(key) != other.getCount(key)) {
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }
    }
    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.subsetOf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">subsetOf</span><a href="#src.zig-std.enums.BoundedEnumMultiset.subsetOf">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff all key counts less than or
equal to the given multiset.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.subsetOf">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
        <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
        <span class="tok-kw">if</span> (self.getCount(key) &gt; other.getCount(key)) {
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }
    }
    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.supersetOf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">supersetOf</span><a href="#src.zig-std.enums.BoundedEnumMultiset.supersetOf">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff all key counts greater than or
equal to the given multiset.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.supersetOf">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
        <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
        <span class="tok-kw">if</span> (self.getCount(key) &lt; other.getCount(key)) {
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }
    }
    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.plusAssertSafe" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">plusAssertSafe</span><a href="#src.zig-std.enums.BoundedEnumMultiset.plusAssertSafe">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">plusAssertSafe</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div class="tldDocs"><p>Returns a multiset with the total key count of this
multiset and the other multiset. Caller asserts
operation will not overflow any key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.plusAssertSafe">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">plusAssertSafe</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
    <span class="tok-kw">var</span> result = self;
    result.addSetAssertSafe(other);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.plus" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">plus</span><a href="#src.zig-std.enums.BoundedEnumMultiset.plus">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">plus</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-kw">error</span>{Overflow}!<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div class="tldDocs"><p>Returns a multiset with the total key count of this
multiset and the other multiset.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.plus">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">plus</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-kw">error</span>{Overflow}!<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
    <span class="tok-kw">var</span> result = self;
    <span class="tok-kw">try</span> result.addSet(other);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.minus" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">minus</span><a href="#src.zig-std.enums.BoundedEnumMultiset.minus">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">minus</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div class="tldDocs"><p>Returns a multiset with the key count of this
multiset minus the corresponding key count in the
other multiset. If the other multiset contains
more key count than this set, that key will have
a count of zero.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.minus">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">minus</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
    <span class="tok-kw">var</span> result = self;
    result.removeSet(other);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.enums.BoundedEnumMultiset.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <a href="std.enums.html#std.enums.BoundedEnumMultiset.Iterator">Iterator</a></code></pre></div><div class="tldDocs"><p>Returns an iterator over this multiset. Keys with zero
counts are included. Modifications to the set during
iteration may or may not be observed by the iterator,
but will not invalidate it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <a href="std.enums.html#std.enums.BoundedEnumMultiset.Iterator">Iterator</a> {
    <span class="tok-kw">return</span> self.counts.iterator();
}</code></pre></details></div></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> EnumMultiset {
    <span class="tok-kw">const</span> Ball = <span class="tok-kw">enum</span> { red, green, blue };

    <span class="tok-kw">const</span> empty = <a href="std.enums.html#std.enums.EnumMultiset">EnumMultiset</a>(Ball).initEmpty();
    <span class="tok-kw">const</span> r0_g1_b2 = <a href="std.enums.html#std.enums.EnumMultiset">EnumMultiset</a>(Ball).init(.{
        .red = <span class="tok-number">0</span>,
        .green = <span class="tok-number">1</span>,
        .blue = <span class="tok-number">2</span>,
    });
    <span class="tok-kw">const</span> ten_of_each = <a href="std.enums.html#std.enums.EnumMultiset">EnumMultiset</a>(Ball).initWithCount(<span class="tok-number">10</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(empty.count(), <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(r0_g1_b2.count(), <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(ten_of_each.count(), <span class="tok-number">30</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!empty.contains(.red));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!empty.contains(.green));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!empty.contains(.blue));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!r0_g1_b2.contains(.red));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(r0_g1_b2.contains(.green));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(r0_g1_b2.contains(.blue));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(ten_of_each.contains(.red));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(ten_of_each.contains(.green));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(ten_of_each.contains(.blue));

    {
        <span class="tok-kw">var</span> copy = ten_of_each;
        copy.removeAll(.red);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!copy.contains(.red));<span class="tok-comment">

        // removeAll second time does nothing
        </span>copy.removeAll(.red);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!copy.contains(.red));
    }

    {
        <span class="tok-kw">var</span> copy = ten_of_each;
        copy.addAssertSafe(.red, <span class="tok-number">6</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.red), <span class="tok-number">16</span>);
    }

    {
        <span class="tok-kw">var</span> copy = ten_of_each;
        <span class="tok-kw">try</span> copy.add(.red, <span class="tok-number">6</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.red), <span class="tok-number">16</span>);

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.Overflow, copy.add(.red, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>)));
    }

    {
        <span class="tok-kw">var</span> copy = ten_of_each;
        copy.remove(.red, <span class="tok-number">4</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.red), <span class="tok-number">6</span>);<span class="tok-comment">

        // subtracting more it contains does not underflow
        </span>copy.remove(.green, <span class="tok-number">14</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.green), <span class="tok-number">0</span>);
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(empty.getCount(.green), <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(r0_g1_b2.getCount(.green), <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(ten_of_each.getCount(.green), <span class="tok-number">10</span>);

    {
        <span class="tok-kw">var</span> copy = empty;
        copy.setCount(.red, <span class="tok-number">6</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.red), <span class="tok-number">6</span>);
    }

    {
        <span class="tok-kw">var</span> copy = r0_g1_b2;
        copy.addSetAssertSafe(ten_of_each);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.red), <span class="tok-number">10</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.green), <span class="tok-number">11</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.blue), <span class="tok-number">12</span>);
    }

    {
        <span class="tok-kw">var</span> copy = r0_g1_b2;
        <span class="tok-kw">try</span> copy.addSet(ten_of_each);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.red), <span class="tok-number">10</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.green), <span class="tok-number">11</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.blue), <span class="tok-number">12</span>);

        <span class="tok-kw">const</span> full = <a href="std.enums.html#std.enums.EnumMultiset">EnumMultiset</a>(Ball).initWithCount(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.Overflow, copy.addSet(full));
    }

    {
        <span class="tok-kw">var</span> copy = ten_of_each;
        copy.removeSet(r0_g1_b2);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.red), <span class="tok-number">10</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.green), <span class="tok-number">9</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.blue), <span class="tok-number">8</span>);

        copy.removeSet(ten_of_each);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.red), <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.green), <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.blue), <span class="tok-number">0</span>);
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(r0_g1_b2.eql(r0_g1_b2));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(ten_of_each.eql(ten_of_each));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!empty.eql(r0_g1_b2));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!r0_g1_b2.eql(ten_of_each));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!ten_of_each.eql(empty));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.subsetOf(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(r0_g1_b2.subsetOf(r0_g1_b2));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.subsetOf(r0_g1_b2));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(r0_g1_b2.subsetOf(ten_of_each));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!ten_of_each.subsetOf(r0_g1_b2));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!r0_g1_b2.subsetOf(empty));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.supersetOf(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(r0_g1_b2.supersetOf(r0_g1_b2));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(r0_g1_b2.supersetOf(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(ten_of_each.supersetOf(r0_g1_b2));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!r0_g1_b2.supersetOf(ten_of_each));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!empty.supersetOf(r0_g1_b2));

    {<span class="tok-comment">
        // with multisets it could be the case where two
        // multisets are neither subset nor superset of each
        // other.

        </span><span class="tok-kw">const</span> r10 = <a href="std.enums.html#std.enums.EnumMultiset">EnumMultiset</a>(Ball).init(.{
            .red = <span class="tok-number">10</span>,
        });
        <span class="tok-kw">const</span> b10 = <a href="std.enums.html#std.enums.EnumMultiset">EnumMultiset</a>(Ball).init(.{
            .blue = <span class="tok-number">10</span>,
        });

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!r10.subsetOf(b10));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!b10.subsetOf(r10));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!r10.supersetOf(b10));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!b10.supersetOf(r10));
    }

    {
        <span class="tok-kw">const</span> result = r0_g1_b2.plusAssertSafe(ten_of_each);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.red), <span class="tok-number">10</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.green), <span class="tok-number">11</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.blue), <span class="tok-number">12</span>);
    }

    {
        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> r0_g1_b2.plus(ten_of_each);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.red), <span class="tok-number">10</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.green), <span class="tok-number">11</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.blue), <span class="tok-number">12</span>);

        <span class="tok-kw">const</span> full = <a href="std.enums.html#std.enums.EnumMultiset">EnumMultiset</a>(Ball).initWithCount(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.Overflow, result.plus(full));
    }

    {
        <span class="tok-kw">const</span> result = ten_of_each.minus(r0_g1_b2);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.red), <span class="tok-number">10</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.green), <span class="tok-number">9</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.blue), <span class="tok-number">8</span>);
    }

    {
        <span class="tok-kw">const</span> result = ten_of_each.minus(r0_g1_b2).minus(ten_of_each);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.red), <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.green), <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.blue), <span class="tok-number">0</span>);
    }

    {
        <span class="tok-kw">var</span> copy = empty;
        <span class="tok-kw">var</span> it = copy.iterator();
        <span class="tok-kw">var</span> entry = it.next().?;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.key, .red);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.value.*, <span class="tok-number">0</span>);
        entry = it.next().?;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.key, .green);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.value.*, <span class="tok-number">0</span>);
        entry = it.next().?;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.key, .blue);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.value.*, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);
    }

    {
        <span class="tok-kw">var</span> copy = r0_g1_b2;
        <span class="tok-kw">var</span> it = copy.iterator();
        <span class="tok-kw">var</span> entry = it.next().?;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.key, .red);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.value.*, <span class="tok-number">0</span>);
        entry = it.next().?;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.key, .green);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.value.*, <span class="tok-number">1</span>);
        entry = it.next().?;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.key, .blue);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.value.*, <span class="tok-number">2</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);
    }
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.enums.EnumMultiset">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">EnumMultiset</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.BoundedEnumMultiset">BoundedEnumMultiset</a>(E, <span class="tok-type">usize</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.enums.BoundedEnumMultiset" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">BoundedEnumMultiset</span><a href="#src.zig-std.enums.BoundedEnumMultiset">[src]</a></h2><div class="tldDocs"><p>A multiset of enum elements up to CountSize. Backed by an
EnumArray. This type does no dynamic allocation and can be
copied by value.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>E: <span class="tok-type">type</span></code></pre></div><div><pre><code>CountSize: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>counts: <a href="std.enums.html#std.enums.EnumArray">EnumArray</a>(E, CountSize)</code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.Entry" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Entry</span><a href="#src.zig-std.enums.BoundedEnumMultiset.Entry">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.Entry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <a href="std.enums.html#std.enums.EnumArray">EnumArray</a>(E, CountSize).Entry</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.Iterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Iterator</span><a href="#src.zig-std.enums.BoundedEnumMultiset.Iterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.Iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.enums.html#std.enums.EnumArray">EnumArray</a>(E, CountSize).Iterator</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.enums.BoundedEnumMultiset.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_counts: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, CountSize, <span class="tok-number">0</span>)) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div class="tldDocs"><p>Initializes the multiset using a struct of counts.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>init_counts: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, CountSize, <span class="tok-number">0</span>)</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_counts: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, CountSize, <span class="tok-number">0</span>)) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
    <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
    <span class="tok-kw">var</span> self = <a href="std.enums.html#std.enums.BoundedEnumMultiset.initWithCount">initWithCount</a>(<span class="tok-number">0</span>);
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
        <span class="tok-kw">const</span> c = <span class="tok-builtin">@field</span>(init_counts, field.name);
        <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
        self.counts.set(key, c);
    }
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.initEmpty" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initEmpty</span><a href="#src.zig-std.enums.BoundedEnumMultiset.initEmpty">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div class="tldDocs"><p>Initializes the multiset with a count of zero.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.initEmpty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
    <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.BoundedEnumMultiset.initWithCount">initWithCount</a>(<span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.initWithCount" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initWithCount</span><a href="#src.zig-std.enums.BoundedEnumMultiset.initWithCount">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initWithCount</span>(<span class="tok-kw">comptime</span> c: CountSize) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div class="tldDocs"><p>Initializes the multiset with all keys at the
same count.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>c: CountSize</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.initWithCount">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initWithCount</span>(<span class="tok-kw">comptime</span> c: CountSize) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
    <span class="tok-kw">return</span> .{
        .counts = <a href="std.enums.html#std.enums.EnumArray">EnumArray</a>(E, CountSize).initDefault(c, .{}),
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.enums.BoundedEnumMultiset.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the total number of key counts in the multiset.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (self.counts.values) |c| {
        sum += c;
    }
    <span class="tok-kw">return</span> sum;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.enums.BoundedEnumMultiset.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Checks if at least one key in multiset.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>key: E</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.counts.get(key) &gt; <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.removeAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeAll</span><a href="#src.zig-std.enums.BoundedEnumMultiset.removeAll">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAll</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Removes all instance of a key from multiset. Same as
setCount(key, 0).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>key: E</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.removeAll">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAll</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.counts.set(key, <span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.addAssertSafe" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addAssertSafe</span><a href="#src.zig-std.enums.BoundedEnumMultiset.addAssertSafe">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAssertSafe</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases the key count by given amount. Caller asserts
operation will not overflow.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>key: E</code></pre></div><div><pre><code>c: CountSize</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.addAssertSafe">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAssertSafe</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-type">void</span> {
    self.counts.getPtr(key).* += c;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.add" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">add</span><a href="#src.zig-std.enums.BoundedEnumMultiset.add">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases the key count by given amount.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>key: E</code></pre></div><div><pre><code>c: CountSize</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.add">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
    self.counts.set(key, <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(CountSize, self.counts.get(key), c));
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.enums.BoundedEnumMultiset.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Decreases the key count by given amount. If amount is
greater than the number of keys in multset, then key count
will be set to zero.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>key: E</code></pre></div><div><pre><code>c: CountSize</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-type">void</span> {
    self.counts.getPtr(key).* -= <span class="tok-builtin">@min</span>(self.getCount(key), c);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.getCount" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getCount</span><a href="#src.zig-std.enums.BoundedEnumMultiset.getCount">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getCount</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E) CountSize</code></pre></div><div class="tldDocs"><p>Returns the count for a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>key: E</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.getCount">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getCount</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E) CountSize {
    <span class="tok-kw">return</span> self.counts.get(key);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.setCount" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setCount</span><a href="#src.zig-std.enums.BoundedEnumMultiset.setCount">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setCount</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Set the count for a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>key: E</code></pre></div><div><pre><code>c: CountSize</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.setCount">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setCount</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-type">void</span> {
    self.counts.set(key, c);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.addSetAssertSafe" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addSetAssertSafe</span><a href="#src.zig-std.enums.BoundedEnumMultiset.addSetAssertSafe">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSetAssertSafe</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases the all key counts by given multiset. Caller
asserts operation will not overflow any key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.addSetAssertSafe">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSetAssertSafe</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
        <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
        self.addAssertSafe(key, other.getCount(key));
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.addSet" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addSet</span><a href="#src.zig-std.enums.BoundedEnumMultiset.addSet">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSet</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases the all key counts by given multiset.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.addSet">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSet</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
        <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
        <span class="tok-kw">try</span> self.add(key, other.getCount(key));
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.removeSet" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeSet</span><a href="#src.zig-std.enums.BoundedEnumMultiset.removeSet">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeSet</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Decreases the all key counts by given multiset. If
the given multiset has more key counts than this,
then that key will have a key count of zero.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.removeSet">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeSet</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
        <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
        self.remove(key, other.getCount(key));
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.eql" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">eql</span><a href="#src.zig-std.enums.BoundedEnumMultiset.eql">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff all key counts are the same as
given multiset.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.eql">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
        <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
        <span class="tok-kw">if</span> (self.getCount(key) != other.getCount(key)) {
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }
    }
    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.subsetOf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">subsetOf</span><a href="#src.zig-std.enums.BoundedEnumMultiset.subsetOf">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff all key counts less than or
equal to the given multiset.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.subsetOf">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
        <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
        <span class="tok-kw">if</span> (self.getCount(key) &gt; other.getCount(key)) {
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }
    }
    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.supersetOf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">supersetOf</span><a href="#src.zig-std.enums.BoundedEnumMultiset.supersetOf">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff all key counts greater than or
equal to the given multiset.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.supersetOf">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
        <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
        <span class="tok-kw">if</span> (self.getCount(key) &lt; other.getCount(key)) {
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }
    }
    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.plusAssertSafe" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">plusAssertSafe</span><a href="#src.zig-std.enums.BoundedEnumMultiset.plusAssertSafe">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">plusAssertSafe</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div class="tldDocs"><p>Returns a multiset with the total key count of this
multiset and the other multiset. Caller asserts
operation will not overflow any key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.plusAssertSafe">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">plusAssertSafe</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
    <span class="tok-kw">var</span> result = self;
    result.addSetAssertSafe(other);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.plus" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">plus</span><a href="#src.zig-std.enums.BoundedEnumMultiset.plus">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">plus</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-kw">error</span>{Overflow}!<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div class="tldDocs"><p>Returns a multiset with the total key count of this
multiset and the other multiset.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.plus">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">plus</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-kw">error</span>{Overflow}!<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
    <span class="tok-kw">var</span> result = self;
    <span class="tok-kw">try</span> result.addSet(other);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.minus" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">minus</span><a href="#src.zig-std.enums.BoundedEnumMultiset.minus">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">minus</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div class="tldDocs"><p>Returns a multiset with the key count of this
multiset minus the corresponding key count in the
other multiset. If the other multiset contains
more key count than this set, that key will have
a count of zero.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.minus">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">minus</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
    <span class="tok-kw">var</span> result = self;
    result.removeSet(other);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.BoundedEnumMultiset.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.enums.BoundedEnumMultiset.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <a href="std.enums.html#std.enums.BoundedEnumMultiset.Iterator">Iterator</a></code></pre></div><div class="tldDocs"><p>Returns an iterator over this multiset. Keys with zero
counts are included. Modifications to the set during
iteration may or may not be observed by the iterator,
but will not invalidate it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <a href="std.enums.html#std.enums.BoundedEnumMultiset.Iterator">Iterator</a> {
    <span class="tok-kw">return</span> self.counts.iterator();
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.enums.BoundedEnumMultiset">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">BoundedEnumMultiset</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> CountSize: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        counts: <a href="std.enums.html#std.enums.EnumArray">EnumArray</a>(E, CountSize),

        <span class="tok-comment">/// Initializes the multiset using a struct of counts.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_counts: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, CountSize, <span class="tok-number">0</span>)) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
            <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
            <span class="tok-kw">var</span> self = <a href="std.enums.html#std.enums.BoundedEnumMultiset.initWithCount">initWithCount</a>(<span class="tok-number">0</span>);
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
                <span class="tok-kw">const</span> c = <span class="tok-builtin">@field</span>(init_counts, field.name);
                <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
                self.counts.set(key, c);
            }
            <span class="tok-kw">return</span> self;
        }

        <span class="tok-comment">/// Initializes the multiset with a count of zero.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
            <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.BoundedEnumMultiset.initWithCount">initWithCount</a>(<span class="tok-number">0</span>);
        }

        <span class="tok-comment">/// Initializes the multiset with all keys at the</span>
        <span class="tok-comment">/// same count.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initWithCount</span>(<span class="tok-kw">comptime</span> c: CountSize) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
            <span class="tok-kw">return</span> .{
                .counts = <a href="std.enums.html#std.enums.EnumArray">EnumArray</a>(E, CountSize).initDefault(c, .{}),
            };
        }

        <span class="tok-comment">/// Returns the total number of key counts in the multiset.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (self.counts.values) |c| {
                sum += c;
            }
            <span class="tok-kw">return</span> sum;
        }

        <span class="tok-comment">/// Checks if at least one key in multiset.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.counts.get(key) &gt; <span class="tok-number">0</span>;
        }

        <span class="tok-comment">/// Removes all instance of a key from multiset. Same as</span>
        <span class="tok-comment">/// setCount(key, 0).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAll</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.counts.set(key, <span class="tok-number">0</span>);
        }

        <span class="tok-comment">/// Increases the key count by given amount. Caller asserts</span>
        <span class="tok-comment">/// operation will not overflow.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAssertSafe</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-type">void</span> {
            self.counts.getPtr(key).* += c;
        }

        <span class="tok-comment">/// Increases the key count by given amount.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
            self.counts.set(key, <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(CountSize, self.counts.get(key), c));
        }

        <span class="tok-comment">/// Decreases the key count by given amount. If amount is</span>
        <span class="tok-comment">/// greater than the number of keys in multset, then key count</span>
        <span class="tok-comment">/// will be set to zero.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-type">void</span> {
            self.counts.getPtr(key).* -= <span class="tok-builtin">@min</span>(self.getCount(key), c);
        }

        <span class="tok-comment">/// Returns the count for a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getCount</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E) CountSize {
            <span class="tok-kw">return</span> self.counts.get(key);
        }

        <span class="tok-comment">/// Set the count for a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setCount</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-type">void</span> {
            self.counts.set(key, c);
        }

        <span class="tok-comment">/// Increases the all key counts by given multiset. Caller</span>
        <span class="tok-comment">/// asserts operation will not overflow any key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSetAssertSafe</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
                <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
                self.addAssertSafe(key, other.getCount(key));
            }
        }

        <span class="tok-comment">/// Increases the all key counts by given multiset.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSet</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
                <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
                <span class="tok-kw">try</span> self.add(key, other.getCount(key));
            }
        }

        <span class="tok-comment">/// Decreases the all key counts by given multiset. If</span>
        <span class="tok-comment">/// the given multiset has more key counts than this,</span>
        <span class="tok-comment">/// then that key will have a key count of zero.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeSet</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
                <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
                self.remove(key, other.getCount(key));
            }
        }

        <span class="tok-comment">/// Returns true iff all key counts are the same as</span>
        <span class="tok-comment">/// given multiset.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
                <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
                <span class="tok-kw">if</span> (self.getCount(key) != other.getCount(key)) {
                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                }
            }
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }

        <span class="tok-comment">/// Returns true iff all key counts less than or</span>
        <span class="tok-comment">/// equal to the given multiset.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
                <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
                <span class="tok-kw">if</span> (self.getCount(key) &gt; other.getCount(key)) {
                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                }
            }
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }

        <span class="tok-comment">/// Returns true iff all key counts greater than or</span>
        <span class="tok-comment">/// equal to the given multiset.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
                <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
                <span class="tok-kw">if</span> (self.getCount(key) &lt; other.getCount(key)) {
                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                }
            }
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }

        <span class="tok-comment">/// Returns a multiset with the total key count of this</span>
        <span class="tok-comment">/// multiset and the other multiset. Caller asserts</span>
        <span class="tok-comment">/// operation will not overflow any key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">plusAssertSafe</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.addSetAssertSafe(other);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns a multiset with the total key count of this</span>
        <span class="tok-comment">/// multiset and the other multiset.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">plus</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-kw">error</span>{Overflow}!<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
            <span class="tok-kw">var</span> result = self;
            <span class="tok-kw">try</span> result.addSet(other);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns a multiset with the key count of this</span>
        <span class="tok-comment">/// multiset minus the corresponding key count in the</span>
        <span class="tok-comment">/// other multiset. If the other multiset contains</span>
        <span class="tok-comment">/// more key count than this set, that key will have</span>
        <span class="tok-comment">/// a count of zero.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">minus</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.removeSet(other);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <a href="std.enums.html#std.enums.EnumArray">EnumArray</a>(E, CountSize).Entry;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.enums.html#std.enums.EnumArray">EnumArray</a>(E, CountSize).Iterator;

        <span class="tok-comment">/// Returns an iterator over this multiset. Keys with zero</span>
        <span class="tok-comment">/// counts are included. Modifications to the set during</span>
        <span class="tok-comment">/// iteration may or may not be observed by the iterator,</span>
        <span class="tok-comment">/// but will not invalidate it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <a href="std.enums.html#std.enums.BoundedEnumMultiset.Iterator">Iterator</a> {
            <span class="tok-kw">return</span> self.counts.iterator();
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.enums.EnumArray" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">EnumArray</span><a href="#src.zig-std.enums.EnumArray">[src]</a></h2><div class="tldDocs"><p>An array keyed by an enum, backed by a dense array.
If the enum is not dense, a mapping will be constructed from
enum values to dense indices.  This type does no dynamic
allocation and can be copied by value.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>E: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.enums.EnumArray.Entry.html">std.enums.EnumArray.Entry</a></li><li><a href="std.enums.EnumArray.Iterator.html">std.enums.EnumArray.Iterator</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.enums.EnumArray.Indexer" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Indexer</span><a href="#src.zig-std.enums.EnumArray.Indexer">[src]</a></h3><div class="tldDocs"><p>The index mapping for this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.Indexer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>values: [<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">count</a>]<a href="std.enums.html#std.enums.EnumArray.Value">Value</a></code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.enums.EnumArray.Key" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Key</span><a href="#src.zig-std.enums.EnumArray.Key">[src]</a></h3><div class="tldDocs"><p>The key type used to index this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.Key">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">Key</a></code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumArray.Value" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Value</span><a href="#src.zig-std.enums.EnumArray.Value">[src]</a></h3><div class="tldDocs"><p>The value type stored in this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.Value">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Value = V</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumArray.len" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">len</span><a href="#src.zig-std.enums.EnumArray.len">[src]</a></h3><div class="tldDocs"><p>The number of possible keys in the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.len">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> len = <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">count</a></code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.enums.EnumArray.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.enums.EnumArray.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, <span class="tok-null">null</span>)) <a href="std.enums.html#std.enums.EnumArray">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, <span class="tok-null">null</span>)</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, <span class="tok-null">null</span>)) <a href="std.enums.html#std.enums.EnumArray">Self</a> {
    <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.EnumArray.initDefault">initDefault</a>(<span class="tok-null">null</span>, init_values);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumArray.initDefault" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initDefault</span><a href="#src.zig-std.enums.EnumArray.initDefault">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initDefault</span>(<span class="tok-kw">comptime</span> default: ?<a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, default)) <a href="std.enums.html#std.enums.EnumArray">Self</a></code></pre></div><div class="tldDocs"><p>Initializes values in the enum array, with the specified default.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>default: ?<a href="std.enums.html#std.enums.EnumArray.Value">Value</a></code></pre></div><div><pre><code>init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, default)</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.initDefault">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initDefault</span>(<span class="tok-kw">comptime</span> default: ?<a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, default)) <a href="std.enums.html#std.enums.EnumArray">Self</a> {
    <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
    <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumArray">Self</a> = .{ .values = <span class="tok-null">undefined</span> };
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<a href="std.enums.html#std.enums.EnumArray">Self</a>.<a href="std.enums.html#std.enums.EnumArray.len">len</a>) |i| {
        <span class="tok-kw">const</span> key = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(i);
        <span class="tok-kw">const</span> tag = <span class="tok-builtin">@tagName</span>(key);
        result.values[i] = <span class="tok-builtin">@field</span>(init_values, tag);
    }
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumArray.initUndefined" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initUndefined</span><a href="#src.zig-std.enums.EnumArray.initUndefined">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initUndefined</span>() <a href="std.enums.html#std.enums.EnumArray">Self</a></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.initUndefined">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initUndefined</span>() <a href="std.enums.html#std.enums.EnumArray">Self</a> {
    <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.EnumArray">Self</a>{ .values = <span class="tok-null">undefined</span> };
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumArray.initFill" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initFill</span><a href="#src.zig-std.enums.EnumArray.initFill">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFill</span>(v: <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>) <a href="std.enums.html#std.enums.EnumArray">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>v: <a href="std.enums.html#std.enums.EnumArray.Value">Value</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.initFill">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFill</span>(v: <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>) <a href="std.enums.html#std.enums.EnumArray">Self</a> {
    <span class="tok-kw">var</span> self: <a href="std.enums.html#std.enums.EnumArray">Self</a> = <span class="tok-null">undefined</span>;
    <span class="tok-builtin">@memset</span>(&amp;self.values, v);
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumArray.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.enums.EnumArray.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) <a href="std.enums.html#std.enums.EnumArray.Value">Value</a></code></pre></div><div class="tldDocs"><p>Returns the value in the array associated with a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumArray">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) <a href="std.enums.html#std.enums.EnumArray.Value">Value</a> {
    <span class="tok-kw">return</span> self.values[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">indexOf</a>(key)];
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumArray.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.enums.EnumArray.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumArray.Value">Value</a></code></pre></div><div class="tldDocs"><p>Returns a pointer to the slot in the array associated with a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumArray">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumArray.Value">Value</a> {
    <span class="tok-kw">return</span> &amp;self.values[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">indexOf</a>(key)];
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumArray.getPtrConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrConst</span><a href="#src.zig-std.enums.EnumArray.getPtrConst">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConst</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumArray.Value">Value</a></code></pre></div><div class="tldDocs"><p>Returns a const pointer to the slot in the array associated with a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumArray">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.getPtrConst">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConst</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumArray.Value">Value</a> {
    <span class="tok-kw">return</span> &amp;self.values[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">indexOf</a>(key)];
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumArray.set" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">set</span><a href="#src.zig-std.enums.EnumArray.set">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sets the value in the slot associated with a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumArray">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a></code></pre></div><div><pre><code>value: <a href="std.enums.html#std.enums.EnumArray.Value">Value</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.set">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>) <span class="tok-type">void</span> {
    self.values[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">indexOf</a>(key)] = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumArray.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.enums.EnumArray.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>) <a href="std.enums.EnumArray.Iterator.html">Iterator</a></code></pre></div><div class="tldDocs"><p>Iterates over the items in the array, in index order.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumArray">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>) <a href="std.enums.EnumArray.Iterator.html">Iterator</a> {
    <span class="tok-kw">return</span> .{
        .values = &amp;self.values,
    };
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.enums.EnumArray">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">EnumArray</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// The index mapping for this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E);
        <span class="tok-comment">/// The key type used to index this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">Key</a>;
        <span class="tok-comment">/// The value type stored in this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Value = V;
        <span class="tok-comment">/// The number of possible keys in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> len = <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">count</a>;

        values: [<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">count</a>]<a href="std.enums.html#std.enums.EnumArray.Value">Value</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, <span class="tok-null">null</span>)) <a href="std.enums.html#std.enums.EnumArray">Self</a> {
            <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.EnumArray.initDefault">initDefault</a>(<span class="tok-null">null</span>, init_values);
        }

        <span class="tok-comment">/// Initializes values in the enum array, with the specified default.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initDefault</span>(<span class="tok-kw">comptime</span> default: ?<a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, default)) <a href="std.enums.html#std.enums.EnumArray">Self</a> {
            <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
            <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumArray">Self</a> = .{ .values = <span class="tok-null">undefined</span> };
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<a href="std.enums.html#std.enums.EnumArray">Self</a>.<a href="std.enums.html#std.enums.EnumArray.len">len</a>) |i| {
                <span class="tok-kw">const</span> key = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(i);
                <span class="tok-kw">const</span> tag = <span class="tok-builtin">@tagName</span>(key);
                result.values[i] = <span class="tok-builtin">@field</span>(init_values, tag);
            }
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initUndefined</span>() <a href="std.enums.html#std.enums.EnumArray">Self</a> {
            <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.EnumArray">Self</a>{ .values = <span class="tok-null">undefined</span> };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFill</span>(v: <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>) <a href="std.enums.html#std.enums.EnumArray">Self</a> {
            <span class="tok-kw">var</span> self: <a href="std.enums.html#std.enums.EnumArray">Self</a> = <span class="tok-null">undefined</span>;
            <span class="tok-builtin">@memset</span>(&amp;self.values, v);
            <span class="tok-kw">return</span> self;
        }

        <span class="tok-comment">/// Returns the value in the array associated with a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) <a href="std.enums.html#std.enums.EnumArray.Value">Value</a> {
            <span class="tok-kw">return</span> self.values[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">indexOf</a>(key)];
        }

        <span class="tok-comment">/// Returns a pointer to the slot in the array associated with a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumArray.Value">Value</a> {
            <span class="tok-kw">return</span> &amp;self.values[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">indexOf</a>(key)];
        }

        <span class="tok-comment">/// Returns a const pointer to the slot in the array associated with a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConst</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumArray.Value">Value</a> {
            <span class="tok-kw">return</span> &amp;self.values[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">indexOf</a>(key)];
        }

        <span class="tok-comment">/// Sets the value in the slot associated with a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>) <span class="tok-type">void</span> {
            self.values[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">indexOf</a>(key)] = value;
        }

        <span class="tok-comment">/// Iterates over the items in the array, in index order.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>) <a href="std.enums.EnumArray.Iterator.html">Iterator</a> {
            <span class="tok-kw">return</span> .{
                .values = &amp;self.values,
            };
        }

        <span class="tok-comment">/// An entry in the array.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// The key associated with this entry.</span>
            <span class="tok-comment">/// Modifying this key will not change the array.</span>
            key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>,

            <span class="tok-comment">/// A pointer to the value in the array associated</span>
            <span class="tok-comment">/// with this key.  Modifications through this</span>
            <span class="tok-comment">/// pointer will modify the underlying data.</span>
            value: *<a href="std.enums.html#std.enums.EnumArray.Value">Value</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {
            index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
            values: *[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">count</a>]<a href="std.enums.html#std.enums.EnumArray.Value">Value</a>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.enums.EnumArray.Iterator.html">Iterator</a>) ?<a href="std.enums.EnumArray.Entry.html">Entry</a> {
                <span class="tok-kw">const</span> index = self.index;
                <span class="tok-kw">if</span> (index &lt; <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">count</a>) {
                    self.index += <span class="tok-number">1</span>;
                    <span class="tok-kw">return</span> <a href="std.enums.EnumArray.Entry.html">Entry</a>{
                        .key = <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(index),
                        .value = &amp;self.values[index],
                    };
                }
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }
        };
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.enums.EnumIndexer" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">EnumIndexer</span><a href="#src.zig-std.enums.EnumIndexer">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>E: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.enums.EnumIndexer.Key" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Key</span><a href="#src.zig-std.enums.EnumIndexer.Key">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumIndexer.Key">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key: <span class="tok-type">type</span> = E</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumIndexer.count" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.enums.EnumIndexer.count">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumIndexer.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> count: <span class="tok-type">comptime_int</span> = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.enums.html#std.enums.EnumIndexer.RangeType">RangeType</a>) + <span class="tok-number">1</span></code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumIndexer.Key" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Key</span><a href="#src.zig-std.enums.EnumIndexer.Key">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumIndexer.Key">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = E</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumIndexer.count" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.enums.EnumIndexer.count">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumIndexer.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> count: <span class="tok-type">comptime_int</span> = <span class="tok-number">0</span></code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumIndexer.Key" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Key</span><a href="#src.zig-std.enums.EnumIndexer.Key">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumIndexer.Key">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = E</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumIndexer.count" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.enums.EnumIndexer.count">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumIndexer.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> count: <span class="tok-type">comptime_int</span> = fields_len</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumIndexer.Key" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Key</span><a href="#src.zig-std.enums.EnumIndexer.Key">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumIndexer.Key">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = E</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumIndexer.count" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.enums.EnumIndexer.count">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumIndexer.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> count: <span class="tok-type">comptime_int</span> = fields_len</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.enums.EnumIndexer.indexOf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">indexOf</span><a href="#src.zig-std.enums.EnumIndexer.indexOf">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(e: E) <span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>e: E</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumIndexer.indexOf">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(e: E) <span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.enums.html#std.enums.EnumIndexer.backing_int_sign">backing_int_sign</a> == .unsigned)
        <span class="tok-kw">return</span> <span class="tok-builtin">@intFromEnum</span>(e);

    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(e) &lt; <span class="tok-number">0</span>)
        <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(e) - <a href="std.enums.html#std.enums.EnumIndexer.min_value">min_value</a>)
    <span class="tok-kw">else</span>
        <span class="tok-builtin">@as</span>(<a href="std.enums.html#std.enums.EnumIndexer.RangeType">RangeType</a>, -<a href="std.enums.html#std.enums.EnumIndexer.min_value">min_value</a>) + <span class="tok-builtin">@as</span>(<a href="std.enums.html#std.enums.EnumIndexer.RangeType">RangeType</a>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(e)));
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumIndexer.keyForIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keyForIndex</span><a href="#src.zig-std.enums.EnumIndexer.keyForIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyForIndex</span>(i: <span class="tok-type">usize</span>) E</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumIndexer.keyForIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyForIndex</span>(i: <span class="tok-type">usize</span>) E {
    <span class="tok-kw">if</span> (<a href="std.enums.html#std.enums.EnumIndexer.backing_int_sign">backing_int_sign</a> == .unsigned)
        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(i);

    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@as</span>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.signed, <span class="tok-builtin">@bitSizeOf</span>(<a href="std.enums.html#std.enums.EnumIndexer.RangeType">RangeType</a>) + <span class="tok-number">1</span>), <span class="tok-builtin">@intCast</span>(i)) + <a href="std.enums.html#std.enums.EnumIndexer.min_value">min_value</a>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumIndexer.indexOf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">indexOf</span><a href="#src.zig-std.enums.EnumIndexer.indexOf">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(e: E) <span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>e: E</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumIndexer.indexOf">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(e: E) <span class="tok-type">usize</span> {
    _ = e;
    <span class="tok-kw">unreachable</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumIndexer.keyForIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keyForIndex</span><a href="#src.zig-std.enums.EnumIndexer.keyForIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyForIndex</span>(i: <span class="tok-type">usize</span>) E</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumIndexer.keyForIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyForIndex</span>(i: <span class="tok-type">usize</span>) E {
    _ = i;
    <span class="tok-kw">unreachable</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumIndexer.lessThan" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lessThan</span><a href="#src.zig-std.enums.EnumIndexer.lessThan">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(<span class="tok-kw">comptime</span> ctx: <span class="tok-builtin">@This</span>(), <span class="tok-kw">comptime</span> a: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> b: <span class="tok-type">usize</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>ctx: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>a: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumIndexer.lessThan">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(<span class="tok-kw">comptime</span> ctx: <span class="tok-builtin">@This</span>(), <span class="tok-kw">comptime</span> a: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> b: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> ctx.fields[a].value &lt; ctx.fields[b].value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumIndexer.swap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swap</span><a href="#src.zig-std.enums.EnumIndexer.swap">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(<span class="tok-kw">comptime</span> ctx: <span class="tok-builtin">@This</span>(), <span class="tok-kw">comptime</span> a: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> b: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>ctx: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>a: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumIndexer.swap">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(<span class="tok-kw">comptime</span> ctx: <span class="tok-builtin">@This</span>(), <span class="tok-kw">comptime</span> a: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> b: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(<a href="std.builtin.Type.EnumField.html">EnumField</a>, &amp;ctx.fields[a], &amp;ctx.fields[b]);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumIndexer.indexOf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">indexOf</span><a href="#src.zig-std.enums.EnumIndexer.indexOf">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(e: E) <span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>e: E</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumIndexer.indexOf">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(e: E) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(e) - min));
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumIndexer.keyForIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keyForIndex</span><a href="#src.zig-std.enums.EnumIndexer.keyForIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyForIndex</span>(i: <span class="tok-type">usize</span>) E</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumIndexer.keyForIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyForIndex</span>(i: <span class="tok-type">usize</span>) E {<span class="tok-comment">
    // TODO fix addition semantics.  This calculation
    // gives up some safety to avoid artificially limiting
    // the range of signed enum values to max_isize.
    </span><span class="tok-kw">const</span> enum_value = <span class="tok-kw">if</span> (min &lt; <span class="tok-number">0</span>) <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@bitCast</span>(i)) +% min <span class="tok-kw">else</span> i + min;
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@as</span>(<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.tag_type, <span class="tok-builtin">@intCast</span>(enum_value))));
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumIndexer.indexOf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">indexOf</span><a href="#src.zig-std.enums.EnumIndexer.indexOf">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(e: E) <span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>e: E</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumIndexer.indexOf">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(e: E) <span class="tok-type">usize</span> {
    <span class="tok-kw">for</span> (keys, <span class="tok-number">0</span>..) |k, i| {
        <span class="tok-kw">if</span> (k == e) <span class="tok-kw">return</span> i;
    }
    <span class="tok-kw">unreachable</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumIndexer.keyForIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keyForIndex</span><a href="#src.zig-std.enums.EnumIndexer.keyForIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyForIndex</span>(i: <span class="tok-type">usize</span>) E</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumIndexer.keyForIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyForIndex</span>(i: <span class="tok-type">usize</span>) E {
    <span class="tok-kw">return</span> keys[i];
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.enums.EnumIndexer">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">EnumIndexer</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>) <span class="tok-type">type</span> {<span class="tok-comment">
    // Assumes that the enum fields are sorted in ascending order (optimistic).
    // Unsorted enums may require the user to manually increase the quota.
    </span><span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">3</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len + <a href="std.enums.html#std.enums.eval_branch_quota_cushion">eval_branch_quota_cushion</a>);

    <span class="tok-kw">if</span> (!<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.is_exhaustive) {
        <span class="tok-kw">const</span> BackingInt = <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.tag_type;
        <span class="tok-kw">if</span> (<span class="tok-builtin">@bitSizeOf</span>(BackingInt) &gt; <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>))
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot create an enum indexer for a given non-exhaustive enum, tag_type is larger than usize.&quot;</span>);

        <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key: <span class="tok-type">type</span> = E;

            <span class="tok-kw">const</span> backing_int_sign = <span class="tok-builtin">@typeInfo</span>(BackingInt).int.signedness;
            <span class="tok-kw">const</span> min_value = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.minInt">minInt</a>(BackingInt);
            <span class="tok-kw">const</span> max_value = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(BackingInt);

            <span class="tok-kw">const</span> RangeType = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(BackingInt));
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> count: <span class="tok-type">comptime_int</span> = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.enums.html#std.enums.EnumIndexer.RangeType">RangeType</a>) + <span class="tok-number">1</span>;

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(e: E) <span class="tok-type">usize</span> {
                <span class="tok-kw">if</span> (<a href="std.enums.html#std.enums.EnumIndexer.backing_int_sign">backing_int_sign</a> == .unsigned)
                    <span class="tok-kw">return</span> <span class="tok-builtin">@intFromEnum</span>(e);

                <span class="tok-kw">return</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(e) &lt; <span class="tok-number">0</span>)
                    <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(e) - <a href="std.enums.html#std.enums.EnumIndexer.min_value">min_value</a>)
                <span class="tok-kw">else</span>
                    <span class="tok-builtin">@as</span>(<a href="std.enums.html#std.enums.EnumIndexer.RangeType">RangeType</a>, -<a href="std.enums.html#std.enums.EnumIndexer.min_value">min_value</a>) + <span class="tok-builtin">@as</span>(<a href="std.enums.html#std.enums.EnumIndexer.RangeType">RangeType</a>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(e)));
            }
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyForIndex</span>(i: <span class="tok-type">usize</span>) E {
                <span class="tok-kw">if</span> (<a href="std.enums.html#std.enums.EnumIndexer.backing_int_sign">backing_int_sign</a> == .unsigned)
                    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(i);

                <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@as</span>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.signed, <span class="tok-builtin">@bitSizeOf</span>(<a href="std.enums.html#std.enums.EnumIndexer.RangeType">RangeType</a>) + <span class="tok-number">1</span>), <span class="tok-builtin">@intCast</span>(i)) + <a href="std.enums.html#std.enums.EnumIndexer.min_value">min_value</a>);
            }
        };
    }

    <span class="tok-kw">const</span> const_fields = <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields;
    <span class="tok-kw">var</span> fields = const_fields[<span class="tok-number">0</span>..const_fields.len].*;
    <span class="tok-kw">const</span> fields_len = fields.len;

    <span class="tok-kw">if</span> (fields_len == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = E;
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> count: <span class="tok-type">comptime_int</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(e: E) <span class="tok-type">usize</span> {
                _ = e;
                <span class="tok-kw">unreachable</span>;
            }
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyForIndex</span>(i: <span class="tok-type">usize</span>) E {
                _ = i;
                <span class="tok-kw">unreachable</span>;
            }
        };
    }

    <span class="tok-kw">const</span> min = fields[<span class="tok-number">0</span>].value;
    <span class="tok-kw">const</span> max = fields[fields.len - <span class="tok-number">1</span>].value;

    <span class="tok-kw">const</span> SortContext = <span class="tok-kw">struct</span> {
        fields: []<a href="std.builtin.Type.EnumField.html">EnumField</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(<span class="tok-kw">comptime</span> ctx: <span class="tok-builtin">@This</span>(), <span class="tok-kw">comptime</span> a: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> b: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> ctx.fields[a].value &lt; ctx.fields[b].value;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(<span class="tok-kw">comptime</span> ctx: <span class="tok-builtin">@This</span>(), <span class="tok-kw">comptime</span> a: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> b: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(<a href="std.builtin.Type.EnumField.html">EnumField</a>, &amp;ctx.fields[a], &amp;ctx.fields[b]);
        }
    };
    <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.html#std.sort.insertionContext">insertionContext</a>(<span class="tok-number">0</span>, fields_len, SortContext{ .fields = &amp;fields });

    <span class="tok-kw">if</span> (max - min == fields.len - <span class="tok-number">1</span>) {
        <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = E;
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> count: <span class="tok-type">comptime_int</span> = fields_len;
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(e: E) <span class="tok-type">usize</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(e) - min));
            }
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyForIndex</span>(i: <span class="tok-type">usize</span>) E {<span class="tok-comment">
                // TODO fix addition semantics.  This calculation
                // gives up some safety to avoid artificially limiting
                // the range of signed enum values to max_isize.
                </span><span class="tok-kw">const</span> enum_value = <span class="tok-kw">if</span> (min &lt; <span class="tok-number">0</span>) <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@bitCast</span>(i)) +% min <span class="tok-kw">else</span> i + min;
                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@as</span>(<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.tag_type, <span class="tok-builtin">@intCast</span>(enum_value))));
            }
        };
    }

    <span class="tok-kw">const</span> keys = <a href="std.enums.html#std.enums.valuesFromFields">valuesFromFields</a>(E, &amp;fields);

    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = E;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> count: <span class="tok-type">comptime_int</span> = fields_len;
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(e: E) <span class="tok-type">usize</span> {
            <span class="tok-kw">for</span> (keys, <span class="tok-number">0</span>..) |k, i| {
                <span class="tok-kw">if</span> (k == e) <span class="tok-kw">return</span> i;
            }
            <span class="tok-kw">unreachable</span>;
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyForIndex</span>(i: <span class="tok-type">usize</span>) E {
            <span class="tok-kw">return</span> keys[i];
        }
    };
}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.enums.valuesFromFields" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">valuesFromFields</span><a href="#src.zig-std.enums.valuesFromFields">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">valuesFromFields</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> fields: []<span class="tok-kw">const</span> <a href="std.builtin.Type.EnumField.html">EnumField</a>) []<span class="tok-kw">const</span> E</code></pre></div><div class="tldDocs"><p>Looks up the supplied fields in the given enum type.
Uses only the field names, field values are ignored.
The result array is in the same order as the input.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>E: <span class="tok-type">type</span></code></pre></div><div><pre><code>fields: []<span class="tok-kw">const</span> <a href="std.builtin.Type.EnumField.html">EnumField</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.enums.valuesFromFields">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">valuesFromFields</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> fields: []<span class="tok-kw">const</span> <a href="std.builtin.Type.EnumField.html">EnumField</a>) []<span class="tok-kw">const</span> E {
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> result: [fields.len]E = <span class="tok-null">undefined</span>;
        <span class="tok-kw">for</span> (&amp;result, fields) |*r, f| {
            r.* = <span class="tok-builtin">@enumFromInt</span>(f.value);
        }
        <span class="tok-kw">const</span> final = result;
        <span class="tok-kw">return</span> &amp;final;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.enums.values" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">values</span><a href="#src.zig-std.enums.values">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>) []<span class="tok-kw">const</span> E</code></pre></div><div class="tldDocs"><p>Returns the set of all named values in the given enum, in
declaration order.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>E: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> values {
    <span class="tok-kw">const</span> E = <span class="tok-kw">enum</span> {
        X,
        Y,
        Z,
        <span class="tok-kw">const</span> A = <span class="tok-number">1</span>;
    };
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(E, &amp;.{ .X, .Y, .Z }, <a href="std.enums.html#std.enums.values">values</a>(E));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.enums.values">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>) []<span class="tok-kw">const</span> E {
    <span class="tok-kw">return</span> <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.valuesFromFields">valuesFromFields</a>(E, <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields);
}</code></pre></details></div></div><div class="decl"><h2 id="std.enums.tagName" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">tagName</span><a href="#src.zig-std.enums.tagName">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tagName</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, e: E) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>A safe alternative to @tagName() for non-exhaustive enums that doesn't
panic when <code>e</code> has no tagged value.
Returns the tag name for <code>e</code> or null if no tag exists.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>E: <span class="tok-type">type</span></code></pre></div><div><pre><code>e: E</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> tagName {
    <span class="tok-kw">const</span> E = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) { a, b, _ };
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.enums.html#std.enums.tagName">tagName</a>(E, .a) != <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;a&quot;</span>, <a href="std.enums.html#std.enums.tagName">tagName</a>(E, .a).?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.enums.html#std.enums.tagName">tagName</a>(E, <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">42</span>))) == <span class="tok-null">null</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.enums.tagName">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tagName</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, e: E) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |f| {
        <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(e) == f.value) <span class="tok-kw">break</span> f.name;
    } <span class="tok-kw">else</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.enums.directEnumArrayLen" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">directEnumArrayLen</span><a href="#src.zig-std.enums.directEnumArrayLen">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">directEnumArrayLen</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> max_unused_slots: <span class="tok-type">comptime_int</span>) <span class="tok-type">comptime_int</span></code></pre></div><div class="tldDocs"><p>Determines the length of a direct-mapped enum array, indexed by
@intCast(usize, @intFromEnum(enum_value)).
If the enum is non-exhaustive, the resulting length will only be enough
to hold all explicit fields.
If the enum contains any fields with values that cannot be represented
by usize, a compile error is issued.  The max_unused_slots parameter limits
the total number of items which have no matching enum key (holes in the enum
numbering).  So for example, if an enum has values 1, 2, 5, and 6, max_unused_slots
must be at least 3, to allow unused slots 0, 3, and 4.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>E: <span class="tok-type">type</span></code></pre></div><div><pre><code>max_unused_slots: <span class="tok-type">comptime_int</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.enums.directEnumArrayLen">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">directEnumArrayLen</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> max_unused_slots: <span class="tok-type">comptime_int</span>) <span class="tok-type">comptime_int</span> {
    <span class="tok-kw">var</span> max_value: <span class="tok-type">comptime_int</span> = -<span class="tok-number">1</span>;
    <span class="tok-kw">const</span> max_usize: <span class="tok-type">comptime_int</span> = ~<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> fields = <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields;
    <span class="tok-kw">for</span> (fields) |f| {
        <span class="tok-kw">if</span> (f.value &lt; <span class="tok-number">0</span>) {
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot create a direct enum array for &quot;</span> ++ <span class="tok-builtin">@typeName</span>(E) ++ <span class="tok-str">&quot;, field .&quot;</span> ++ f.name ++ <span class="tok-str">&quot; has a negative value.&quot;</span>);
        }
        <span class="tok-kw">if</span> (f.value &gt; max_value) {
            <span class="tok-kw">if</span> (f.value &gt; max_usize) {
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot create a direct enum array for &quot;</span> ++ <span class="tok-builtin">@typeName</span>(E) ++ <span class="tok-str">&quot;, field .&quot;</span> ++ f.name ++ <span class="tok-str">&quot; is larger than the max value of usize.&quot;</span>);
            }
            max_value = f.value;
        }
    }

    <span class="tok-kw">const</span> unused_slots = max_value + <span class="tok-number">1</span> - fields.len;
    <span class="tok-kw">if</span> (unused_slots &gt; max_unused_slots) {
        <span class="tok-kw">const</span> unused_str = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.comptimePrint">comptimePrint</a>(<span class="tok-str">&quot;{d}&quot;</span>, .{unused_slots});
        <span class="tok-kw">const</span> allowed_str = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.comptimePrint">comptimePrint</a>(<span class="tok-str">&quot;{d}&quot;</span>, .{max_unused_slots});
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot create a direct enum array for &quot;</span> ++ <span class="tok-builtin">@typeName</span>(E) ++ <span class="tok-str">&quot;. It would have &quot;</span> ++ unused_str ++ <span class="tok-str">&quot; unused slots, but only &quot;</span> ++ allowed_str ++ <span class="tok-str">&quot; are allowed.&quot;</span>);
    }

    <span class="tok-kw">return</span> max_value + <span class="tok-number">1</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.enums.directEnumArray" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">directEnumArray</span><a href="#src.zig-std.enums.directEnumArray">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">directEnumArray</span>( <span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Data: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> max_unused_slots: <span class="tok-type">comptime_int</span>, init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, Data, <span class="tok-null">null</span>), ) [<a href="std.enums.html#std.enums.directEnumArrayLen">directEnumArrayLen</a>(E, max_unused_slots)]Data</code></pre></div><div class="tldDocs"><p>Initializes an array of Data which can be indexed by
@intCast(usize, @intFromEnum(enum_value)).
If the enum is non-exhaustive, the resulting array will only be large enough
to hold all explicit fields.
If the enum contains any fields with values that cannot be represented
by usize, a compile error is issued.  The max_unused_slots parameter limits
the total number of items which have no matching enum key (holes in the enum
numbering).  So for example, if an enum has values 1, 2, 5, and 6, max_unused_slots
must be at least 3, to allow unused slots 0, 3, and 4.
The init_values parameter must be a struct with field names that match the enum values.
If the enum has multiple fields with the same value, the name of the first one must
be used.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>E: <span class="tok-type">type</span></code></pre></div><div><pre><code>Data: <span class="tok-type">type</span></code></pre></div><div><pre><code>max_unused_slots: <span class="tok-type">comptime_int</span></code></pre></div><div><pre><code>init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, Data, <span class="tok-null">null</span>)</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> directEnumArray {
    <span class="tok-kw">const</span> E = <span class="tok-kw">enum</span>(<span class="tok-type">i4</span>) { a = <span class="tok-number">4</span>, b = <span class="tok-number">6</span>, c = <span class="tok-number">2</span> };
    <span class="tok-kw">var</span> runtime_false: <span class="tok-type">bool</span> = <span class="tok-null">false</span>;
    _ = &amp;runtime_false;
    <span class="tok-kw">const</span> array = <a href="std.enums.html#std.enums.directEnumArray">directEnumArray</a>(E, <span class="tok-type">bool</span>, <span class="tok-number">4</span>, .{
        .a = <span class="tok-null">true</span>,
        .b = runtime_false,
        .c = <span class="tok-null">true</span>,
    });

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>([<span class="tok-number">7</span>]<span class="tok-type">bool</span>, <span class="tok-builtin">@TypeOf</span>(array));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">true</span>, array[<span class="tok-number">4</span>]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, array[<span class="tok-number">6</span>]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">true</span>, array[<span class="tok-number">2</span>]);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.enums.directEnumArray">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">directEnumArray</span>(
    <span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> Data: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> max_unused_slots: <span class="tok-type">comptime_int</span>,
    init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, Data, <span class="tok-null">null</span>),
) [<a href="std.enums.html#std.enums.directEnumArrayLen">directEnumArrayLen</a>(E, max_unused_slots)]Data {
    <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.directEnumArrayDefault">directEnumArrayDefault</a>(E, Data, <span class="tok-null">null</span>, max_unused_slots, init_values);
}</code></pre></details></div></div><div class="decl"><h2 id="std.enums.directEnumArrayDefault" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">directEnumArrayDefault</span><a href="#src.zig-std.enums.directEnumArrayDefault">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">directEnumArrayDefault</span>( <span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Data: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> default: ?Data, <span class="tok-kw">comptime</span> max_unused_slots: <span class="tok-type">comptime_int</span>, init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, Data, default), ) [<a href="std.enums.html#std.enums.directEnumArrayLen">directEnumArrayLen</a>(E, max_unused_slots)]Data</code></pre></div><div class="tldDocs"><p>Initializes an array of Data which can be indexed by
@intCast(usize, @intFromEnum(enum_value)).  The enum must be exhaustive.
If the enum contains any fields with values that cannot be represented
by usize, a compile error is issued.  The max_unused_slots parameter limits
the total number of items which have no matching enum key (holes in the enum
numbering).  So for example, if an enum has values 1, 2, 5, and 6, max_unused_slots
must be at least 3, to allow unused slots 0, 3, and 4.
The init_values parameter must be a struct with field names that match the enum values.
If the enum has multiple fields with the same value, the name of the first one must
be used.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>E: <span class="tok-type">type</span></code></pre></div><div><pre><code>Data: <span class="tok-type">type</span></code></pre></div><div><pre><code>default: ?Data</code></pre></div><div><pre><code>max_unused_slots: <span class="tok-type">comptime_int</span></code></pre></div><div><pre><code>init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, Data, default)</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> directEnumArrayDefault {
    <span class="tok-kw">const</span> E = <span class="tok-kw">enum</span>(<span class="tok-type">i4</span>) { a = <span class="tok-number">4</span>, b = <span class="tok-number">6</span>, c = <span class="tok-number">2</span> };
    <span class="tok-kw">var</span> runtime_false: <span class="tok-type">bool</span> = <span class="tok-null">false</span>;
    _ = &amp;runtime_false;
    <span class="tok-kw">const</span> array = <a href="std.enums.html#std.enums.directEnumArrayDefault">directEnumArrayDefault</a>(E, <span class="tok-type">bool</span>, <span class="tok-null">false</span>, <span class="tok-number">4</span>, .{
        .a = <span class="tok-null">true</span>,
        .b = runtime_false,
    });

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>([<span class="tok-number">7</span>]<span class="tok-type">bool</span>, <span class="tok-builtin">@TypeOf</span>(array));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">true</span>, array[<span class="tok-number">4</span>]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, array[<span class="tok-number">6</span>]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, array[<span class="tok-number">2</span>]);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.enums.directEnumArrayDefault">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">directEnumArrayDefault</span>(
    <span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> Data: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> default: ?Data,
    <span class="tok-kw">comptime</span> max_unused_slots: <span class="tok-type">comptime_int</span>,
    init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, Data, default),
) [<a href="std.enums.html#std.enums.directEnumArrayLen">directEnumArrayLen</a>(E, max_unused_slots)]Data {
    <span class="tok-kw">const</span> len = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.directEnumArrayLen">directEnumArrayLen</a>(E, max_unused_slots);
    <span class="tok-kw">var</span> result: [len]Data = <span class="tok-kw">if</span> (default) |d| [_]Data{d} ** len <span class="tok-kw">else</span> <span class="tok-null">undefined</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(init_values)).@&quot;struct&quot;.fields) |f| {
        <span class="tok-kw">const</span> enum_value = <span class="tok-builtin">@field</span>(E, f.name);
        <span class="tok-kw">const</span> index = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(enum_value)));
        result[index] = <span class="tok-builtin">@field</span>(init_values, f.name);
    }
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h2 id="std.enums.nameCast" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">nameCast</span><a href="#src.zig-std.enums.nameCast">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nameCast</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> value: <span class="tok-kw">anytype</span>) E</code></pre></div><div class="tldDocs"><p>Cast an enum literal, value, or string to the enum value of type E
with the same name.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>E: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> nameCast {
    <span class="tok-kw">const</span> A = <span class="tok-kw">enum</span>(<span class="tok-type">u1</span>) { a = <span class="tok-number">0</span>, b = <span class="tok-number">1</span> };
    <span class="tok-kw">const</span> B = <span class="tok-kw">enum</span>(<span class="tok-type">u1</span>) { a = <span class="tok-number">1</span>, b = <span class="tok-number">0</span> };
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(A.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(A, .a));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(A.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(A, A.a));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(A.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(A, B.a));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(A.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(A, <span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(A.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(A, <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> [<span class="tok-number">1</span>]<span class="tok-type">u8</span>, <span class="tok-str">&quot;a&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(A.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(A, <span class="tok-builtin">@as</span>([:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-str">&quot;a&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(A.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(A, <span class="tok-builtin">@as</span>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-str">&quot;a&quot;</span>)));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(B.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(B, .a));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(B.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(B, A.a));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(B.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(B, B.a));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(B.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(B, <span class="tok-str">&quot;a&quot;</span>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(B.b, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(B, .b));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(B.b, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(B, A.b));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(B.b, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(B, B.b));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(B.b, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(B, <span class="tok-str">&quot;b&quot;</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.enums.nameCast">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nameCast</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> value: <span class="tok-kw">anytype</span>) E {
    <span class="tok-kw">return</span> <span class="tok-kw">comptime</span> blk: {
        <span class="tok-kw">const</span> V = <span class="tok-builtin">@TypeOf</span>(value);
        <span class="tok-kw">if</span> (V == E) <span class="tok-kw">break</span> :blk value;
        <span class="tok-kw">const</span> name: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(V)) {
            .enum_literal, .@&quot;enum&quot; =&gt; <span class="tok-builtin">@tagName</span>(value),
            .pointer =&gt; value,
            <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
        };
        <span class="tok-kw">if</span> (name) |n| {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(E, n)) {
                <span class="tok-kw">break</span> :blk <span class="tok-builtin">@field</span>(E, n);
            }
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Enum &quot;</span> ++ <span class="tok-builtin">@typeName</span>(E) ++ <span class="tok-str">&quot; has no field named &quot;</span> ++ n);
        }
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot cast from &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(value)) ++ <span class="tok-str">&quot; to &quot;</span> ++ <span class="tok-builtin">@typeName</span>(E));
    };
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.enums">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! This module contains utilities and data structures for working with enums.</span>

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;
<span class="tok-kw">const</span> EnumField = <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.EnumField.html">EnumField</a>;

<span class="tok-comment">/// Increment this value when adding APIs that add single backwards branches.</span>
<span class="tok-kw">const</span> eval_branch_quota_cushion = <span class="tok-number">10</span>;

<span class="tok-comment">/// Returns a struct with a field matching each unique named enum element.</span>
<span class="tok-comment">/// If the enum is extern and has multiple names for the same value, only</span>
<span class="tok-comment">/// the first name is used.  Each field is of type Data and has the provided</span>
<span class="tok-comment">/// default, which may be undefined.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">EnumFieldStruct</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Data: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> field_default: ?Data) <span class="tok-type">type</span> {
    <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len + <a href="std.enums.html#std.enums.eval_branch_quota_cushion">eval_branch_quota_cushion</a>);
    <span class="tok-kw">var</span> struct_fields: [<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len]<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.StructField.html">StructField</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">for</span> (&amp;struct_fields, <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |*struct_field, enum_field| {
        struct_field.* = .{
            .name = enum_field.name ++ <span class="tok-str">&quot;&quot;</span>,
            .<span class="tok-type">type</span> = Data,
            .default_value_ptr = <span class="tok-kw">if</span> (field_default) |d| <span class="tok-builtin">@as</span>(?*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(&amp;d)) <span class="tok-kw">else</span> <span class="tok-null">null</span>,
            .is_comptime = <span class="tok-null">false</span>,
            .alignment = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Data) &gt; <span class="tok-number">0</span>) <span class="tok-builtin">@alignOf</span>(Data) <span class="tok-kw">else</span> <span class="tok-number">0</span>,
        };
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{ .@&quot;struct&quot; = .{
        .layout = .auto,
        .fields = &amp;struct_fields,
        .decls = &amp;.{},
        .is_tuple = <span class="tok-null">false</span>,
    } });
}

<span class="tok-comment">/// Looks up the supplied fields in the given enum type.</span>
<span class="tok-comment">/// Uses only the field names, field values are ignored.</span>
<span class="tok-comment">/// The result array is in the same order as the input.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">valuesFromFields</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> fields: []<span class="tok-kw">const</span> <a href="std.builtin.Type.EnumField.html">EnumField</a>) []<span class="tok-kw">const</span> E {
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> result: [fields.len]E = <span class="tok-null">undefined</span>;
        <span class="tok-kw">for</span> (&amp;result, fields) |*r, f| {
            r.* = <span class="tok-builtin">@enumFromInt</span>(f.value);
        }
        <span class="tok-kw">const</span> final = result;
        <span class="tok-kw">return</span> &amp;final;
    }
}

<span class="tok-comment">/// Returns the set of all named values in the given enum, in</span>
<span class="tok-comment">/// declaration order.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>) []<span class="tok-kw">const</span> E {
    <span class="tok-kw">return</span> <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.valuesFromFields">valuesFromFields</a>(E, <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields);
}

<span class="tok-comment">/// A safe alternative to @tagName() for non-exhaustive enums that doesn't</span>
<span class="tok-comment">/// panic when `e` has no tagged value.</span>
<span class="tok-comment">/// Returns the tag name for `e` or null if no tag exists.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tagName</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, e: E) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |f| {
        <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(e) == f.value) <span class="tok-kw">break</span> f.name;
    } <span class="tok-kw">else</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">test</span> tagName {
    <span class="tok-kw">const</span> E = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) { a, b, _ };
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.enums.html#std.enums.tagName">tagName</a>(E, .a) != <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;a&quot;</span>, <a href="std.enums.html#std.enums.tagName">tagName</a>(E, .a).?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.enums.html#std.enums.tagName">tagName</a>(E, <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">42</span>))) == <span class="tok-null">null</span>);
}

<span class="tok-comment">/// Determines the length of a direct-mapped enum array, indexed by</span>
<span class="tok-comment">/// @intCast(usize, @intFromEnum(enum_value)).</span>
<span class="tok-comment">/// If the enum is non-exhaustive, the resulting length will only be enough</span>
<span class="tok-comment">/// to hold all explicit fields.</span>
<span class="tok-comment">/// If the enum contains any fields with values that cannot be represented</span>
<span class="tok-comment">/// by usize, a compile error is issued.  The max_unused_slots parameter limits</span>
<span class="tok-comment">/// the total number of items which have no matching enum key (holes in the enum</span>
<span class="tok-comment">/// numbering).  So for example, if an enum has values 1, 2, 5, and 6, max_unused_slots</span>
<span class="tok-comment">/// must be at least 3, to allow unused slots 0, 3, and 4.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">directEnumArrayLen</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> max_unused_slots: <span class="tok-type">comptime_int</span>) <span class="tok-type">comptime_int</span> {
    <span class="tok-kw">var</span> max_value: <span class="tok-type">comptime_int</span> = -<span class="tok-number">1</span>;
    <span class="tok-kw">const</span> max_usize: <span class="tok-type">comptime_int</span> = ~<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> fields = <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields;
    <span class="tok-kw">for</span> (fields) |f| {
        <span class="tok-kw">if</span> (f.value &lt; <span class="tok-number">0</span>) {
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot create a direct enum array for &quot;</span> ++ <span class="tok-builtin">@typeName</span>(E) ++ <span class="tok-str">&quot;, field .&quot;</span> ++ f.name ++ <span class="tok-str">&quot; has a negative value.&quot;</span>);
        }
        <span class="tok-kw">if</span> (f.value &gt; max_value) {
            <span class="tok-kw">if</span> (f.value &gt; max_usize) {
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot create a direct enum array for &quot;</span> ++ <span class="tok-builtin">@typeName</span>(E) ++ <span class="tok-str">&quot;, field .&quot;</span> ++ f.name ++ <span class="tok-str">&quot; is larger than the max value of usize.&quot;</span>);
            }
            max_value = f.value;
        }
    }

    <span class="tok-kw">const</span> unused_slots = max_value + <span class="tok-number">1</span> - fields.len;
    <span class="tok-kw">if</span> (unused_slots &gt; max_unused_slots) {
        <span class="tok-kw">const</span> unused_str = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.comptimePrint">comptimePrint</a>(<span class="tok-str">&quot;{d}&quot;</span>, .{unused_slots});
        <span class="tok-kw">const</span> allowed_str = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.comptimePrint">comptimePrint</a>(<span class="tok-str">&quot;{d}&quot;</span>, .{max_unused_slots});
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot create a direct enum array for &quot;</span> ++ <span class="tok-builtin">@typeName</span>(E) ++ <span class="tok-str">&quot;. It would have &quot;</span> ++ unused_str ++ <span class="tok-str">&quot; unused slots, but only &quot;</span> ++ allowed_str ++ <span class="tok-str">&quot; are allowed.&quot;</span>);
    }

    <span class="tok-kw">return</span> max_value + <span class="tok-number">1</span>;
}

<span class="tok-comment">/// Initializes an array of Data which can be indexed by</span>
<span class="tok-comment">/// @intCast(usize, @intFromEnum(enum_value)).</span>
<span class="tok-comment">/// If the enum is non-exhaustive, the resulting array will only be large enough</span>
<span class="tok-comment">/// to hold all explicit fields.</span>
<span class="tok-comment">/// If the enum contains any fields with values that cannot be represented</span>
<span class="tok-comment">/// by usize, a compile error is issued.  The max_unused_slots parameter limits</span>
<span class="tok-comment">/// the total number of items which have no matching enum key (holes in the enum</span>
<span class="tok-comment">/// numbering).  So for example, if an enum has values 1, 2, 5, and 6, max_unused_slots</span>
<span class="tok-comment">/// must be at least 3, to allow unused slots 0, 3, and 4.</span>
<span class="tok-comment">/// The init_values parameter must be a struct with field names that match the enum values.</span>
<span class="tok-comment">/// If the enum has multiple fields with the same value, the name of the first one must</span>
<span class="tok-comment">/// be used.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">directEnumArray</span>(
    <span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> Data: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> max_unused_slots: <span class="tok-type">comptime_int</span>,
    init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, Data, <span class="tok-null">null</span>),
) [<a href="std.enums.html#std.enums.directEnumArrayLen">directEnumArrayLen</a>(E, max_unused_slots)]Data {
    <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.directEnumArrayDefault">directEnumArrayDefault</a>(E, Data, <span class="tok-null">null</span>, max_unused_slots, init_values);
}

<span class="tok-kw">test</span> directEnumArray {
    <span class="tok-kw">const</span> E = <span class="tok-kw">enum</span>(<span class="tok-type">i4</span>) { a = <span class="tok-number">4</span>, b = <span class="tok-number">6</span>, c = <span class="tok-number">2</span> };
    <span class="tok-kw">var</span> runtime_false: <span class="tok-type">bool</span> = <span class="tok-null">false</span>;
    _ = &amp;runtime_false;
    <span class="tok-kw">const</span> array = <a href="std.enums.html#std.enums.directEnumArray">directEnumArray</a>(E, <span class="tok-type">bool</span>, <span class="tok-number">4</span>, .{
        .a = <span class="tok-null">true</span>,
        .b = runtime_false,
        .c = <span class="tok-null">true</span>,
    });

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>([<span class="tok-number">7</span>]<span class="tok-type">bool</span>, <span class="tok-builtin">@TypeOf</span>(array));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">true</span>, array[<span class="tok-number">4</span>]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, array[<span class="tok-number">6</span>]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">true</span>, array[<span class="tok-number">2</span>]);
}

<span class="tok-comment">/// Initializes an array of Data which can be indexed by</span>
<span class="tok-comment">/// @intCast(usize, @intFromEnum(enum_value)).  The enum must be exhaustive.</span>
<span class="tok-comment">/// If the enum contains any fields with values that cannot be represented</span>
<span class="tok-comment">/// by usize, a compile error is issued.  The max_unused_slots parameter limits</span>
<span class="tok-comment">/// the total number of items which have no matching enum key (holes in the enum</span>
<span class="tok-comment">/// numbering).  So for example, if an enum has values 1, 2, 5, and 6, max_unused_slots</span>
<span class="tok-comment">/// must be at least 3, to allow unused slots 0, 3, and 4.</span>
<span class="tok-comment">/// The init_values parameter must be a struct with field names that match the enum values.</span>
<span class="tok-comment">/// If the enum has multiple fields with the same value, the name of the first one must</span>
<span class="tok-comment">/// be used.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">directEnumArrayDefault</span>(
    <span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> Data: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> default: ?Data,
    <span class="tok-kw">comptime</span> max_unused_slots: <span class="tok-type">comptime_int</span>,
    init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, Data, default),
) [<a href="std.enums.html#std.enums.directEnumArrayLen">directEnumArrayLen</a>(E, max_unused_slots)]Data {
    <span class="tok-kw">const</span> len = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.directEnumArrayLen">directEnumArrayLen</a>(E, max_unused_slots);
    <span class="tok-kw">var</span> result: [len]Data = <span class="tok-kw">if</span> (default) |d| [_]Data{d} ** len <span class="tok-kw">else</span> <span class="tok-null">undefined</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(init_values)).@&quot;struct&quot;.fields) |f| {
        <span class="tok-kw">const</span> enum_value = <span class="tok-builtin">@field</span>(E, f.name);
        <span class="tok-kw">const</span> index = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(enum_value)));
        result[index] = <span class="tok-builtin">@field</span>(init_values, f.name);
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">test</span> directEnumArrayDefault {
    <span class="tok-kw">const</span> E = <span class="tok-kw">enum</span>(<span class="tok-type">i4</span>) { a = <span class="tok-number">4</span>, b = <span class="tok-number">6</span>, c = <span class="tok-number">2</span> };
    <span class="tok-kw">var</span> runtime_false: <span class="tok-type">bool</span> = <span class="tok-null">false</span>;
    _ = &amp;runtime_false;
    <span class="tok-kw">const</span> array = <a href="std.enums.html#std.enums.directEnumArrayDefault">directEnumArrayDefault</a>(E, <span class="tok-type">bool</span>, <span class="tok-null">false</span>, <span class="tok-number">4</span>, .{
        .a = <span class="tok-null">true</span>,
        .b = runtime_false,
    });

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>([<span class="tok-number">7</span>]<span class="tok-type">bool</span>, <span class="tok-builtin">@TypeOf</span>(array));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">true</span>, array[<span class="tok-number">4</span>]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, array[<span class="tok-number">6</span>]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, array[<span class="tok-number">2</span>]);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;directEnumArrayDefault slice&quot;</span> {
    <span class="tok-kw">const</span> E = <span class="tok-kw">enum</span>(<span class="tok-type">i4</span>) { a = <span class="tok-number">4</span>, b = <span class="tok-number">6</span>, c = <span class="tok-number">2</span> };
    <span class="tok-kw">var</span> runtime_b = <span class="tok-str">&quot;b&quot;</span>;
    _ = &amp;runtime_b;
    <span class="tok-kw">const</span> array = <a href="std.enums.html#std.enums.directEnumArrayDefault">directEnumArrayDefault</a>(E, []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-str">&quot;default&quot;</span>, <span class="tok-number">4</span>, .{
        .a = <span class="tok-str">&quot;a&quot;</span>,
        .b = runtime_b,
    });

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>([<span class="tok-number">7</span>][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@TypeOf</span>(array));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a&quot;</span>, array[<span class="tok-number">4</span>]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;b&quot;</span>, array[<span class="tok-number">6</span>]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;default&quot;</span>, array[<span class="tok-number">2</span>]);
}

<span class="tok-comment">/// Cast an enum literal, value, or string to the enum value of type E</span>
<span class="tok-comment">/// with the same name.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nameCast</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> value: <span class="tok-kw">anytype</span>) E {
    <span class="tok-kw">return</span> <span class="tok-kw">comptime</span> blk: {
        <span class="tok-kw">const</span> V = <span class="tok-builtin">@TypeOf</span>(value);
        <span class="tok-kw">if</span> (V == E) <span class="tok-kw">break</span> :blk value;
        <span class="tok-kw">const</span> name: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(V)) {
            .enum_literal, .@&quot;enum&quot; =&gt; <span class="tok-builtin">@tagName</span>(value),
            .pointer =&gt; value,
            <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
        };
        <span class="tok-kw">if</span> (name) |n| {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(E, n)) {
                <span class="tok-kw">break</span> :blk <span class="tok-builtin">@field</span>(E, n);
            }
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Enum &quot;</span> ++ <span class="tok-builtin">@typeName</span>(E) ++ <span class="tok-str">&quot; has no field named &quot;</span> ++ n);
        }
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot cast from &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(value)) ++ <span class="tok-str">&quot; to &quot;</span> ++ <span class="tok-builtin">@typeName</span>(E));
    };
}

<span class="tok-kw">test</span> nameCast {
    <span class="tok-kw">const</span> A = <span class="tok-kw">enum</span>(<span class="tok-type">u1</span>) { a = <span class="tok-number">0</span>, b = <span class="tok-number">1</span> };
    <span class="tok-kw">const</span> B = <span class="tok-kw">enum</span>(<span class="tok-type">u1</span>) { a = <span class="tok-number">1</span>, b = <span class="tok-number">0</span> };
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(A.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(A, .a));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(A.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(A, A.a));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(A.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(A, B.a));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(A.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(A, <span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(A.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(A, <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> [<span class="tok-number">1</span>]<span class="tok-type">u8</span>, <span class="tok-str">&quot;a&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(A.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(A, <span class="tok-builtin">@as</span>([:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-str">&quot;a&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(A.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(A, <span class="tok-builtin">@as</span>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-str">&quot;a&quot;</span>)));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(B.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(B, .a));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(B.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(B, A.a));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(B.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(B, B.a));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(B.a, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(B, <span class="tok-str">&quot;a&quot;</span>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(B.b, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(B, .b));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(B.b, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(B, A.b));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(B.b, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(B, B.b));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(B.b, <a href="std.enums.html#std.enums.nameCast">nameCast</a>(B, <span class="tok-str">&quot;b&quot;</span>));
}

<span class="tok-comment">/// A set of enum elements, backed by a bitfield.  If the enum</span>
<span class="tok-comment">/// is exhaustive but not dense, a mapping will be constructed from enum values</span>
<span class="tok-comment">/// to dense indices.  This type does no dynamic allocation and</span>
<span class="tok-comment">/// can be copied by value.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">EnumSet</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// The indexing rules for converting between keys and indices.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E);
        <span class="tok-comment">/// The element type for this set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">Key</a>;

        <span class="tok-kw">const</span> BitSet = <a href="std.html">std</a>.<a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">count</a>);

        <span class="tok-comment">/// The maximum number of items in this set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> len = <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">count</a>;

        bits: <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a> = <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a>.<a href="#">initEmpty</a>(),

        <span class="tok-comment">/// Initializes the set using a struct of bools</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <span class="tok-type">bool</span>, <span class="tok-null">false</span>)) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
            <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumSet">Self</a> = .{};
            <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.is_exhaustive) {
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<a href="std.enums.html#std.enums.EnumSet">Self</a>.<a href="std.enums.html#std.enums.EnumSet.len">len</a>) |i| {
                    <span class="tok-kw">const</span> key = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(i);
                    <span class="tok-kw">const</span> tag = <span class="tok-builtin">@tagName</span>(key);
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(init_values, tag)) {
                        result.bits.set(i);
                    }
                }
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(E)) |field| {
                    <span class="tok-kw">const</span> key = <span class="tok-builtin">@field</span>(E, field.name);
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(init_values, field.name)) {
                        <span class="tok-kw">const</span> i = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
                        result.bits.set(i);
                    }
                }
            }
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns a set containing no keys.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a>.<a href="#">initEmpty</a>() };
        }

        <span class="tok-comment">/// Returns a set containing all possible keys.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>() <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a>.<a href="#">initFull</a>() };
        }

        <span class="tok-comment">/// Returns a set containing multiple keys.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initMany</span>(keys: []<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">var</span> set = <a href="std.enums.html#std.enums.EnumSet.initEmpty">initEmpty</a>();
            <span class="tok-kw">for</span> (keys) |key| set.insert(key);
            <span class="tok-kw">return</span> set;
        }

        <span class="tok-comment">/// Returns a set containing a single key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initOne</span>(key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.EnumSet.initMany">initMany</a>(&amp;[_]<a href="std.enums.html#std.enums.EnumSet.Key">Key</a>{key});
        }

        <span class="tok-comment">/// Returns the number of keys in the set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.bits.count();
        }

        <span class="tok-comment">/// Checks if a key is in the set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.bits.isSet(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
        }

        <span class="tok-comment">/// Puts a key in the set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span> {
            self.bits.set(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
        }

        <span class="tok-comment">/// Removes a key from the set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span> {
            self.bits.unset(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
        }

        <span class="tok-comment">/// Changes the presence of a key in the set to match the passed bool.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setPresent</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>, present: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
            self.bits.setValue(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key), present);
        }

        <span class="tok-comment">/// Toggles the presence of a key in the set.  If the key is in</span>
        <span class="tok-comment">/// the set, removes it.  Otherwise adds it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggle</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span> {
            self.bits.toggle(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
        }

        <span class="tok-comment">/// Toggles the presence of all keys in the passed set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleSet</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span> {
            self.bits.toggleSet(other.bits);
        }

        <span class="tok-comment">/// Toggles all possible keys in the set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleAll</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span> {
            self.bits.toggleAll();
        }

        <span class="tok-comment">/// Adds all keys in the passed set to this set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span> {
            self.bits.setUnion(other.bits);
        }

        <span class="tok-comment">/// Removes all keys which are not in the passed set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIntersection</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span> {
            self.bits.setIntersection(other.bits);
        }

        <span class="tok-comment">/// Returns true iff both sets have the same keys.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.bits.eql(other.bits);
        }

        <span class="tok-comment">/// Returns true iff all the keys in this set are</span>
        <span class="tok-comment">/// in the other set. The other set may have keys</span>
        <span class="tok-comment">/// not found in this set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.bits.subsetOf(other.bits);
        }

        <span class="tok-comment">/// Returns true iff this set contains all the keys</span>
        <span class="tok-comment">/// in the other set. This set may have keys not</span>
        <span class="tok-comment">/// found in the other set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.bits.supersetOf(other.bits);
        }

        <span class="tok-comment">/// Returns a set with all the keys not in this set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">complement</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = self.bits.complement() };
        }

        <span class="tok-comment">/// Returns a set with keys that are in either this</span>
        <span class="tok-comment">/// set or the other set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unionWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = self.bits.unionWith(other.bits) };
        }

        <span class="tok-comment">/// Returns a set with keys that are in both this</span>
        <span class="tok-comment">/// set and the other set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intersectWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = self.bits.intersectWith(other.bits) };
        }

        <span class="tok-comment">/// Returns a set with keys that are in either this</span>
        <span class="tok-comment">/// set or the other set, but not both.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">xorWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = self.bits.xorWith(other.bits) };
        }

        <span class="tok-comment">/// Returns a set with keys that are in this set</span>
        <span class="tok-comment">/// except for keys in the other set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">differenceWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = self.bits.differenceWith(other.bits) };
        }

        <span class="tok-comment">/// Returns an iterator over this set, which iterates in</span>
        <span class="tok-comment">/// index order.  Modifications to the set during iteration</span>
        <span class="tok-comment">/// may or may not be observed by the iterator, but will</span>
        <span class="tok-comment">/// not invalidate it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.EnumSet.Iterator.html">Iterator</a> {
            <span class="tok-kw">return</span> .{ .inner = self.bits.iterator(.{}) };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {
            inner: <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a>.<a href="#">Iterator</a>(.{}),

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.enums.EnumSet.Iterator.html">Iterator</a>) ?<a href="std.enums.html#std.enums.EnumSet.Key">Key</a> {
                <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.inner.next()) |index|
                    <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(index)
                <span class="tok-kw">else</span>
                    <span class="tok-null">null</span>;
            }
        };
    };
}

<span class="tok-comment">/// A map keyed by an enum, backed by a bitfield and a dense array.</span>
<span class="tok-comment">/// If the enum is exhaustive but not dense, a mapping will be constructed from</span>
<span class="tok-comment">/// enum values to dense indices.  This type does no dynamic</span>
<span class="tok-comment">/// allocation and can be copied by value.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">EnumMap</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// The index mapping for this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E);
        <span class="tok-comment">/// The key type used to index this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">Key</a>;
        <span class="tok-comment">/// The value type stored in this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Value = V;
        <span class="tok-comment">/// The number of possible keys in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> len = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">count</a>;

        <span class="tok-kw">const</span> BitSet = <a href="std.html">std</a>.<a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">count</a>);

        <span class="tok-comment">/// Bits determining whether items are in the map</span>
        bits: <a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a> = <a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a>.<a href="#">initEmpty</a>(),
        <span class="tok-comment">/// Values of items in the map.  If the associated</span>
        <span class="tok-comment">/// bit is zero, the value is undefined.</span>
        values: [<a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">count</a>]<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> = <span class="tok-null">undefined</span>,

        <span class="tok-comment">/// Initializes the map using a sparse struct of optionals</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-builtin">@as</span>(?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-null">null</span>))) <a href="std.enums.html#std.enums.EnumMap">Self</a> {
            <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
            <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumMap">Self</a> = .{};
            <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.is_exhaustive) {
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<a href="std.enums.html#std.enums.EnumMap">Self</a>.<a href="std.enums.html#std.enums.EnumMap.len">len</a>) |i| {
                    <span class="tok-kw">const</span> key = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(i);
                    <span class="tok-kw">const</span> tag = <span class="tok-builtin">@tagName</span>(key);
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(init_values, tag)) |*v| {
                        result.bits.set(i);
                        result.values[i] = v.*;
                    }
                }
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(E)) |field| {
                    <span class="tok-kw">const</span> key = <span class="tok-builtin">@field</span>(E, field.name);
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(init_values, field.name)) |*v| {
                        <span class="tok-kw">const</span> i = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
                        result.bits.set(i);
                        result.values[i] = v.*;
                    }
                }
            }
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Initializes a full mapping with all keys set to value.</span>
        <span class="tok-comment">/// Consider using EnumArray instead if the map will remain full.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>(value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) <a href="std.enums.html#std.enums.EnumMap">Self</a> {
            <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumMap">Self</a> = .{
                .bits = <a href="std.enums.html#std.enums.EnumMap">Self</a>.<a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a>.<a href="#">initFull</a>(),
                .values = <span class="tok-null">undefined</span>,
            };
            <span class="tok-builtin">@memset</span>(&amp;result.values, value);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Initializes a full mapping with supplied values.</span>
        <span class="tok-comment">/// Consider using EnumArray instead if the map will remain full.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFullWith</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-null">null</span>)) <a href="std.enums.html#std.enums.EnumMap">Self</a> {
            <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.EnumMap.initFullWithDefault">initFullWithDefault</a>(<span class="tok-null">null</span>, init_values);
        }

        <span class="tok-comment">/// Initializes a full mapping with a provided default.</span>
        <span class="tok-comment">/// Consider using EnumArray instead if the map will remain full.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFullWithDefault</span>(<span class="tok-kw">comptime</span> default: ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, default)) <a href="std.enums.html#std.enums.EnumMap">Self</a> {
            <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
            <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumMap">Self</a> = .{
                .bits = <a href="std.enums.html#std.enums.EnumMap">Self</a>.<a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a>.<a href="#">initFull</a>(),
                .values = <span class="tok-null">undefined</span>,
            };
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<a href="std.enums.html#std.enums.EnumMap">Self</a>.<a href="std.enums.html#std.enums.EnumMap.len">len</a>) |i| {
                <span class="tok-kw">const</span> key = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(i);
                <span class="tok-kw">const</span> tag = <span class="tok-builtin">@tagName</span>(key);
                result.values[i] = <span class="tok-builtin">@field</span>(init_values, tag);
            }
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// The number of items in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.bits.count();
        }

        <span class="tok-comment">/// Checks if the map contains an item.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.bits.isSet(<a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
        }

        <span class="tok-comment">/// Gets the value associated with a key.</span>
        <span class="tok-comment">/// If the key is not in the map, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.bits.isSet(index)) self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Gets the value associated with a key, which must</span>
        <span class="tok-comment">/// exist in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAssertContains</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <a href="std.debug.html#std.debug.assert">assert</a>(self.bits.isSet(index));
            <span class="tok-kw">return</span> self.values[index];
        }

        <span class="tok-comment">/// Gets the address of the value associated with a key.</span>
        <span class="tok-comment">/// If the key is not in the map, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?*<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.bits.isSet(index)) &amp;self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Gets the address of the const value associated with a key.</span>
        <span class="tok-comment">/// If the key is not in the map, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConst</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?*<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.bits.isSet(index)) &amp;self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Gets the address of the value associated with a key.</span>
        <span class="tok-comment">/// The key must be present in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAssertContains</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <a href="std.debug.html#std.debug.assert">assert</a>(self.bits.isSet(index));
            <span class="tok-kw">return</span> &amp;self.values[index];
        }

        <span class="tok-comment">/// Gets the address of the const value associated with a key.</span>
        <span class="tok-comment">/// The key must be present in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConstAssertContains</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <a href="std.debug.html#std.debug.assert">assert</a>(self.bits.isSet(index));
            <span class="tok-kw">return</span> &amp;self.values[index];
        }

        <span class="tok-comment">/// Adds the key to the map with the supplied value.</span>
        <span class="tok-comment">/// If the key is already in the map, overwrites the value.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            self.bits.set(index);
            self.values[index] = value;
        }

        <span class="tok-comment">/// Adds the key to the map with an undefined value.</span>
        <span class="tok-comment">/// If the key is already in the map, the value becomes undefined.</span>
        <span class="tok-comment">/// A pointer to the value is returned, which should be</span>
        <span class="tok-comment">/// used to initialize the value.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putUninitialized</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            self.bits.set(index);
            self.values[index] = <span class="tok-null">undefined</span>;
            <span class="tok-kw">return</span> &amp;self.values[index];
        }

        <span class="tok-comment">/// Sets the value associated with the key in the map,</span>
        <span class="tok-comment">/// and returns the old value.  If the key was not in</span>
        <span class="tok-comment">/// the map, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <span class="tok-kw">const</span> result: ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> = <span class="tok-kw">if</span> (self.bits.isSet(index)) self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
            self.bits.set(index);
            self.values[index] = value;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Removes a key from the map.  If the key was not in the map,</span>
        <span class="tok-comment">/// does nothing.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            self.bits.unset(index);
            self.values[index] = <span class="tok-null">undefined</span>;
        }

        <span class="tok-comment">/// Removes a key from the map, and returns the old value.</span>
        <span class="tok-comment">/// If the key was not in the map, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <span class="tok-kw">const</span> result: ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> = <span class="tok-kw">if</span> (self.bits.isSet(index)) self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
            self.bits.unset(index);
            self.values[index] = <span class="tok-null">undefined</span>;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns an iterator over the map, which visits items in index order.</span>
        <span class="tok-comment">/// Modifications to the underlying map may or may not be observed by</span>
        <span class="tok-comment">/// the iterator, but will not invalidate it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>) <a href="std.enums.EnumMap.Iterator.html">Iterator</a> {
            <span class="tok-kw">return</span> .{
                .inner = self.bits.iterator(.{}),
                .values = &amp;self.values,
            };
        }

        <span class="tok-comment">/// An entry in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// The key associated with this entry.</span>
            <span class="tok-comment">/// Modifying this key will not change the map.</span>
            key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>,

            <span class="tok-comment">/// A pointer to the value in the map associated</span>
            <span class="tok-comment">/// with this key.  Modifications through this</span>
            <span class="tok-comment">/// pointer will modify the underlying data.</span>
            value: *<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {
            inner: <a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a>.<a href="#">Iterator</a>(.{}),
            values: *[<a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">count</a>]<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.enums.EnumMap.Iterator.html">Iterator</a>) ?<a href="std.enums.EnumMap.Entry.html">Entry</a> {
                <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.inner.next()) |index|
                    <a href="std.enums.EnumMap.Entry.html">Entry</a>{
                        .key = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(index),
                        .value = &amp;self.values[index],
                    }
                <span class="tok-kw">else</span>
                    <span class="tok-null">null</span>;
            }
        };
    };
}

<span class="tok-kw">test</span> EnumMap {
    <span class="tok-kw">const</span> Ball = <span class="tok-kw">enum</span> { red, green, blue };

    <span class="tok-kw">const</span> some = <a href="std.enums.html#std.enums.EnumMap">EnumMap</a>(Ball, <span class="tok-type">u8</span>).init(.{
        .green = <span class="tok-number">0xff</span>,
        .blue = <span class="tok-number">0x80</span>,
    });
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, some.count());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, some.get(.red));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0xff</span>, some.get(.green));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0x80</span>, some.get(.blue));
}

<span class="tok-comment">/// A multiset of enum elements up to a count of usize. Backed</span>
<span class="tok-comment">/// by an EnumArray. This type does no dynamic allocation and can</span>
<span class="tok-comment">/// be copied by value.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">EnumMultiset</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.BoundedEnumMultiset">BoundedEnumMultiset</a>(E, <span class="tok-type">usize</span>);
}

<span class="tok-comment">/// A multiset of enum elements up to CountSize. Backed by an</span>
<span class="tok-comment">/// EnumArray. This type does no dynamic allocation and can be</span>
<span class="tok-comment">/// copied by value.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">BoundedEnumMultiset</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> CountSize: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        counts: <a href="std.enums.html#std.enums.EnumArray">EnumArray</a>(E, CountSize),

        <span class="tok-comment">/// Initializes the multiset using a struct of counts.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_counts: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, CountSize, <span class="tok-number">0</span>)) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
            <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
            <span class="tok-kw">var</span> self = <a href="std.enums.html#std.enums.BoundedEnumMultiset.initWithCount">initWithCount</a>(<span class="tok-number">0</span>);
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
                <span class="tok-kw">const</span> c = <span class="tok-builtin">@field</span>(init_counts, field.name);
                <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
                self.counts.set(key, c);
            }
            <span class="tok-kw">return</span> self;
        }

        <span class="tok-comment">/// Initializes the multiset with a count of zero.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
            <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.BoundedEnumMultiset.initWithCount">initWithCount</a>(<span class="tok-number">0</span>);
        }

        <span class="tok-comment">/// Initializes the multiset with all keys at the</span>
        <span class="tok-comment">/// same count.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initWithCount</span>(<span class="tok-kw">comptime</span> c: CountSize) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
            <span class="tok-kw">return</span> .{
                .counts = <a href="std.enums.html#std.enums.EnumArray">EnumArray</a>(E, CountSize).initDefault(c, .{}),
            };
        }

        <span class="tok-comment">/// Returns the total number of key counts in the multiset.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (self.counts.values) |c| {
                sum += c;
            }
            <span class="tok-kw">return</span> sum;
        }

        <span class="tok-comment">/// Checks if at least one key in multiset.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.counts.get(key) &gt; <span class="tok-number">0</span>;
        }

        <span class="tok-comment">/// Removes all instance of a key from multiset. Same as</span>
        <span class="tok-comment">/// setCount(key, 0).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAll</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.counts.set(key, <span class="tok-number">0</span>);
        }

        <span class="tok-comment">/// Increases the key count by given amount. Caller asserts</span>
        <span class="tok-comment">/// operation will not overflow.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAssertSafe</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-type">void</span> {
            self.counts.getPtr(key).* += c;
        }

        <span class="tok-comment">/// Increases the key count by given amount.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
            self.counts.set(key, <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(CountSize, self.counts.get(key), c));
        }

        <span class="tok-comment">/// Decreases the key count by given amount. If amount is</span>
        <span class="tok-comment">/// greater than the number of keys in multset, then key count</span>
        <span class="tok-comment">/// will be set to zero.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-type">void</span> {
            self.counts.getPtr(key).* -= <span class="tok-builtin">@min</span>(self.getCount(key), c);
        }

        <span class="tok-comment">/// Returns the count for a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getCount</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E) CountSize {
            <span class="tok-kw">return</span> self.counts.get(key);
        }

        <span class="tok-comment">/// Set the count for a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setCount</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, key: E, c: CountSize) <span class="tok-type">void</span> {
            self.counts.set(key, c);
        }

        <span class="tok-comment">/// Increases the all key counts by given multiset. Caller</span>
        <span class="tok-comment">/// asserts operation will not overflow any key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSetAssertSafe</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
                <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
                self.addAssertSafe(key, other.getCount(key));
            }
        }

        <span class="tok-comment">/// Increases the all key counts by given multiset.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSet</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
                <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
                <span class="tok-kw">try</span> self.add(key, other.getCount(key));
            }
        }

        <span class="tok-comment">/// Decreases the all key counts by given multiset. If</span>
        <span class="tok-comment">/// the given multiset has more key counts than this,</span>
        <span class="tok-comment">/// then that key will have a key count of zero.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeSet</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
                <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
                self.remove(key, other.getCount(key));
            }
        }

        <span class="tok-comment">/// Returns true iff all key counts are the same as</span>
        <span class="tok-comment">/// given multiset.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
                <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
                <span class="tok-kw">if</span> (self.getCount(key) != other.getCount(key)) {
                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                }
            }
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }

        <span class="tok-comment">/// Returns true iff all key counts less than or</span>
        <span class="tok-comment">/// equal to the given multiset.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
                <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
                <span class="tok-kw">if</span> (self.getCount(key) &gt; other.getCount(key)) {
                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                }
            }
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }

        <span class="tok-comment">/// Returns true iff all key counts greater than or</span>
        <span class="tok-comment">/// equal to the given multiset.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields) |field| {
                <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(field.value));
                <span class="tok-kw">if</span> (self.getCount(key) &lt; other.getCount(key)) {
                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                }
            }
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }

        <span class="tok-comment">/// Returns a multiset with the total key count of this</span>
        <span class="tok-comment">/// multiset and the other multiset. Caller asserts</span>
        <span class="tok-comment">/// operation will not overflow any key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">plusAssertSafe</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.addSetAssertSafe(other);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns a multiset with the total key count of this</span>
        <span class="tok-comment">/// multiset and the other multiset.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">plus</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <span class="tok-kw">error</span>{Overflow}!<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
            <span class="tok-kw">var</span> result = self;
            <span class="tok-kw">try</span> result.addSet(other);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns a multiset with the key count of this</span>
        <span class="tok-comment">/// multiset minus the corresponding key count in the</span>
        <span class="tok-comment">/// other multiset. If the other multiset contains</span>
        <span class="tok-comment">/// more key count than this set, that key will have</span>
        <span class="tok-comment">/// a count of zero.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">minus</span>(self: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>, other: <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a> {
            <span class="tok-kw">var</span> result = self;
            result.removeSet(other);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <a href="std.enums.html#std.enums.EnumArray">EnumArray</a>(E, CountSize).Entry;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.enums.html#std.enums.EnumArray">EnumArray</a>(E, CountSize).Iterator;

        <span class="tok-comment">/// Returns an iterator over this multiset. Keys with zero</span>
        <span class="tok-comment">/// counts are included. Modifications to the set during</span>
        <span class="tok-comment">/// iteration may or may not be observed by the iterator,</span>
        <span class="tok-comment">/// but will not invalidate it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.enums.html#std.enums.BoundedEnumMultiset">Self</a>) <a href="std.enums.html#std.enums.BoundedEnumMultiset.Iterator">Iterator</a> {
            <span class="tok-kw">return</span> self.counts.iterator();
        }
    };
}

<span class="tok-kw">test</span> EnumMultiset {
    <span class="tok-kw">const</span> Ball = <span class="tok-kw">enum</span> { red, green, blue };

    <span class="tok-kw">const</span> empty = <a href="std.enums.html#std.enums.EnumMultiset">EnumMultiset</a>(Ball).initEmpty();
    <span class="tok-kw">const</span> r0_g1_b2 = <a href="std.enums.html#std.enums.EnumMultiset">EnumMultiset</a>(Ball).init(.{
        .red = <span class="tok-number">0</span>,
        .green = <span class="tok-number">1</span>,
        .blue = <span class="tok-number">2</span>,
    });
    <span class="tok-kw">const</span> ten_of_each = <a href="std.enums.html#std.enums.EnumMultiset">EnumMultiset</a>(Ball).initWithCount(<span class="tok-number">10</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(empty.count(), <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(r0_g1_b2.count(), <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(ten_of_each.count(), <span class="tok-number">30</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!empty.contains(.red));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!empty.contains(.green));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!empty.contains(.blue));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!r0_g1_b2.contains(.red));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(r0_g1_b2.contains(.green));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(r0_g1_b2.contains(.blue));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(ten_of_each.contains(.red));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(ten_of_each.contains(.green));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(ten_of_each.contains(.blue));

    {
        <span class="tok-kw">var</span> copy = ten_of_each;
        copy.removeAll(.red);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!copy.contains(.red));<span class="tok-comment">

        // removeAll second time does nothing
        </span>copy.removeAll(.red);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!copy.contains(.red));
    }

    {
        <span class="tok-kw">var</span> copy = ten_of_each;
        copy.addAssertSafe(.red, <span class="tok-number">6</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.red), <span class="tok-number">16</span>);
    }

    {
        <span class="tok-kw">var</span> copy = ten_of_each;
        <span class="tok-kw">try</span> copy.add(.red, <span class="tok-number">6</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.red), <span class="tok-number">16</span>);

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.Overflow, copy.add(.red, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>)));
    }

    {
        <span class="tok-kw">var</span> copy = ten_of_each;
        copy.remove(.red, <span class="tok-number">4</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.red), <span class="tok-number">6</span>);<span class="tok-comment">

        // subtracting more it contains does not underflow
        </span>copy.remove(.green, <span class="tok-number">14</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.green), <span class="tok-number">0</span>);
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(empty.getCount(.green), <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(r0_g1_b2.getCount(.green), <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(ten_of_each.getCount(.green), <span class="tok-number">10</span>);

    {
        <span class="tok-kw">var</span> copy = empty;
        copy.setCount(.red, <span class="tok-number">6</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.red), <span class="tok-number">6</span>);
    }

    {
        <span class="tok-kw">var</span> copy = r0_g1_b2;
        copy.addSetAssertSafe(ten_of_each);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.red), <span class="tok-number">10</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.green), <span class="tok-number">11</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.blue), <span class="tok-number">12</span>);
    }

    {
        <span class="tok-kw">var</span> copy = r0_g1_b2;
        <span class="tok-kw">try</span> copy.addSet(ten_of_each);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.red), <span class="tok-number">10</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.green), <span class="tok-number">11</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.blue), <span class="tok-number">12</span>);

        <span class="tok-kw">const</span> full = <a href="std.enums.html#std.enums.EnumMultiset">EnumMultiset</a>(Ball).initWithCount(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.Overflow, copy.addSet(full));
    }

    {
        <span class="tok-kw">var</span> copy = ten_of_each;
        copy.removeSet(r0_g1_b2);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.red), <span class="tok-number">10</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.green), <span class="tok-number">9</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.blue), <span class="tok-number">8</span>);

        copy.removeSet(ten_of_each);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.red), <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.green), <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(copy.getCount(.blue), <span class="tok-number">0</span>);
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(r0_g1_b2.eql(r0_g1_b2));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(ten_of_each.eql(ten_of_each));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!empty.eql(r0_g1_b2));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!r0_g1_b2.eql(ten_of_each));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!ten_of_each.eql(empty));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.subsetOf(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(r0_g1_b2.subsetOf(r0_g1_b2));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.subsetOf(r0_g1_b2));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(r0_g1_b2.subsetOf(ten_of_each));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!ten_of_each.subsetOf(r0_g1_b2));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!r0_g1_b2.subsetOf(empty));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.supersetOf(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(r0_g1_b2.supersetOf(r0_g1_b2));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(r0_g1_b2.supersetOf(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(ten_of_each.supersetOf(r0_g1_b2));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!r0_g1_b2.supersetOf(ten_of_each));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!empty.supersetOf(r0_g1_b2));

    {<span class="tok-comment">
        // with multisets it could be the case where two
        // multisets are neither subset nor superset of each
        // other.

        </span><span class="tok-kw">const</span> r10 = <a href="std.enums.html#std.enums.EnumMultiset">EnumMultiset</a>(Ball).init(.{
            .red = <span class="tok-number">10</span>,
        });
        <span class="tok-kw">const</span> b10 = <a href="std.enums.html#std.enums.EnumMultiset">EnumMultiset</a>(Ball).init(.{
            .blue = <span class="tok-number">10</span>,
        });

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!r10.subsetOf(b10));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!b10.subsetOf(r10));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!r10.supersetOf(b10));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!b10.supersetOf(r10));
    }

    {
        <span class="tok-kw">const</span> result = r0_g1_b2.plusAssertSafe(ten_of_each);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.red), <span class="tok-number">10</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.green), <span class="tok-number">11</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.blue), <span class="tok-number">12</span>);
    }

    {
        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> r0_g1_b2.plus(ten_of_each);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.red), <span class="tok-number">10</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.green), <span class="tok-number">11</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.blue), <span class="tok-number">12</span>);

        <span class="tok-kw">const</span> full = <a href="std.enums.html#std.enums.EnumMultiset">EnumMultiset</a>(Ball).initWithCount(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.Overflow, result.plus(full));
    }

    {
        <span class="tok-kw">const</span> result = ten_of_each.minus(r0_g1_b2);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.red), <span class="tok-number">10</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.green), <span class="tok-number">9</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.blue), <span class="tok-number">8</span>);
    }

    {
        <span class="tok-kw">const</span> result = ten_of_each.minus(r0_g1_b2).minus(ten_of_each);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.red), <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.green), <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(result.getCount(.blue), <span class="tok-number">0</span>);
    }

    {
        <span class="tok-kw">var</span> copy = empty;
        <span class="tok-kw">var</span> it = copy.iterator();
        <span class="tok-kw">var</span> entry = it.next().?;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.key, .red);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.value.*, <span class="tok-number">0</span>);
        entry = it.next().?;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.key, .green);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.value.*, <span class="tok-number">0</span>);
        entry = it.next().?;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.key, .blue);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.value.*, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);
    }

    {
        <span class="tok-kw">var</span> copy = r0_g1_b2;
        <span class="tok-kw">var</span> it = copy.iterator();
        <span class="tok-kw">var</span> entry = it.next().?;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.key, .red);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.value.*, <span class="tok-number">0</span>);
        entry = it.next().?;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.key, .green);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.value.*, <span class="tok-number">1</span>);
        entry = it.next().?;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.key, .blue);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(entry.value.*, <span class="tok-number">2</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);
    }
}

<span class="tok-comment">/// An array keyed by an enum, backed by a dense array.</span>
<span class="tok-comment">/// If the enum is not dense, a mapping will be constructed from</span>
<span class="tok-comment">/// enum values to dense indices.  This type does no dynamic</span>
<span class="tok-comment">/// allocation and can be copied by value.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">EnumArray</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// The index mapping for this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E);
        <span class="tok-comment">/// The key type used to index this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">Key</a>;
        <span class="tok-comment">/// The value type stored in this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Value = V;
        <span class="tok-comment">/// The number of possible keys in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> len = <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">count</a>;

        values: [<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">count</a>]<a href="std.enums.html#std.enums.EnumArray.Value">Value</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, <span class="tok-null">null</span>)) <a href="std.enums.html#std.enums.EnumArray">Self</a> {
            <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.EnumArray.initDefault">initDefault</a>(<span class="tok-null">null</span>, init_values);
        }

        <span class="tok-comment">/// Initializes values in the enum array, with the specified default.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initDefault</span>(<span class="tok-kw">comptime</span> default: ?<a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, default)) <a href="std.enums.html#std.enums.EnumArray">Self</a> {
            <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
            <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumArray">Self</a> = .{ .values = <span class="tok-null">undefined</span> };
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<a href="std.enums.html#std.enums.EnumArray">Self</a>.<a href="std.enums.html#std.enums.EnumArray.len">len</a>) |i| {
                <span class="tok-kw">const</span> key = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(i);
                <span class="tok-kw">const</span> tag = <span class="tok-builtin">@tagName</span>(key);
                result.values[i] = <span class="tok-builtin">@field</span>(init_values, tag);
            }
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initUndefined</span>() <a href="std.enums.html#std.enums.EnumArray">Self</a> {
            <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.EnumArray">Self</a>{ .values = <span class="tok-null">undefined</span> };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFill</span>(v: <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>) <a href="std.enums.html#std.enums.EnumArray">Self</a> {
            <span class="tok-kw">var</span> self: <a href="std.enums.html#std.enums.EnumArray">Self</a> = <span class="tok-null">undefined</span>;
            <span class="tok-builtin">@memset</span>(&amp;self.values, v);
            <span class="tok-kw">return</span> self;
        }

        <span class="tok-comment">/// Returns the value in the array associated with a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) <a href="std.enums.html#std.enums.EnumArray.Value">Value</a> {
            <span class="tok-kw">return</span> self.values[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">indexOf</a>(key)];
        }

        <span class="tok-comment">/// Returns a pointer to the slot in the array associated with a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumArray.Value">Value</a> {
            <span class="tok-kw">return</span> &amp;self.values[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">indexOf</a>(key)];
        }

        <span class="tok-comment">/// Returns a const pointer to the slot in the array associated with a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConst</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumArray.Value">Value</a> {
            <span class="tok-kw">return</span> &amp;self.values[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">indexOf</a>(key)];
        }

        <span class="tok-comment">/// Sets the value in the slot associated with a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>) <span class="tok-type">void</span> {
            self.values[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">indexOf</a>(key)] = value;
        }

        <span class="tok-comment">/// Iterates over the items in the array, in index order.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>) <a href="std.enums.EnumArray.Iterator.html">Iterator</a> {
            <span class="tok-kw">return</span> .{
                .values = &amp;self.values,
            };
        }

        <span class="tok-comment">/// An entry in the array.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// The key associated with this entry.</span>
            <span class="tok-comment">/// Modifying this key will not change the array.</span>
            key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>,

            <span class="tok-comment">/// A pointer to the value in the array associated</span>
            <span class="tok-comment">/// with this key.  Modifications through this</span>
            <span class="tok-comment">/// pointer will modify the underlying data.</span>
            value: *<a href="std.enums.html#std.enums.EnumArray.Value">Value</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {
            index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
            values: *[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">count</a>]<a href="std.enums.html#std.enums.EnumArray.Value">Value</a>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.enums.EnumArray.Iterator.html">Iterator</a>) ?<a href="std.enums.EnumArray.Entry.html">Entry</a> {
                <span class="tok-kw">const</span> index = self.index;
                <span class="tok-kw">if</span> (index &lt; <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">count</a>) {
                    self.index += <span class="tok-number">1</span>;
                    <span class="tok-kw">return</span> <a href="std.enums.EnumArray.Entry.html">Entry</a>{
                        .key = <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(index),
                        .value = &amp;self.values[index],
                    };
                }
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }
        };
    };
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;pure EnumSet fns&quot;</span> {
    <span class="tok-kw">const</span> Suit = <span class="tok-kw">enum</span> { spades, hearts, clubs, diamonds };

    <span class="tok-kw">const</span> empty = <a href="std.enums.html#std.enums.EnumSet">EnumSet</a>(Suit).initEmpty();
    <span class="tok-kw">const</span> full = <a href="std.enums.html#std.enums.EnumSet">EnumSet</a>(Suit).initFull();
    <span class="tok-kw">const</span> black = <a href="std.enums.html#std.enums.EnumSet">EnumSet</a>(Suit).initMany(&amp;[_]Suit{ .spades, .clubs });
    <span class="tok-kw">const</span> red = <a href="std.enums.html#std.enums.EnumSet">EnumSet</a>(Suit).initMany(&amp;[_]Suit{ .hearts, .diamonds });

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!empty.eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!full.eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!empty.eql(black));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!full.eql(red));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!red.eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!black.eql(full));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.subsetOf(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.subsetOf(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.subsetOf(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!black.subsetOf(red));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!red.subsetOf(black));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.supersetOf(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.supersetOf(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.supersetOf(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!black.supersetOf(red));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!red.supersetOf(black));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.complement().eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.complement().eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(black.complement().eql(red));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(red.complement().eql(black));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.unionWith(empty).eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.unionWith(full).eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.unionWith(full).eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.unionWith(empty).eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(black.unionWith(red).eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(red.unionWith(black).eql(full));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.intersectWith(empty).eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.intersectWith(full).eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.intersectWith(full).eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.intersectWith(empty).eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(black.intersectWith(red).eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(red.intersectWith(black).eql(empty));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.xorWith(empty).eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.xorWith(full).eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.xorWith(full).eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.xorWith(empty).eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(black.xorWith(red).eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(red.xorWith(black).eql(full));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.differenceWith(empty).eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.differenceWith(full).eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.differenceWith(full).eql(empty));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.differenceWith(empty).eql(full));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.differenceWith(red).eql(black));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(full.differenceWith(black).eql(red));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;EnumSet empty&quot;</span> {
    <span class="tok-kw">const</span> E = <span class="tok-kw">enum</span> {};
    <span class="tok-kw">const</span> empty = <a href="std.enums.html#std.enums.EnumSet">EnumSet</a>(E).initEmpty();
    <span class="tok-kw">const</span> full = <a href="std.enums.html#std.enums.EnumSet">EnumSet</a>(E).initFull();

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.eql(full));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.complement().eql(full));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.complement().eql(full.complement()));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(empty.eql(full.complement()));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;EnumSet const iterator&quot;</span> {
    <span class="tok-kw">const</span> Direction = <span class="tok-kw">enum</span> { up, down, left, right };
    <span class="tok-kw">const</span> diag_move = init: {
        <span class="tok-kw">var</span> move = <a href="std.enums.html#std.enums.EnumSet">EnumSet</a>(Direction).initEmpty();
        move.insert(.right);
        move.insert(.up);
        <span class="tok-kw">break</span> :init move;
    };

    <span class="tok-kw">var</span> result = <a href="std.enums.html#std.enums.EnumSet">EnumSet</a>(Direction).initEmpty();
    <span class="tok-kw">var</span> it = diag_move.iterator();
    <span class="tok-kw">while</span> (it.next()) |dir| {
        result.insert(dir);
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(result.eql(diag_move));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;EnumSet non-exhaustive&quot;</span> {
    <span class="tok-kw">const</span> BitIndices = <span class="tok-kw">enum</span>(<span class="tok-type">u4</span>) {
        a = <span class="tok-number">0</span>,
        b = <span class="tok-number">1</span>,
        c = <span class="tok-number">4</span>,
        _,
    };
    <span class="tok-kw">const</span> BitField = <a href="std.enums.html#std.enums.EnumSet">EnumSet</a>(BitIndices);

    <span class="tok-kw">var</span> flags = BitField.init(.{ .a = <span class="tok-null">true</span>, .b = <span class="tok-null">true</span> });
    flags.insert(.c);
    flags.remove(.a);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!flags.contains(.a));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(flags.contains(.b));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(flags.contains(.c));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">EnumIndexer</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>) <span class="tok-type">type</span> {<span class="tok-comment">
    // Assumes that the enum fields are sorted in ascending order (optimistic).
    // Unsorted enums may require the user to manually increase the quota.
    </span><span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">3</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len + <a href="std.enums.html#std.enums.eval_branch_quota_cushion">eval_branch_quota_cushion</a>);

    <span class="tok-kw">if</span> (!<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.is_exhaustive) {
        <span class="tok-kw">const</span> BackingInt = <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.tag_type;
        <span class="tok-kw">if</span> (<span class="tok-builtin">@bitSizeOf</span>(BackingInt) &gt; <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>))
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot create an enum indexer for a given non-exhaustive enum, tag_type is larger than usize.&quot;</span>);

        <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key: <span class="tok-type">type</span> = E;

            <span class="tok-kw">const</span> backing_int_sign = <span class="tok-builtin">@typeInfo</span>(BackingInt).int.signedness;
            <span class="tok-kw">const</span> min_value = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.minInt">minInt</a>(BackingInt);
            <span class="tok-kw">const</span> max_value = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(BackingInt);

            <span class="tok-kw">const</span> RangeType = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(BackingInt));
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> count: <span class="tok-type">comptime_int</span> = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.enums.html#std.enums.EnumIndexer.RangeType">RangeType</a>) + <span class="tok-number">1</span>;

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(e: E) <span class="tok-type">usize</span> {
                <span class="tok-kw">if</span> (<a href="std.enums.html#std.enums.EnumIndexer.backing_int_sign">backing_int_sign</a> == .unsigned)
                    <span class="tok-kw">return</span> <span class="tok-builtin">@intFromEnum</span>(e);

                <span class="tok-kw">return</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(e) &lt; <span class="tok-number">0</span>)
                    <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(e) - <a href="std.enums.html#std.enums.EnumIndexer.min_value">min_value</a>)
                <span class="tok-kw">else</span>
                    <span class="tok-builtin">@as</span>(<a href="std.enums.html#std.enums.EnumIndexer.RangeType">RangeType</a>, -<a href="std.enums.html#std.enums.EnumIndexer.min_value">min_value</a>) + <span class="tok-builtin">@as</span>(<a href="std.enums.html#std.enums.EnumIndexer.RangeType">RangeType</a>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(e)));
            }
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyForIndex</span>(i: <span class="tok-type">usize</span>) E {
                <span class="tok-kw">if</span> (<a href="std.enums.html#std.enums.EnumIndexer.backing_int_sign">backing_int_sign</a> == .unsigned)
                    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(i);

                <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@as</span>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.signed, <span class="tok-builtin">@bitSizeOf</span>(<a href="std.enums.html#std.enums.EnumIndexer.RangeType">RangeType</a>) + <span class="tok-number">1</span>), <span class="tok-builtin">@intCast</span>(i)) + <a href="std.enums.html#std.enums.EnumIndexer.min_value">min_value</a>);
            }
        };
    }

    <span class="tok-kw">const</span> const_fields = <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields;
    <span class="tok-kw">var</span> fields = const_fields[<span class="tok-number">0</span>..const_fields.len].*;
    <span class="tok-kw">const</span> fields_len = fields.len;

    <span class="tok-kw">if</span> (fields_len == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = E;
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> count: <span class="tok-type">comptime_int</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(e: E) <span class="tok-type">usize</span> {
                _ = e;
                <span class="tok-kw">unreachable</span>;
            }
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyForIndex</span>(i: <span class="tok-type">usize</span>) E {
                _ = i;
                <span class="tok-kw">unreachable</span>;
            }
        };
    }

    <span class="tok-kw">const</span> min = fields[<span class="tok-number">0</span>].value;
    <span class="tok-kw">const</span> max = fields[fields.len - <span class="tok-number">1</span>].value;

    <span class="tok-kw">const</span> SortContext = <span class="tok-kw">struct</span> {
        fields: []<a href="std.builtin.Type.EnumField.html">EnumField</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(<span class="tok-kw">comptime</span> ctx: <span class="tok-builtin">@This</span>(), <span class="tok-kw">comptime</span> a: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> b: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> ctx.fields[a].value &lt; ctx.fields[b].value;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(<span class="tok-kw">comptime</span> ctx: <span class="tok-builtin">@This</span>(), <span class="tok-kw">comptime</span> a: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> b: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(<a href="std.builtin.Type.EnumField.html">EnumField</a>, &amp;ctx.fields[a], &amp;ctx.fields[b]);
        }
    };
    <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.html#std.sort.insertionContext">insertionContext</a>(<span class="tok-number">0</span>, fields_len, SortContext{ .fields = &amp;fields });

    <span class="tok-kw">if</span> (max - min == fields.len - <span class="tok-number">1</span>) {
        <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = E;
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> count: <span class="tok-type">comptime_int</span> = fields_len;
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(e: E) <span class="tok-type">usize</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(e) - min));
            }
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyForIndex</span>(i: <span class="tok-type">usize</span>) E {<span class="tok-comment">
                // TODO fix addition semantics.  This calculation
                // gives up some safety to avoid artificially limiting
                // the range of signed enum values to max_isize.
                </span><span class="tok-kw">const</span> enum_value = <span class="tok-kw">if</span> (min &lt; <span class="tok-number">0</span>) <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@bitCast</span>(i)) +% min <span class="tok-kw">else</span> i + min;
                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(E, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@as</span>(<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.tag_type, <span class="tok-builtin">@intCast</span>(enum_value))));
            }
        };
    }

    <span class="tok-kw">const</span> keys = <a href="std.enums.html#std.enums.valuesFromFields">valuesFromFields</a>(E, &amp;fields);

    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = E;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> count: <span class="tok-type">comptime_int</span> = fields_len;
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(e: E) <span class="tok-type">usize</span> {
            <span class="tok-kw">for</span> (keys, <span class="tok-number">0</span>..) |k, i| {
                <span class="tok-kw">if</span> (k == e) <span class="tok-kw">return</span> i;
            }
            <span class="tok-kw">unreachable</span>;
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyForIndex</span>(i: <span class="tok-type">usize</span>) E {
            <span class="tok-kw">return</span> keys[i];
        }
    };
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;EnumIndexer non-exhaustive&quot;</span> {
    <span class="tok-kw">const</span> backing_ints = [_]<span class="tok-type">type</span>{
        <span class="tok-type">i1</span>,
        <span class="tok-type">i2</span>,
        <span class="tok-type">i3</span>,
        <span class="tok-type">i4</span>,
        <span class="tok-type">i8</span>,
        <span class="tok-type">i16</span>,
        <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.signed, <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">isize</span>) - <span class="tok-number">1</span>),
        <span class="tok-type">isize</span>,
        <span class="tok-type">u1</span>,
        <span class="tok-type">u2</span>,
        <span class="tok-type">u3</span>,
        <span class="tok-type">u4</span>,
        <span class="tok-type">u16</span>,
        <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>) - <span class="tok-number">1</span>),
        <span class="tok-type">usize</span>,
    };
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (backing_ints) |BackingInt| {
        <span class="tok-kw">const</span> E = <span class="tok-kw">enum</span>(BackingInt) {
            number_zero_tag = <span class="tok-number">0</span>,
            _,
        };
        <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E);

        <span class="tok-kw">const</span> min_tag: E = <span class="tok-builtin">@enumFromInt</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.minInt">minInt</a>(BackingInt));
        <span class="tok-kw">const</span> max_tag: E = <span class="tok-builtin">@enumFromInt</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(BackingInt));

        <span class="tok-kw">const</span> RangedType = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(BackingInt));
        <span class="tok-kw">const</span> max_index: <span class="tok-type">comptime_int</span> = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(RangedType);
        <span class="tok-kw">const</span> number_zero_tag_index: <span class="tok-type">usize</span> = <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(BackingInt).int.signedness) {
            .unsigned =&gt; <span class="tok-number">0</span>,
            .signed =&gt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">comptime_int</span>, max_index, <span class="tok-number">2</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>,
        };

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E, Indexer.Key);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(max_index + <span class="tok-number">1</span>, Indexer.count);

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), Indexer.indexOf(min_tag));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(number_zero_tag_index, Indexer.indexOf(E.number_zero_tag));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, max_index), Indexer.indexOf(max_tag));

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(min_tag, Indexer.keyForIndex(<span class="tok-number">0</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E.number_zero_tag, Indexer.keyForIndex(number_zero_tag_index));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(max_tag, Indexer.keyForIndex(max_index));
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;EnumIndexer dense zeroed&quot;</span> {
    <span class="tok-kw">const</span> E = <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) { b = <span class="tok-number">1</span>, a = <span class="tok-number">0</span>, c = <span class="tok-number">2</span> };
    <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E, Indexer.Key);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">3</span>, Indexer.count);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), Indexer.indexOf(.a));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>), Indexer.indexOf(.b));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">2</span>), Indexer.indexOf(.c));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E.a, Indexer.keyForIndex(<span class="tok-number">0</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E.b, Indexer.keyForIndex(<span class="tok-number">1</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E.c, Indexer.keyForIndex(<span class="tok-number">2</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;EnumIndexer dense positive&quot;</span> {
    <span class="tok-kw">const</span> E = <span class="tok-kw">enum</span>(<span class="tok-type">u4</span>) { c = <span class="tok-number">6</span>, a = <span class="tok-number">4</span>, b = <span class="tok-number">5</span> };
    <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E, Indexer.Key);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">3</span>, Indexer.count);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), Indexer.indexOf(.a));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>), Indexer.indexOf(.b));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">2</span>), Indexer.indexOf(.c));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E.a, Indexer.keyForIndex(<span class="tok-number">0</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E.b, Indexer.keyForIndex(<span class="tok-number">1</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E.c, Indexer.keyForIndex(<span class="tok-number">2</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;EnumIndexer dense negative&quot;</span> {
    <span class="tok-kw">const</span> E = <span class="tok-kw">enum</span>(<span class="tok-type">i4</span>) { a = -<span class="tok-number">6</span>, c = -<span class="tok-number">4</span>, b = -<span class="tok-number">5</span> };
    <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E, Indexer.Key);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">3</span>, Indexer.count);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), Indexer.indexOf(.a));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>), Indexer.indexOf(.b));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">2</span>), Indexer.indexOf(.c));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E.a, Indexer.keyForIndex(<span class="tok-number">0</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E.b, Indexer.keyForIndex(<span class="tok-number">1</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E.c, Indexer.keyForIndex(<span class="tok-number">2</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;EnumIndexer sparse&quot;</span> {
    <span class="tok-kw">const</span> E = <span class="tok-kw">enum</span>(<span class="tok-type">i4</span>) { a = -<span class="tok-number">2</span>, c = <span class="tok-number">6</span>, b = <span class="tok-number">4</span> };
    <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E, Indexer.Key);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">3</span>, Indexer.count);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), Indexer.indexOf(.a));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>), Indexer.indexOf(.b));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">2</span>), Indexer.indexOf(.c));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E.a, Indexer.keyForIndex(<span class="tok-number">0</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E.b, Indexer.keyForIndex(<span class="tok-number">1</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E.c, Indexer.keyForIndex(<span class="tok-number">2</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;EnumIndexer empty&quot;</span> {
    <span class="tok-kw">const</span> E = <span class="tok-kw">enum</span> {};
    <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(E, Indexer.Key);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, Indexer.count);
}

<span class="tok-kw">test</span> values {
    <span class="tok-kw">const</span> E = <span class="tok-kw">enum</span> {
        X,
        Y,
        Z,
        <span class="tok-kw">const</span> A = <span class="tok-number">1</span>;
    };
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(E, &amp;.{ .X, .Y, .Z }, <a href="std.enums.html#std.enums.values">values</a>(E));
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
