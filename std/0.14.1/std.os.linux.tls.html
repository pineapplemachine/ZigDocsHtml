<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">os</a></li><li><a href="std.os.html" class="">linux</a></li><li><a href="std.os.linux.tls.html" class="active">tls</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.os.linux.tls" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.os.linux.tls</span><a href="#src.zig-std.os.linux.tls">[src]</a></h1><div class="tldDocs"><p>This file implements the two TLS variants [1] used by ELF-based systems. Note that, in reality,
Variant I has two sub-variants.</p>
<p>It is important to understand that the term TCB (Thread Control Block) is overloaded here.
Official ABI documentation uses it simply to mean the ABI TCB, i.e. a small area of ABI-defined
data, usually one or two words (see the <code><a href="std.os.linux.tls.html#std.os.linux.tls.AbiTcb">AbiTcb</a></code> type below). People will also often use TCB to
refer to the libc TCB, which can be any size and contain anything. (One could even omit it!) We
refer to the latter as the Zig TCB; see the <code><a href="std.os.linux.tls.ZigTcb.html">ZigTcb</a></code> type below.</p>
<p>[1] <a href="https://www.akkadia.org/drepper/tls.pdf">https://www.akkadia.org/drepper/tls.pdf</a></p>
</div><div class="sectGlobalVars"><h2 class="sectionHeader">Global Variables</h2><div class="listGlobalVars"><div class="decl"><h2 id="std.os.linux.tls.area_desc" class="declHeader"><span class="declHeaderCategory">Global Variable</span><span class="declHeaderIdentifier">area_desc</span><a href="#src.zig-std.os.linux.tls.area_desc">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.tls.area_desc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">var</span> area_desc: <a href="std.os.linux.tls.AreaDesc.html">AreaDesc</a> = <span class="tok-null">undefined</span></code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.os.linux.tls.setThreadPointer" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setThreadPointer</span><a href="#src.zig-std.os.linux.tls.setThreadPointer">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setThreadPointer</span>(addr: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>addr: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.tls.setThreadPointer">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setThreadPointer</span>(addr: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<span class="tok-null">false</span>);
    <span class="tok-builtin">@disableInstrumentation</span>();

    <span class="tok-kw">switch</span> (<a href="std.os.linux.tls.html#std.os.linux.tls.native_arch">native_arch</a>) {
        .x86 =&gt; {
            <span class="tok-kw">var</span> user_desc: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.user_desc">user_desc</a> = .{
                .entry_number = <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">gdt_entry_number</a>,
                .base_addr = addr,
                .limit = <span class="tok-number">0xfffff</span>,
                .flags = .{
                    .seg_32bit = <span class="tok-number">1</span>,
                    .contents = <span class="tok-number">0</span>,<span class="tok-comment"> // Data
                    </span>.read_exec_only = <span class="tok-number">0</span>,
                    .limit_in_pages = <span class="tok-number">1</span>,
                    .seg_not_present = <span class="tok-number">0</span>,
                    .useable = <span class="tok-number">1</span>,
                },
            };
            <span class="tok-kw">const</span> rc = <span class="tok-builtin">@call</span>(.always_inline, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.syscall1">syscall1</a>, .{ .set_thread_area, <span class="tok-builtin">@intFromPtr</span>(&amp;user_desc) });
            <a href="std.debug.html#std.debug.assert">assert</a>(rc == <span class="tok-number">0</span>);

            <span class="tok-kw">const</span> gdt_entry_number = user_desc.entry_number;<span class="tok-comment">
            // We have to keep track of our slot as it's also needed for clone()
            </span><a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">gdt_entry_number</a> = gdt_entry_number;<span class="tok-comment">
            // Update the %gs selector
            </span><span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">&quot;movl %[gs_val], %%gs&quot;</span>
                :
                : [gs_val] <span class="tok-str">&quot;r&quot;</span> (gdt_entry_number &lt;&lt; <span class="tok-number">3</span> | <span class="tok-number">3</span>),
            );
        },
        .x86_64 =&gt; {
            <span class="tok-kw">const</span> rc = <span class="tok-builtin">@call</span>(.always_inline, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.syscall2">syscall2</a>, .{ .arch_prctl, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.ARCH">ARCH</a>.<a href="#">SET_FS</a>, addr });
            <a href="std.debug.html#std.debug.assert">assert</a>(rc == <span class="tok-number">0</span>);
        },
        .aarch64, .aarch64_be =&gt; {
            <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (
                <span class="tok-str">\\ msr tpidr_el0, %[addr]</span>
                :
                : [addr] <span class="tok-str">&quot;r&quot;</span> (addr),
            );
        },
        .arc =&gt; {<span class="tok-comment">
            // We apparently need to both set r25 (TP) *and* inform the kernel...
            </span><span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (
                <span class="tok-str">\\ mov r25, %[addr]</span>
                :
                : [addr] <span class="tok-str">&quot;r&quot;</span> (addr),
            );
            <span class="tok-kw">const</span> rc = <span class="tok-builtin">@call</span>(.always_inline, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.syscall1">syscall1</a>, .{ .arc_settls, addr });
            <a href="std.debug.html#std.debug.assert">assert</a>(rc == <span class="tok-number">0</span>);
        },
        .arm, .armeb, .thumb, .thumbeb =&gt; {
            <span class="tok-kw">const</span> rc = <span class="tok-builtin">@call</span>(.always_inline, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.syscall1">syscall1</a>, .{ .set_tls, addr });
            <a href="std.debug.html#std.debug.assert">assert</a>(rc == <span class="tok-number">0</span>);
        },
        .m68k =&gt; {
            <span class="tok-kw">const</span> rc = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.syscall1">syscall1</a>(.set_thread_area, addr);
            <a href="std.debug.html#std.debug.assert">assert</a>(rc == <span class="tok-number">0</span>);
        },
        .hexagon =&gt; {
            <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (
                <span class="tok-str">\\ ugp = %[addr]</span>
                :
                : [addr] <span class="tok-str">&quot;r&quot;</span> (addr),
            );
        },
        .loongarch32, .loongarch64 =&gt; {
            <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (
                <span class="tok-str">\\ move $tp, %[addr]</span>
                :
                : [addr] <span class="tok-str">&quot;r&quot;</span> (addr),
            );
        },
        .riscv32, .riscv64 =&gt; {
            <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (
                <span class="tok-str">\\ mv tp, %[addr]</span>
                :
                : [addr] <span class="tok-str">&quot;r&quot;</span> (addr),
            );
        },
        .csky, .mips, .mipsel, .mips64, .mips64el =&gt; {
            <span class="tok-kw">const</span> rc = <span class="tok-builtin">@call</span>(.always_inline, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.syscall1">syscall1</a>, .{ .set_thread_area, addr });
            <a href="std.debug.html#std.debug.assert">assert</a>(rc == <span class="tok-number">0</span>);
        },
        .powerpc, .powerpcle =&gt; {
            <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (
                <span class="tok-str">\\ mr 2, %[addr]</span>
                :
                : [addr] <span class="tok-str">&quot;r&quot;</span> (addr),
            );
        },
        .powerpc64, .powerpc64le =&gt; {
            <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (
                <span class="tok-str">\\ mr 13, %[addr]</span>
                :
                : [addr] <span class="tok-str">&quot;r&quot;</span> (addr),
            );
        },
        .s390x =&gt; {
            <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (
                <span class="tok-str">\\ lgr %%r0, %[addr]</span>
                <span class="tok-str">\\ sar %%a1, %%r0</span>
                <span class="tok-str">\\ srlg %%r0, %%r0, 32</span>
                <span class="tok-str">\\ sar %%a0, %%r0</span>
                :
                : [addr] <span class="tok-str">&quot;r&quot;</span> (addr),
                : <span class="tok-str">&quot;r0&quot;</span>
            );
        },
        .sparc, .sparc64 =&gt; {
            <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (
                <span class="tok-str">\\ mov %[addr], %%g7</span>
                :
                : [addr] <span class="tok-str">&quot;r&quot;</span> (addr),
            );
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported architecture&quot;</span>),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.tls.prepareArea" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">prepareArea</span><a href="#src.zig-std.os.linux.tls.prepareArea">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prepareArea</span>(area: []<span class="tok-type">u8</span>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Initializes all the fields of the static TLS area and returns the computed architecture-specific
value of the TP register.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>area: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.tls.prepareArea">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prepareArea</span>(area: []<span class="tok-type">u8</span>) <span class="tok-type">usize</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<span class="tok-null">false</span>);
    <span class="tok-builtin">@disableInstrumentation</span>();<span class="tok-comment">

    // Clear the area we're going to use, just to be safe.
    </span><span class="tok-builtin">@memset</span>(area, <span class="tok-number">0</span>);<span class="tok-comment">

    // Prepare the ABI TCB.
    </span><span class="tok-kw">const</span> abi_tcb = <a href="std.os.linux.tls.html#std.os.linux.tls.alignPtrCast">alignPtrCast</a>(<a href="std.os.linux.tls.html#std.os.linux.tls.AbiTcb">AbiTcb</a>, area.ptr + <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">abi_tcb</a>.<a href="#">offset</a>);
    <span class="tok-kw">switch</span> (<a href="std.os.linux.tls.html#std.os.linux.tls.current_variant">current_variant</a>) {
        .I_original, .I_modified =&gt; abi_tcb.dtv = <span class="tok-builtin">@intFromPtr</span>(area.ptr + <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">dtv</a>.<a href="#">offset</a>),
        .II =&gt; abi_tcb.self = abi_tcb,
    }<span class="tok-comment">

    // Prepare the DTV.
    </span><span class="tok-kw">const</span> dtv = <a href="std.os.linux.tls.html#std.os.linux.tls.alignPtrCast">alignPtrCast</a>(<a href="std.os.linux.tls.Dtv.html">Dtv</a>, area.ptr + <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">dtv</a>.<a href="#">offset</a>);
    dtv.len = <span class="tok-number">1</span>;
    dtv.tls_block = area.ptr + <a href="std.os.linux.tls.html#std.os.linux.tls.current_dtv_offset">current_dtv_offset</a> + <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">block</a>.<a href="#">offset</a>;<span class="tok-comment">

    // Copy the initial data.
    </span><span class="tok-builtin">@memcpy</span>(area[<a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">block</a>.<a href="#">offset</a>..][<span class="tok-number">0</span>..<a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">block</a>.<a href="#">init</a>.<a href="#">len</a>], <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">block</a>.<a href="#">init</a>);<span class="tok-comment">

    // Return the corrected value (if needed) for the TP register. Overflow here is not a problem;
    // the pointer arithmetic involving the TP is done with wrapping semantics.
    </span><span class="tok-kw">return</span> <span class="tok-builtin">@intFromPtr</span>(area.ptr) +% <span class="tok-kw">switch</span> (<a href="std.os.linux.tls.html#std.os.linux.tls.current_variant">current_variant</a>) {
        .I_original, .II =&gt; <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">abi_tcb</a>.<a href="#">offset</a>,
        .I_modified =&gt; <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">block</a>.<a href="#">offset</a> +% <a href="std.os.linux.tls.html#std.os.linux.tls.current_tp_offset">current_tp_offset</a>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.tls.initStatic" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initStatic</span><a href="#src.zig-std.os.linux.tls.initStatic">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initStatic</span>(phdrs: []<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.Phdr">Phdr</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Computes the layout of the static TLS area, allocates the area, initializes all of its fields,
and assigns the architecture-specific value to the TP register.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>phdrs: []<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.Phdr">Phdr</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.tls.initStatic">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initStatic</span>(phdrs: []<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.Phdr">Phdr</a>) <span class="tok-type">void</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<span class="tok-null">false</span>);
    <span class="tok-builtin">@disableInstrumentation</span>();

    <a href="std.os.linux.tls.html#std.os.linux.tls.computeAreaDesc">computeAreaDesc</a>(phdrs);

    <span class="tok-kw">const</span> area = blk: {<span class="tok-comment">
        // Fast path for the common case where the TLS data is really small, avoid an allocation and
        // use our local buffer.
        </span><span class="tok-kw">if</span> (<a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">alignment</a> &lt;= <a href="std.heap.html#std.heap.page_size_min">page_size_min</a> <span class="tok-kw">and</span> <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">size</a> &lt;= <a href="std.os.linux.tls.html#std.os.linux.tls.main_thread_area_buffer">main_thread_area_buffer</a>.<a href="#">len</a>) {
            <span class="tok-kw">break</span> :blk <a href="std.os.linux.tls.html#std.os.linux.tls.main_thread_area_buffer">main_thread_area_buffer</a>[<span class="tok-number">0</span>..<a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">size</a>];
        }

        <span class="tok-kw">const</span> begin_addr = <a href="std.os.linux.tls.html#std.os.linux.tls.mmap">mmap</a>(
            <span class="tok-null">null</span>,
            <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">size</a> + <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">alignment</a> - <span class="tok-number">1</span>,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PROT">PROT</a>.<a href="#">READ</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PROT">PROT</a>.<a href="#">WRITE</a>,
            .{ .TYPE = .PRIVATE, .ANONYMOUS = <span class="tok-null">true</span> },
            -<span class="tok-number">1</span>,
            <span class="tok-number">0</span>,
        );
        <span class="tok-kw">if</span> (<span class="tok-builtin">@call</span>(.always_inline, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>, .{begin_addr}) != .SUCCESS) <span class="tok-builtin">@trap</span>();

        <span class="tok-kw">const</span> area_ptr: [*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span> = <span class="tok-builtin">@ptrFromInt</span>(begin_addr);<span class="tok-comment">

        // Make sure the slice is correctly aligned.
        </span><span class="tok-kw">const</span> begin_aligned_addr = <a href="std.os.linux.tls.html#std.os.linux.tls.alignForward">alignForward</a>(begin_addr, <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">alignment</a>);
        <span class="tok-kw">const</span> start = begin_aligned_addr - begin_addr;
        <span class="tok-kw">break</span> :blk area_ptr[start..][<span class="tok-number">0</span>..<a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">size</a>];
    };

    <span class="tok-kw">const</span> tp_value = <a href="std.os.linux.tls.html#std.os.linux.tls.prepareArea">prepareArea</a>(area);
    <a href="std.os.linux.tls.html#std.os.linux.tls.setThreadPointer">setThreadPointer</a>(tp_value);
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.os.linux.tls">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! This file implements the two TLS variants [1] used by ELF-based systems. Note that, in reality,</span>
<span class="tok-comment">//! Variant I has two sub-variants.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! It is important to understand that the term TCB (Thread Control Block) is overloaded here.</span>
<span class="tok-comment">//! Official ABI documentation uses it simply to mean the ABI TCB, i.e. a small area of ABI-defined</span>
<span class="tok-comment">//! data, usually one or two words (see the `AbiTcb` type below). People will also often use TCB to</span>
<span class="tok-comment">//! refer to the libc TCB, which can be any size and contain anything. (One could even omit it!) We</span>
<span class="tok-comment">//! refer to the latter as the Zig TCB; see the `ZigTcb` type below.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! [1] https://www.akkadia.org/drepper/tls.pdf</span>

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> elf = <a href="std.html">std</a>.<a href="std.elf.html">elf</a>;
<span class="tok-kw">const</span> math = <a href="std.html">std</a>.<a href="std.math.html">math</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> native_arch = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).cpu.arch;
<span class="tok-kw">const</span> linux = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>;
<span class="tok-kw">const</span> posix = <a href="std.html">std</a>.<a href="std.posix.html">posix</a>;
<span class="tok-kw">const</span> page_size_min = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>;

<span class="tok-comment">/// Represents an ELF TLS variant.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// In all variants, the TP and the TLS blocks must be aligned to the `p_align` value in the</span>
<span class="tok-comment">/// `PT_TLS` ELF program header. Everything else has natural alignment.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The location of the DTV does not actually matter. For simplicity, we put it in the TLS area, but</span>
<span class="tok-comment">/// there is no actual ABI requirement that it reside there.</span>
<span class="tok-kw">const</span> Variant = <span class="tok-kw">enum</span> {
    <span class="tok-comment">/// The original Variant I:</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// ----------------------------------------</span>
    <span class="tok-comment">/// | DTV | Zig TCB | ABI TCB | TLS Blocks |</span>
    <span class="tok-comment">/// ----------------^-----------------------</span>
    <span class="tok-comment">///                 `-- The TP register points here.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The layout in this variant necessitates separate alignment of both the TP and the TLS</span>
    <span class="tok-comment">/// blocks.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The first word in the ABI TCB points to the DTV. For some architectures, there may be a</span>
    <span class="tok-comment">/// second word with an unspecified meaning.</span>
    I_original,
    <span class="tok-comment">/// The modified Variant I:</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// ---------------------------------------------------</span>
    <span class="tok-comment">/// | DTV | Zig TCB | ABI TCB | [Offset] | TLS Blocks |</span>
    <span class="tok-comment">/// -------------------------------------^-------------</span>
    <span class="tok-comment">///                                      `-- The TP register points here.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The offset (which can be zero) is applied to the TP only; there is never physical gap</span>
    <span class="tok-comment">/// between the ABI TCB and the TLS blocks. This implies that we only need to align the TP.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The first (and only) word in the ABI TCB points to the DTV.</span>
    I_modified,
    <span class="tok-comment">/// Variant II:</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// ----------------------------------------</span>
    <span class="tok-comment">/// | TLS Blocks | ABI TCB | Zig TCB | DTV |</span>
    <span class="tok-comment">/// -------------^--------------------------</span>
    <span class="tok-comment">///              `-- The TP register points here.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The first (and only) word in the ABI TCB points to the ABI TCB itself.</span>
    II,
};

<span class="tok-kw">const</span> current_variant: <a href="std.os.linux.tls.Variant.html">Variant</a> = <span class="tok-kw">switch</span> (<a href="std.os.linux.tls.html#std.os.linux.tls.native_arch">native_arch</a>) {
    .arc,
    .arm,
    .armeb,
    .aarch64,
    .aarch64_be,
    .csky,
    .thumb,
    .thumbeb,
    =&gt; .I_original,
    .loongarch32,
    .loongarch64,
    .m68k,
    .mips,
    .mipsel,
    .mips64,
    .mips64el,
    .powerpc,
    .powerpcle,
    .powerpc64,
    .powerpc64le,
    .riscv32,
    .riscv64,
    =&gt; .I_modified,
    .hexagon,
    .s390x,
    .sparc,
    .sparc64,
    .x86,
    .x86_64,
    =&gt; .II,
    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;undefined TLS variant for this architecture&quot;</span>),
};

<span class="tok-comment">/// The Offset value for the modified Variant I.</span>
<span class="tok-kw">const</span> current_tp_offset = <span class="tok-kw">switch</span> (<a href="std.os.linux.tls.html#std.os.linux.tls.native_arch">native_arch</a>) {
    .m68k,
    .mips,
    .mipsel,
    .mips64,
    .mips64el,
    .powerpc,
    .powerpcle,
    .powerpc64,
    .powerpc64le,
    =&gt; <span class="tok-number">0x7000</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-number">0</span>,
};

<span class="tok-comment">/// Usually only used by the modified Variant I.</span>
<span class="tok-kw">const</span> current_dtv_offset = <span class="tok-kw">switch</span> (<a href="std.os.linux.tls.html#std.os.linux.tls.native_arch">native_arch</a>) {
    .m68k,
    .mips,
    .mipsel,
    .mips64,
    .mips64el,
    .powerpc,
    .powerpcle,
    .powerpc64,
    .powerpc64le,
    =&gt; <span class="tok-number">0x8000</span>,
    .riscv32,
    .riscv64,
    =&gt; <span class="tok-number">0x800</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-number">0</span>,
};

<span class="tok-comment">/// Per-thread storage for the ELF TLS ABI.</span>
<span class="tok-kw">const</span> AbiTcb = <span class="tok-kw">switch</span> (<a href="std.os.linux.tls.html#std.os.linux.tls.current_variant">current_variant</a>) {
    .I_original, .I_modified =&gt; <span class="tok-kw">switch</span> (<a href="std.os.linux.tls.html#std.os.linux.tls.native_arch">native_arch</a>) {<span class="tok-comment">
        // ARM EABI mandates enough space for two pointers: the first one points to the DTV as
        // usual, while the second one is unspecified.
        </span>.aarch64,
        .aarch64_be,
        .arm,
        .armeb,
        .thumb,
        .thumbeb,
        =&gt; <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// This is offset by `current_dtv_offset`.</span>
            dtv: <span class="tok-type">usize</span>,
            reserved: ?*<span class="tok-type">anyopaque</span>,
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// This is offset by `current_dtv_offset`.</span>
            dtv: <span class="tok-type">usize</span>,
        },
    },
    .II =&gt; <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// This is self-referential.</span>
        self: *<a href="std.os.linux.tls.html#std.os.linux.tls.AbiTcb">AbiTcb</a>,
    },
};

<span class="tok-comment">/// Per-thread storage for Zig's use. Currently unused.</span>
<span class="tok-kw">const</span> ZigTcb = <span class="tok-kw">struct</span> {
    dummy: <span class="tok-type">usize</span>,
};

<span class="tok-comment">/// Dynamic Thread Vector as specified in the ELF TLS ABI. Ordinarily, there is a block pointer per</span>
<span class="tok-comment">/// dynamically-loaded module, but since we only support static TLS, we only need one block pointer.</span>
<span class="tok-kw">const</span> Dtv = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
    len: <span class="tok-type">usize</span> = <span class="tok-number">1</span>,
    tls_block: [*]<span class="tok-type">u8</span>,
};

<span class="tok-comment">/// Describes a process's TLS area. The area encompasses the DTV, both TCBs, and the TLS block, with</span>
<span class="tok-comment">/// the exact layout of these being dependent primarily on `current_variant`.</span>
<span class="tok-kw">const</span> AreaDesc = <span class="tok-kw">struct</span> {
    size: <span class="tok-type">usize</span>,
    alignment: <span class="tok-type">usize</span>,

    dtv: <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// Offset into the TLS area.</span>
        offset: <span class="tok-type">usize</span>,
    },

    abi_tcb: <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// Offset into the TLS area.</span>
        offset: <span class="tok-type">usize</span>,
    },

    block: <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// The initial data to be copied into the TLS block. Note that this may be smaller than</span>
        <span class="tok-comment">/// `size`, in which case any remaining data in the TLS block is simply left uninitialized.</span>
        init: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        <span class="tok-comment">/// Offset into the TLS area.</span>
        offset: <span class="tok-type">usize</span>,
        <span class="tok-comment">/// This is the effective size of the TLS block, which may be greater than `init.len`.</span>
        size: <span class="tok-type">usize</span>,
    },

    <span class="tok-comment">/// Only used on the 32-bit x86 architecture (not x86_64, nor x32).</span>
    gdt_entry_number: <span class="tok-type">usize</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">var</span> area_desc: <a href="std.os.linux.tls.AreaDesc.html">AreaDesc</a> = <span class="tok-null">undefined</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setThreadPointer</span>(addr: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<span class="tok-null">false</span>);
    <span class="tok-builtin">@disableInstrumentation</span>();

    <span class="tok-kw">switch</span> (<a href="std.os.linux.tls.html#std.os.linux.tls.native_arch">native_arch</a>) {
        .x86 =&gt; {
            <span class="tok-kw">var</span> user_desc: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.user_desc">user_desc</a> = .{
                .entry_number = <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">gdt_entry_number</a>,
                .base_addr = addr,
                .limit = <span class="tok-number">0xfffff</span>,
                .flags = .{
                    .seg_32bit = <span class="tok-number">1</span>,
                    .contents = <span class="tok-number">0</span>,<span class="tok-comment"> // Data
                    </span>.read_exec_only = <span class="tok-number">0</span>,
                    .limit_in_pages = <span class="tok-number">1</span>,
                    .seg_not_present = <span class="tok-number">0</span>,
                    .useable = <span class="tok-number">1</span>,
                },
            };
            <span class="tok-kw">const</span> rc = <span class="tok-builtin">@call</span>(.always_inline, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.syscall1">syscall1</a>, .{ .set_thread_area, <span class="tok-builtin">@intFromPtr</span>(&amp;user_desc) });
            <a href="std.debug.html#std.debug.assert">assert</a>(rc == <span class="tok-number">0</span>);

            <span class="tok-kw">const</span> gdt_entry_number = user_desc.entry_number;<span class="tok-comment">
            // We have to keep track of our slot as it's also needed for clone()
            </span><a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">gdt_entry_number</a> = gdt_entry_number;<span class="tok-comment">
            // Update the %gs selector
            </span><span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">&quot;movl %[gs_val], %%gs&quot;</span>
                :
                : [gs_val] <span class="tok-str">&quot;r&quot;</span> (gdt_entry_number &lt;&lt; <span class="tok-number">3</span> | <span class="tok-number">3</span>),
            );
        },
        .x86_64 =&gt; {
            <span class="tok-kw">const</span> rc = <span class="tok-builtin">@call</span>(.always_inline, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.syscall2">syscall2</a>, .{ .arch_prctl, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.ARCH">ARCH</a>.<a href="#">SET_FS</a>, addr });
            <a href="std.debug.html#std.debug.assert">assert</a>(rc == <span class="tok-number">0</span>);
        },
        .aarch64, .aarch64_be =&gt; {
            <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (
                <span class="tok-str">\\ msr tpidr_el0, %[addr]</span>
                :
                : [addr] <span class="tok-str">&quot;r&quot;</span> (addr),
            );
        },
        .arc =&gt; {<span class="tok-comment">
            // We apparently need to both set r25 (TP) *and* inform the kernel...
            </span><span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (
                <span class="tok-str">\\ mov r25, %[addr]</span>
                :
                : [addr] <span class="tok-str">&quot;r&quot;</span> (addr),
            );
            <span class="tok-kw">const</span> rc = <span class="tok-builtin">@call</span>(.always_inline, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.syscall1">syscall1</a>, .{ .arc_settls, addr });
            <a href="std.debug.html#std.debug.assert">assert</a>(rc == <span class="tok-number">0</span>);
        },
        .arm, .armeb, .thumb, .thumbeb =&gt; {
            <span class="tok-kw">const</span> rc = <span class="tok-builtin">@call</span>(.always_inline, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.syscall1">syscall1</a>, .{ .set_tls, addr });
            <a href="std.debug.html#std.debug.assert">assert</a>(rc == <span class="tok-number">0</span>);
        },
        .m68k =&gt; {
            <span class="tok-kw">const</span> rc = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.syscall1">syscall1</a>(.set_thread_area, addr);
            <a href="std.debug.html#std.debug.assert">assert</a>(rc == <span class="tok-number">0</span>);
        },
        .hexagon =&gt; {
            <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (
                <span class="tok-str">\\ ugp = %[addr]</span>
                :
                : [addr] <span class="tok-str">&quot;r&quot;</span> (addr),
            );
        },
        .loongarch32, .loongarch64 =&gt; {
            <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (
                <span class="tok-str">\\ move $tp, %[addr]</span>
                :
                : [addr] <span class="tok-str">&quot;r&quot;</span> (addr),
            );
        },
        .riscv32, .riscv64 =&gt; {
            <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (
                <span class="tok-str">\\ mv tp, %[addr]</span>
                :
                : [addr] <span class="tok-str">&quot;r&quot;</span> (addr),
            );
        },
        .csky, .mips, .mipsel, .mips64, .mips64el =&gt; {
            <span class="tok-kw">const</span> rc = <span class="tok-builtin">@call</span>(.always_inline, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.syscall1">syscall1</a>, .{ .set_thread_area, addr });
            <a href="std.debug.html#std.debug.assert">assert</a>(rc == <span class="tok-number">0</span>);
        },
        .powerpc, .powerpcle =&gt; {
            <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (
                <span class="tok-str">\\ mr 2, %[addr]</span>
                :
                : [addr] <span class="tok-str">&quot;r&quot;</span> (addr),
            );
        },
        .powerpc64, .powerpc64le =&gt; {
            <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (
                <span class="tok-str">\\ mr 13, %[addr]</span>
                :
                : [addr] <span class="tok-str">&quot;r&quot;</span> (addr),
            );
        },
        .s390x =&gt; {
            <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (
                <span class="tok-str">\\ lgr %%r0, %[addr]</span>
                <span class="tok-str">\\ sar %%a1, %%r0</span>
                <span class="tok-str">\\ srlg %%r0, %%r0, 32</span>
                <span class="tok-str">\\ sar %%a0, %%r0</span>
                :
                : [addr] <span class="tok-str">&quot;r&quot;</span> (addr),
                : <span class="tok-str">&quot;r0&quot;</span>
            );
        },
        .sparc, .sparc64 =&gt; {
            <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (
                <span class="tok-str">\\ mov %[addr], %%g7</span>
                :
                : [addr] <span class="tok-str">&quot;r&quot;</span> (addr),
            );
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported architecture&quot;</span>),
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">computeAreaDesc</span>(phdrs: []<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.Phdr">Phdr</a>) <span class="tok-type">void</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<span class="tok-null">false</span>);
    <span class="tok-builtin">@disableInstrumentation</span>();

    <span class="tok-kw">var</span> tls_phdr: ?*<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.Phdr">Phdr</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">var</span> img_base: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">for</span> (phdrs) |*phdr| {
        <span class="tok-kw">switch</span> (phdr.p_type) {
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_PHDR">PT_PHDR</a> =&gt; img_base = <span class="tok-builtin">@intFromPtr</span>(phdrs.ptr) - phdr.p_vaddr,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_TLS">PT_TLS</a> =&gt; tls_phdr = phdr,
            <span class="tok-kw">else</span> =&gt; {},
        }
    }

    <span class="tok-kw">var</span> align_factor: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> block_init: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> block_size: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">if</span> (tls_phdr) |phdr| {
        align_factor = phdr.p_align;<span class="tok-comment">

        // The effective size in memory is represented by `p_memsz`; the length of the data stored
        // in the `PT_TLS` segment is `p_filesz` and may be less than the former.
        </span>block_init = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(img_base + phdr.p_vaddr))[<span class="tok-number">0</span>..phdr.p_filesz];
        block_size = phdr.p_memsz;
    } <span class="tok-kw">else</span> {
        align_factor = <span class="tok-builtin">@alignOf</span>(<span class="tok-type">usize</span>);

        block_init = &amp;[_]<span class="tok-type">u8</span>{};
        block_size = <span class="tok-number">0</span>;
    }<span class="tok-comment">

    // Offsets into the allocated TLS area.
    </span><span class="tok-kw">var</span> dtv_offset: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> abi_tcb_offset: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> block_offset: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">

    // Compute the total size of the ABI-specific data plus our own `ZigTcb` structure. All the
    // offsets calculated here assume a well-aligned base address.
    </span><span class="tok-kw">const</span> area_size = <span class="tok-kw">switch</span> (<a href="std.os.linux.tls.html#std.os.linux.tls.current_variant">current_variant</a>) {
        .I_original =&gt; blk: {
            <span class="tok-kw">var</span> l: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            dtv_offset = l;
            l += <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.tls.Dtv.html">Dtv</a>);<span class="tok-comment">
            // Add some padding here so that the TP (`abi_tcb_offset`) is aligned to `align_factor`
            // and the `ZigTcb` structure can be found by simply subtracting `@sizeOf(ZigTcb)` from
            // the TP.
            </span><span class="tok-kw">const</span> delta = (l + <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.tls.ZigTcb.html">ZigTcb</a>)) &amp; (align_factor - <span class="tok-number">1</span>);
            <span class="tok-kw">if</span> (delta &gt; <span class="tok-number">0</span>)
                l += align_factor - delta;
            l += <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.tls.ZigTcb.html">ZigTcb</a>);
            abi_tcb_offset = l;
            l += <a href="std.os.linux.tls.html#std.os.linux.tls.alignForward">alignForward</a>(<span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.tls.html#std.os.linux.tls.AbiTcb">AbiTcb</a>), align_factor);
            block_offset = l;
            l += block_size;
            <span class="tok-kw">break</span> :blk l;
        },
        .I_modified =&gt; blk: {
            <span class="tok-kw">var</span> l: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            dtv_offset = l;
            l += <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.tls.Dtv.html">Dtv</a>);<span class="tok-comment">
            // In this variant, the TLS blocks must begin immediately after the end of the ABI TCB,
            // with the TP pointing to the beginning of the TLS blocks. Add padding so that the TP
            // (`abi_tcb_offset`) is aligned to `align_factor` and the `ZigTcb` structure can be
            // found by subtracting `@sizeOf(AbiTcb) + @sizeOf(ZigTcb)` from the TP.
            </span><span class="tok-kw">const</span> delta = (l + <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.tls.ZigTcb.html">ZigTcb</a>) + <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.tls.html#std.os.linux.tls.AbiTcb">AbiTcb</a>)) &amp; (align_factor - <span class="tok-number">1</span>);
            <span class="tok-kw">if</span> (delta &gt; <span class="tok-number">0</span>)
                l += align_factor - delta;
            l += <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.tls.ZigTcb.html">ZigTcb</a>);
            abi_tcb_offset = l;
            l += <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.tls.html#std.os.linux.tls.AbiTcb">AbiTcb</a>);
            block_offset = l;
            l += block_size;
            <span class="tok-kw">break</span> :blk l;
        },
        .II =&gt; blk: {
            <span class="tok-kw">var</span> l: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            block_offset = l;
            l += <a href="std.os.linux.tls.html#std.os.linux.tls.alignForward">alignForward</a>(block_size, align_factor);<span class="tok-comment">
            // The TP is aligned to `align_factor`.
            </span>abi_tcb_offset = l;
            l += <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.tls.html#std.os.linux.tls.AbiTcb">AbiTcb</a>);<span class="tok-comment">
            // The `ZigTcb` structure is right after the `AbiTcb` with no padding in between so it
            // can be easily found.
            </span>l += <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.tls.ZigTcb.html">ZigTcb</a>);<span class="tok-comment">
            // It doesn't really matter where we put the DTV, so give it natural alignment.
            </span>l = <a href="std.os.linux.tls.html#std.os.linux.tls.alignForward">alignForward</a>(l, <span class="tok-builtin">@alignOf</span>(<a href="std.os.linux.tls.Dtv.html">Dtv</a>));
            dtv_offset = l;
            l += <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.tls.Dtv.html">Dtv</a>);
            <span class="tok-kw">break</span> :blk l;
        },
    };

    <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a> = .{
        .size = area_size,
        .alignment = align_factor,

        .dtv = .{
            .offset = dtv_offset,
        },

        .abi_tcb = .{
            .offset = abi_tcb_offset,
        },

        .block = .{
            .init = block_init,
            .offset = block_offset,
            .size = block_size,
        },

        .gdt_entry_number = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, -<span class="tok-number">1</span>))),
    };
}

<span class="tok-comment">/// Inline because TLS is not set up yet.</span>
<span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignForward</span>(addr: <span class="tok-type">usize</span>, alignment: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.os.linux.tls.html#std.os.linux.tls.alignBackward">alignBackward</a>(addr + (alignment - <span class="tok-number">1</span>), alignment);
}

<span class="tok-comment">/// Inline because TLS is not set up yet.</span>
<span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignBackward</span>(addr: <span class="tok-type">usize</span>, alignment: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> addr &amp; ~(alignment - <span class="tok-number">1</span>);
}

<span class="tok-comment">/// Inline because TLS is not set up yet.</span>
<span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignPtrCast</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: [*]<span class="tok-type">u8</span>) *T {
    <span class="tok-kw">return</span> <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ptr));
}

<span class="tok-comment">/// Initializes all the fields of the static TLS area and returns the computed architecture-specific</span>
<span class="tok-comment">/// value of the TP register.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prepareArea</span>(area: []<span class="tok-type">u8</span>) <span class="tok-type">usize</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<span class="tok-null">false</span>);
    <span class="tok-builtin">@disableInstrumentation</span>();<span class="tok-comment">

    // Clear the area we're going to use, just to be safe.
    </span><span class="tok-builtin">@memset</span>(area, <span class="tok-number">0</span>);<span class="tok-comment">

    // Prepare the ABI TCB.
    </span><span class="tok-kw">const</span> abi_tcb = <a href="std.os.linux.tls.html#std.os.linux.tls.alignPtrCast">alignPtrCast</a>(<a href="std.os.linux.tls.html#std.os.linux.tls.AbiTcb">AbiTcb</a>, area.ptr + <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">abi_tcb</a>.<a href="#">offset</a>);
    <span class="tok-kw">switch</span> (<a href="std.os.linux.tls.html#std.os.linux.tls.current_variant">current_variant</a>) {
        .I_original, .I_modified =&gt; abi_tcb.dtv = <span class="tok-builtin">@intFromPtr</span>(area.ptr + <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">dtv</a>.<a href="#">offset</a>),
        .II =&gt; abi_tcb.self = abi_tcb,
    }<span class="tok-comment">

    // Prepare the DTV.
    </span><span class="tok-kw">const</span> dtv = <a href="std.os.linux.tls.html#std.os.linux.tls.alignPtrCast">alignPtrCast</a>(<a href="std.os.linux.tls.Dtv.html">Dtv</a>, area.ptr + <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">dtv</a>.<a href="#">offset</a>);
    dtv.len = <span class="tok-number">1</span>;
    dtv.tls_block = area.ptr + <a href="std.os.linux.tls.html#std.os.linux.tls.current_dtv_offset">current_dtv_offset</a> + <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">block</a>.<a href="#">offset</a>;<span class="tok-comment">

    // Copy the initial data.
    </span><span class="tok-builtin">@memcpy</span>(area[<a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">block</a>.<a href="#">offset</a>..][<span class="tok-number">0</span>..<a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">block</a>.<a href="#">init</a>.<a href="#">len</a>], <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">block</a>.<a href="#">init</a>);<span class="tok-comment">

    // Return the corrected value (if needed) for the TP register. Overflow here is not a problem;
    // the pointer arithmetic involving the TP is done with wrapping semantics.
    </span><span class="tok-kw">return</span> <span class="tok-builtin">@intFromPtr</span>(area.ptr) +% <span class="tok-kw">switch</span> (<a href="std.os.linux.tls.html#std.os.linux.tls.current_variant">current_variant</a>) {
        .I_original, .II =&gt; <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">abi_tcb</a>.<a href="#">offset</a>,
        .I_modified =&gt; <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">block</a>.<a href="#">offset</a> +% <a href="std.os.linux.tls.html#std.os.linux.tls.current_tp_offset">current_tp_offset</a>,
    };
}

<span class="tok-comment">/// The main motivation for the size chosen here is that this is how much ends up being requested for</span>
<span class="tok-comment">/// the thread-local variables of the `std.crypto.random` implementation. I'm not sure why it ends up</span>
<span class="tok-comment">/// being so much; the struct itself is only 64 bytes. I think it has to do with being page-aligned</span>
<span class="tok-comment">/// and LLVM or LLD is not smart enough to lay out the TLS data in a space-conserving way. Anyway, I</span>
<span class="tok-comment">/// think it's fine because it's less than 3 pages of memory, and putting it in the ELF like this is</span>
<span class="tok-comment">/// equivalent to moving the `mmap` call below into the kernel, avoiding syscall overhead.</span>
<span class="tok-kw">var</span> main_thread_area_buffer: [<span class="tok-number">0x2100</span>]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) = <span class="tok-null">undefined</span>;

<span class="tok-comment">/// Computes the layout of the static TLS area, allocates the area, initializes all of its fields,</span>
<span class="tok-comment">/// and assigns the architecture-specific value to the TP register.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initStatic</span>(phdrs: []<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.Phdr">Phdr</a>) <span class="tok-type">void</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<span class="tok-null">false</span>);
    <span class="tok-builtin">@disableInstrumentation</span>();

    <a href="std.os.linux.tls.html#std.os.linux.tls.computeAreaDesc">computeAreaDesc</a>(phdrs);

    <span class="tok-kw">const</span> area = blk: {<span class="tok-comment">
        // Fast path for the common case where the TLS data is really small, avoid an allocation and
        // use our local buffer.
        </span><span class="tok-kw">if</span> (<a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">alignment</a> &lt;= <a href="std.heap.html#std.heap.page_size_min">page_size_min</a> <span class="tok-kw">and</span> <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">size</a> &lt;= <a href="std.os.linux.tls.html#std.os.linux.tls.main_thread_area_buffer">main_thread_area_buffer</a>.<a href="#">len</a>) {
            <span class="tok-kw">break</span> :blk <a href="std.os.linux.tls.html#std.os.linux.tls.main_thread_area_buffer">main_thread_area_buffer</a>[<span class="tok-number">0</span>..<a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">size</a>];
        }

        <span class="tok-kw">const</span> begin_addr = <a href="std.os.linux.tls.html#std.os.linux.tls.mmap">mmap</a>(
            <span class="tok-null">null</span>,
            <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">size</a> + <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">alignment</a> - <span class="tok-number">1</span>,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PROT">PROT</a>.<a href="#">READ</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PROT">PROT</a>.<a href="#">WRITE</a>,
            .{ .TYPE = .PRIVATE, .ANONYMOUS = <span class="tok-null">true</span> },
            -<span class="tok-number">1</span>,
            <span class="tok-number">0</span>,
        );
        <span class="tok-kw">if</span> (<span class="tok-builtin">@call</span>(.always_inline, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>, .{begin_addr}) != .SUCCESS) <span class="tok-builtin">@trap</span>();

        <span class="tok-kw">const</span> area_ptr: [*]<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span> = <span class="tok-builtin">@ptrFromInt</span>(begin_addr);<span class="tok-comment">

        // Make sure the slice is correctly aligned.
        </span><span class="tok-kw">const</span> begin_aligned_addr = <a href="std.os.linux.tls.html#std.os.linux.tls.alignForward">alignForward</a>(begin_addr, <a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">alignment</a>);
        <span class="tok-kw">const</span> start = begin_aligned_addr - begin_addr;
        <span class="tok-kw">break</span> :blk area_ptr[start..][<span class="tok-number">0</span>..<a href="std.os.linux.tls.html#std.os.linux.tls.area_desc">area_desc</a>.<a href="#">size</a>];
    };

    <span class="tok-kw">const</span> tp_value = <a href="std.os.linux.tls.html#std.os.linux.tls.prepareArea">prepareArea</a>(area);
    <a href="std.os.linux.tls.html#std.os.linux.tls.setThreadPointer">setThreadPointer</a>(tp_value);
}

<span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">mmap</span>(address: ?[*]<span class="tok-type">u8</span>, length: <span class="tok-type">usize</span>, prot: <span class="tok-type">usize</span>, flags: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.MAP">MAP</a>, fd: <span class="tok-type">i32</span>, offset: <span class="tok-type">i64</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.SYS">SYS</a>, <span class="tok-str">&quot;mmap2&quot;</span>)) {
        <span class="tok-kw">return</span> <span class="tok-builtin">@call</span>(.always_inline, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.syscall6">syscall6</a>, .{
            .mmap2,
            <span class="tok-builtin">@intFromPtr</span>(address),
            length,
            prot,
            <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(flags)),
            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, fd))),
            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(offset)) / <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.MMAP2_UNIT">MMAP2_UNIT</a>)),
        });
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // The s390x mmap() syscall existed before Linux supported syscalls with 5+ parameters, so
        // it takes a single pointer to an array of arguments instead.
        </span><span class="tok-kw">return</span> <span class="tok-kw">if</span> (<a href="std.os.linux.tls.html#std.os.linux.tls.native_arch">native_arch</a> == .s390x) <span class="tok-builtin">@call</span>(.always_inline, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.syscall1">syscall1</a>, .{
            .mmap,
            <span class="tok-builtin">@intFromPtr</span>(&amp;[_]<span class="tok-type">usize</span>{
                <span class="tok-builtin">@intFromPtr</span>(address),
                length,
                prot,
                <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(flags)),
                <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, fd))),
                <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(offset)),
            }),
        }) <span class="tok-kw">else</span> <span class="tok-builtin">@call</span>(.always_inline, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.syscall6">syscall6</a>, .{
            .mmap,
            <span class="tok-builtin">@intFromPtr</span>(address),
            length,
            prot,
            <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(flags)),
            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, fd))),
            <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(offset)),
        });
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
