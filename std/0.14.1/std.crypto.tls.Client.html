<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">crypto</a></li><li><a href="std.crypto.html" class="">tls</a></li><li><a href="std.crypto.tls.Client.html" class="active">Client</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.crypto.tls.Client" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.crypto.tls.Client</span><a href="#src.zig-std.crypto.tls.Client">[src]</a></h1><div class="sectNamespaces"><h2 class="sectionHeader">Namespaces</h2><ul class="listNamespaces columns"><li><a href="std.crypto.tls.Client.StreamInterface.html">std.crypto.tls.Client.StreamInterface</a></li></ul></div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.crypto.tls.Client.Options.html">std.crypto.tls.Client.Options</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.crypto.tls.Client.InitError" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">InitError</span><a href="#src.zig-std.crypto.tls.Client.InitError">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>Stream: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.tls.Client.InitError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">InitError</span>(<span class="tok-kw">comptime</span> Stream: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || Stream.WriteError || Stream.ReadError || <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.AlertDescription.html">AlertDescription</a>.<a href="std.crypto.tls.AlertDescription.html#std.crypto.tls.AlertDescription.Error">Error</a> || <span class="tok-kw">error</span>{
        InsufficientEntropy,
        DiskQuota,
        LockViolation,
        NotOpenForWriting,
        TlsUnexpectedMessage,
        TlsIllegalParameter,
        TlsDecryptFailure,
        TlsRecordOverflow,
        TlsBadRecordMac,
        CertificateFieldHasInvalidLength,
        CertificateHostMismatch,
        CertificatePublicKeyInvalid,
        CertificateExpired,
        CertificateFieldHasWrongDataType,
        CertificateIssuerMismatch,
        CertificateNotYetValid,
        CertificateSignatureAlgorithmMismatch,
        CertificateSignatureAlgorithmUnsupported,
        CertificateSignatureInvalid,
        CertificateSignatureInvalidLength,
        CertificateSignatureNamedCurveUnsupported,
        CertificateSignatureUnsupportedBitCount,
        TlsCertificateNotVerified,
        TlsBadSignatureScheme,
        TlsBadRsaSignatureBitCount,
        InvalidEncoding,
        IdentityElement,
        SignatureVerificationFailed,
        TlsDecryptError,
        TlsConnectionTruncated,
        TlsDecodeError,
        UnsupportedCertificateVersion,
        CertificateTimeInvalid,
        CertificateHasUnrecognizedObjectId,
        CertificateHasInvalidBitString,
        MessageTooLong,
        NegativeIntoUnsigned,
        TargetTooSmall,
        BufferTooSmall,
        InvalidSignature,
        NotSquare,
        NonCanonical,
        WeakPublicKey,
    };
}</code></pre></details></div></div></div></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>tls_version: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a></code></pre></div><div><pre><code>read_seq: <span class="tok-type">u64</span></code></pre></div><div><pre><code>write_seq: <span class="tok-type">u64</span></code></pre></div><div><pre><code>partial_cleartext_idx: <span class="tok-type">u15</span></code></pre><div class="fieldDocs"><p>The starting index of cleartext bytes inside <code>partially_read_buffer</code>.</p>
</div></div><div><pre><code>partial_ciphertext_idx: <span class="tok-type">u15</span></code></pre><div class="fieldDocs"><p>The ending index of cleartext bytes inside <code>partially_read_buffer</code> as well
as the starting index of ciphertext bytes.</p>
</div></div><div><pre><code>partial_ciphertext_end: <span class="tok-type">u15</span></code></pre><div class="fieldDocs"><p>The ending index of ciphertext bytes inside <code>partially_read_buffer</code>.</p>
</div></div><div><pre><code>received_close_notify: <span class="tok-type">bool</span></code></pre><div class="fieldDocs"><p>When this is true, the stream may still not be at the end because there
may be data in <code>partially_read_buffer</code>.</p>
</div></div><div><pre><code>allow_truncation_attacks: <span class="tok-type">bool</span></code></pre><div class="fieldDocs"><p>By default, reaching the end-of-stream when reading from the server will
cause <code>error.TlsConnectionTruncated</code> to be returned, unless a close_notify
message has been received. By setting this flag to <code>true</code>, instead, the
end-of-stream will be forwarded to the application layer above TLS.
This makes the application vulnerable to truncation attacks unless the
application layer itself verifies that the amount of data received equals
the amount of data expected, such as HTTP with the Content-Length header.</p>
</div></div><div><pre><code>application_cipher: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ApplicationCipher.html">ApplicationCipher</a></code></pre></div><div><pre><code>partially_read_buffer: [<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_record_len">max_ciphertext_record_len</a>]<span class="tok-type">u8</span></code></pre><div class="fieldDocs"><p>The size is enough to contain exactly one TLSCiphertext record.
This buffer is segmented into four parts:</p>
<ol start="0">
<li>unused</li>
<li>cleartext</li>
<li>ciphertext</li>
<li>unused
The fields <code>partial_cleartext_idx</code>, <code>partial_ciphertext_idx</code>, and
<code>partial_ciphertext_end</code> describe the span of the segments.</li>
</ol>
</div></div><div><pre><code>ssl_key_log: ?<span class="tok-kw">struct</span> {
    client_key_seq: <span class="tok-type">u64</span>,
    server_key_seq: <span class="tok-type">u64</span>,
    client_random: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>,
    file: <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>,

    <span class="tok-kw">fn</span> <span class="tok-fn">clientCounter</span>(key_log: *<span class="tok-builtin">@This</span>()) <span class="tok-type">u64</span> {
        <span class="tok-kw">defer</span> key_log.client_key_seq += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> key_log.client_key_seq;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">serverCounter</span>(key_log: *<span class="tok-builtin">@This</span>()) <span class="tok-type">u64</span> {
        <span class="tok-kw">defer</span> key_log.server_key_seq += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> key_log.server_key_seq;
    }
}</code></pre><div class="fieldDocs"><p>If non-null, ssl secrets are logged to a file.  Creating such a log file allows other
programs with access to that file to decrypt all traffic over this connection.</p>
</div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.crypto.tls.Client.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.crypto.tls.Client.init">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(stream: <span class="tok-kw">anytype</span>, options: <a href="std.crypto.tls.Client.Options.html">Options</a>) <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.InitError">InitError</a>(<span class="tok-builtin">@TypeOf</span>(stream))!<a href="std.crypto.tls.Client.html">Client</a></code></pre></div><div class="tldDocs"><p>Initiates a TLS handshake and establishes a TLSv1.2 or TLSv1.3 session with <code>stream</code>, which
must conform to <code><a href="std.crypto.tls.Client.StreamInterface.html">StreamInterface</a></code>.</p>
<p><code>host</code> is only borrowed during this function call.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>options: <a href="std.crypto.tls.Client.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.tls.Client.init">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(stream: <span class="tok-kw">anytype</span>, options: <a href="std.crypto.tls.Client.Options.html">Options</a>) <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.InitError">InitError</a>(<span class="tok-builtin">@TypeOf</span>(stream))!<a href="std.crypto.tls.Client.html">Client</a> {
    <span class="tok-kw">const</span> host = <span class="tok-kw">switch</span> (options.host) {
        .no_verification =&gt; <span class="tok-str">&quot;&quot;</span>,
        .explicit =&gt; |host| host,
    };
    <span class="tok-kw">const</span> host_len: <span class="tok-type">u16</span> = <span class="tok-builtin">@intCast</span>(host.len);

    <span class="tok-kw">var</span> random_buffer: [<span class="tok-number">176</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <a href="std.crypto.html">crypto</a>.<a href="std.crypto.tlcsprng.html#std.crypto.tlcsprng.interface">random</a>.<a href="#">bytes</a>(&amp;random_buffer);
    <span class="tok-kw">const</span> client_hello_rand = random_buffer[<span class="tok-number">0</span>..<span class="tok-number">32</span>].*;
    <span class="tok-kw">var</span> key_seq: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> server_hello_rand: [<span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> legacy_session_id = random_buffer[<span class="tok-number">32</span>..<span class="tok-number">64</span>].*;

    <span class="tok-kw">var</span> key_share = <a href="std.crypto.tls.Client.KeyShare.html">KeyShare</a>.<a href="std.crypto.tls.Client.KeyShare.html#std.crypto.tls.Client.KeyShare.init">init</a>(random_buffer[<span class="tok-number">64</span>..<span class="tok-number">176</span>].*) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {<span class="tok-comment">
        // Only possible to happen if the seed is all zeroes.
        </span><span class="tok-kw">error</span>.IdentityElement =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InsufficientEntropy,
    };

    <span class="tok-kw">const</span> extensions_payload = <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.extension">extension</a>(.supported_versions, <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u8</span>, <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a>, .{
        .tls_1_3,
        .tls_1_2,
    })) ++ <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.extension">extension</a>(.signature_algorithms, <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.SignatureScheme.html">SignatureScheme</a>, .{
        .ecdsa_secp256r1_sha256,
        .ecdsa_secp384r1_sha384,
        .rsa_pkcs1_sha256,
        .rsa_pkcs1_sha384,
        .rsa_pkcs1_sha512,
        .rsa_pss_rsae_sha256,
        .rsa_pss_rsae_sha384,
        .rsa_pss_rsae_sha512,
        .rsa_pss_pss_sha256,
        .rsa_pss_pss_sha384,
        .rsa_pss_pss_sha512,
        .rsa_pkcs1_sha1,
        .ed25519,
    })) ++ <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.extension">extension</a>(.supported_groups, <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.NamedGroup.html">NamedGroup</a>, .{
        .x25519_ml_kem768,
        .secp256r1,
        .secp384r1,
        .x25519,
    })) ++ <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.extension">extension</a>(.psk_key_exchange_modes, <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u8</span>, <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.PskKeyExchangeMode.html">PskKeyExchangeMode</a>, .{
        .psk_dhe_ke,
    })) ++ <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.extension">extension</a>(.key_share, <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(
        <span class="tok-type">u16</span>,
        <span class="tok-type">u8</span>,
        <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.NamedGroup.html">NamedGroup</a>.<a href="#">x25519_ml_kem768</a>)) ++
            <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <span class="tok-type">u8</span>, key_share.ml_kem768_kp.public_key.toBytes() ++ key_share.x25519_kp.public_key) ++
            <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.NamedGroup.html">NamedGroup</a>.<a href="#">secp256r1</a>)) ++
            <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <span class="tok-type">u8</span>, key_share.secp256r1_kp.public_key.toUncompressedSec1()) ++
            <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.NamedGroup.html">NamedGroup</a>.<a href="#">secp384r1</a>)) ++
            <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <span class="tok-type">u8</span>, key_share.secp384r1_kp.public_key.toUncompressedSec1()) ++
            <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.NamedGroup.html">NamedGroup</a>.<a href="#">x25519</a>)) ++
            <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <span class="tok-type">u8</span>, key_share.x25519_kp.public_key),
    ));
    <span class="tok-kw">const</span> server_name_extension = <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ExtensionType.html">ExtensionType</a>.<a href="#">server_name</a>)) ++
        <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-number">2</span> + <span class="tok-number">1</span> + <span class="tok-number">2</span> + host_len) ++<span class="tok-comment"> // byte length of this extension payload
        </span><a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-number">1</span> + <span class="tok-number">2</span> + host_len) ++<span class="tok-comment"> // server_name_list byte count
        </span>.{<span class="tok-number">0x00</span>} ++<span class="tok-comment"> // name_type
        </span><a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, host_len);
    <span class="tok-kw">const</span> server_name_extension_len = <span class="tok-kw">switch</span> (options.host) {
        .no_verification =&gt; <span class="tok-number">0</span>,
        .explicit =&gt; server_name_extension.len + host_len,
    };

    <span class="tok-kw">const</span> extensions_header =
        <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intCast</span>(extensions_payload.len + server_name_extension_len)) ++
        extensions_payload ++
        server_name_extension;

    <span class="tok-kw">const</span> client_hello =
        <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a>.<a href="#">tls_1_2</a>)) ++
        client_hello_rand ++
        [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">32</span>} ++ legacy_session_id ++
        <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.cipher_suites">cipher_suites</a> ++
        <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u8</span>, <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.CompressionMethod.html">CompressionMethod</a>, .{.<span class="tok-null">null</span>}) ++
        extensions_header;

    <span class="tok-kw">const</span> out_handshake = .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.HandshakeType.html">HandshakeType</a>.<a href="#">client_hello</a>)} ++
        <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u24</span>, <span class="tok-builtin">@intCast</span>(client_hello.len - server_name_extension.len + server_name_extension_len)) ++
        client_hello;

    <span class="tok-kw">const</span> cleartext_header_buf = .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ContentType.html">ContentType</a>.<a href="#">handshake</a>)} ++
        <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a>.<a href="#">tls_1_0</a>)) ++
        <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intCast</span>(out_handshake.len - server_name_extension.len + server_name_extension_len)) ++
        out_handshake;
    <span class="tok-kw">const</span> cleartext_header = <span class="tok-kw">switch</span> (options.host) {
        .no_verification =&gt; cleartext_header_buf[<span class="tok-number">0</span> .. cleartext_header_buf.len - server_name_extension.len],
        .explicit =&gt; &amp;cleartext_header_buf,
    };

    {
        <span class="tok-kw">var</span> iovecs = [_]<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>{
            .{ .base = cleartext_header.ptr, .len = cleartext_header.len },
            .{ .base = host.ptr, .len = host.len },
        };
        <span class="tok-kw">try</span> stream.writevAll(iovecs[<span class="tok-number">0</span>..<span class="tok-kw">if</span> (host.len == <span class="tok-number">0</span>) <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-number">2</span>]);
    }

    <span class="tok-kw">var</span> tls_version: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a> = <span class="tok-null">undefined</span>;<span class="tok-comment">
    // These are used for two purposes:
    // * Detect whether a certificate is the first one presented, in which case
    //   we need to verify the host name.
    </span><span class="tok-kw">var</span> cert_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;<span class="tok-comment">
    // * Flip back and forth between the two cleartext buffers in order to keep
    //   the previous certificate in memory so that it can be verified by the
    //   next one.
    </span><span class="tok-kw">var</span> cert_buf_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> write_seq: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> read_seq: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> prev_cert: <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.Parsed.html">Parsed</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> CipherState = <span class="tok-kw">enum</span> {
        <span class="tok-comment">/// No cipher is in use</span>
        cleartext,
        <span class="tok-comment">/// Handshake cipher is in use</span>
        handshake,
        <span class="tok-comment">/// Application cipher is in use</span>
        application,
    };
    <span class="tok-kw">var</span> pending_cipher_state: CipherState = .cleartext;
    <span class="tok-kw">var</span> cipher_state = pending_cipher_state;
    <span class="tok-kw">const</span> HandshakeState = <span class="tok-kw">enum</span> {
        <span class="tok-comment">/// In this state we expect only a server hello message.</span>
        hello,
        <span class="tok-comment">/// In this state we expect only an encrypted_extensions message.</span>
        encrypted_extensions,
        <span class="tok-comment">/// In this state we expect certificate handshake messages.</span>
        certificate,
        <span class="tok-comment">/// In this state we expect certificate or certificate_verify messages.</span>
        <span class="tok-comment">/// certificate messages are ignored since the trust chain is already</span>
        <span class="tok-comment">/// established.</span>
        trust_chain_established,
        <span class="tok-comment">/// In this state, we expect only the server_hello_done handshake message.</span>
        server_hello_done,
        <span class="tok-comment">/// In this state, we expect only the finished handshake message.</span>
        finished,
    };
    <span class="tok-kw">var</span> handshake_state: HandshakeState = .hello;
    <span class="tok-kw">var</span> handshake_cipher: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.HandshakeCipher.html">HandshakeCipher</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> main_cert_pub_key: <a href="std.crypto.tls.Client.CertificatePublicKey.html">CertificatePublicKey</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> now_sec = <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.timestamp">timestamp</a>();

    <span class="tok-kw">var</span> cleartext_fragment_start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> cleartext_fragment_end: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> cleartext_bufs: [<span class="tok-number">2</span>][<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_inner_record_len">max_ciphertext_inner_record_len</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> handshake_buffer: [<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_record_len">max_ciphertext_record_len</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> d: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.Decoder.html">Decoder</a> = .{ .buf = &amp;handshake_buffer };
    fragment: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">try</span> d.readAtLeastOurAmt(stream, <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>);
        <span class="tok-kw">const</span> record_header = d.buf[d.idx..][<span class="tok-number">0</span>..<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>];
        <span class="tok-kw">const</span> record_ct = d.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ContentType.html">ContentType</a>);
        d.skip(<span class="tok-number">2</span>);<span class="tok-comment"> // legacy_version
        </span><span class="tok-kw">const</span> record_len = d.decode(<span class="tok-type">u16</span>);
        <span class="tok-kw">try</span> d.readAtLeast(stream, record_len);
        <span class="tok-kw">var</span> record_decoder = <span class="tok-kw">try</span> d.sub(record_len);
        <span class="tok-kw">var</span> ctd, <span class="tok-kw">const</span> ct = content: <span class="tok-kw">switch</span> (cipher_state) {
            .cleartext =&gt; .{ record_decoder, record_ct },
            .handshake =&gt; {
                std.debug.assert(tls_version == .tls_1_3);
                <span class="tok-kw">if</span> (record_ct != .application_data) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                <span class="tok-kw">try</span> record_decoder.ensure(record_len);
                <span class="tok-kw">const</span> cleartext_buf = &amp;cleartext_bufs[cert_buf_index % <span class="tok-number">2</span>];
                <span class="tok-kw">switch</span> (handshake_cipher) {
                    <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| {
                        <span class="tok-kw">const</span> pv = &amp;p.version.tls_1_3;
                        <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*).A;
                        <span class="tok-kw">if</span> (record_len &lt; P.AEAD.tag_length) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsRecordOverflow;
                        <span class="tok-kw">const</span> ciphertext = record_decoder.slice(record_len - P.AEAD.tag_length);
                        <span class="tok-kw">const</span> cleartext_fragment_buf = cleartext_buf[cleartext_fragment_end..];
                        <span class="tok-kw">if</span> (ciphertext.len &gt; cleartext_fragment_buf.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsRecordOverflow;
                        <span class="tok-kw">const</span> cleartext = cleartext_fragment_buf[<span class="tok-number">0</span>..ciphertext.len];
                        <span class="tok-kw">const</span> auth_tag = record_decoder.array(P.AEAD.tag_length).*;
                        <span class="tok-kw">const</span> nonce = nonce: {
                            <span class="tok-kw">const</span> V = <span class="tok-builtin">@Vector</span>(P.AEAD.nonce_length, <span class="tok-type">u8</span>);
                            <span class="tok-kw">const</span> pad = [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** (P.AEAD.nonce_length - <span class="tok-number">8</span>);
                            <span class="tok-kw">const</span> operand: V = pad ++ <span class="tok-builtin">@as</span>([<span class="tok-number">8</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(big(read_seq)));
                            <span class="tok-kw">break</span> :nonce <span class="tok-builtin">@as</span>(V, pv.server_handshake_iv) ^ operand;
                        };
                        P.AEAD.decrypt(cleartext, ciphertext, auth_tag, record_header, nonce, pv.server_handshake_key) <span class="tok-kw">catch</span>
                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsBadRecordMac;
                        cleartext_fragment_end += std.mem.trimRight(<span class="tok-type">u8</span>, cleartext, <span class="tok-str">&quot;\x00&quot;</span>).len;
                    },
                }
                read_seq += <span class="tok-number">1</span>;
                cleartext_fragment_end -= <span class="tok-number">1</span>;
                <span class="tok-kw">const</span> ct: tls.ContentType = <span class="tok-builtin">@enumFromInt</span>(cleartext_buf[cleartext_fragment_end]);
                <span class="tok-kw">if</span> (ct != .handshake) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                <span class="tok-kw">break</span> :content .{ tls.Decoder.fromTheirSlice(<span class="tok-builtin">@constCast</span>(cleartext_buf[cleartext_fragment_start..cleartext_fragment_end])), ct };
            },
            .application =&gt; {
                std.debug.assert(tls_version == .tls_1_2);
                <span class="tok-kw">if</span> (record_ct != .handshake) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                <span class="tok-kw">try</span> record_decoder.ensure(record_len);
                <span class="tok-kw">const</span> cleartext_buf = &amp;cleartext_bufs[cert_buf_index % <span class="tok-number">2</span>];
                <span class="tok-kw">switch</span> (handshake_cipher) {
                    <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| {
                        <span class="tok-kw">const</span> pv = &amp;p.version.tls_1_2;
                        <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*).A;
                        <span class="tok-kw">if</span> (record_len &lt; P.record_iv_length + P.mac_length) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsRecordOverflow;
                        <span class="tok-kw">const</span> message_len: <span class="tok-type">u16</span> = record_len - P.record_iv_length - P.mac_length;
                        <span class="tok-kw">const</span> cleartext_fragment_buf = cleartext_buf[cleartext_fragment_end..];
                        <span class="tok-kw">if</span> (message_len &gt; cleartext_fragment_buf.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsRecordOverflow;
                        <span class="tok-kw">const</span> cleartext = cleartext_fragment_buf[<span class="tok-number">0</span>..message_len];
                        <span class="tok-kw">const</span> ad = std.mem.toBytes(big(read_seq)) ++
                            record_header[<span class="tok-number">0</span> .. <span class="tok-number">1</span> + <span class="tok-number">2</span>] ++
                            std.mem.toBytes(big(message_len));
                        <span class="tok-kw">const</span> record_iv = record_decoder.array(P.record_iv_length).*;
                        <span class="tok-kw">const</span> masked_read_seq = read_seq &amp;
                            <span class="tok-kw">comptime</span> std.math.shl(<span class="tok-type">u64</span>, std.math.maxInt(<span class="tok-type">u64</span>), <span class="tok-number">8</span> * P.record_iv_length);
                        <span class="tok-kw">const</span> nonce: [P.AEAD.nonce_length]<span class="tok-type">u8</span> = nonce: {
                            <span class="tok-kw">const</span> V = <span class="tok-builtin">@Vector</span>(P.AEAD.nonce_length, <span class="tok-type">u8</span>);
                            <span class="tok-kw">const</span> pad = [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** (P.AEAD.nonce_length - <span class="tok-number">8</span>);
                            <span class="tok-kw">const</span> operand: V = pad ++ <span class="tok-builtin">@as</span>([<span class="tok-number">8</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(big(masked_read_seq)));
                            <span class="tok-kw">break</span> :nonce <span class="tok-builtin">@as</span>(V, pv.app_cipher.server_write_IV ++ record_iv) ^ operand;
                        };
                        <span class="tok-kw">const</span> ciphertext = record_decoder.slice(message_len);
                        <span class="tok-kw">const</span> auth_tag = record_decoder.array(P.mac_length);
                        P.AEAD.decrypt(cleartext, ciphertext, auth_tag.*, ad, nonce, pv.app_cipher.server_write_key) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsBadRecordMac;
                        cleartext_fragment_end += message_len;
                    },
                }
                read_seq += <span class="tok-number">1</span>;
                <span class="tok-kw">break</span> :content .{ tls.Decoder.fromTheirSlice(cleartext_buf[cleartext_fragment_start..cleartext_fragment_end]), record_ct };
            },
        };
        <span class="tok-kw">switch</span> (ct) {
            .alert =&gt; {
                ctd.ensure(<span class="tok-number">2</span>) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span> :fragment;
                <span class="tok-kw">const</span> level = ctd.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.AlertLevel.html">AlertLevel</a>);
                <span class="tok-kw">const</span> desc = ctd.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.AlertDescription.html">AlertDescription</a>);
                _ = level;<span class="tok-comment">

                // if this isn't a error alert, then it's a closure alert, which makes no sense in a handshake
                </span><span class="tok-kw">try</span> desc.toError();<span class="tok-comment">
                // TODO: handle server-side closures
                </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
            },
            .change_cipher_spec =&gt; {
                ctd.ensure(<span class="tok-number">1</span>) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span> :fragment;
                <span class="tok-kw">if</span> (ctd.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ChangeCipherSpecType.html">ChangeCipherSpecType</a>) != .change_cipher_spec) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter;
                cipher_state = pending_cipher_state;
            },
            .handshake =&gt; <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                ctd.ensure(<span class="tok-number">4</span>) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span> :fragment;
                <span class="tok-kw">const</span> handshake_type = ctd.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.HandshakeType.html">HandshakeType</a>);
                <span class="tok-kw">const</span> handshake_len = ctd.decode(<span class="tok-type">u24</span>);
                <span class="tok-kw">var</span> hsd = ctd.sub(handshake_len) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span> :fragment;
                <span class="tok-kw">const</span> wrapped_handshake = ctd.buf[ctd.idx - handshake_len - <span class="tok-number">4</span> .. ctd.idx];
                <span class="tok-kw">switch</span> (handshake_type) {
                    .server_hello =&gt; {
                        <span class="tok-kw">if</span> (cipher_state != .cleartext) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">if</span> (handshake_state != .hello) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">try</span> hsd.ensure(<span class="tok-number">2</span> + <span class="tok-number">32</span> + <span class="tok-number">1</span>);
                        <span class="tok-kw">const</span> legacy_version = hsd.decode(<span class="tok-type">u16</span>);
                        <span class="tok-builtin">@memcpy</span>(&amp;server_hello_rand, hsd.array(<span class="tok-number">32</span>));
                        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;server_hello_rand, &amp;<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.hello_retry_request_sequence">hello_retry_request_sequence</a>)) {<span class="tok-comment">
                            // This is a HelloRetryRequest message. This client implementation
                            // does not expect to get one.
                            </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        }
                        <span class="tok-kw">const</span> legacy_session_id_echo_len = hsd.decode(<span class="tok-type">u8</span>);
                        <span class="tok-kw">try</span> hsd.ensure(legacy_session_id_echo_len + <span class="tok-number">2</span> + <span class="tok-number">1</span>);
                        <span class="tok-kw">const</span> legacy_session_id_echo = hsd.slice(legacy_session_id_echo_len);
                        <span class="tok-kw">const</span> cipher_suite_tag = hsd.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.CipherSuite.html">CipherSuite</a>);
                        hsd.skip(<span class="tok-number">1</span>);<span class="tok-comment"> // legacy_compression_method
                        </span><span class="tok-kw">var</span> supported_version: ?<span class="tok-type">u16</span> = <span class="tok-null">null</span>;
                        <span class="tok-kw">if</span> (!hsd.eof()) {
                            <span class="tok-kw">try</span> hsd.ensure(<span class="tok-number">2</span>);
                            <span class="tok-kw">const</span> extensions_size = hsd.decode(<span class="tok-type">u16</span>);
                            <span class="tok-kw">var</span> all_extd = <span class="tok-kw">try</span> hsd.sub(extensions_size);
                            <span class="tok-kw">while</span> (!all_extd.eof()) {
                                <span class="tok-kw">try</span> all_extd.ensure(<span class="tok-number">2</span> + <span class="tok-number">2</span>);
                                <span class="tok-kw">const</span> et = all_extd.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ExtensionType.html">ExtensionType</a>);
                                <span class="tok-kw">const</span> ext_size = all_extd.decode(<span class="tok-type">u16</span>);
                                <span class="tok-kw">var</span> extd = <span class="tok-kw">try</span> all_extd.sub(ext_size);
                                <span class="tok-kw">switch</span> (et) {
                                    .supported_versions =&gt; {
                                        <span class="tok-kw">if</span> (supported_version) |_| <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter;
                                        <span class="tok-kw">try</span> extd.ensure(<span class="tok-number">2</span>);
                                        supported_version = extd.decode(<span class="tok-type">u16</span>);
                                    },
                                    .key_share =&gt; {
                                        <span class="tok-kw">if</span> (key_share.getSharedSecret()) |_| <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter;
                                        <span class="tok-kw">try</span> extd.ensure(<span class="tok-number">4</span>);
                                        <span class="tok-kw">const</span> named_group = extd.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.NamedGroup.html">NamedGroup</a>);
                                        <span class="tok-kw">const</span> key_size = extd.decode(<span class="tok-type">u16</span>);
                                        <span class="tok-kw">try</span> extd.ensure(key_size);
                                        <span class="tok-kw">try</span> key_share.exchange(named_group, extd.slice(key_size));
                                    },
                                    <span class="tok-kw">else</span> =&gt; {},
                                }
                            }
                        }

                        tls_version = <span class="tok-builtin">@enumFromInt</span>(supported_version <span class="tok-kw">orelse</span> legacy_version);
                        <span class="tok-kw">switch</span> (tls_version) {
                            .tls_1_3 =&gt; <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, legacy_session_id_echo, &amp;legacy_session_id)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter,
                            .tls_1_2 =&gt; <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, server_hello_rand[<span class="tok-number">24</span>..<span class="tok-number">31</span>], <span class="tok-str">&quot;DOWNGRD&quot;</span>) <span class="tok-kw">and</span>
                                server_hello_rand[<span class="tok-number">31</span>] &gt;&gt; <span class="tok-number">1</span> == <span class="tok-number">0x00</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter,
                        }

                        <span class="tok-kw">switch</span> (cipher_suite_tag) {
                            <span class="tok-kw">inline</span> .AES_128_GCM_SHA256,
                            .AES_256_GCM_SHA384,
                            .CHACHA20_POLY1305_SHA256,
                            .AEGIS_256_SHA512,
                            .AEGIS_128L_SHA256,

                            .ECDHE_RSA_WITH_AES_128_GCM_SHA256,
                            .ECDHE_RSA_WITH_AES_256_GCM_SHA384,
                            .ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
                            =&gt; |tag| {
                                handshake_cipher = <span class="tok-builtin">@unionInit</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.HandshakeCipher.html">HandshakeCipher</a>, <span class="tok-builtin">@tagName</span>(tag.with()), .{
                                    .transcript_hash = .init(.{}),
                                    .version = <span class="tok-null">undefined</span>,
                                });
                                <span class="tok-kw">const</span> p = &amp;<span class="tok-builtin">@field</span>(handshake_cipher, <span class="tok-builtin">@tagName</span>(tag.with()));
                                p.transcript_hash.update(cleartext_header[<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>..]);<span class="tok-comment"> // Client Hello part 1
                                </span>p.transcript_hash.update(host);<span class="tok-comment"> // Client Hello part 2
                                </span>p.transcript_hash.update(wrapped_handshake);
                            },

                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter,
                        }
                        <span class="tok-kw">switch</span> (tls_version) {
                            .tls_1_3 =&gt; {
                                <span class="tok-kw">switch</span> (cipher_suite_tag) {
                                    <span class="tok-kw">inline</span> .AES_128_GCM_SHA256,
                                    .AES_256_GCM_SHA384,
                                    .CHACHA20_POLY1305_SHA256,
                                    .AEGIS_256_SHA512,
                                    .AEGIS_128L_SHA256,
                                    =&gt; |tag| {
                                        <span class="tok-kw">const</span> sk = key_share.getSharedSecret() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter;
                                        <span class="tok-kw">const</span> p = &amp;<span class="tok-builtin">@field</span>(handshake_cipher, <span class="tok-builtin">@tagName</span>(tag.with()));
                                        <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*).A;
                                        <span class="tok-kw">const</span> hello_hash = p.transcript_hash.peek();
                                        <span class="tok-kw">const</span> zeroes = [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** P.Hash.digest_length;
                                        <span class="tok-kw">const</span> early_secret = P.Hkdf.extract(&amp;[<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>}, &amp;zeroes);
                                        <span class="tok-kw">const</span> empty_hash = <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.emptyHash">emptyHash</a>(P.Hash);
                                        p.version = .{ .tls_1_3 = <span class="tok-null">undefined</span> };
                                        <span class="tok-kw">const</span> pv = &amp;p.version.tls_1_3;
                                        <span class="tok-kw">const</span> hs_derived_secret = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, early_secret, <span class="tok-str">&quot;derived&quot;</span>, &amp;empty_hash, P.Hash.digest_length);
                                        pv.handshake_secret = P.Hkdf.extract(&amp;hs_derived_secret, sk);
                                        <span class="tok-kw">const</span> ap_derived_secret = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, pv.handshake_secret, <span class="tok-str">&quot;derived&quot;</span>, &amp;empty_hash, P.Hash.digest_length);
                                        pv.master_secret = P.Hkdf.extract(&amp;ap_derived_secret, &amp;zeroes);
                                        <span class="tok-kw">const</span> client_secret = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, pv.handshake_secret, <span class="tok-str">&quot;c hs traffic&quot;</span>, &amp;hello_hash, P.Hash.digest_length);
                                        <span class="tok-kw">const</span> server_secret = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, pv.handshake_secret, <span class="tok-str">&quot;s hs traffic&quot;</span>, &amp;hello_hash, P.Hash.digest_length);
                                        <span class="tok-kw">if</span> (options.ssl_key_log_file) |key_log_file| <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.logSecrets">logSecrets</a>(key_log_file, .{
                                            .client_random = &amp;client_hello_rand,
                                        }, .{
                                            .SERVER_HANDSHAKE_TRAFFIC_SECRET = &amp;server_secret,
                                            .CLIENT_HANDSHAKE_TRAFFIC_SECRET = &amp;client_secret,
                                        });
                                        pv.client_finished_key = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, client_secret, <span class="tok-str">&quot;finished&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.Hmac.key_length);
                                        pv.server_finished_key = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, server_secret, <span class="tok-str">&quot;finished&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.Hmac.key_length);
                                        pv.client_handshake_key = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, client_secret, <span class="tok-str">&quot;key&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.key_length);
                                        pv.server_handshake_key = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, server_secret, <span class="tok-str">&quot;key&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.key_length);
                                        pv.client_handshake_iv = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, client_secret, <span class="tok-str">&quot;iv&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.nonce_length);
                                        pv.server_handshake_iv = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, server_secret, <span class="tok-str">&quot;iv&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.nonce_length);
                                    },
                                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter,
                                }
                                pending_cipher_state = .handshake;
                                handshake_state = .encrypted_extensions;
                            },
                            .tls_1_2 =&gt; <span class="tok-kw">switch</span> (cipher_suite_tag) {
                                .ECDHE_RSA_WITH_AES_128_GCM_SHA256,
                                .ECDHE_RSA_WITH_AES_256_GCM_SHA384,
                                .ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
                                =&gt; handshake_state = .certificate,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter,
                            },
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter,
                        }
                    },
                    .encrypted_extensions =&gt; {
                        <span class="tok-kw">if</span> (tls_version != .tls_1_3) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">if</span> (cipher_state != .handshake) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">if</span> (handshake_state != .encrypted_extensions) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">switch</span> (handshake_cipher) {
                            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| p.transcript_hash.update(wrapped_handshake),
                        }
                        <span class="tok-kw">try</span> hsd.ensure(<span class="tok-number">2</span>);
                        <span class="tok-kw">const</span> total_ext_size = hsd.decode(<span class="tok-type">u16</span>);
                        <span class="tok-kw">var</span> all_extd = <span class="tok-kw">try</span> hsd.sub(total_ext_size);
                        <span class="tok-kw">while</span> (!all_extd.eof()) {
                            <span class="tok-kw">try</span> all_extd.ensure(<span class="tok-number">4</span>);
                            <span class="tok-kw">const</span> et = all_extd.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ExtensionType.html">ExtensionType</a>);
                            <span class="tok-kw">const</span> ext_size = all_extd.decode(<span class="tok-type">u16</span>);
                            <span class="tok-kw">const</span> extd = <span class="tok-kw">try</span> all_extd.sub(ext_size);
                            _ = extd;
                            <span class="tok-kw">switch</span> (et) {
                                .server_name =&gt; {},
                                <span class="tok-kw">else</span> =&gt; {},
                            }
                        }
                        handshake_state = .certificate;
                    },
                    .certificate =&gt; cert: {
                        <span class="tok-kw">if</span> (cipher_state == .application) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">switch</span> (handshake_state) {
                            .certificate =&gt; {},
                            .trust_chain_established =&gt; <span class="tok-kw">break</span> :cert,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage,
                        }
                        <span class="tok-kw">switch</span> (handshake_cipher) {
                            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| p.transcript_hash.update(wrapped_handshake),
                        }

                        <span class="tok-kw">switch</span> (tls_version) {
                            .tls_1_3 =&gt; {
                                <span class="tok-kw">try</span> hsd.ensure(<span class="tok-number">1</span> + <span class="tok-number">3</span>);
                                <span class="tok-kw">const</span> cert_req_ctx_len = hsd.decode(<span class="tok-type">u8</span>);
                                <span class="tok-kw">if</span> (cert_req_ctx_len != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter;
                            },
                            .tls_1_2 =&gt; <span class="tok-kw">try</span> hsd.ensure(<span class="tok-number">3</span>),
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        }
                        <span class="tok-kw">const</span> certs_size = hsd.decode(<span class="tok-type">u24</span>);
                        <span class="tok-kw">var</span> certs_decoder = <span class="tok-kw">try</span> hsd.sub(certs_size);
                        <span class="tok-kw">while</span> (!certs_decoder.eof()) {
                            <span class="tok-kw">try</span> certs_decoder.ensure(<span class="tok-number">3</span>);
                            <span class="tok-kw">const</span> cert_size = certs_decoder.decode(<span class="tok-type">u24</span>);
                            <span class="tok-kw">const</span> certd = <span class="tok-kw">try</span> certs_decoder.sub(cert_size);

                            <span class="tok-kw">if</span> (tls_version == .tls_1_3) {
                                <span class="tok-kw">try</span> certs_decoder.ensure(<span class="tok-number">2</span>);
                                <span class="tok-kw">const</span> total_ext_size = certs_decoder.decode(<span class="tok-type">u16</span>);
                                <span class="tok-kw">const</span> all_extd = <span class="tok-kw">try</span> certs_decoder.sub(total_ext_size);
                                _ = all_extd;
                            }

                            <span class="tok-kw">const</span> subject_cert: <a href="std.crypto.Certificate.html">Certificate</a> = .{
                                .buffer = certd.buf,
                                .index = <span class="tok-builtin">@intCast</span>(certd.idx),
                            };
                            <span class="tok-kw">const</span> subject = <span class="tok-kw">try</span> subject_cert.parse();
                            <span class="tok-kw">if</span> (cert_index == <span class="tok-number">0</span>) {<span class="tok-comment">
                                // Verify the host on the first certificate.
                                </span><span class="tok-kw">switch</span> (options.host) {
                                    .no_verification =&gt; {},
                                    .explicit =&gt; <span class="tok-kw">try</span> subject.verifyHostName(host),
                                }<span class="tok-comment">

                                // Keep track of the public key for the
                                // certificate_verify message later.
                                </span><span class="tok-kw">try</span> main_cert_pub_key.init(subject.pub_key_algo, subject.pubKey());
                            } <span class="tok-kw">else</span> {
                                <span class="tok-kw">try</span> prev_cert.verify(subject, now_sec);
                            }

                            <span class="tok-kw">switch</span> (options.ca) {
                                .no_verification =&gt; {
                                    handshake_state = .trust_chain_established;
                                    <span class="tok-kw">break</span> :cert;
                                },
                                .self_signed =&gt; {
                                    <span class="tok-kw">try</span> subject.verify(subject, now_sec);
                                    handshake_state = .trust_chain_established;
                                    <span class="tok-kw">break</span> :cert;
                                },
                                .bundle =&gt; |ca_bundle| <span class="tok-kw">if</span> (ca_bundle.verify(subject, now_sec)) |_| {
                                    handshake_state = .trust_chain_established;
                                    <span class="tok-kw">break</span> :cert;
                                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                                    <span class="tok-kw">error</span>.CertificateIssuerNotFound =&gt; {},
                                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
                                },
                            }

                            prev_cert = subject;
                            cert_index += <span class="tok-number">1</span>;
                        }
                        cert_buf_index += <span class="tok-number">1</span>;
                    },
                    .server_key_exchange =&gt; {
                        <span class="tok-kw">if</span> (tls_version != .tls_1_2) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">if</span> (cipher_state != .cleartext) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">switch</span> (handshake_state) {
                            .trust_chain_established =&gt; {},
                            .certificate =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsCertificateNotVerified,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage,
                        }

                        <span class="tok-kw">switch</span> (handshake_cipher) {
                            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| p.transcript_hash.update(wrapped_handshake),
                        }
                        <span class="tok-kw">try</span> hsd.ensure(<span class="tok-number">1</span> + <span class="tok-number">2</span> + <span class="tok-number">1</span>);
                        <span class="tok-kw">const</span> curve_type = hsd.decode(<span class="tok-type">u8</span>);
                        <span class="tok-kw">if</span> (curve_type != <span class="tok-number">0x03</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter;<span class="tok-comment"> // named_curve
                        </span><span class="tok-kw">const</span> named_group = hsd.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.NamedGroup.html">NamedGroup</a>);
                        <span class="tok-kw">const</span> key_size = hsd.decode(<span class="tok-type">u8</span>);
                        <span class="tok-kw">try</span> hsd.ensure(key_size);
                        <span class="tok-kw">const</span> server_pub_key = hsd.slice(key_size);
                        <span class="tok-kw">try</span> main_cert_pub_key.verifySignature(&amp;hsd, &amp;.{ &amp;client_hello_rand, &amp;server_hello_rand, hsd.buf[<span class="tok-number">0</span>..hsd.idx] });
                        <span class="tok-kw">try</span> key_share.exchange(named_group, server_pub_key);
                        handshake_state = .server_hello_done;
                    },
                    .server_hello_done =&gt; {
                        <span class="tok-kw">if</span> (tls_version != .tls_1_2) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">if</span> (cipher_state != .cleartext) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">if</span> (handshake_state != .server_hello_done) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;

                        <span class="tok-kw">const</span> client_key_exchange_msg = .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ContentType.html">ContentType</a>.<a href="#">handshake</a>)} ++
                            <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a>.<a href="#">tls_1_2</a>)) ++
                            <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <span class="tok-type">u8</span>, .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.HandshakeType.html">HandshakeType</a>.<a href="#">client_key_exchange</a>)} ++
                                <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u24</span>, <span class="tok-type">u8</span>, <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u8</span>, <span class="tok-type">u8</span>, key_share.secp256r1_kp.public_key.toUncompressedSec1())));
                        <span class="tok-kw">const</span> client_change_cipher_spec_msg = .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ContentType.html">ContentType</a>.<a href="#">change_cipher_spec</a>)} ++
                            <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a>.<a href="#">tls_1_2</a>)) ++
                            <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ChangeCipherSpecType.html">ChangeCipherSpecType</a>, .{.change_cipher_spec});
                        <span class="tok-kw">const</span> pre_master_secret = key_share.getSharedSecret().?;
                        <span class="tok-kw">switch</span> (handshake_cipher) {
                            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| {
                                <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*).A;
                                p.transcript_hash.update(wrapped_handshake);
                                p.transcript_hash.update(client_key_exchange_msg[<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>..]);
                                <span class="tok-kw">const</span> master_secret = <a href="std.crypto.tls.html#std.crypto.tls.hmacExpandLabel">hmacExpandLabel</a>(P.Hmac, pre_master_secret, &amp;.{
                                    <span class="tok-str">&quot;master secret&quot;</span>,
                                    &amp;client_hello_rand,
                                    &amp;server_hello_rand,
                                }, <span class="tok-number">48</span>);
                                <span class="tok-kw">if</span> (options.ssl_key_log_file) |key_log_file| <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.logSecrets">logSecrets</a>(key_log_file, .{
                                    .client_random = &amp;client_hello_rand,
                                }, .{
                                    .CLIENT_RANDOM = &amp;master_secret,
                                });
                                <span class="tok-kw">const</span> key_block = <a href="std.crypto.tls.html#std.crypto.tls.hmacExpandLabel">hmacExpandLabel</a>(
                                    P.Hmac,
                                    &amp;master_secret,
                                    &amp;.{ <span class="tok-str">&quot;key expansion&quot;</span>, &amp;server_hello_rand, &amp;client_hello_rand },
                                    <span class="tok-builtin">@sizeOf</span>(P.Tls_1_2),
                                );
                                <span class="tok-kw">const</span> client_verify_cleartext = .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.HandshakeType.html">HandshakeType</a>.<a href="#">finished</a>)} ++
                                    <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u24</span>, <span class="tok-type">u8</span>, <a href="std.crypto.tls.html#std.crypto.tls.hmacExpandLabel">hmacExpandLabel</a>(
                                        P.Hmac,
                                        &amp;master_secret,
                                        &amp;.{ <span class="tok-str">&quot;client finished&quot;</span>, &amp;p.transcript_hash.peek() },
                                        P.verify_data_length,
                                    ));
                                p.transcript_hash.update(&amp;client_verify_cleartext);
                                p.version = .{ .tls_1_2 = .{
                                    .expected_server_verify_data = <a href="std.crypto.tls.html#std.crypto.tls.hmacExpandLabel">hmacExpandLabel</a>(
                                        P.Hmac,
                                        &amp;master_secret,
                                        &amp;.{ <span class="tok-str">&quot;server finished&quot;</span>, &amp;p.transcript_hash.finalResult() },
                                        P.verify_data_length,
                                    ),
                                    .app_cipher = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesToValue">bytesToValue</a>(P.Tls_1_2, &amp;key_block),
                                } };
                                <span class="tok-kw">const</span> pv = &amp;p.version.tls_1_2;
                                <span class="tok-kw">const</span> nonce: [P.AEAD.nonce_length]<span class="tok-type">u8</span> = nonce: {
                                    <span class="tok-kw">const</span> V = <span class="tok-builtin">@Vector</span>(P.AEAD.nonce_length, <span class="tok-type">u8</span>);
                                    <span class="tok-kw">const</span> pad = [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** (P.AEAD.nonce_length - <span class="tok-number">8</span>);
                                    <span class="tok-kw">const</span> operand: V = pad ++ <span class="tok-builtin">@as</span>([<span class="tok-number">8</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(<a href="std.crypto.tls.Client.html#std.crypto.tls.Client.big">big</a>(write_seq)));
                                    <span class="tok-kw">break</span> :nonce <span class="tok-builtin">@as</span>(V, pv.app_cipher.client_write_IV ++ pv.app_cipher.client_salt) ^ operand;
                                };
                                <span class="tok-kw">var</span> client_verify_msg = .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ContentType.html">ContentType</a>.<a href="#">handshake</a>)} ++
                                    <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a>.<a href="#">tls_1_2</a>)) ++
                                    <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <span class="tok-type">u8</span>, nonce[P.fixed_iv_length..].* ++
                                        <span class="tok-builtin">@as</span>([client_verify_cleartext.len + P.mac_length]<span class="tok-type">u8</span>, <span class="tok-null">undefined</span>));
                                P.AEAD.encrypt(
                                    client_verify_msg[client_verify_msg.len - P.mac_length -
                                        client_verify_cleartext.len ..][<span class="tok-number">0</span>..client_verify_cleartext.len],
                                    client_verify_msg[client_verify_msg.len - P.mac_length ..][<span class="tok-number">0</span>..P.mac_length],
                                    &amp;client_verify_cleartext,
                                    <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.toBytes">toBytes</a>(<a href="std.crypto.tls.Client.html#std.crypto.tls.Client.big">big</a>(write_seq)) ++ client_verify_msg[<span class="tok-number">0</span> .. <span class="tok-number">1</span> + <span class="tok-number">2</span>] ++ <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, client_verify_cleartext.len),
                                    nonce,
                                    pv.app_cipher.client_write_key,
                                );
                                <span class="tok-kw">const</span> all_msgs = client_key_exchange_msg ++ client_change_cipher_spec_msg ++ client_verify_msg;
                                <span class="tok-kw">var</span> all_msgs_vec = [_]<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>{
                                    .{ .base = &amp;all_msgs, .len = all_msgs.len },
                                };
                                <span class="tok-kw">try</span> stream.writevAll(&amp;all_msgs_vec);
                            },
                        }
                        write_seq += <span class="tok-number">1</span>;
                        pending_cipher_state = .application;
                        handshake_state = .finished;
                    },
                    .certificate_verify =&gt; {
                        <span class="tok-kw">if</span> (tls_version != .tls_1_3) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">if</span> (cipher_state != .handshake) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">switch</span> (handshake_state) {
                            .trust_chain_established =&gt; {},
                            .certificate =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsCertificateNotVerified,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage,
                        }
                        <span class="tok-kw">switch</span> (handshake_cipher) {
                            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| {
                                <span class="tok-kw">try</span> main_cert_pub_key.verifySignature(&amp;hsd, &amp;.{
                                    <span class="tok-str">&quot; &quot;</span> ** <span class="tok-number">64</span> ++ <span class="tok-str">&quot;TLS 1.3, server CertificateVerify\x00&quot;</span>,
                                    &amp;p.transcript_hash.peek(),
                                });
                                p.transcript_hash.update(wrapped_handshake);
                            },
                        }
                        handshake_state = .finished;
                    },
                    .finished =&gt; {
                        <span class="tok-kw">if</span> (cipher_state == .cleartext) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">if</span> (handshake_state != .finished) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;<span class="tok-comment">
                        // This message is to trick buggy proxies into behaving correctly.
                        </span><span class="tok-kw">const</span> client_change_cipher_spec_msg = .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ContentType.html">ContentType</a>.<a href="#">change_cipher_spec</a>)} ++
                            <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a>.<a href="#">tls_1_2</a>)) ++
                            <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ChangeCipherSpecType.html">ChangeCipherSpecType</a>, .{.change_cipher_spec});
                        <span class="tok-kw">const</span> app_cipher = app_cipher: <span class="tok-kw">switch</span> (handshake_cipher) {
                            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p, tag| <span class="tok-kw">switch</span> (tls_version) {
                                .tls_1_3 =&gt; {
                                    <span class="tok-kw">const</span> pv = &amp;p.version.tls_1_3;
                                    <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*).A;
                                    <span class="tok-kw">try</span> hsd.ensure(P.Hmac.mac_length);
                                    <span class="tok-kw">const</span> finished_digest = p.transcript_hash.peek();
                                    p.transcript_hash.update(wrapped_handshake);
                                    <span class="tok-kw">const</span> expected_server_verify_data = <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.hmac">hmac</a>(P.Hmac, &amp;finished_digest, pv.server_finished_key);
                                    <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>.<a href="std.crypto.timing_safe.html">timing_safe</a>.<a href="std.crypto.timing_safe.html#std.crypto.timing_safe.eql">eql</a>([P.Hmac.mac_length]<span class="tok-type">u8</span>, expected_server_verify_data, hsd.array(P.Hmac.mac_length).*)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsDecryptError;
                                    <span class="tok-kw">const</span> handshake_hash = p.transcript_hash.finalResult();
                                    <span class="tok-kw">const</span> verify_data = <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.hmac">hmac</a>(P.Hmac, &amp;handshake_hash, pv.client_finished_key);
                                    <span class="tok-kw">const</span> out_cleartext = .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.HandshakeType.html">HandshakeType</a>.<a href="#">finished</a>)} ++
                                        <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u24</span>, <span class="tok-type">u8</span>, verify_data) ++
                                        .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ContentType.html">ContentType</a>.<a href="#">handshake</a>)};

                                    <span class="tok-kw">const</span> wrapped_len = out_cleartext.len + P.AEAD.tag_length;

                                    <span class="tok-kw">var</span> finished_msg = .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ContentType.html">ContentType</a>.<a href="#">application_data</a>)} ++
                                        <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a>.<a href="#">tls_1_2</a>)) ++
                                        <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <span class="tok-type">u8</span>, <span class="tok-builtin">@as</span>([wrapped_len]<span class="tok-type">u8</span>, <span class="tok-null">undefined</span>));

                                    <span class="tok-kw">const</span> ad = finished_msg[<span class="tok-number">0</span>..<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>];
                                    <span class="tok-kw">const</span> ciphertext = finished_msg[<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>..][<span class="tok-number">0</span>..out_cleartext.len];
                                    <span class="tok-kw">const</span> auth_tag = finished_msg[finished_msg.len - P.AEAD.tag_length ..];
                                    <span class="tok-kw">const</span> nonce = pv.client_handshake_iv;
                                    P.AEAD.encrypt(ciphertext, auth_tag, &amp;out_cleartext, ad, nonce, pv.client_handshake_key);

                                    <span class="tok-kw">const</span> all_msgs = client_change_cipher_spec_msg ++ finished_msg;
                                    <span class="tok-kw">var</span> all_msgs_vec = [_]<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>{
                                        .{ .base = &amp;all_msgs, .len = all_msgs.len },
                                    };
                                    <span class="tok-kw">try</span> stream.writevAll(&amp;all_msgs_vec);

                                    <span class="tok-kw">const</span> client_secret = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, pv.master_secret, <span class="tok-str">&quot;c ap traffic&quot;</span>, &amp;handshake_hash, P.Hash.digest_length);
                                    <span class="tok-kw">const</span> server_secret = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, pv.master_secret, <span class="tok-str">&quot;s ap traffic&quot;</span>, &amp;handshake_hash, P.Hash.digest_length);
                                    <span class="tok-kw">if</span> (options.ssl_key_log_file) |key_log_file| <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.logSecrets">logSecrets</a>(key_log_file, .{
                                        .counter = key_seq,
                                        .client_random = &amp;client_hello_rand,
                                    }, .{
                                        .SERVER_TRAFFIC_SECRET = &amp;server_secret,
                                        .CLIENT_TRAFFIC_SECRET = &amp;client_secret,
                                    });
                                    key_seq += <span class="tok-number">1</span>;
                                    <span class="tok-kw">break</span> :app_cipher <span class="tok-builtin">@unionInit</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ApplicationCipher.html">ApplicationCipher</a>, <span class="tok-builtin">@tagName</span>(tag), .{ .tls_1_3 = .{
                                        .client_secret = client_secret,
                                        .server_secret = server_secret,
                                        .client_key = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, client_secret, <span class="tok-str">&quot;key&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.key_length),
                                        .server_key = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, server_secret, <span class="tok-str">&quot;key&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.key_length),
                                        .client_iv = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, client_secret, <span class="tok-str">&quot;iv&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.nonce_length),
                                        .server_iv = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, server_secret, <span class="tok-str">&quot;iv&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.nonce_length),
                                    } });
                                },
                                .tls_1_2 =&gt; {
                                    <span class="tok-kw">const</span> pv = &amp;p.version.tls_1_2;
                                    <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*).A;
                                    <span class="tok-kw">try</span> hsd.ensure(P.verify_data_length);
                                    <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>.<a href="std.crypto.timing_safe.html">timing_safe</a>.<a href="std.crypto.timing_safe.html#std.crypto.timing_safe.eql">eql</a>([P.verify_data_length]<span class="tok-type">u8</span>, pv.expected_server_verify_data, hsd.array(P.verify_data_length).*)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsDecryptError;
                                    <span class="tok-kw">break</span> :app_cipher <span class="tok-builtin">@unionInit</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ApplicationCipher.html">ApplicationCipher</a>, <span class="tok-builtin">@tagName</span>(tag), .{ .tls_1_2 = pv.app_cipher });
                                },
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                        };
                        <span class="tok-kw">const</span> leftover = d.rest();
                        <span class="tok-kw">var</span> client: <a href="std.crypto.tls.Client.html">Client</a> = .{
                            .tls_version = tls_version,
                            .read_seq = <span class="tok-kw">switch</span> (tls_version) {
                                .tls_1_3 =&gt; <span class="tok-number">0</span>,
                                .tls_1_2 =&gt; read_seq,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                            .write_seq = <span class="tok-kw">switch</span> (tls_version) {
                                .tls_1_3 =&gt; <span class="tok-number">0</span>,
                                .tls_1_2 =&gt; write_seq,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                            .partial_cleartext_idx = <span class="tok-number">0</span>,
                            .partial_ciphertext_idx = <span class="tok-number">0</span>,
                            .partial_ciphertext_end = <span class="tok-builtin">@intCast</span>(leftover.len),
                            .received_close_notify = <span class="tok-null">false</span>,
                            .allow_truncation_attacks = <span class="tok-null">false</span>,
                            .application_cipher = app_cipher,
                            .partially_read_buffer = <span class="tok-null">undefined</span>,
                            .ssl_key_log = <span class="tok-kw">if</span> (options.ssl_key_log_file) |key_log_file| .{
                                .client_key_seq = key_seq,
                                .server_key_seq = key_seq,
                                .client_random = client_hello_rand,
                                .file = key_log_file,
                            } <span class="tok-kw">else</span> <span class="tok-null">null</span>,
                        };
                        <span class="tok-builtin">@memcpy</span>(client.partially_read_buffer[<span class="tok-number">0</span>..leftover.len], leftover);
                        <span class="tok-kw">return</span> client;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage,
                }
                <span class="tok-kw">if</span> (ctd.eof()) <span class="tok-kw">break</span>;
                cleartext_fragment_start = ctd.idx;
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage,
        }
        cleartext_fragment_start = <span class="tok-number">0</span>;
        cleartext_fragment_end = <span class="tok-number">0</span>;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.tls.Client.write" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">write</span><a href="#src.zig-std.crypto.tls.Client.write">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Sends TLS-encrypted data to <code>stream</code>, which must conform to <code><a href="std.crypto.tls.Client.StreamInterface.html">StreamInterface</a></code>.
Returns the number of cleartext bytes sent, which may be fewer than <code>bytes.len</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>c: *<a href="std.crypto.tls.Client.html">Client</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.tls.Client.write">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.writeEnd">writeEnd</a>(c, stream, bytes, <span class="tok-null">false</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.tls.Client.writeAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeAll</span><a href="#src.zig-std.crypto.tls.Client.writeAll">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAll</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sends TLS-encrypted data to <code>stream</code>, which must conform to <code><a href="std.crypto.tls.Client.StreamInterface.html">StreamInterface</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>c: *<a href="std.crypto.tls.Client.html">Client</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.tls.Client.writeAll">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAll</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (index &lt; bytes.len) {
        index += <span class="tok-kw">try</span> c.write(stream, bytes[index..]);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.tls.Client.writeAllEnd" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeAllEnd</span><a href="#src.zig-std.crypto.tls.Client.writeAllEnd">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAllEnd</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, end: <span class="tok-type">bool</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sends TLS-encrypted data to <code>stream</code>, which must conform to <code><a href="std.crypto.tls.Client.StreamInterface.html">StreamInterface</a></code>.
If <code>end</code> is true, then this function additionally sends a <code>close_notify</code> alert,
which is necessary for the server to distinguish between a properly finished
TLS session, or a truncation attack.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>c: *<a href="std.crypto.tls.Client.html">Client</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>end: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.tls.Client.writeAllEnd">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAllEnd</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, end: <span class="tok-type">bool</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (index &lt; bytes.len) {
        index += <span class="tok-kw">try</span> c.writeEnd(stream, bytes[index..], end);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.tls.Client.writeEnd" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeEnd</span><a href="#src.zig-std.crypto.tls.Client.writeEnd">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeEnd</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, end: <span class="tok-type">bool</span>) !<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Sends TLS-encrypted data to <code>stream</code>, which must conform to <code><a href="std.crypto.tls.Client.StreamInterface.html">StreamInterface</a></code>.
Returns the number of cleartext bytes sent, which may be fewer than <code>bytes.len</code>.
If <code>end</code> is true, then this function additionally sends a <code>close_notify</code> alert,
which is necessary for the server to distinguish between a properly finished
TLS session, or a truncation attack.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>c: *<a href="std.crypto.tls.Client.html">Client</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>end: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.tls.Client.writeEnd">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeEnd</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, end: <span class="tok-type">bool</span>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> ciphertext_buf: [<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_record_len">max_ciphertext_record_len</a> * <span class="tok-number">4</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> iovecs_buf: [<span class="tok-number">6</span>]<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> prepared = <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.prepareCiphertextRecord">prepareCiphertextRecord</a>(c, &amp;iovecs_buf, &amp;ciphertext_buf, bytes, .application_data);
    <span class="tok-kw">if</span> (end) {
        prepared.iovec_end += <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.prepareCiphertextRecord">prepareCiphertextRecord</a>(
            c,
            iovecs_buf[prepared.iovec_end..],
            ciphertext_buf[prepared.ciphertext_end..],
            &amp;<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.close_notify_alert">close_notify_alert</a>,
            .alert,
        ).iovec_end;
    }

    <span class="tok-kw">const</span> iovec_end = prepared.iovec_end;
    <span class="tok-kw">const</span> overhead_len = prepared.overhead_len;<span class="tok-comment">

    // Ideally we would call writev exactly once here, however, we must ensure
    // that we don't return with a record partially written.
    </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> total_amt: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">var</span> amt = <span class="tok-kw">try</span> stream.writev(iovecs_buf[i..iovec_end]);
        <span class="tok-kw">while</span> (amt &gt;= iovecs_buf[i].len) {
            <span class="tok-kw">const</span> encrypted_amt = iovecs_buf[i].len;
            total_amt += encrypted_amt - overhead_len;
            amt -= encrypted_amt;
            i += <span class="tok-number">1</span>;<span class="tok-comment">
            // Rely on the property that iovecs delineate records, meaning that
            // if amt equals zero here, we have fortunately found ourselves
            // with a short read that aligns at the record boundary.
            </span><span class="tok-kw">if</span> (i &gt;= iovec_end) <span class="tok-kw">return</span> total_amt;<span class="tok-comment">
            // We also cannot return on a vector boundary if the final close_notify is
            // not sent; otherwise the caller would not know to retry the call.
            </span><span class="tok-kw">if</span> (amt == <span class="tok-number">0</span> <span class="tok-kw">and</span> (!end <span class="tok-kw">or</span> i &lt; iovec_end - <span class="tok-number">1</span>)) <span class="tok-kw">return</span> total_amt;
        }
        iovecs_buf[i].base += amt;
        iovecs_buf[i].len -= amt;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.tls.Client.eof" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">eof</span><a href="#src.zig-std.crypto.tls.Client.eof">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eof</span>(c: <a href="std.crypto.tls.Client.html">Client</a>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>c: <a href="std.crypto.tls.Client.html">Client</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.tls.Client.eof">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eof</span>(c: <a href="std.crypto.tls.Client.html">Client</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> c.received_close_notify <span class="tok-kw">and</span>
        c.partial_cleartext_idx &gt;= c.partial_ciphertext_idx <span class="tok-kw">and</span>
        c.partial_ciphertext_idx &gt;= c.partial_ciphertext_end;
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.tls.Client.readAtLeast" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readAtLeast</span><a href="#src.zig-std.crypto.tls.Client.readAtLeast">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readAtLeast</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, buffer: []<span class="tok-type">u8</span>, len: <span class="tok-type">usize</span>) !<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Receives TLS-encrypted data from <code>stream</code>, which must conform to <code><a href="std.crypto.tls.Client.StreamInterface.html">StreamInterface</a></code>.
Returns the number of bytes read, calling the underlying read function the
minimal number of times until the buffer has at least <code>len</code> bytes filled.
If the number read is less than <code>len</code> it means the stream reached the end.
Reaching the end of the stream is not an error condition.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>c: *<a href="std.crypto.tls.Client.html">Client</a></code></pre></div><div><pre><code>buffer: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.tls.Client.readAtLeast">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readAtLeast</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, buffer: []<span class="tok-type">u8</span>, len: <span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> iovecs = [<span class="tok-number">1</span>]<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>{.{ .base = buffer.ptr, .len = buffer.len }};
    <span class="tok-kw">return</span> <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.readvAtLeast">readvAtLeast</a>(c, stream, &amp;iovecs, len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.tls.Client.read" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">read</span><a href="#src.zig-std.crypto.tls.Client.read">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, buffer: []<span class="tok-type">u8</span>) !<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Receives TLS-encrypted data from <code>stream</code>, which must conform to <code><a href="std.crypto.tls.Client.StreamInterface.html">StreamInterface</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>c: *<a href="std.crypto.tls.Client.html">Client</a></code></pre></div><div><pre><code>buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.tls.Client.read">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, buffer: []<span class="tok-type">u8</span>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.readAtLeast">readAtLeast</a>(c, stream, buffer, <span class="tok-number">1</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.tls.Client.readAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readAll</span><a href="#src.zig-std.crypto.tls.Client.readAll">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readAll</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, buffer: []<span class="tok-type">u8</span>) !<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Receives TLS-encrypted data from <code>stream</code>, which must conform to <code><a href="std.crypto.tls.Client.StreamInterface.html">StreamInterface</a></code>.
Returns the number of bytes read. If the number read is smaller than
<code>buffer.len</code>, it means the stream reached the end. Reaching the end of the
stream is not an error condition.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>c: *<a href="std.crypto.tls.Client.html">Client</a></code></pre></div><div><pre><code>buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.tls.Client.readAll">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readAll</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, buffer: []<span class="tok-type">u8</span>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.readAtLeast">readAtLeast</a>(c, stream, buffer, buffer.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.tls.Client.readv" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readv</span><a href="#src.zig-std.crypto.tls.Client.readv">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readv</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, iovecs: []<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>) !<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Receives TLS-encrypted data from <code>stream</code>, which must conform to <code><a href="std.crypto.tls.Client.StreamInterface.html">StreamInterface</a></code>.
Returns the number of bytes read. If the number read is less than the space
provided it means the stream reached the end. Reaching the end of the
stream is not an error condition.
The <code>iovecs</code> parameter is mutable because this function needs to mutate the fields in
order to handle partial reads from the underlying stream layer.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>c: *<a href="std.crypto.tls.Client.html">Client</a></code></pre></div><div><pre><code>iovecs: []<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.tls.Client.readv">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readv</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, iovecs: []<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.readvAtLeast">readvAtLeast</a>(c, stream, iovecs, <span class="tok-number">1</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.tls.Client.readvAtLeast" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readvAtLeast</span><a href="#src.zig-std.crypto.tls.Client.readvAtLeast">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readvAtLeast</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, iovecs: []<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>, len: <span class="tok-type">usize</span>) !<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Receives TLS-encrypted data from <code>stream</code>, which must conform to <code><a href="std.crypto.tls.Client.StreamInterface.html">StreamInterface</a></code>.
Returns the number of bytes read, calling the underlying read function the
minimal number of times until the iovecs have at least <code>len</code> bytes filled.
If the number read is less than <code>len</code> it means the stream reached the end.
Reaching the end of the stream is not an error condition.
The <code>iovecs</code> parameter is mutable because this function needs to mutate the fields in
order to handle partial reads from the underlying stream layer.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>c: *<a href="std.crypto.tls.Client.html">Client</a></code></pre></div><div><pre><code>iovecs: []<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.tls.Client.readvAtLeast">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readvAtLeast</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, iovecs: []<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>, len: <span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (c.eof()) <span class="tok-kw">return</span> <span class="tok-number">0</span>;

    <span class="tok-kw">var</span> off_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> vec_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">var</span> amt = <span class="tok-kw">try</span> c.readvAdvanced(stream, iovecs[vec_i..]);
        off_i += amt;
        <span class="tok-kw">if</span> (c.eof() <span class="tok-kw">or</span> off_i &gt;= len) <span class="tok-kw">return</span> off_i;
        <span class="tok-kw">while</span> (amt &gt;= iovecs[vec_i].len) {
            amt -= iovecs[vec_i].len;
            vec_i += <span class="tok-number">1</span>;
        }
        iovecs[vec_i].base += amt;
        iovecs[vec_i].len -= amt;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.tls.Client.readvAdvanced" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readvAdvanced</span><a href="#src.zig-std.crypto.tls.Client.readvAdvanced">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readvAdvanced</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, iovecs: []<span class="tok-kw">const</span> <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>) !<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Receives TLS-encrypted data from <code>stream</code>, which must conform to <code><a href="std.crypto.tls.Client.StreamInterface.html">StreamInterface</a></code>.
Returns number of bytes that have been read, populated inside <code>iovecs</code>. A
return value of zero bytes does not mean end of stream. Instead, check the <code>eof()</code>
for the end of stream. The <code>eof()</code> may be true after any call to
<code><a href="std.crypto.tls.Client.html#std.crypto.tls.Client.read">read</a></code>, including when greater than zero bytes are returned, and this
function asserts that <code>eof()</code> is <code>false</code>.
See <code><a href="std.crypto.tls.Client.html#std.crypto.tls.Client.readv">readv</a></code> for a higher level function that has the same, familiar API as
other read functions, such as <code><a href="std.fs.File.html#std.fs.File.read">std.fs.File.read</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>c: *<a href="std.crypto.tls.Client.html">Client</a></code></pre></div><div><pre><code>iovecs: []<span class="tok-kw">const</span> <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.tls.Client.readvAdvanced">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readvAdvanced</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, iovecs: []<span class="tok-kw">const</span> <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> vp: <a href="std.crypto.tls.Client.VecPut.html">VecPut</a> = .{ .iovecs = iovecs };<span class="tok-comment">

    // Give away the buffered cleartext we have, if any.
    </span><span class="tok-kw">const</span> partial_cleartext = c.partially_read_buffer[c.partial_cleartext_idx..c.partial_ciphertext_idx];
    <span class="tok-kw">if</span> (partial_cleartext.len &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> amt: <span class="tok-type">u15</span> = <span class="tok-builtin">@intCast</span>(vp.put(partial_cleartext));
        c.partial_cleartext_idx += amt;

        <span class="tok-kw">if</span> (c.partial_cleartext_idx == c.partial_ciphertext_idx <span class="tok-kw">and</span>
            c.partial_ciphertext_end == c.partial_ciphertext_idx)
        {<span class="tok-comment">
            // The buffer is now empty.
            </span>c.partial_cleartext_idx = <span class="tok-number">0</span>;
            c.partial_ciphertext_idx = <span class="tok-number">0</span>;
            c.partial_ciphertext_end = <span class="tok-number">0</span>;
        }

        <span class="tok-kw">if</span> (c.received_close_notify) {
            c.partial_ciphertext_end = <span class="tok-number">0</span>;
            <a href="std.debug.html#std.debug.assert">assert</a>(vp.total == amt);
            <span class="tok-kw">return</span> amt;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (amt &gt; <span class="tok-number">0</span>) {<span class="tok-comment">
            // We don't need more data, so don't call read.
            </span><a href="std.debug.html#std.debug.assert">assert</a>(vp.total == amt);
            <span class="tok-kw">return</span> amt;
        }
    }

    <a href="std.debug.html#std.debug.assert">assert</a>(!c.received_close_notify);<span class="tok-comment">

    // Ideally, this buffer would never be used. It is needed when `iovecs` are
    // too small to fit the cleartext, which may be as large as `max_ciphertext_len`.
    </span><span class="tok-kw">var</span> cleartext_stack_buffer: [<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_len">max_ciphertext_len</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">
    // Temporarily stores ciphertext before decrypting it and giving it to `iovecs`.
    </span><span class="tok-kw">var</span> in_stack_buffer: [<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_len">max_ciphertext_len</a> * <span class="tok-number">4</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">
    // How many bytes left in the user's buffer.
    </span><span class="tok-kw">const</span> free_size = vp.freeSize();<span class="tok-comment">
    // The amount of the user's buffer that we need to repurpose for storing
    // ciphertext. The end of the buffer will be used for such purposes.
    </span><span class="tok-kw">const</span> ciphertext_buf_len = (free_size / <span class="tok-number">2</span>) -| in_stack_buffer.len;<span class="tok-comment">
    // The amount of the user's buffer that will be used to give cleartext. The
    // beginning of the buffer will be used for such purposes.
    </span><span class="tok-kw">const</span> cleartext_buf_len = free_size - ciphertext_buf_len;<span class="tok-comment">

    // Recoup `partially_read_buffer` space. This is necessary because it is assumed
    // below that `frag0` is big enough to hold at least one record.
    </span><a href="std.crypto.tls.Client.html#std.crypto.tls.Client.limitedOverlapCopy">limitedOverlapCopy</a>(c.partially_read_buffer[<span class="tok-number">0</span>..c.partial_ciphertext_end], c.partial_ciphertext_idx);
    c.partial_ciphertext_end -= c.partial_ciphertext_idx;
    c.partial_ciphertext_idx = <span class="tok-number">0</span>;
    c.partial_cleartext_idx = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> first_iov = c.partially_read_buffer[c.partial_ciphertext_end..];

    <span class="tok-kw">var</span> ask_iovecs_buf: [<span class="tok-number">2</span>]<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a> = .{
        .{
            .base = first_iov.ptr,
            .len = first_iov.len,
        },
        .{
            .base = &amp;in_stack_buffer,
            .len = in_stack_buffer.len,
        },
    };<span class="tok-comment">

    // Cleartext capacity of output buffer, in records. Minimum one full record.
    </span><span class="tok-kw">const</span> buf_cap = <span class="tok-builtin">@max</span>(cleartext_buf_len / <a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_len">max_ciphertext_len</a>, <span class="tok-number">1</span>);
    <span class="tok-kw">const</span> wanted_read_len = buf_cap * (<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_len">max_ciphertext_len</a> + <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>);
    <span class="tok-kw">const</span> ask_len = <span class="tok-builtin">@max</span>(wanted_read_len, cleartext_stack_buffer.len) - c.partial_ciphertext_end;
    <span class="tok-kw">const</span> ask_iovecs = <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.limitVecs">limitVecs</a>(&amp;ask_iovecs_buf, ask_len);
    <span class="tok-kw">const</span> actual_read_len = <span class="tok-kw">try</span> stream.readv(ask_iovecs);
    <span class="tok-kw">if</span> (actual_read_len == <span class="tok-number">0</span>) {<span class="tok-comment">
        // This is either a truncation attack, a bug in the server, or an
        // intentional omission of the close_notify message due to truncation
        // detection handled above the TLS layer.
        </span><span class="tok-kw">if</span> (c.allow_truncation_attacks) {
            c.received_close_notify = <span class="tok-null">true</span>;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsConnectionTruncated;
        }
    }<span class="tok-comment">

    // There might be more bytes inside `in_stack_buffer` that need to be processed,
    // but at least frag0 will have one complete ciphertext record.
    </span><span class="tok-kw">const</span> frag0_end = <span class="tok-builtin">@min</span>(c.partially_read_buffer.len, c.partial_ciphertext_end + actual_read_len);
    <span class="tok-kw">const</span> frag0 = c.partially_read_buffer[c.partial_ciphertext_idx..frag0_end];
    <span class="tok-kw">var</span> frag1 = in_stack_buffer[<span class="tok-number">0</span>..actual_read_len -| first_iov.len];<span class="tok-comment">
    // We need to decipher frag0 and frag1 but there may be a ciphertext record
    // straddling the boundary. We can handle this with two memcpy() calls to
    // assemble the straddling record in between handling the two sides.
    </span><span class="tok-kw">var</span> frag = frag0;
    <span class="tok-kw">var</span> in: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">if</span> (in == frag.len) {<span class="tok-comment">
            // Perfect split.
            </span><span class="tok-kw">if</span> (frag.ptr == frag1.ptr) {
                c.partial_ciphertext_end = c.partial_ciphertext_idx;
                <span class="tok-kw">return</span> vp.total;
            }
            frag = frag1;
            in = <span class="tok-number">0</span>;
            <span class="tok-kw">continue</span>;
        }

        <span class="tok-kw">if</span> (in + <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a> &gt; frag.len) {
            <span class="tok-kw">if</span> (frag.ptr == frag1.ptr)
                <span class="tok-kw">return</span> <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.finishRead">finishRead</a>(c, frag, in, vp.total);

            <span class="tok-kw">const</span> first = frag[in..];

            <span class="tok-kw">if</span> (frag1.len &lt; <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>)
                <span class="tok-kw">return</span> <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.finishRead2">finishRead2</a>(c, first, frag1, vp.total);<span class="tok-comment">

            // A record straddles the two fragments. Copy into the now-empty first fragment.
            </span><span class="tok-kw">const</span> record_len_byte_0: <span class="tok-type">u16</span> = <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.straddleByte">straddleByte</a>(frag, frag1, in + <span class="tok-number">3</span>);
            <span class="tok-kw">const</span> record_len_byte_1: <span class="tok-type">u16</span> = <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.straddleByte">straddleByte</a>(frag, frag1, in + <span class="tok-number">4</span>);
            <span class="tok-kw">const</span> record_len = (record_len_byte_0 &lt;&lt; <span class="tok-number">8</span>) | record_len_byte_1;
            <span class="tok-kw">if</span> (record_len &gt; <a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_len">max_ciphertext_len</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsRecordOverflow;

            <span class="tok-kw">const</span> full_record_len = record_len + <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>;
            <span class="tok-kw">const</span> second_len = full_record_len - first.len;
            <span class="tok-kw">if</span> (frag1.len &lt; second_len)
                <span class="tok-kw">return</span> <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.finishRead2">finishRead2</a>(c, first, frag1, vp.total);

            <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.limitedOverlapCopy">limitedOverlapCopy</a>(frag, in);
            <span class="tok-builtin">@memcpy</span>(frag[first.len..][<span class="tok-number">0</span>..second_len], frag1[<span class="tok-number">0</span>..second_len]);
            frag = frag[<span class="tok-number">0</span>..full_record_len];
            frag1 = frag1[second_len..];
            in = <span class="tok-number">0</span>;
            <span class="tok-kw">continue</span>;
        }
        <span class="tok-kw">const</span> ct: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ContentType.html">ContentType</a> = <span class="tok-builtin">@enumFromInt</span>(frag[in]);
        in += <span class="tok-number">1</span>;
        <span class="tok-kw">const</span> legacy_version = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u16</span>, frag[in..][<span class="tok-number">0</span>..<span class="tok-number">2</span>], .big);
        in += <span class="tok-number">2</span>;
        _ = legacy_version;
        <span class="tok-kw">const</span> record_len = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u16</span>, frag[in..][<span class="tok-number">0</span>..<span class="tok-number">2</span>], .big);
        <span class="tok-kw">if</span> (record_len &gt; <a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_len">max_ciphertext_len</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsRecordOverflow;
        in += <span class="tok-number">2</span>;
        <span class="tok-kw">const</span> end = in + record_len;
        <span class="tok-kw">if</span> (end &gt; frag.len) {<span class="tok-comment">
            // We need the record header on the next iteration of the loop.
            </span>in -= <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>;

            <span class="tok-kw">if</span> (frag.ptr == frag1.ptr)
                <span class="tok-kw">return</span> <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.finishRead">finishRead</a>(c, frag, in, vp.total);<span class="tok-comment">

            // A record straddles the two fragments. Copy into the now-empty first fragment.
            </span><span class="tok-kw">const</span> first = frag[in..];
            <span class="tok-kw">const</span> full_record_len = record_len + <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>;
            <span class="tok-kw">const</span> second_len = full_record_len - first.len;
            <span class="tok-kw">if</span> (frag1.len &lt; second_len)
                <span class="tok-kw">return</span> <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.finishRead2">finishRead2</a>(c, first, frag1, vp.total);

            <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.limitedOverlapCopy">limitedOverlapCopy</a>(frag, in);
            <span class="tok-builtin">@memcpy</span>(frag[first.len..][<span class="tok-number">0</span>..second_len], frag1[<span class="tok-number">0</span>..second_len]);
            frag = frag[<span class="tok-number">0</span>..full_record_len];
            frag1 = frag1[second_len..];
            in = <span class="tok-number">0</span>;
            <span class="tok-kw">continue</span>;
        }
        <span class="tok-kw">const</span> cleartext, <span class="tok-kw">const</span> inner_ct: tls.ContentType = cleartext: <span class="tok-kw">switch</span> (c.application_cipher) {
            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| <span class="tok-kw">switch</span> (c.tls_version) {
                .tls_1_3 =&gt; {
                    <span class="tok-kw">const</span> pv = &amp;p.tls_1_3;
                    <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*);
                    <span class="tok-kw">const</span> ad = frag[in - tls.record_header_len ..][<span class="tok-number">0</span>..tls.record_header_len];
                    <span class="tok-kw">const</span> ciphertext_len = record_len - P.AEAD.tag_length;
                    <span class="tok-kw">const</span> ciphertext = frag[in..][<span class="tok-number">0</span>..ciphertext_len];
                    in += ciphertext_len;
                    <span class="tok-kw">const</span> auth_tag = frag[in..][<span class="tok-number">0</span>..P.AEAD.tag_length].*;
                    <span class="tok-kw">const</span> nonce = nonce: {
                        <span class="tok-kw">const</span> V = <span class="tok-builtin">@Vector</span>(P.AEAD.nonce_length, <span class="tok-type">u8</span>);
                        <span class="tok-kw">const</span> pad = [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** (P.AEAD.nonce_length - <span class="tok-number">8</span>);
                        <span class="tok-kw">const</span> operand: V = pad ++ std.mem.toBytes(big(c.read_seq));
                        <span class="tok-kw">break</span> :nonce <span class="tok-builtin">@as</span>(V, pv.server_iv) ^ operand;
                    };
                    <span class="tok-kw">const</span> out_buf = vp.peek();
                    <span class="tok-kw">const</span> cleartext_buf = <span class="tok-kw">if</span> (ciphertext.len &lt;= out_buf.len)
                        out_buf
                    <span class="tok-kw">else</span>
                        &amp;cleartext_stack_buffer;
                    <span class="tok-kw">const</span> cleartext = cleartext_buf[<span class="tok-number">0</span>..ciphertext.len];
                    P.AEAD.decrypt(cleartext, ciphertext, auth_tag, ad, nonce, pv.server_key) <span class="tok-kw">catch</span>
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsBadRecordMac;
                    <span class="tok-kw">const</span> msg = mem.trimRight(<span class="tok-type">u8</span>, cleartext, <span class="tok-str">&quot;\x00&quot;</span>);
                    <span class="tok-kw">break</span> :cleartext .{ msg[<span class="tok-number">0</span> .. msg.len - <span class="tok-number">1</span>], <span class="tok-builtin">@enumFromInt</span>(msg[msg.len - <span class="tok-number">1</span>]) };
                },
                .tls_1_2 =&gt; {
                    <span class="tok-kw">const</span> pv = &amp;p.tls_1_2;
                    <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*);
                    <span class="tok-kw">const</span> message_len: <span class="tok-type">u16</span> = record_len - P.record_iv_length - P.mac_length;
                    <span class="tok-kw">const</span> ad = std.mem.toBytes(big(c.read_seq)) ++
                        frag[in - tls.record_header_len ..][<span class="tok-number">0</span> .. <span class="tok-number">1</span> + <span class="tok-number">2</span>] ++
                        std.mem.toBytes(big(message_len));
                    <span class="tok-kw">const</span> record_iv = frag[in..][<span class="tok-number">0</span>..P.record_iv_length].*;
                    in += P.record_iv_length;
                    <span class="tok-kw">const</span> masked_read_seq = c.read_seq &amp;
                        <span class="tok-kw">comptime</span> std.math.shl(<span class="tok-type">u64</span>, std.math.maxInt(<span class="tok-type">u64</span>), <span class="tok-number">8</span> * P.record_iv_length);
                    <span class="tok-kw">const</span> nonce: [P.AEAD.nonce_length]<span class="tok-type">u8</span> = nonce: {
                        <span class="tok-kw">const</span> V = <span class="tok-builtin">@Vector</span>(P.AEAD.nonce_length, <span class="tok-type">u8</span>);
                        <span class="tok-kw">const</span> pad = [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** (P.AEAD.nonce_length - <span class="tok-number">8</span>);
                        <span class="tok-kw">const</span> operand: V = pad ++ <span class="tok-builtin">@as</span>([<span class="tok-number">8</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(big(masked_read_seq)));
                        <span class="tok-kw">break</span> :nonce <span class="tok-builtin">@as</span>(V, pv.server_write_IV ++ record_iv) ^ operand;
                    };
                    <span class="tok-kw">const</span> ciphertext = frag[in..][<span class="tok-number">0</span>..message_len];
                    in += message_len;
                    <span class="tok-kw">const</span> auth_tag = frag[in..][<span class="tok-number">0</span>..P.mac_length].*;
                    in += P.mac_length;
                    <span class="tok-kw">const</span> out_buf = vp.peek();
                    <span class="tok-kw">const</span> cleartext_buf = <span class="tok-kw">if</span> (message_len &lt;= out_buf.len)
                        out_buf
                    <span class="tok-kw">else</span>
                        &amp;cleartext_stack_buffer;
                    <span class="tok-kw">const</span> cleartext = cleartext_buf[<span class="tok-number">0</span>..ciphertext.len];
                    P.AEAD.decrypt(cleartext, ciphertext, auth_tag, ad, nonce, pv.server_write_key) <span class="tok-kw">catch</span>
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsBadRecordMac;
                    <span class="tok-kw">break</span> :cleartext .{ cleartext, ct };
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            },
        };
        c.read_seq = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(<span class="tok-type">u64</span>, c.read_seq, <span class="tok-number">1</span>);
        <span class="tok-kw">switch</span> (inner_ct) {
            .alert =&gt; {
                <span class="tok-kw">if</span> (cleartext.len != <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsDecodeError;
                <span class="tok-kw">const</span> level: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.AlertLevel.html">AlertLevel</a> = <span class="tok-builtin">@enumFromInt</span>(cleartext[<span class="tok-number">0</span>]);
                <span class="tok-kw">const</span> desc: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.AlertDescription.html">AlertDescription</a> = <span class="tok-builtin">@enumFromInt</span>(cleartext[<span class="tok-number">1</span>]);
                <span class="tok-kw">if</span> (desc == .close_notify) {
                    c.received_close_notify = <span class="tok-null">true</span>;
                    c.partial_ciphertext_end = c.partial_ciphertext_idx;
                    <span class="tok-kw">return</span> vp.total;
                }
                _ = level;

                <span class="tok-kw">try</span> desc.toError();<span class="tok-comment">
                // TODO: handle server-side closures
                </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
            },
            .handshake =&gt; {
                <span class="tok-kw">var</span> ct_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                    <span class="tok-kw">const</span> handshake_type: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.HandshakeType.html">HandshakeType</a> = <span class="tok-builtin">@enumFromInt</span>(cleartext[ct_i]);
                    ct_i += <span class="tok-number">1</span>;
                    <span class="tok-kw">const</span> handshake_len = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u24</span>, cleartext[ct_i..][<span class="tok-number">0</span>..<span class="tok-number">3</span>], .big);
                    ct_i += <span class="tok-number">3</span>;
                    <span class="tok-kw">const</span> next_handshake_i = ct_i + handshake_len;
                    <span class="tok-kw">if</span> (next_handshake_i &gt; cleartext.len)
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsBadLength;
                    <span class="tok-kw">const</span> handshake = cleartext[ct_i..next_handshake_i];
                    <span class="tok-kw">switch</span> (handshake_type) {
                        .new_session_ticket =&gt; {<span class="tok-comment">
                            // This client implementation ignores new session tickets.
                        </span>},
                        .key_update =&gt; {
                            <span class="tok-kw">switch</span> (c.application_cipher) {
                                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| {
                                    <span class="tok-kw">const</span> pv = &amp;p.tls_1_3;
                                    <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*);
                                    <span class="tok-kw">const</span> server_secret = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, pv.server_secret, <span class="tok-str">&quot;traffic upd&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.Hash.digest_length);
                                    <span class="tok-kw">if</span> (c.ssl_key_log) |*key_log| <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.logSecrets">logSecrets</a>(key_log.file, .{
                                        .counter = key_log.serverCounter(),
                                        .client_random = &amp;key_log.client_random,
                                    }, .{
                                        .SERVER_TRAFFIC_SECRET = &amp;server_secret,
                                    });
                                    pv.server_secret = server_secret;
                                    pv.server_key = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, server_secret, <span class="tok-str">&quot;key&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.key_length);
                                    pv.server_iv = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, server_secret, <span class="tok-str">&quot;iv&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.nonce_length);
                                },
                            }
                            c.read_seq = <span class="tok-number">0</span>;

                            <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.KeyUpdateRequest.html">KeyUpdateRequest</a>, <span class="tok-builtin">@enumFromInt</span>(handshake[<span class="tok-number">0</span>]))) {
                                .update_requested =&gt; {
                                    <span class="tok-kw">switch</span> (c.application_cipher) {
                                        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| {
                                            <span class="tok-kw">const</span> pv = &amp;p.tls_1_3;
                                            <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*);
                                            <span class="tok-kw">const</span> client_secret = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, pv.client_secret, <span class="tok-str">&quot;traffic upd&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.Hash.digest_length);
                                            <span class="tok-kw">if</span> (c.ssl_key_log) |*key_log| <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.logSecrets">logSecrets</a>(key_log.file, .{
                                                .counter = key_log.clientCounter(),
                                                .client_random = &amp;key_log.client_random,
                                            }, .{
                                                .CLIENT_TRAFFIC_SECRET = &amp;client_secret,
                                            });
                                            pv.client_secret = client_secret;
                                            pv.client_key = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, client_secret, <span class="tok-str">&quot;key&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.key_length);
                                            pv.client_iv = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, client_secret, <span class="tok-str">&quot;iv&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.nonce_length);
                                        },
                                    }
                                    c.write_seq = <span class="tok-number">0</span>;
                                },
                                .update_not_requested =&gt; {},
                                _ =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter,
                            }
                        },
                        <span class="tok-kw">else</span> =&gt; {
                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        },
                    }
                    ct_i = next_handshake_i;
                    <span class="tok-kw">if</span> (ct_i &gt;= cleartext.len) <span class="tok-kw">break</span>;
                }
            },
            .application_data =&gt; {<span class="tok-comment">
                // Determine whether the output buffer or a stack
                // buffer was used for storing the cleartext.
                </span><span class="tok-kw">if</span> (cleartext.ptr == &amp;cleartext_stack_buffer) {<span class="tok-comment">
                    // Stack buffer was used, so we must copy to the output buffer.
                    </span><span class="tok-kw">if</span> (c.partial_ciphertext_idx &gt; c.partial_cleartext_idx) {<span class="tok-comment">
                        // We have already run out of room in iovecs. Continue
                        // appending to `partially_read_buffer`.
                        </span><span class="tok-builtin">@memcpy</span>(
                            c.partially_read_buffer[c.partial_ciphertext_idx..][<span class="tok-number">0</span>..cleartext.len],
                            cleartext,
                        );
                        c.partial_ciphertext_idx = <span class="tok-builtin">@intCast</span>(c.partial_ciphertext_idx + cleartext.len);
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">const</span> amt = vp.put(cleartext);
                        <span class="tok-kw">if</span> (amt &lt; cleartext.len) {
                            <span class="tok-kw">const</span> rest = cleartext[amt..];
                            c.partial_cleartext_idx = <span class="tok-number">0</span>;
                            c.partial_ciphertext_idx = <span class="tok-builtin">@intCast</span>(rest.len);
                            <span class="tok-builtin">@memcpy</span>(c.partially_read_buffer[<span class="tok-number">0</span>..rest.len], rest);
                        }
                    }
                } <span class="tok-kw">else</span> {<span class="tok-comment">
                    // Output buffer was used directly which means no
                    // memory copying needs to occur, and we can move
                    // on to the next ciphertext record.
                    </span>vp.next(cleartext.len);
                }
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage,
        }
        in = end;
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.crypto.tls.Client">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../../std.zig&quot;</span>);
<span class="tok-kw">const</span> tls = <a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>.<a href="std.crypto.tls.html">tls</a>;
<span class="tok-kw">const</span> Client = <span class="tok-builtin">@This</span>();
<span class="tok-kw">const</span> net = <a href="std.html">std</a>.<a href="std.net.html">net</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> crypto = <a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> Certificate = <a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>.<a href="std.crypto.Certificate.html">Certificate</a>;

<span class="tok-kw">const</span> max_ciphertext_len = <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_len">max_ciphertext_len</a>;
<span class="tok-kw">const</span> hmacExpandLabel = <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.hmacExpandLabel">hmacExpandLabel</a>;
<span class="tok-kw">const</span> hkdfExpandLabel = <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>;
<span class="tok-kw">const</span> int = <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.int">int</a>;
<span class="tok-kw">const</span> array = <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.array">array</a>;

tls_version: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a>,
read_seq: <span class="tok-type">u64</span>,
write_seq: <span class="tok-type">u64</span>,
<span class="tok-comment">/// The starting index of cleartext bytes inside `partially_read_buffer`.</span>
partial_cleartext_idx: <span class="tok-type">u15</span>,
<span class="tok-comment">/// The ending index of cleartext bytes inside `partially_read_buffer` as well</span>
<span class="tok-comment">/// as the starting index of ciphertext bytes.</span>
partial_ciphertext_idx: <span class="tok-type">u15</span>,
<span class="tok-comment">/// The ending index of ciphertext bytes inside `partially_read_buffer`.</span>
partial_ciphertext_end: <span class="tok-type">u15</span>,
<span class="tok-comment">/// When this is true, the stream may still not be at the end because there</span>
<span class="tok-comment">/// may be data in `partially_read_buffer`.</span>
received_close_notify: <span class="tok-type">bool</span>,
<span class="tok-comment">/// By default, reaching the end-of-stream when reading from the server will</span>
<span class="tok-comment">/// cause `error.TlsConnectionTruncated` to be returned, unless a close_notify</span>
<span class="tok-comment">/// message has been received. By setting this flag to `true`, instead, the</span>
<span class="tok-comment">/// end-of-stream will be forwarded to the application layer above TLS.</span>
<span class="tok-comment">/// This makes the application vulnerable to truncation attacks unless the</span>
<span class="tok-comment">/// application layer itself verifies that the amount of data received equals</span>
<span class="tok-comment">/// the amount of data expected, such as HTTP with the Content-Length header.</span>
allow_truncation_attacks: <span class="tok-type">bool</span>,
application_cipher: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ApplicationCipher.html">ApplicationCipher</a>,
<span class="tok-comment">/// The size is enough to contain exactly one TLSCiphertext record.</span>
<span class="tok-comment">/// This buffer is segmented into four parts:</span>
<span class="tok-comment">/// 0. unused</span>
<span class="tok-comment">/// 1. cleartext</span>
<span class="tok-comment">/// 2. ciphertext</span>
<span class="tok-comment">/// 3. unused</span>
<span class="tok-comment">/// The fields `partial_cleartext_idx`, `partial_ciphertext_idx`, and</span>
<span class="tok-comment">/// `partial_ciphertext_end` describe the span of the segments.</span>
partially_read_buffer: [<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_record_len">max_ciphertext_record_len</a>]<span class="tok-type">u8</span>,
<span class="tok-comment">/// If non-null, ssl secrets are logged to a file.  Creating such a log file allows other</span>
<span class="tok-comment">/// programs with access to that file to decrypt all traffic over this connection.</span>
ssl_key_log: ?<span class="tok-kw">struct</span> {
    client_key_seq: <span class="tok-type">u64</span>,
    server_key_seq: <span class="tok-type">u64</span>,
    client_random: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>,
    file: <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>,

    <span class="tok-kw">fn</span> <span class="tok-fn">clientCounter</span>(key_log: *<span class="tok-builtin">@This</span>()) <span class="tok-type">u64</span> {
        <span class="tok-kw">defer</span> key_log.client_key_seq += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> key_log.client_key_seq;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">serverCounter</span>(key_log: *<span class="tok-builtin">@This</span>()) <span class="tok-type">u64</span> {
        <span class="tok-kw">defer</span> key_log.server_key_seq += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> key_log.server_key_seq;
    }
},

<span class="tok-comment">/// This is an example of the type that is needed by the read and write</span>
<span class="tok-comment">/// functions. It can have any fields but it must at least have these</span>
<span class="tok-comment">/// functions.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Note that `std.net.Stream` conforms to this interface.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This declaration serves as documentation only.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StreamInterface = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// Can be any error set.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadError = <span class="tok-kw">error</span>{};

    <span class="tok-comment">/// Returns the number of bytes read. The number read may be less than the</span>
    <span class="tok-comment">/// buffer space provided. End-of-stream is indicated by a return value of 0.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The `iovecs` parameter is mutable because so that function may to</span>
    <span class="tok-comment">/// mutate the fields in order to handle partial reads from the underlying</span>
    <span class="tok-comment">/// stream layer.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readv</span>(this: <span class="tok-builtin">@This</span>(), iovecs: []<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>) <a href="std.crypto.tls.Client.StreamInterface.html#std.crypto.tls.Client.StreamInterface.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
        _ = .{ this, iovecs };
        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unimplemented&quot;</span>);
    }

    <span class="tok-comment">/// Can be any error set.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteError = <span class="tok-kw">error</span>{};

    <span class="tok-comment">/// Returns the number of bytes read, which may be less than the buffer</span>
    <span class="tok-comment">/// space provided. A short read does not indicate end-of-stream.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writev</span>(this: <span class="tok-builtin">@This</span>(), iovecs: []<span class="tok-kw">const</span> <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>) <a href="std.crypto.tls.Client.StreamInterface.html#std.crypto.tls.Client.StreamInterface.WriteError">WriteError</a>!<span class="tok-type">usize</span> {
        _ = .{ this, iovecs };
        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unimplemented&quot;</span>);
    }

    <span class="tok-comment">/// Returns the number of bytes read, which may be less than the buffer</span>
    <span class="tok-comment">/// space provided, indicating end-of-stream.</span>
    <span class="tok-comment">/// The `iovecs` parameter is mutable in case this function needs to mutate</span>
    <span class="tok-comment">/// the fields in order to handle partial writes from the underlying layer.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writevAll</span>(this: <span class="tok-builtin">@This</span>(), iovecs: []<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>) <a href="std.crypto.tls.Client.StreamInterface.html#std.crypto.tls.Client.StreamInterface.WriteError">WriteError</a>!<span class="tok-type">usize</span> {<span class="tok-comment">
        // This can be implemented in terms of writev, or specialized if desired.
        </span>_ = .{ this, iovecs };
        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unimplemented&quot;</span>);
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Options = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// How to perform host verification of server certificates.</span>
    host: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        <span class="tok-comment">/// No host verification is performed, which prevents a trusted connection from</span>
        <span class="tok-comment">/// being established.</span>
        no_verification,
        <span class="tok-comment">/// Verify that the server certificate was issued for a given host.</span>
        explicit: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    },
    <span class="tok-comment">/// How to verify the authenticity of server certificates.</span>
    ca: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        <span class="tok-comment">/// No ca verification is performed, which prevents a trusted connection from</span>
        <span class="tok-comment">/// being established.</span>
        no_verification,
        <span class="tok-comment">/// Verify that the server certificate is a valid self-signed certificate.</span>
        <span class="tok-comment">/// This provides no authorization guarantees, as anyone can create a</span>
        <span class="tok-comment">/// self-signed certificate.</span>
        self_signed,
        <span class="tok-comment">/// Verify that the server certificate is authorized by a given ca bundle.</span>
        bundle: <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.Bundle.html">Bundle</a>,
    },
    <span class="tok-comment">/// If non-null, ssl secrets are logged to this file.  Creating such a log file allows</span>
    <span class="tok-comment">/// other programs with access to that file to decrypt all traffic over this connection.</span>
    ssl_key_log_file: ?<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a> = <span class="tok-null">null</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">InitError</span>(<span class="tok-kw">comptime</span> Stream: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || Stream.WriteError || Stream.ReadError || <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.AlertDescription.html">AlertDescription</a>.<a href="std.crypto.tls.AlertDescription.html#std.crypto.tls.AlertDescription.Error">Error</a> || <span class="tok-kw">error</span>{
        InsufficientEntropy,
        DiskQuota,
        LockViolation,
        NotOpenForWriting,
        TlsUnexpectedMessage,
        TlsIllegalParameter,
        TlsDecryptFailure,
        TlsRecordOverflow,
        TlsBadRecordMac,
        CertificateFieldHasInvalidLength,
        CertificateHostMismatch,
        CertificatePublicKeyInvalid,
        CertificateExpired,
        CertificateFieldHasWrongDataType,
        CertificateIssuerMismatch,
        CertificateNotYetValid,
        CertificateSignatureAlgorithmMismatch,
        CertificateSignatureAlgorithmUnsupported,
        CertificateSignatureInvalid,
        CertificateSignatureInvalidLength,
        CertificateSignatureNamedCurveUnsupported,
        CertificateSignatureUnsupportedBitCount,
        TlsCertificateNotVerified,
        TlsBadSignatureScheme,
        TlsBadRsaSignatureBitCount,
        InvalidEncoding,
        IdentityElement,
        SignatureVerificationFailed,
        TlsDecryptError,
        TlsConnectionTruncated,
        TlsDecodeError,
        UnsupportedCertificateVersion,
        CertificateTimeInvalid,
        CertificateHasUnrecognizedObjectId,
        CertificateHasInvalidBitString,
        MessageTooLong,
        NegativeIntoUnsigned,
        TargetTooSmall,
        BufferTooSmall,
        InvalidSignature,
        NotSquare,
        NonCanonical,
        WeakPublicKey,
    };
}

<span class="tok-comment">/// Initiates a TLS handshake and establishes a TLSv1.2 or TLSv1.3 session with `stream`, which</span>
<span class="tok-comment">/// must conform to `StreamInterface`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `host` is only borrowed during this function call.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(stream: <span class="tok-kw">anytype</span>, options: <a href="std.crypto.tls.Client.Options.html">Options</a>) <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.InitError">InitError</a>(<span class="tok-builtin">@TypeOf</span>(stream))!<a href="std.crypto.tls.Client.html">Client</a> {
    <span class="tok-kw">const</span> host = <span class="tok-kw">switch</span> (options.host) {
        .no_verification =&gt; <span class="tok-str">&quot;&quot;</span>,
        .explicit =&gt; |host| host,
    };
    <span class="tok-kw">const</span> host_len: <span class="tok-type">u16</span> = <span class="tok-builtin">@intCast</span>(host.len);

    <span class="tok-kw">var</span> random_buffer: [<span class="tok-number">176</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <a href="std.crypto.html">crypto</a>.<a href="std.crypto.tlcsprng.html#std.crypto.tlcsprng.interface">random</a>.<a href="#">bytes</a>(&amp;random_buffer);
    <span class="tok-kw">const</span> client_hello_rand = random_buffer[<span class="tok-number">0</span>..<span class="tok-number">32</span>].*;
    <span class="tok-kw">var</span> key_seq: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> server_hello_rand: [<span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> legacy_session_id = random_buffer[<span class="tok-number">32</span>..<span class="tok-number">64</span>].*;

    <span class="tok-kw">var</span> key_share = <a href="std.crypto.tls.Client.KeyShare.html">KeyShare</a>.<a href="std.crypto.tls.Client.KeyShare.html#std.crypto.tls.Client.KeyShare.init">init</a>(random_buffer[<span class="tok-number">64</span>..<span class="tok-number">176</span>].*) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {<span class="tok-comment">
        // Only possible to happen if the seed is all zeroes.
        </span><span class="tok-kw">error</span>.IdentityElement =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InsufficientEntropy,
    };

    <span class="tok-kw">const</span> extensions_payload = <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.extension">extension</a>(.supported_versions, <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u8</span>, <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a>, .{
        .tls_1_3,
        .tls_1_2,
    })) ++ <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.extension">extension</a>(.signature_algorithms, <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.SignatureScheme.html">SignatureScheme</a>, .{
        .ecdsa_secp256r1_sha256,
        .ecdsa_secp384r1_sha384,
        .rsa_pkcs1_sha256,
        .rsa_pkcs1_sha384,
        .rsa_pkcs1_sha512,
        .rsa_pss_rsae_sha256,
        .rsa_pss_rsae_sha384,
        .rsa_pss_rsae_sha512,
        .rsa_pss_pss_sha256,
        .rsa_pss_pss_sha384,
        .rsa_pss_pss_sha512,
        .rsa_pkcs1_sha1,
        .ed25519,
    })) ++ <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.extension">extension</a>(.supported_groups, <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.NamedGroup.html">NamedGroup</a>, .{
        .x25519_ml_kem768,
        .secp256r1,
        .secp384r1,
        .x25519,
    })) ++ <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.extension">extension</a>(.psk_key_exchange_modes, <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u8</span>, <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.PskKeyExchangeMode.html">PskKeyExchangeMode</a>, .{
        .psk_dhe_ke,
    })) ++ <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.extension">extension</a>(.key_share, <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(
        <span class="tok-type">u16</span>,
        <span class="tok-type">u8</span>,
        <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.NamedGroup.html">NamedGroup</a>.<a href="#">x25519_ml_kem768</a>)) ++
            <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <span class="tok-type">u8</span>, key_share.ml_kem768_kp.public_key.toBytes() ++ key_share.x25519_kp.public_key) ++
            <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.NamedGroup.html">NamedGroup</a>.<a href="#">secp256r1</a>)) ++
            <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <span class="tok-type">u8</span>, key_share.secp256r1_kp.public_key.toUncompressedSec1()) ++
            <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.NamedGroup.html">NamedGroup</a>.<a href="#">secp384r1</a>)) ++
            <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <span class="tok-type">u8</span>, key_share.secp384r1_kp.public_key.toUncompressedSec1()) ++
            <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.NamedGroup.html">NamedGroup</a>.<a href="#">x25519</a>)) ++
            <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <span class="tok-type">u8</span>, key_share.x25519_kp.public_key),
    ));
    <span class="tok-kw">const</span> server_name_extension = <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ExtensionType.html">ExtensionType</a>.<a href="#">server_name</a>)) ++
        <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-number">2</span> + <span class="tok-number">1</span> + <span class="tok-number">2</span> + host_len) ++<span class="tok-comment"> // byte length of this extension payload
        </span><a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-number">1</span> + <span class="tok-number">2</span> + host_len) ++<span class="tok-comment"> // server_name_list byte count
        </span>.{<span class="tok-number">0x00</span>} ++<span class="tok-comment"> // name_type
        </span><a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, host_len);
    <span class="tok-kw">const</span> server_name_extension_len = <span class="tok-kw">switch</span> (options.host) {
        .no_verification =&gt; <span class="tok-number">0</span>,
        .explicit =&gt; server_name_extension.len + host_len,
    };

    <span class="tok-kw">const</span> extensions_header =
        <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intCast</span>(extensions_payload.len + server_name_extension_len)) ++
        extensions_payload ++
        server_name_extension;

    <span class="tok-kw">const</span> client_hello =
        <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a>.<a href="#">tls_1_2</a>)) ++
        client_hello_rand ++
        [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">32</span>} ++ legacy_session_id ++
        <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.cipher_suites">cipher_suites</a> ++
        <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u8</span>, <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.CompressionMethod.html">CompressionMethod</a>, .{.<span class="tok-null">null</span>}) ++
        extensions_header;

    <span class="tok-kw">const</span> out_handshake = .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.HandshakeType.html">HandshakeType</a>.<a href="#">client_hello</a>)} ++
        <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u24</span>, <span class="tok-builtin">@intCast</span>(client_hello.len - server_name_extension.len + server_name_extension_len)) ++
        client_hello;

    <span class="tok-kw">const</span> cleartext_header_buf = .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ContentType.html">ContentType</a>.<a href="#">handshake</a>)} ++
        <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a>.<a href="#">tls_1_0</a>)) ++
        <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intCast</span>(out_handshake.len - server_name_extension.len + server_name_extension_len)) ++
        out_handshake;
    <span class="tok-kw">const</span> cleartext_header = <span class="tok-kw">switch</span> (options.host) {
        .no_verification =&gt; cleartext_header_buf[<span class="tok-number">0</span> .. cleartext_header_buf.len - server_name_extension.len],
        .explicit =&gt; &amp;cleartext_header_buf,
    };

    {
        <span class="tok-kw">var</span> iovecs = [_]<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>{
            .{ .base = cleartext_header.ptr, .len = cleartext_header.len },
            .{ .base = host.ptr, .len = host.len },
        };
        <span class="tok-kw">try</span> stream.writevAll(iovecs[<span class="tok-number">0</span>..<span class="tok-kw">if</span> (host.len == <span class="tok-number">0</span>) <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-number">2</span>]);
    }

    <span class="tok-kw">var</span> tls_version: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a> = <span class="tok-null">undefined</span>;<span class="tok-comment">
    // These are used for two purposes:
    // * Detect whether a certificate is the first one presented, in which case
    //   we need to verify the host name.
    </span><span class="tok-kw">var</span> cert_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;<span class="tok-comment">
    // * Flip back and forth between the two cleartext buffers in order to keep
    //   the previous certificate in memory so that it can be verified by the
    //   next one.
    </span><span class="tok-kw">var</span> cert_buf_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> write_seq: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> read_seq: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> prev_cert: <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.Parsed.html">Parsed</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> CipherState = <span class="tok-kw">enum</span> {
        <span class="tok-comment">/// No cipher is in use</span>
        cleartext,
        <span class="tok-comment">/// Handshake cipher is in use</span>
        handshake,
        <span class="tok-comment">/// Application cipher is in use</span>
        application,
    };
    <span class="tok-kw">var</span> pending_cipher_state: CipherState = .cleartext;
    <span class="tok-kw">var</span> cipher_state = pending_cipher_state;
    <span class="tok-kw">const</span> HandshakeState = <span class="tok-kw">enum</span> {
        <span class="tok-comment">/// In this state we expect only a server hello message.</span>
        hello,
        <span class="tok-comment">/// In this state we expect only an encrypted_extensions message.</span>
        encrypted_extensions,
        <span class="tok-comment">/// In this state we expect certificate handshake messages.</span>
        certificate,
        <span class="tok-comment">/// In this state we expect certificate or certificate_verify messages.</span>
        <span class="tok-comment">/// certificate messages are ignored since the trust chain is already</span>
        <span class="tok-comment">/// established.</span>
        trust_chain_established,
        <span class="tok-comment">/// In this state, we expect only the server_hello_done handshake message.</span>
        server_hello_done,
        <span class="tok-comment">/// In this state, we expect only the finished handshake message.</span>
        finished,
    };
    <span class="tok-kw">var</span> handshake_state: HandshakeState = .hello;
    <span class="tok-kw">var</span> handshake_cipher: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.HandshakeCipher.html">HandshakeCipher</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> main_cert_pub_key: <a href="std.crypto.tls.Client.CertificatePublicKey.html">CertificatePublicKey</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> now_sec = <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.timestamp">timestamp</a>();

    <span class="tok-kw">var</span> cleartext_fragment_start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> cleartext_fragment_end: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> cleartext_bufs: [<span class="tok-number">2</span>][<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_inner_record_len">max_ciphertext_inner_record_len</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> handshake_buffer: [<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_record_len">max_ciphertext_record_len</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> d: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.Decoder.html">Decoder</a> = .{ .buf = &amp;handshake_buffer };
    fragment: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">try</span> d.readAtLeastOurAmt(stream, <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>);
        <span class="tok-kw">const</span> record_header = d.buf[d.idx..][<span class="tok-number">0</span>..<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>];
        <span class="tok-kw">const</span> record_ct = d.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ContentType.html">ContentType</a>);
        d.skip(<span class="tok-number">2</span>);<span class="tok-comment"> // legacy_version
        </span><span class="tok-kw">const</span> record_len = d.decode(<span class="tok-type">u16</span>);
        <span class="tok-kw">try</span> d.readAtLeast(stream, record_len);
        <span class="tok-kw">var</span> record_decoder = <span class="tok-kw">try</span> d.sub(record_len);
        <span class="tok-kw">var</span> ctd, <span class="tok-kw">const</span> ct = content: <span class="tok-kw">switch</span> (cipher_state) {
            .cleartext =&gt; .{ record_decoder, record_ct },
            .handshake =&gt; {
                std.debug.assert(tls_version == .tls_1_3);
                <span class="tok-kw">if</span> (record_ct != .application_data) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                <span class="tok-kw">try</span> record_decoder.ensure(record_len);
                <span class="tok-kw">const</span> cleartext_buf = &amp;cleartext_bufs[cert_buf_index % <span class="tok-number">2</span>];
                <span class="tok-kw">switch</span> (handshake_cipher) {
                    <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| {
                        <span class="tok-kw">const</span> pv = &amp;p.version.tls_1_3;
                        <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*).A;
                        <span class="tok-kw">if</span> (record_len &lt; P.AEAD.tag_length) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsRecordOverflow;
                        <span class="tok-kw">const</span> ciphertext = record_decoder.slice(record_len - P.AEAD.tag_length);
                        <span class="tok-kw">const</span> cleartext_fragment_buf = cleartext_buf[cleartext_fragment_end..];
                        <span class="tok-kw">if</span> (ciphertext.len &gt; cleartext_fragment_buf.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsRecordOverflow;
                        <span class="tok-kw">const</span> cleartext = cleartext_fragment_buf[<span class="tok-number">0</span>..ciphertext.len];
                        <span class="tok-kw">const</span> auth_tag = record_decoder.array(P.AEAD.tag_length).*;
                        <span class="tok-kw">const</span> nonce = nonce: {
                            <span class="tok-kw">const</span> V = <span class="tok-builtin">@Vector</span>(P.AEAD.nonce_length, <span class="tok-type">u8</span>);
                            <span class="tok-kw">const</span> pad = [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** (P.AEAD.nonce_length - <span class="tok-number">8</span>);
                            <span class="tok-kw">const</span> operand: V = pad ++ <span class="tok-builtin">@as</span>([<span class="tok-number">8</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(big(read_seq)));
                            <span class="tok-kw">break</span> :nonce <span class="tok-builtin">@as</span>(V, pv.server_handshake_iv) ^ operand;
                        };
                        P.AEAD.decrypt(cleartext, ciphertext, auth_tag, record_header, nonce, pv.server_handshake_key) <span class="tok-kw">catch</span>
                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsBadRecordMac;
                        cleartext_fragment_end += std.mem.trimRight(<span class="tok-type">u8</span>, cleartext, <span class="tok-str">&quot;\x00&quot;</span>).len;
                    },
                }
                read_seq += <span class="tok-number">1</span>;
                cleartext_fragment_end -= <span class="tok-number">1</span>;
                <span class="tok-kw">const</span> ct: tls.ContentType = <span class="tok-builtin">@enumFromInt</span>(cleartext_buf[cleartext_fragment_end]);
                <span class="tok-kw">if</span> (ct != .handshake) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                <span class="tok-kw">break</span> :content .{ tls.Decoder.fromTheirSlice(<span class="tok-builtin">@constCast</span>(cleartext_buf[cleartext_fragment_start..cleartext_fragment_end])), ct };
            },
            .application =&gt; {
                std.debug.assert(tls_version == .tls_1_2);
                <span class="tok-kw">if</span> (record_ct != .handshake) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                <span class="tok-kw">try</span> record_decoder.ensure(record_len);
                <span class="tok-kw">const</span> cleartext_buf = &amp;cleartext_bufs[cert_buf_index % <span class="tok-number">2</span>];
                <span class="tok-kw">switch</span> (handshake_cipher) {
                    <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| {
                        <span class="tok-kw">const</span> pv = &amp;p.version.tls_1_2;
                        <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*).A;
                        <span class="tok-kw">if</span> (record_len &lt; P.record_iv_length + P.mac_length) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsRecordOverflow;
                        <span class="tok-kw">const</span> message_len: <span class="tok-type">u16</span> = record_len - P.record_iv_length - P.mac_length;
                        <span class="tok-kw">const</span> cleartext_fragment_buf = cleartext_buf[cleartext_fragment_end..];
                        <span class="tok-kw">if</span> (message_len &gt; cleartext_fragment_buf.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsRecordOverflow;
                        <span class="tok-kw">const</span> cleartext = cleartext_fragment_buf[<span class="tok-number">0</span>..message_len];
                        <span class="tok-kw">const</span> ad = std.mem.toBytes(big(read_seq)) ++
                            record_header[<span class="tok-number">0</span> .. <span class="tok-number">1</span> + <span class="tok-number">2</span>] ++
                            std.mem.toBytes(big(message_len));
                        <span class="tok-kw">const</span> record_iv = record_decoder.array(P.record_iv_length).*;
                        <span class="tok-kw">const</span> masked_read_seq = read_seq &amp;
                            <span class="tok-kw">comptime</span> std.math.shl(<span class="tok-type">u64</span>, std.math.maxInt(<span class="tok-type">u64</span>), <span class="tok-number">8</span> * P.record_iv_length);
                        <span class="tok-kw">const</span> nonce: [P.AEAD.nonce_length]<span class="tok-type">u8</span> = nonce: {
                            <span class="tok-kw">const</span> V = <span class="tok-builtin">@Vector</span>(P.AEAD.nonce_length, <span class="tok-type">u8</span>);
                            <span class="tok-kw">const</span> pad = [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** (P.AEAD.nonce_length - <span class="tok-number">8</span>);
                            <span class="tok-kw">const</span> operand: V = pad ++ <span class="tok-builtin">@as</span>([<span class="tok-number">8</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(big(masked_read_seq)));
                            <span class="tok-kw">break</span> :nonce <span class="tok-builtin">@as</span>(V, pv.app_cipher.server_write_IV ++ record_iv) ^ operand;
                        };
                        <span class="tok-kw">const</span> ciphertext = record_decoder.slice(message_len);
                        <span class="tok-kw">const</span> auth_tag = record_decoder.array(P.mac_length);
                        P.AEAD.decrypt(cleartext, ciphertext, auth_tag.*, ad, nonce, pv.app_cipher.server_write_key) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsBadRecordMac;
                        cleartext_fragment_end += message_len;
                    },
                }
                read_seq += <span class="tok-number">1</span>;
                <span class="tok-kw">break</span> :content .{ tls.Decoder.fromTheirSlice(cleartext_buf[cleartext_fragment_start..cleartext_fragment_end]), record_ct };
            },
        };
        <span class="tok-kw">switch</span> (ct) {
            .alert =&gt; {
                ctd.ensure(<span class="tok-number">2</span>) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span> :fragment;
                <span class="tok-kw">const</span> level = ctd.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.AlertLevel.html">AlertLevel</a>);
                <span class="tok-kw">const</span> desc = ctd.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.AlertDescription.html">AlertDescription</a>);
                _ = level;<span class="tok-comment">

                // if this isn't a error alert, then it's a closure alert, which makes no sense in a handshake
                </span><span class="tok-kw">try</span> desc.toError();<span class="tok-comment">
                // TODO: handle server-side closures
                </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
            },
            .change_cipher_spec =&gt; {
                ctd.ensure(<span class="tok-number">1</span>) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span> :fragment;
                <span class="tok-kw">if</span> (ctd.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ChangeCipherSpecType.html">ChangeCipherSpecType</a>) != .change_cipher_spec) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter;
                cipher_state = pending_cipher_state;
            },
            .handshake =&gt; <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                ctd.ensure(<span class="tok-number">4</span>) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span> :fragment;
                <span class="tok-kw">const</span> handshake_type = ctd.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.HandshakeType.html">HandshakeType</a>);
                <span class="tok-kw">const</span> handshake_len = ctd.decode(<span class="tok-type">u24</span>);
                <span class="tok-kw">var</span> hsd = ctd.sub(handshake_len) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span> :fragment;
                <span class="tok-kw">const</span> wrapped_handshake = ctd.buf[ctd.idx - handshake_len - <span class="tok-number">4</span> .. ctd.idx];
                <span class="tok-kw">switch</span> (handshake_type) {
                    .server_hello =&gt; {
                        <span class="tok-kw">if</span> (cipher_state != .cleartext) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">if</span> (handshake_state != .hello) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">try</span> hsd.ensure(<span class="tok-number">2</span> + <span class="tok-number">32</span> + <span class="tok-number">1</span>);
                        <span class="tok-kw">const</span> legacy_version = hsd.decode(<span class="tok-type">u16</span>);
                        <span class="tok-builtin">@memcpy</span>(&amp;server_hello_rand, hsd.array(<span class="tok-number">32</span>));
                        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;server_hello_rand, &amp;<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.hello_retry_request_sequence">hello_retry_request_sequence</a>)) {<span class="tok-comment">
                            // This is a HelloRetryRequest message. This client implementation
                            // does not expect to get one.
                            </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        }
                        <span class="tok-kw">const</span> legacy_session_id_echo_len = hsd.decode(<span class="tok-type">u8</span>);
                        <span class="tok-kw">try</span> hsd.ensure(legacy_session_id_echo_len + <span class="tok-number">2</span> + <span class="tok-number">1</span>);
                        <span class="tok-kw">const</span> legacy_session_id_echo = hsd.slice(legacy_session_id_echo_len);
                        <span class="tok-kw">const</span> cipher_suite_tag = hsd.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.CipherSuite.html">CipherSuite</a>);
                        hsd.skip(<span class="tok-number">1</span>);<span class="tok-comment"> // legacy_compression_method
                        </span><span class="tok-kw">var</span> supported_version: ?<span class="tok-type">u16</span> = <span class="tok-null">null</span>;
                        <span class="tok-kw">if</span> (!hsd.eof()) {
                            <span class="tok-kw">try</span> hsd.ensure(<span class="tok-number">2</span>);
                            <span class="tok-kw">const</span> extensions_size = hsd.decode(<span class="tok-type">u16</span>);
                            <span class="tok-kw">var</span> all_extd = <span class="tok-kw">try</span> hsd.sub(extensions_size);
                            <span class="tok-kw">while</span> (!all_extd.eof()) {
                                <span class="tok-kw">try</span> all_extd.ensure(<span class="tok-number">2</span> + <span class="tok-number">2</span>);
                                <span class="tok-kw">const</span> et = all_extd.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ExtensionType.html">ExtensionType</a>);
                                <span class="tok-kw">const</span> ext_size = all_extd.decode(<span class="tok-type">u16</span>);
                                <span class="tok-kw">var</span> extd = <span class="tok-kw">try</span> all_extd.sub(ext_size);
                                <span class="tok-kw">switch</span> (et) {
                                    .supported_versions =&gt; {
                                        <span class="tok-kw">if</span> (supported_version) |_| <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter;
                                        <span class="tok-kw">try</span> extd.ensure(<span class="tok-number">2</span>);
                                        supported_version = extd.decode(<span class="tok-type">u16</span>);
                                    },
                                    .key_share =&gt; {
                                        <span class="tok-kw">if</span> (key_share.getSharedSecret()) |_| <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter;
                                        <span class="tok-kw">try</span> extd.ensure(<span class="tok-number">4</span>);
                                        <span class="tok-kw">const</span> named_group = extd.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.NamedGroup.html">NamedGroup</a>);
                                        <span class="tok-kw">const</span> key_size = extd.decode(<span class="tok-type">u16</span>);
                                        <span class="tok-kw">try</span> extd.ensure(key_size);
                                        <span class="tok-kw">try</span> key_share.exchange(named_group, extd.slice(key_size));
                                    },
                                    <span class="tok-kw">else</span> =&gt; {},
                                }
                            }
                        }

                        tls_version = <span class="tok-builtin">@enumFromInt</span>(supported_version <span class="tok-kw">orelse</span> legacy_version);
                        <span class="tok-kw">switch</span> (tls_version) {
                            .tls_1_3 =&gt; <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, legacy_session_id_echo, &amp;legacy_session_id)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter,
                            .tls_1_2 =&gt; <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, server_hello_rand[<span class="tok-number">24</span>..<span class="tok-number">31</span>], <span class="tok-str">&quot;DOWNGRD&quot;</span>) <span class="tok-kw">and</span>
                                server_hello_rand[<span class="tok-number">31</span>] &gt;&gt; <span class="tok-number">1</span> == <span class="tok-number">0x00</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter,
                        }

                        <span class="tok-kw">switch</span> (cipher_suite_tag) {
                            <span class="tok-kw">inline</span> .AES_128_GCM_SHA256,
                            .AES_256_GCM_SHA384,
                            .CHACHA20_POLY1305_SHA256,
                            .AEGIS_256_SHA512,
                            .AEGIS_128L_SHA256,

                            .ECDHE_RSA_WITH_AES_128_GCM_SHA256,
                            .ECDHE_RSA_WITH_AES_256_GCM_SHA384,
                            .ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
                            =&gt; |tag| {
                                handshake_cipher = <span class="tok-builtin">@unionInit</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.HandshakeCipher.html">HandshakeCipher</a>, <span class="tok-builtin">@tagName</span>(tag.with()), .{
                                    .transcript_hash = .init(.{}),
                                    .version = <span class="tok-null">undefined</span>,
                                });
                                <span class="tok-kw">const</span> p = &amp;<span class="tok-builtin">@field</span>(handshake_cipher, <span class="tok-builtin">@tagName</span>(tag.with()));
                                p.transcript_hash.update(cleartext_header[<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>..]);<span class="tok-comment"> // Client Hello part 1
                                </span>p.transcript_hash.update(host);<span class="tok-comment"> // Client Hello part 2
                                </span>p.transcript_hash.update(wrapped_handshake);
                            },

                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter,
                        }
                        <span class="tok-kw">switch</span> (tls_version) {
                            .tls_1_3 =&gt; {
                                <span class="tok-kw">switch</span> (cipher_suite_tag) {
                                    <span class="tok-kw">inline</span> .AES_128_GCM_SHA256,
                                    .AES_256_GCM_SHA384,
                                    .CHACHA20_POLY1305_SHA256,
                                    .AEGIS_256_SHA512,
                                    .AEGIS_128L_SHA256,
                                    =&gt; |tag| {
                                        <span class="tok-kw">const</span> sk = key_share.getSharedSecret() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter;
                                        <span class="tok-kw">const</span> p = &amp;<span class="tok-builtin">@field</span>(handshake_cipher, <span class="tok-builtin">@tagName</span>(tag.with()));
                                        <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*).A;
                                        <span class="tok-kw">const</span> hello_hash = p.transcript_hash.peek();
                                        <span class="tok-kw">const</span> zeroes = [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** P.Hash.digest_length;
                                        <span class="tok-kw">const</span> early_secret = P.Hkdf.extract(&amp;[<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>}, &amp;zeroes);
                                        <span class="tok-kw">const</span> empty_hash = <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.emptyHash">emptyHash</a>(P.Hash);
                                        p.version = .{ .tls_1_3 = <span class="tok-null">undefined</span> };
                                        <span class="tok-kw">const</span> pv = &amp;p.version.tls_1_3;
                                        <span class="tok-kw">const</span> hs_derived_secret = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, early_secret, <span class="tok-str">&quot;derived&quot;</span>, &amp;empty_hash, P.Hash.digest_length);
                                        pv.handshake_secret = P.Hkdf.extract(&amp;hs_derived_secret, sk);
                                        <span class="tok-kw">const</span> ap_derived_secret = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, pv.handshake_secret, <span class="tok-str">&quot;derived&quot;</span>, &amp;empty_hash, P.Hash.digest_length);
                                        pv.master_secret = P.Hkdf.extract(&amp;ap_derived_secret, &amp;zeroes);
                                        <span class="tok-kw">const</span> client_secret = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, pv.handshake_secret, <span class="tok-str">&quot;c hs traffic&quot;</span>, &amp;hello_hash, P.Hash.digest_length);
                                        <span class="tok-kw">const</span> server_secret = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, pv.handshake_secret, <span class="tok-str">&quot;s hs traffic&quot;</span>, &amp;hello_hash, P.Hash.digest_length);
                                        <span class="tok-kw">if</span> (options.ssl_key_log_file) |key_log_file| <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.logSecrets">logSecrets</a>(key_log_file, .{
                                            .client_random = &amp;client_hello_rand,
                                        }, .{
                                            .SERVER_HANDSHAKE_TRAFFIC_SECRET = &amp;server_secret,
                                            .CLIENT_HANDSHAKE_TRAFFIC_SECRET = &amp;client_secret,
                                        });
                                        pv.client_finished_key = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, client_secret, <span class="tok-str">&quot;finished&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.Hmac.key_length);
                                        pv.server_finished_key = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, server_secret, <span class="tok-str">&quot;finished&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.Hmac.key_length);
                                        pv.client_handshake_key = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, client_secret, <span class="tok-str">&quot;key&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.key_length);
                                        pv.server_handshake_key = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, server_secret, <span class="tok-str">&quot;key&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.key_length);
                                        pv.client_handshake_iv = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, client_secret, <span class="tok-str">&quot;iv&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.nonce_length);
                                        pv.server_handshake_iv = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, server_secret, <span class="tok-str">&quot;iv&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.nonce_length);
                                    },
                                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter,
                                }
                                pending_cipher_state = .handshake;
                                handshake_state = .encrypted_extensions;
                            },
                            .tls_1_2 =&gt; <span class="tok-kw">switch</span> (cipher_suite_tag) {
                                .ECDHE_RSA_WITH_AES_128_GCM_SHA256,
                                .ECDHE_RSA_WITH_AES_256_GCM_SHA384,
                                .ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
                                =&gt; handshake_state = .certificate,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter,
                            },
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter,
                        }
                    },
                    .encrypted_extensions =&gt; {
                        <span class="tok-kw">if</span> (tls_version != .tls_1_3) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">if</span> (cipher_state != .handshake) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">if</span> (handshake_state != .encrypted_extensions) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">switch</span> (handshake_cipher) {
                            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| p.transcript_hash.update(wrapped_handshake),
                        }
                        <span class="tok-kw">try</span> hsd.ensure(<span class="tok-number">2</span>);
                        <span class="tok-kw">const</span> total_ext_size = hsd.decode(<span class="tok-type">u16</span>);
                        <span class="tok-kw">var</span> all_extd = <span class="tok-kw">try</span> hsd.sub(total_ext_size);
                        <span class="tok-kw">while</span> (!all_extd.eof()) {
                            <span class="tok-kw">try</span> all_extd.ensure(<span class="tok-number">4</span>);
                            <span class="tok-kw">const</span> et = all_extd.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ExtensionType.html">ExtensionType</a>);
                            <span class="tok-kw">const</span> ext_size = all_extd.decode(<span class="tok-type">u16</span>);
                            <span class="tok-kw">const</span> extd = <span class="tok-kw">try</span> all_extd.sub(ext_size);
                            _ = extd;
                            <span class="tok-kw">switch</span> (et) {
                                .server_name =&gt; {},
                                <span class="tok-kw">else</span> =&gt; {},
                            }
                        }
                        handshake_state = .certificate;
                    },
                    .certificate =&gt; cert: {
                        <span class="tok-kw">if</span> (cipher_state == .application) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">switch</span> (handshake_state) {
                            .certificate =&gt; {},
                            .trust_chain_established =&gt; <span class="tok-kw">break</span> :cert,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage,
                        }
                        <span class="tok-kw">switch</span> (handshake_cipher) {
                            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| p.transcript_hash.update(wrapped_handshake),
                        }

                        <span class="tok-kw">switch</span> (tls_version) {
                            .tls_1_3 =&gt; {
                                <span class="tok-kw">try</span> hsd.ensure(<span class="tok-number">1</span> + <span class="tok-number">3</span>);
                                <span class="tok-kw">const</span> cert_req_ctx_len = hsd.decode(<span class="tok-type">u8</span>);
                                <span class="tok-kw">if</span> (cert_req_ctx_len != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter;
                            },
                            .tls_1_2 =&gt; <span class="tok-kw">try</span> hsd.ensure(<span class="tok-number">3</span>),
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        }
                        <span class="tok-kw">const</span> certs_size = hsd.decode(<span class="tok-type">u24</span>);
                        <span class="tok-kw">var</span> certs_decoder = <span class="tok-kw">try</span> hsd.sub(certs_size);
                        <span class="tok-kw">while</span> (!certs_decoder.eof()) {
                            <span class="tok-kw">try</span> certs_decoder.ensure(<span class="tok-number">3</span>);
                            <span class="tok-kw">const</span> cert_size = certs_decoder.decode(<span class="tok-type">u24</span>);
                            <span class="tok-kw">const</span> certd = <span class="tok-kw">try</span> certs_decoder.sub(cert_size);

                            <span class="tok-kw">if</span> (tls_version == .tls_1_3) {
                                <span class="tok-kw">try</span> certs_decoder.ensure(<span class="tok-number">2</span>);
                                <span class="tok-kw">const</span> total_ext_size = certs_decoder.decode(<span class="tok-type">u16</span>);
                                <span class="tok-kw">const</span> all_extd = <span class="tok-kw">try</span> certs_decoder.sub(total_ext_size);
                                _ = all_extd;
                            }

                            <span class="tok-kw">const</span> subject_cert: <a href="std.crypto.Certificate.html">Certificate</a> = .{
                                .buffer = certd.buf,
                                .index = <span class="tok-builtin">@intCast</span>(certd.idx),
                            };
                            <span class="tok-kw">const</span> subject = <span class="tok-kw">try</span> subject_cert.parse();
                            <span class="tok-kw">if</span> (cert_index == <span class="tok-number">0</span>) {<span class="tok-comment">
                                // Verify the host on the first certificate.
                                </span><span class="tok-kw">switch</span> (options.host) {
                                    .no_verification =&gt; {},
                                    .explicit =&gt; <span class="tok-kw">try</span> subject.verifyHostName(host),
                                }<span class="tok-comment">

                                // Keep track of the public key for the
                                // certificate_verify message later.
                                </span><span class="tok-kw">try</span> main_cert_pub_key.init(subject.pub_key_algo, subject.pubKey());
                            } <span class="tok-kw">else</span> {
                                <span class="tok-kw">try</span> prev_cert.verify(subject, now_sec);
                            }

                            <span class="tok-kw">switch</span> (options.ca) {
                                .no_verification =&gt; {
                                    handshake_state = .trust_chain_established;
                                    <span class="tok-kw">break</span> :cert;
                                },
                                .self_signed =&gt; {
                                    <span class="tok-kw">try</span> subject.verify(subject, now_sec);
                                    handshake_state = .trust_chain_established;
                                    <span class="tok-kw">break</span> :cert;
                                },
                                .bundle =&gt; |ca_bundle| <span class="tok-kw">if</span> (ca_bundle.verify(subject, now_sec)) |_| {
                                    handshake_state = .trust_chain_established;
                                    <span class="tok-kw">break</span> :cert;
                                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                                    <span class="tok-kw">error</span>.CertificateIssuerNotFound =&gt; {},
                                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
                                },
                            }

                            prev_cert = subject;
                            cert_index += <span class="tok-number">1</span>;
                        }
                        cert_buf_index += <span class="tok-number">1</span>;
                    },
                    .server_key_exchange =&gt; {
                        <span class="tok-kw">if</span> (tls_version != .tls_1_2) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">if</span> (cipher_state != .cleartext) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">switch</span> (handshake_state) {
                            .trust_chain_established =&gt; {},
                            .certificate =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsCertificateNotVerified,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage,
                        }

                        <span class="tok-kw">switch</span> (handshake_cipher) {
                            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| p.transcript_hash.update(wrapped_handshake),
                        }
                        <span class="tok-kw">try</span> hsd.ensure(<span class="tok-number">1</span> + <span class="tok-number">2</span> + <span class="tok-number">1</span>);
                        <span class="tok-kw">const</span> curve_type = hsd.decode(<span class="tok-type">u8</span>);
                        <span class="tok-kw">if</span> (curve_type != <span class="tok-number">0x03</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter;<span class="tok-comment"> // named_curve
                        </span><span class="tok-kw">const</span> named_group = hsd.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.NamedGroup.html">NamedGroup</a>);
                        <span class="tok-kw">const</span> key_size = hsd.decode(<span class="tok-type">u8</span>);
                        <span class="tok-kw">try</span> hsd.ensure(key_size);
                        <span class="tok-kw">const</span> server_pub_key = hsd.slice(key_size);
                        <span class="tok-kw">try</span> main_cert_pub_key.verifySignature(&amp;hsd, &amp;.{ &amp;client_hello_rand, &amp;server_hello_rand, hsd.buf[<span class="tok-number">0</span>..hsd.idx] });
                        <span class="tok-kw">try</span> key_share.exchange(named_group, server_pub_key);
                        handshake_state = .server_hello_done;
                    },
                    .server_hello_done =&gt; {
                        <span class="tok-kw">if</span> (tls_version != .tls_1_2) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">if</span> (cipher_state != .cleartext) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">if</span> (handshake_state != .server_hello_done) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;

                        <span class="tok-kw">const</span> client_key_exchange_msg = .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ContentType.html">ContentType</a>.<a href="#">handshake</a>)} ++
                            <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a>.<a href="#">tls_1_2</a>)) ++
                            <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <span class="tok-type">u8</span>, .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.HandshakeType.html">HandshakeType</a>.<a href="#">client_key_exchange</a>)} ++
                                <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u24</span>, <span class="tok-type">u8</span>, <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u8</span>, <span class="tok-type">u8</span>, key_share.secp256r1_kp.public_key.toUncompressedSec1())));
                        <span class="tok-kw">const</span> client_change_cipher_spec_msg = .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ContentType.html">ContentType</a>.<a href="#">change_cipher_spec</a>)} ++
                            <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a>.<a href="#">tls_1_2</a>)) ++
                            <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ChangeCipherSpecType.html">ChangeCipherSpecType</a>, .{.change_cipher_spec});
                        <span class="tok-kw">const</span> pre_master_secret = key_share.getSharedSecret().?;
                        <span class="tok-kw">switch</span> (handshake_cipher) {
                            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| {
                                <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*).A;
                                p.transcript_hash.update(wrapped_handshake);
                                p.transcript_hash.update(client_key_exchange_msg[<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>..]);
                                <span class="tok-kw">const</span> master_secret = <a href="std.crypto.tls.html#std.crypto.tls.hmacExpandLabel">hmacExpandLabel</a>(P.Hmac, pre_master_secret, &amp;.{
                                    <span class="tok-str">&quot;master secret&quot;</span>,
                                    &amp;client_hello_rand,
                                    &amp;server_hello_rand,
                                }, <span class="tok-number">48</span>);
                                <span class="tok-kw">if</span> (options.ssl_key_log_file) |key_log_file| <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.logSecrets">logSecrets</a>(key_log_file, .{
                                    .client_random = &amp;client_hello_rand,
                                }, .{
                                    .CLIENT_RANDOM = &amp;master_secret,
                                });
                                <span class="tok-kw">const</span> key_block = <a href="std.crypto.tls.html#std.crypto.tls.hmacExpandLabel">hmacExpandLabel</a>(
                                    P.Hmac,
                                    &amp;master_secret,
                                    &amp;.{ <span class="tok-str">&quot;key expansion&quot;</span>, &amp;server_hello_rand, &amp;client_hello_rand },
                                    <span class="tok-builtin">@sizeOf</span>(P.Tls_1_2),
                                );
                                <span class="tok-kw">const</span> client_verify_cleartext = .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.HandshakeType.html">HandshakeType</a>.<a href="#">finished</a>)} ++
                                    <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u24</span>, <span class="tok-type">u8</span>, <a href="std.crypto.tls.html#std.crypto.tls.hmacExpandLabel">hmacExpandLabel</a>(
                                        P.Hmac,
                                        &amp;master_secret,
                                        &amp;.{ <span class="tok-str">&quot;client finished&quot;</span>, &amp;p.transcript_hash.peek() },
                                        P.verify_data_length,
                                    ));
                                p.transcript_hash.update(&amp;client_verify_cleartext);
                                p.version = .{ .tls_1_2 = .{
                                    .expected_server_verify_data = <a href="std.crypto.tls.html#std.crypto.tls.hmacExpandLabel">hmacExpandLabel</a>(
                                        P.Hmac,
                                        &amp;master_secret,
                                        &amp;.{ <span class="tok-str">&quot;server finished&quot;</span>, &amp;p.transcript_hash.finalResult() },
                                        P.verify_data_length,
                                    ),
                                    .app_cipher = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesToValue">bytesToValue</a>(P.Tls_1_2, &amp;key_block),
                                } };
                                <span class="tok-kw">const</span> pv = &amp;p.version.tls_1_2;
                                <span class="tok-kw">const</span> nonce: [P.AEAD.nonce_length]<span class="tok-type">u8</span> = nonce: {
                                    <span class="tok-kw">const</span> V = <span class="tok-builtin">@Vector</span>(P.AEAD.nonce_length, <span class="tok-type">u8</span>);
                                    <span class="tok-kw">const</span> pad = [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** (P.AEAD.nonce_length - <span class="tok-number">8</span>);
                                    <span class="tok-kw">const</span> operand: V = pad ++ <span class="tok-builtin">@as</span>([<span class="tok-number">8</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(<a href="std.crypto.tls.Client.html#std.crypto.tls.Client.big">big</a>(write_seq)));
                                    <span class="tok-kw">break</span> :nonce <span class="tok-builtin">@as</span>(V, pv.app_cipher.client_write_IV ++ pv.app_cipher.client_salt) ^ operand;
                                };
                                <span class="tok-kw">var</span> client_verify_msg = .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ContentType.html">ContentType</a>.<a href="#">handshake</a>)} ++
                                    <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a>.<a href="#">tls_1_2</a>)) ++
                                    <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <span class="tok-type">u8</span>, nonce[P.fixed_iv_length..].* ++
                                        <span class="tok-builtin">@as</span>([client_verify_cleartext.len + P.mac_length]<span class="tok-type">u8</span>, <span class="tok-null">undefined</span>));
                                P.AEAD.encrypt(
                                    client_verify_msg[client_verify_msg.len - P.mac_length -
                                        client_verify_cleartext.len ..][<span class="tok-number">0</span>..client_verify_cleartext.len],
                                    client_verify_msg[client_verify_msg.len - P.mac_length ..][<span class="tok-number">0</span>..P.mac_length],
                                    &amp;client_verify_cleartext,
                                    <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.toBytes">toBytes</a>(<a href="std.crypto.tls.Client.html#std.crypto.tls.Client.big">big</a>(write_seq)) ++ client_verify_msg[<span class="tok-number">0</span> .. <span class="tok-number">1</span> + <span class="tok-number">2</span>] ++ <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, client_verify_cleartext.len),
                                    nonce,
                                    pv.app_cipher.client_write_key,
                                );
                                <span class="tok-kw">const</span> all_msgs = client_key_exchange_msg ++ client_change_cipher_spec_msg ++ client_verify_msg;
                                <span class="tok-kw">var</span> all_msgs_vec = [_]<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>{
                                    .{ .base = &amp;all_msgs, .len = all_msgs.len },
                                };
                                <span class="tok-kw">try</span> stream.writevAll(&amp;all_msgs_vec);
                            },
                        }
                        write_seq += <span class="tok-number">1</span>;
                        pending_cipher_state = .application;
                        handshake_state = .finished;
                    },
                    .certificate_verify =&gt; {
                        <span class="tok-kw">if</span> (tls_version != .tls_1_3) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">if</span> (cipher_state != .handshake) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">switch</span> (handshake_state) {
                            .trust_chain_established =&gt; {},
                            .certificate =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsCertificateNotVerified,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage,
                        }
                        <span class="tok-kw">switch</span> (handshake_cipher) {
                            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| {
                                <span class="tok-kw">try</span> main_cert_pub_key.verifySignature(&amp;hsd, &amp;.{
                                    <span class="tok-str">&quot; &quot;</span> ** <span class="tok-number">64</span> ++ <span class="tok-str">&quot;TLS 1.3, server CertificateVerify\x00&quot;</span>,
                                    &amp;p.transcript_hash.peek(),
                                });
                                p.transcript_hash.update(wrapped_handshake);
                            },
                        }
                        handshake_state = .finished;
                    },
                    .finished =&gt; {
                        <span class="tok-kw">if</span> (cipher_state == .cleartext) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        <span class="tok-kw">if</span> (handshake_state != .finished) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;<span class="tok-comment">
                        // This message is to trick buggy proxies into behaving correctly.
                        </span><span class="tok-kw">const</span> client_change_cipher_spec_msg = .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ContentType.html">ContentType</a>.<a href="#">change_cipher_spec</a>)} ++
                            <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a>.<a href="#">tls_1_2</a>)) ++
                            <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ChangeCipherSpecType.html">ChangeCipherSpecType</a>, .{.change_cipher_spec});
                        <span class="tok-kw">const</span> app_cipher = app_cipher: <span class="tok-kw">switch</span> (handshake_cipher) {
                            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p, tag| <span class="tok-kw">switch</span> (tls_version) {
                                .tls_1_3 =&gt; {
                                    <span class="tok-kw">const</span> pv = &amp;p.version.tls_1_3;
                                    <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*).A;
                                    <span class="tok-kw">try</span> hsd.ensure(P.Hmac.mac_length);
                                    <span class="tok-kw">const</span> finished_digest = p.transcript_hash.peek();
                                    p.transcript_hash.update(wrapped_handshake);
                                    <span class="tok-kw">const</span> expected_server_verify_data = <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.hmac">hmac</a>(P.Hmac, &amp;finished_digest, pv.server_finished_key);
                                    <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>.<a href="std.crypto.timing_safe.html">timing_safe</a>.<a href="std.crypto.timing_safe.html#std.crypto.timing_safe.eql">eql</a>([P.Hmac.mac_length]<span class="tok-type">u8</span>, expected_server_verify_data, hsd.array(P.Hmac.mac_length).*)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsDecryptError;
                                    <span class="tok-kw">const</span> handshake_hash = p.transcript_hash.finalResult();
                                    <span class="tok-kw">const</span> verify_data = <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.hmac">hmac</a>(P.Hmac, &amp;handshake_hash, pv.client_finished_key);
                                    <span class="tok-kw">const</span> out_cleartext = .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.HandshakeType.html">HandshakeType</a>.<a href="#">finished</a>)} ++
                                        <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u24</span>, <span class="tok-type">u8</span>, verify_data) ++
                                        .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ContentType.html">ContentType</a>.<a href="#">handshake</a>)};

                                    <span class="tok-kw">const</span> wrapped_len = out_cleartext.len + P.AEAD.tag_length;

                                    <span class="tok-kw">var</span> finished_msg = .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ContentType.html">ContentType</a>.<a href="#">application_data</a>)} ++
                                        <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a>.<a href="#">tls_1_2</a>)) ++
                                        <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <span class="tok-type">u8</span>, <span class="tok-builtin">@as</span>([wrapped_len]<span class="tok-type">u8</span>, <span class="tok-null">undefined</span>));

                                    <span class="tok-kw">const</span> ad = finished_msg[<span class="tok-number">0</span>..<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>];
                                    <span class="tok-kw">const</span> ciphertext = finished_msg[<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>..][<span class="tok-number">0</span>..out_cleartext.len];
                                    <span class="tok-kw">const</span> auth_tag = finished_msg[finished_msg.len - P.AEAD.tag_length ..];
                                    <span class="tok-kw">const</span> nonce = pv.client_handshake_iv;
                                    P.AEAD.encrypt(ciphertext, auth_tag, &amp;out_cleartext, ad, nonce, pv.client_handshake_key);

                                    <span class="tok-kw">const</span> all_msgs = client_change_cipher_spec_msg ++ finished_msg;
                                    <span class="tok-kw">var</span> all_msgs_vec = [_]<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>{
                                        .{ .base = &amp;all_msgs, .len = all_msgs.len },
                                    };
                                    <span class="tok-kw">try</span> stream.writevAll(&amp;all_msgs_vec);

                                    <span class="tok-kw">const</span> client_secret = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, pv.master_secret, <span class="tok-str">&quot;c ap traffic&quot;</span>, &amp;handshake_hash, P.Hash.digest_length);
                                    <span class="tok-kw">const</span> server_secret = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, pv.master_secret, <span class="tok-str">&quot;s ap traffic&quot;</span>, &amp;handshake_hash, P.Hash.digest_length);
                                    <span class="tok-kw">if</span> (options.ssl_key_log_file) |key_log_file| <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.logSecrets">logSecrets</a>(key_log_file, .{
                                        .counter = key_seq,
                                        .client_random = &amp;client_hello_rand,
                                    }, .{
                                        .SERVER_TRAFFIC_SECRET = &amp;server_secret,
                                        .CLIENT_TRAFFIC_SECRET = &amp;client_secret,
                                    });
                                    key_seq += <span class="tok-number">1</span>;
                                    <span class="tok-kw">break</span> :app_cipher <span class="tok-builtin">@unionInit</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ApplicationCipher.html">ApplicationCipher</a>, <span class="tok-builtin">@tagName</span>(tag), .{ .tls_1_3 = .{
                                        .client_secret = client_secret,
                                        .server_secret = server_secret,
                                        .client_key = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, client_secret, <span class="tok-str">&quot;key&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.key_length),
                                        .server_key = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, server_secret, <span class="tok-str">&quot;key&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.key_length),
                                        .client_iv = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, client_secret, <span class="tok-str">&quot;iv&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.nonce_length),
                                        .server_iv = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, server_secret, <span class="tok-str">&quot;iv&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.nonce_length),
                                    } });
                                },
                                .tls_1_2 =&gt; {
                                    <span class="tok-kw">const</span> pv = &amp;p.version.tls_1_2;
                                    <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*).A;
                                    <span class="tok-kw">try</span> hsd.ensure(P.verify_data_length);
                                    <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>.<a href="std.crypto.timing_safe.html">timing_safe</a>.<a href="std.crypto.timing_safe.html#std.crypto.timing_safe.eql">eql</a>([P.verify_data_length]<span class="tok-type">u8</span>, pv.expected_server_verify_data, hsd.array(P.verify_data_length).*)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsDecryptError;
                                    <span class="tok-kw">break</span> :app_cipher <span class="tok-builtin">@unionInit</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ApplicationCipher.html">ApplicationCipher</a>, <span class="tok-builtin">@tagName</span>(tag), .{ .tls_1_2 = pv.app_cipher });
                                },
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                        };
                        <span class="tok-kw">const</span> leftover = d.rest();
                        <span class="tok-kw">var</span> client: <a href="std.crypto.tls.Client.html">Client</a> = .{
                            .tls_version = tls_version,
                            .read_seq = <span class="tok-kw">switch</span> (tls_version) {
                                .tls_1_3 =&gt; <span class="tok-number">0</span>,
                                .tls_1_2 =&gt; read_seq,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                            .write_seq = <span class="tok-kw">switch</span> (tls_version) {
                                .tls_1_3 =&gt; <span class="tok-number">0</span>,
                                .tls_1_2 =&gt; write_seq,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                            .partial_cleartext_idx = <span class="tok-number">0</span>,
                            .partial_ciphertext_idx = <span class="tok-number">0</span>,
                            .partial_ciphertext_end = <span class="tok-builtin">@intCast</span>(leftover.len),
                            .received_close_notify = <span class="tok-null">false</span>,
                            .allow_truncation_attacks = <span class="tok-null">false</span>,
                            .application_cipher = app_cipher,
                            .partially_read_buffer = <span class="tok-null">undefined</span>,
                            .ssl_key_log = <span class="tok-kw">if</span> (options.ssl_key_log_file) |key_log_file| .{
                                .client_key_seq = key_seq,
                                .server_key_seq = key_seq,
                                .client_random = client_hello_rand,
                                .file = key_log_file,
                            } <span class="tok-kw">else</span> <span class="tok-null">null</span>,
                        };
                        <span class="tok-builtin">@memcpy</span>(client.partially_read_buffer[<span class="tok-number">0</span>..leftover.len], leftover);
                        <span class="tok-kw">return</span> client;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage,
                }
                <span class="tok-kw">if</span> (ctd.eof()) <span class="tok-kw">break</span>;
                cleartext_fragment_start = ctd.idx;
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage,
        }
        cleartext_fragment_start = <span class="tok-number">0</span>;
        cleartext_fragment_end = <span class="tok-number">0</span>;
    }
}

<span class="tok-comment">/// Sends TLS-encrypted data to `stream`, which must conform to `StreamInterface`.</span>
<span class="tok-comment">/// Returns the number of cleartext bytes sent, which may be fewer than `bytes.len`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.writeEnd">writeEnd</a>(c, stream, bytes, <span class="tok-null">false</span>);
}

<span class="tok-comment">/// Sends TLS-encrypted data to `stream`, which must conform to `StreamInterface`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAll</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (index &lt; bytes.len) {
        index += <span class="tok-kw">try</span> c.write(stream, bytes[index..]);
    }
}

<span class="tok-comment">/// Sends TLS-encrypted data to `stream`, which must conform to `StreamInterface`.</span>
<span class="tok-comment">/// If `end` is true, then this function additionally sends a `close_notify` alert,</span>
<span class="tok-comment">/// which is necessary for the server to distinguish between a properly finished</span>
<span class="tok-comment">/// TLS session, or a truncation attack.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAllEnd</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, end: <span class="tok-type">bool</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (index &lt; bytes.len) {
        index += <span class="tok-kw">try</span> c.writeEnd(stream, bytes[index..], end);
    }
}

<span class="tok-comment">/// Sends TLS-encrypted data to `stream`, which must conform to `StreamInterface`.</span>
<span class="tok-comment">/// Returns the number of cleartext bytes sent, which may be fewer than `bytes.len`.</span>
<span class="tok-comment">/// If `end` is true, then this function additionally sends a `close_notify` alert,</span>
<span class="tok-comment">/// which is necessary for the server to distinguish between a properly finished</span>
<span class="tok-comment">/// TLS session, or a truncation attack.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeEnd</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, end: <span class="tok-type">bool</span>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> ciphertext_buf: [<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_record_len">max_ciphertext_record_len</a> * <span class="tok-number">4</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> iovecs_buf: [<span class="tok-number">6</span>]<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> prepared = <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.prepareCiphertextRecord">prepareCiphertextRecord</a>(c, &amp;iovecs_buf, &amp;ciphertext_buf, bytes, .application_data);
    <span class="tok-kw">if</span> (end) {
        prepared.iovec_end += <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.prepareCiphertextRecord">prepareCiphertextRecord</a>(
            c,
            iovecs_buf[prepared.iovec_end..],
            ciphertext_buf[prepared.ciphertext_end..],
            &amp;<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.close_notify_alert">close_notify_alert</a>,
            .alert,
        ).iovec_end;
    }

    <span class="tok-kw">const</span> iovec_end = prepared.iovec_end;
    <span class="tok-kw">const</span> overhead_len = prepared.overhead_len;<span class="tok-comment">

    // Ideally we would call writev exactly once here, however, we must ensure
    // that we don't return with a record partially written.
    </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> total_amt: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">var</span> amt = <span class="tok-kw">try</span> stream.writev(iovecs_buf[i..iovec_end]);
        <span class="tok-kw">while</span> (amt &gt;= iovecs_buf[i].len) {
            <span class="tok-kw">const</span> encrypted_amt = iovecs_buf[i].len;
            total_amt += encrypted_amt - overhead_len;
            amt -= encrypted_amt;
            i += <span class="tok-number">1</span>;<span class="tok-comment">
            // Rely on the property that iovecs delineate records, meaning that
            // if amt equals zero here, we have fortunately found ourselves
            // with a short read that aligns at the record boundary.
            </span><span class="tok-kw">if</span> (i &gt;= iovec_end) <span class="tok-kw">return</span> total_amt;<span class="tok-comment">
            // We also cannot return on a vector boundary if the final close_notify is
            // not sent; otherwise the caller would not know to retry the call.
            </span><span class="tok-kw">if</span> (amt == <span class="tok-number">0</span> <span class="tok-kw">and</span> (!end <span class="tok-kw">or</span> i &lt; iovec_end - <span class="tok-number">1</span>)) <span class="tok-kw">return</span> total_amt;
        }
        iovecs_buf[i].base += amt;
        iovecs_buf[i].len -= amt;
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">prepareCiphertextRecord</span>(
    c: *<a href="std.crypto.tls.Client.html">Client</a>,
    iovecs: []<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>,
    ciphertext_buf: []<span class="tok-type">u8</span>,
    bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    inner_content_type: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ContentType.html">ContentType</a>,
) <span class="tok-kw">struct</span> {
    iovec_end: <span class="tok-type">usize</span>,
    ciphertext_end: <span class="tok-type">usize</span>,
    <span class="tok-comment">/// How many bytes are taken up by overhead per record.</span>
    overhead_len: <span class="tok-type">usize</span>,
} {<span class="tok-comment">
    // Due to the trailing inner content type byte in the ciphertext, we need
    // an additional buffer for storing the cleartext into before encrypting.
    </span><span class="tok-kw">var</span> cleartext_buf: [<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_len">max_ciphertext_len</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> ciphertext_end: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> iovec_end: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> bytes_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">switch</span> (c.application_cipher) {
        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| <span class="tok-kw">switch</span> (c.tls_version) {
            .tls_1_3 =&gt; {
                <span class="tok-kw">const</span> pv = &amp;p.tls_1_3;
                <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*);
                <span class="tok-kw">const</span> overhead_len = <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a> + P.AEAD.tag_length + <span class="tok-number">1</span>;
                <span class="tok-kw">const</span> close_notify_alert_reserved = <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.close_notify_alert">close_notify_alert</a>.<a href="#">len</a> + overhead_len;
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                    <span class="tok-kw">const</span> encrypted_content_len: <span class="tok-type">u16</span> = <span class="tok-builtin">@min</span>(
                        bytes.len - bytes_i,
                        <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_inner_record_len">max_ciphertext_inner_record_len</a>,
                        ciphertext_buf.len -|
                            (close_notify_alert_reserved + overhead_len + ciphertext_end),
                    );
                    <span class="tok-kw">if</span> (encrypted_content_len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> .{
                        .iovec_end = iovec_end,
                        .ciphertext_end = ciphertext_end,
                        .overhead_len = overhead_len,
                    };

                    <span class="tok-builtin">@memcpy</span>(cleartext_buf[<span class="tok-number">0</span>..encrypted_content_len], bytes[bytes_i..][<span class="tok-number">0</span>..encrypted_content_len]);
                    cleartext_buf[encrypted_content_len] = <span class="tok-builtin">@intFromEnum</span>(inner_content_type);
                    bytes_i += encrypted_content_len;
                    <span class="tok-kw">const</span> ciphertext_len = encrypted_content_len + <span class="tok-number">1</span>;
                    <span class="tok-kw">const</span> cleartext = cleartext_buf[<span class="tok-number">0</span>..ciphertext_len];

                    <span class="tok-kw">const</span> record_start = ciphertext_end;
                    <span class="tok-kw">const</span> ad = ciphertext_buf[ciphertext_end..][<span class="tok-number">0</span>..<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>];
                    ad.* = .{<span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ContentType.html">ContentType</a>.<a href="#">application_data</a>)} ++
                        <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a>.<a href="#">tls_1_2</a>)) ++
                        <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, ciphertext_len + P.AEAD.tag_length);
                    ciphertext_end += ad.len;
                    <span class="tok-kw">const</span> ciphertext = ciphertext_buf[ciphertext_end..][<span class="tok-number">0</span>..ciphertext_len];
                    ciphertext_end += ciphertext_len;
                    <span class="tok-kw">const</span> auth_tag = ciphertext_buf[ciphertext_end..][<span class="tok-number">0</span>..P.AEAD.tag_length];
                    ciphertext_end += auth_tag.len;
                    <span class="tok-kw">const</span> nonce = nonce: {
                        <span class="tok-kw">const</span> V = <span class="tok-builtin">@Vector</span>(P.AEAD.nonce_length, <span class="tok-type">u8</span>);
                        <span class="tok-kw">const</span> pad = [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** (P.AEAD.nonce_length - <span class="tok-number">8</span>);
                        <span class="tok-kw">const</span> operand: V = pad ++ <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.toBytes">toBytes</a>(<a href="std.crypto.tls.Client.html#std.crypto.tls.Client.big">big</a>(c.write_seq));
                        <span class="tok-kw">break</span> :nonce <span class="tok-builtin">@as</span>(V, pv.client_iv) ^ operand;
                    };
                    P.AEAD.encrypt(ciphertext, auth_tag, cleartext, ad, nonce, pv.client_key);
                    c.write_seq += <span class="tok-number">1</span>;<span class="tok-comment"> // TODO send key_update on overflow

                    </span><span class="tok-kw">const</span> record = ciphertext_buf[record_start..ciphertext_end];
                    iovecs[iovec_end] = .{
                        .base = record.ptr,
                        .len = record.len,
                    };
                    iovec_end += <span class="tok-number">1</span>;
                }
            },
            .tls_1_2 =&gt; {
                <span class="tok-kw">const</span> pv = &amp;p.tls_1_2;
                <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*);
                <span class="tok-kw">const</span> overhead_len = <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a> + P.record_iv_length + P.mac_length;
                <span class="tok-kw">const</span> close_notify_alert_reserved = <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.close_notify_alert">close_notify_alert</a>.<a href="#">len</a> + overhead_len;
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                    <span class="tok-kw">const</span> message_len: <span class="tok-type">u16</span> = <span class="tok-builtin">@min</span>(
                        bytes.len - bytes_i,
                        <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_inner_record_len">max_ciphertext_inner_record_len</a>,
                        ciphertext_buf.len -|
                            (close_notify_alert_reserved + overhead_len + ciphertext_end),
                    );
                    <span class="tok-kw">if</span> (message_len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> .{
                        .iovec_end = iovec_end,
                        .ciphertext_end = ciphertext_end,
                        .overhead_len = overhead_len,
                    };

                    <span class="tok-builtin">@memcpy</span>(cleartext_buf[<span class="tok-number">0</span>..message_len], bytes[bytes_i..][<span class="tok-number">0</span>..message_len]);
                    bytes_i += message_len;
                    <span class="tok-kw">const</span> cleartext = cleartext_buf[<span class="tok-number">0</span>..message_len];

                    <span class="tok-kw">const</span> record_start = ciphertext_end;
                    <span class="tok-kw">const</span> record_header = ciphertext_buf[ciphertext_end..][<span class="tok-number">0</span>..<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>];
                    ciphertext_end += <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>;
                    record_header.* = .{<span class="tok-builtin">@intFromEnum</span>(inner_content_type)} ++
                        <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ProtocolVersion.html">ProtocolVersion</a>.<a href="#">tls_1_2</a>)) ++
                        <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, P.record_iv_length + message_len + P.mac_length);
                    <span class="tok-kw">const</span> ad = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.toBytes">toBytes</a>(<a href="std.crypto.tls.Client.html#std.crypto.tls.Client.big">big</a>(c.write_seq)) ++ record_header[<span class="tok-number">0</span> .. <span class="tok-number">1</span> + <span class="tok-number">2</span>] ++ <a href="std.crypto.tls.html#std.crypto.tls.int">int</a>(<span class="tok-type">u16</span>, message_len);
                    <span class="tok-kw">const</span> record_iv = ciphertext_buf[ciphertext_end..][<span class="tok-number">0</span>..P.record_iv_length];
                    ciphertext_end += P.record_iv_length;
                    <span class="tok-kw">const</span> nonce: [P.AEAD.nonce_length]<span class="tok-type">u8</span> = nonce: {
                        <span class="tok-kw">const</span> V = <span class="tok-builtin">@Vector</span>(P.AEAD.nonce_length, <span class="tok-type">u8</span>);
                        <span class="tok-kw">const</span> pad = [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** (P.AEAD.nonce_length - <span class="tok-number">8</span>);
                        <span class="tok-kw">const</span> operand: V = pad ++ <span class="tok-builtin">@as</span>([<span class="tok-number">8</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(<a href="std.crypto.tls.Client.html#std.crypto.tls.Client.big">big</a>(c.write_seq)));
                        <span class="tok-kw">break</span> :nonce <span class="tok-builtin">@as</span>(V, pv.client_write_IV ++ pv.client_salt) ^ operand;
                    };
                    record_iv.* = nonce[P.fixed_iv_length..].*;
                    <span class="tok-kw">const</span> ciphertext = ciphertext_buf[ciphertext_end..][<span class="tok-number">0</span>..message_len];
                    ciphertext_end += message_len;
                    <span class="tok-kw">const</span> auth_tag = ciphertext_buf[ciphertext_end..][<span class="tok-number">0</span>..P.mac_length];
                    ciphertext_end += P.mac_length;
                    P.AEAD.encrypt(ciphertext, auth_tag, cleartext, ad, nonce, pv.client_write_key);
                    c.write_seq += <span class="tok-number">1</span>;<span class="tok-comment"> // TODO send key_update on overflow

                    </span><span class="tok-kw">const</span> record = ciphertext_buf[record_start..ciphertext_end];
                    iovecs[iovec_end] = .{
                        .base = record.ptr,
                        .len = record.len,
                    };
                    iovec_end += <span class="tok-number">1</span>;
                }
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        },
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eof</span>(c: <a href="std.crypto.tls.Client.html">Client</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> c.received_close_notify <span class="tok-kw">and</span>
        c.partial_cleartext_idx &gt;= c.partial_ciphertext_idx <span class="tok-kw">and</span>
        c.partial_ciphertext_idx &gt;= c.partial_ciphertext_end;
}

<span class="tok-comment">/// Receives TLS-encrypted data from `stream`, which must conform to `StreamInterface`.</span>
<span class="tok-comment">/// Returns the number of bytes read, calling the underlying read function the</span>
<span class="tok-comment">/// minimal number of times until the buffer has at least `len` bytes filled.</span>
<span class="tok-comment">/// If the number read is less than `len` it means the stream reached the end.</span>
<span class="tok-comment">/// Reaching the end of the stream is not an error condition.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readAtLeast</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, buffer: []<span class="tok-type">u8</span>, len: <span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> iovecs = [<span class="tok-number">1</span>]<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>{.{ .base = buffer.ptr, .len = buffer.len }};
    <span class="tok-kw">return</span> <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.readvAtLeast">readvAtLeast</a>(c, stream, &amp;iovecs, len);
}

<span class="tok-comment">/// Receives TLS-encrypted data from `stream`, which must conform to `StreamInterface`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, buffer: []<span class="tok-type">u8</span>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.readAtLeast">readAtLeast</a>(c, stream, buffer, <span class="tok-number">1</span>);
}

<span class="tok-comment">/// Receives TLS-encrypted data from `stream`, which must conform to `StreamInterface`.</span>
<span class="tok-comment">/// Returns the number of bytes read. If the number read is smaller than</span>
<span class="tok-comment">/// `buffer.len`, it means the stream reached the end. Reaching the end of the</span>
<span class="tok-comment">/// stream is not an error condition.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readAll</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, buffer: []<span class="tok-type">u8</span>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.readAtLeast">readAtLeast</a>(c, stream, buffer, buffer.len);
}

<span class="tok-comment">/// Receives TLS-encrypted data from `stream`, which must conform to `StreamInterface`.</span>
<span class="tok-comment">/// Returns the number of bytes read. If the number read is less than the space</span>
<span class="tok-comment">/// provided it means the stream reached the end. Reaching the end of the</span>
<span class="tok-comment">/// stream is not an error condition.</span>
<span class="tok-comment">/// The `iovecs` parameter is mutable because this function needs to mutate the fields in</span>
<span class="tok-comment">/// order to handle partial reads from the underlying stream layer.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readv</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, iovecs: []<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.readvAtLeast">readvAtLeast</a>(c, stream, iovecs, <span class="tok-number">1</span>);
}

<span class="tok-comment">/// Receives TLS-encrypted data from `stream`, which must conform to `StreamInterface`.</span>
<span class="tok-comment">/// Returns the number of bytes read, calling the underlying read function the</span>
<span class="tok-comment">/// minimal number of times until the iovecs have at least `len` bytes filled.</span>
<span class="tok-comment">/// If the number read is less than `len` it means the stream reached the end.</span>
<span class="tok-comment">/// Reaching the end of the stream is not an error condition.</span>
<span class="tok-comment">/// The `iovecs` parameter is mutable because this function needs to mutate the fields in</span>
<span class="tok-comment">/// order to handle partial reads from the underlying stream layer.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readvAtLeast</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, iovecs: []<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>, len: <span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (c.eof()) <span class="tok-kw">return</span> <span class="tok-number">0</span>;

    <span class="tok-kw">var</span> off_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> vec_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">var</span> amt = <span class="tok-kw">try</span> c.readvAdvanced(stream, iovecs[vec_i..]);
        off_i += amt;
        <span class="tok-kw">if</span> (c.eof() <span class="tok-kw">or</span> off_i &gt;= len) <span class="tok-kw">return</span> off_i;
        <span class="tok-kw">while</span> (amt &gt;= iovecs[vec_i].len) {
            amt -= iovecs[vec_i].len;
            vec_i += <span class="tok-number">1</span>;
        }
        iovecs[vec_i].base += amt;
        iovecs[vec_i].len -= amt;
    }
}

<span class="tok-comment">/// Receives TLS-encrypted data from `stream`, which must conform to `StreamInterface`.</span>
<span class="tok-comment">/// Returns number of bytes that have been read, populated inside `iovecs`. A</span>
<span class="tok-comment">/// return value of zero bytes does not mean end of stream. Instead, check the `eof()`</span>
<span class="tok-comment">/// for the end of stream. The `eof()` may be true after any call to</span>
<span class="tok-comment">/// `read`, including when greater than zero bytes are returned, and this</span>
<span class="tok-comment">/// function asserts that `eof()` is `false`.</span>
<span class="tok-comment">/// See `readv` for a higher level function that has the same, familiar API as</span>
<span class="tok-comment">/// other read functions, such as `std.fs.File.read`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readvAdvanced</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, stream: <span class="tok-kw">anytype</span>, iovecs: []<span class="tok-kw">const</span> <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> vp: <a href="std.crypto.tls.Client.VecPut.html">VecPut</a> = .{ .iovecs = iovecs };<span class="tok-comment">

    // Give away the buffered cleartext we have, if any.
    </span><span class="tok-kw">const</span> partial_cleartext = c.partially_read_buffer[c.partial_cleartext_idx..c.partial_ciphertext_idx];
    <span class="tok-kw">if</span> (partial_cleartext.len &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> amt: <span class="tok-type">u15</span> = <span class="tok-builtin">@intCast</span>(vp.put(partial_cleartext));
        c.partial_cleartext_idx += amt;

        <span class="tok-kw">if</span> (c.partial_cleartext_idx == c.partial_ciphertext_idx <span class="tok-kw">and</span>
            c.partial_ciphertext_end == c.partial_ciphertext_idx)
        {<span class="tok-comment">
            // The buffer is now empty.
            </span>c.partial_cleartext_idx = <span class="tok-number">0</span>;
            c.partial_ciphertext_idx = <span class="tok-number">0</span>;
            c.partial_ciphertext_end = <span class="tok-number">0</span>;
        }

        <span class="tok-kw">if</span> (c.received_close_notify) {
            c.partial_ciphertext_end = <span class="tok-number">0</span>;
            <a href="std.debug.html#std.debug.assert">assert</a>(vp.total == amt);
            <span class="tok-kw">return</span> amt;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (amt &gt; <span class="tok-number">0</span>) {<span class="tok-comment">
            // We don't need more data, so don't call read.
            </span><a href="std.debug.html#std.debug.assert">assert</a>(vp.total == amt);
            <span class="tok-kw">return</span> amt;
        }
    }

    <a href="std.debug.html#std.debug.assert">assert</a>(!c.received_close_notify);<span class="tok-comment">

    // Ideally, this buffer would never be used. It is needed when `iovecs` are
    // too small to fit the cleartext, which may be as large as `max_ciphertext_len`.
    </span><span class="tok-kw">var</span> cleartext_stack_buffer: [<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_len">max_ciphertext_len</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">
    // Temporarily stores ciphertext before decrypting it and giving it to `iovecs`.
    </span><span class="tok-kw">var</span> in_stack_buffer: [<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_len">max_ciphertext_len</a> * <span class="tok-number">4</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">
    // How many bytes left in the user's buffer.
    </span><span class="tok-kw">const</span> free_size = vp.freeSize();<span class="tok-comment">
    // The amount of the user's buffer that we need to repurpose for storing
    // ciphertext. The end of the buffer will be used for such purposes.
    </span><span class="tok-kw">const</span> ciphertext_buf_len = (free_size / <span class="tok-number">2</span>) -| in_stack_buffer.len;<span class="tok-comment">
    // The amount of the user's buffer that will be used to give cleartext. The
    // beginning of the buffer will be used for such purposes.
    </span><span class="tok-kw">const</span> cleartext_buf_len = free_size - ciphertext_buf_len;<span class="tok-comment">

    // Recoup `partially_read_buffer` space. This is necessary because it is assumed
    // below that `frag0` is big enough to hold at least one record.
    </span><a href="std.crypto.tls.Client.html#std.crypto.tls.Client.limitedOverlapCopy">limitedOverlapCopy</a>(c.partially_read_buffer[<span class="tok-number">0</span>..c.partial_ciphertext_end], c.partial_ciphertext_idx);
    c.partial_ciphertext_end -= c.partial_ciphertext_idx;
    c.partial_ciphertext_idx = <span class="tok-number">0</span>;
    c.partial_cleartext_idx = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> first_iov = c.partially_read_buffer[c.partial_ciphertext_end..];

    <span class="tok-kw">var</span> ask_iovecs_buf: [<span class="tok-number">2</span>]<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a> = .{
        .{
            .base = first_iov.ptr,
            .len = first_iov.len,
        },
        .{
            .base = &amp;in_stack_buffer,
            .len = in_stack_buffer.len,
        },
    };<span class="tok-comment">

    // Cleartext capacity of output buffer, in records. Minimum one full record.
    </span><span class="tok-kw">const</span> buf_cap = <span class="tok-builtin">@max</span>(cleartext_buf_len / <a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_len">max_ciphertext_len</a>, <span class="tok-number">1</span>);
    <span class="tok-kw">const</span> wanted_read_len = buf_cap * (<a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_len">max_ciphertext_len</a> + <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>);
    <span class="tok-kw">const</span> ask_len = <span class="tok-builtin">@max</span>(wanted_read_len, cleartext_stack_buffer.len) - c.partial_ciphertext_end;
    <span class="tok-kw">const</span> ask_iovecs = <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.limitVecs">limitVecs</a>(&amp;ask_iovecs_buf, ask_len);
    <span class="tok-kw">const</span> actual_read_len = <span class="tok-kw">try</span> stream.readv(ask_iovecs);
    <span class="tok-kw">if</span> (actual_read_len == <span class="tok-number">0</span>) {<span class="tok-comment">
        // This is either a truncation attack, a bug in the server, or an
        // intentional omission of the close_notify message due to truncation
        // detection handled above the TLS layer.
        </span><span class="tok-kw">if</span> (c.allow_truncation_attacks) {
            c.received_close_notify = <span class="tok-null">true</span>;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsConnectionTruncated;
        }
    }<span class="tok-comment">

    // There might be more bytes inside `in_stack_buffer` that need to be processed,
    // but at least frag0 will have one complete ciphertext record.
    </span><span class="tok-kw">const</span> frag0_end = <span class="tok-builtin">@min</span>(c.partially_read_buffer.len, c.partial_ciphertext_end + actual_read_len);
    <span class="tok-kw">const</span> frag0 = c.partially_read_buffer[c.partial_ciphertext_idx..frag0_end];
    <span class="tok-kw">var</span> frag1 = in_stack_buffer[<span class="tok-number">0</span>..actual_read_len -| first_iov.len];<span class="tok-comment">
    // We need to decipher frag0 and frag1 but there may be a ciphertext record
    // straddling the boundary. We can handle this with two memcpy() calls to
    // assemble the straddling record in between handling the two sides.
    </span><span class="tok-kw">var</span> frag = frag0;
    <span class="tok-kw">var</span> in: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">if</span> (in == frag.len) {<span class="tok-comment">
            // Perfect split.
            </span><span class="tok-kw">if</span> (frag.ptr == frag1.ptr) {
                c.partial_ciphertext_end = c.partial_ciphertext_idx;
                <span class="tok-kw">return</span> vp.total;
            }
            frag = frag1;
            in = <span class="tok-number">0</span>;
            <span class="tok-kw">continue</span>;
        }

        <span class="tok-kw">if</span> (in + <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a> &gt; frag.len) {
            <span class="tok-kw">if</span> (frag.ptr == frag1.ptr)
                <span class="tok-kw">return</span> <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.finishRead">finishRead</a>(c, frag, in, vp.total);

            <span class="tok-kw">const</span> first = frag[in..];

            <span class="tok-kw">if</span> (frag1.len &lt; <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>)
                <span class="tok-kw">return</span> <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.finishRead2">finishRead2</a>(c, first, frag1, vp.total);<span class="tok-comment">

            // A record straddles the two fragments. Copy into the now-empty first fragment.
            </span><span class="tok-kw">const</span> record_len_byte_0: <span class="tok-type">u16</span> = <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.straddleByte">straddleByte</a>(frag, frag1, in + <span class="tok-number">3</span>);
            <span class="tok-kw">const</span> record_len_byte_1: <span class="tok-type">u16</span> = <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.straddleByte">straddleByte</a>(frag, frag1, in + <span class="tok-number">4</span>);
            <span class="tok-kw">const</span> record_len = (record_len_byte_0 &lt;&lt; <span class="tok-number">8</span>) | record_len_byte_1;
            <span class="tok-kw">if</span> (record_len &gt; <a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_len">max_ciphertext_len</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsRecordOverflow;

            <span class="tok-kw">const</span> full_record_len = record_len + <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>;
            <span class="tok-kw">const</span> second_len = full_record_len - first.len;
            <span class="tok-kw">if</span> (frag1.len &lt; second_len)
                <span class="tok-kw">return</span> <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.finishRead2">finishRead2</a>(c, first, frag1, vp.total);

            <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.limitedOverlapCopy">limitedOverlapCopy</a>(frag, in);
            <span class="tok-builtin">@memcpy</span>(frag[first.len..][<span class="tok-number">0</span>..second_len], frag1[<span class="tok-number">0</span>..second_len]);
            frag = frag[<span class="tok-number">0</span>..full_record_len];
            frag1 = frag1[second_len..];
            in = <span class="tok-number">0</span>;
            <span class="tok-kw">continue</span>;
        }
        <span class="tok-kw">const</span> ct: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.ContentType.html">ContentType</a> = <span class="tok-builtin">@enumFromInt</span>(frag[in]);
        in += <span class="tok-number">1</span>;
        <span class="tok-kw">const</span> legacy_version = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u16</span>, frag[in..][<span class="tok-number">0</span>..<span class="tok-number">2</span>], .big);
        in += <span class="tok-number">2</span>;
        _ = legacy_version;
        <span class="tok-kw">const</span> record_len = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u16</span>, frag[in..][<span class="tok-number">0</span>..<span class="tok-number">2</span>], .big);
        <span class="tok-kw">if</span> (record_len &gt; <a href="std.crypto.tls.html#std.crypto.tls.max_ciphertext_len">max_ciphertext_len</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsRecordOverflow;
        in += <span class="tok-number">2</span>;
        <span class="tok-kw">const</span> end = in + record_len;
        <span class="tok-kw">if</span> (end &gt; frag.len) {<span class="tok-comment">
            // We need the record header on the next iteration of the loop.
            </span>in -= <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>;

            <span class="tok-kw">if</span> (frag.ptr == frag1.ptr)
                <span class="tok-kw">return</span> <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.finishRead">finishRead</a>(c, frag, in, vp.total);<span class="tok-comment">

            // A record straddles the two fragments. Copy into the now-empty first fragment.
            </span><span class="tok-kw">const</span> first = frag[in..];
            <span class="tok-kw">const</span> full_record_len = record_len + <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.html#std.crypto.tls.record_header_len">record_header_len</a>;
            <span class="tok-kw">const</span> second_len = full_record_len - first.len;
            <span class="tok-kw">if</span> (frag1.len &lt; second_len)
                <span class="tok-kw">return</span> <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.finishRead2">finishRead2</a>(c, first, frag1, vp.total);

            <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.limitedOverlapCopy">limitedOverlapCopy</a>(frag, in);
            <span class="tok-builtin">@memcpy</span>(frag[first.len..][<span class="tok-number">0</span>..second_len], frag1[<span class="tok-number">0</span>..second_len]);
            frag = frag[<span class="tok-number">0</span>..full_record_len];
            frag1 = frag1[second_len..];
            in = <span class="tok-number">0</span>;
            <span class="tok-kw">continue</span>;
        }
        <span class="tok-kw">const</span> cleartext, <span class="tok-kw">const</span> inner_ct: tls.ContentType = cleartext: <span class="tok-kw">switch</span> (c.application_cipher) {
            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| <span class="tok-kw">switch</span> (c.tls_version) {
                .tls_1_3 =&gt; {
                    <span class="tok-kw">const</span> pv = &amp;p.tls_1_3;
                    <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*);
                    <span class="tok-kw">const</span> ad = frag[in - tls.record_header_len ..][<span class="tok-number">0</span>..tls.record_header_len];
                    <span class="tok-kw">const</span> ciphertext_len = record_len - P.AEAD.tag_length;
                    <span class="tok-kw">const</span> ciphertext = frag[in..][<span class="tok-number">0</span>..ciphertext_len];
                    in += ciphertext_len;
                    <span class="tok-kw">const</span> auth_tag = frag[in..][<span class="tok-number">0</span>..P.AEAD.tag_length].*;
                    <span class="tok-kw">const</span> nonce = nonce: {
                        <span class="tok-kw">const</span> V = <span class="tok-builtin">@Vector</span>(P.AEAD.nonce_length, <span class="tok-type">u8</span>);
                        <span class="tok-kw">const</span> pad = [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** (P.AEAD.nonce_length - <span class="tok-number">8</span>);
                        <span class="tok-kw">const</span> operand: V = pad ++ std.mem.toBytes(big(c.read_seq));
                        <span class="tok-kw">break</span> :nonce <span class="tok-builtin">@as</span>(V, pv.server_iv) ^ operand;
                    };
                    <span class="tok-kw">const</span> out_buf = vp.peek();
                    <span class="tok-kw">const</span> cleartext_buf = <span class="tok-kw">if</span> (ciphertext.len &lt;= out_buf.len)
                        out_buf
                    <span class="tok-kw">else</span>
                        &amp;cleartext_stack_buffer;
                    <span class="tok-kw">const</span> cleartext = cleartext_buf[<span class="tok-number">0</span>..ciphertext.len];
                    P.AEAD.decrypt(cleartext, ciphertext, auth_tag, ad, nonce, pv.server_key) <span class="tok-kw">catch</span>
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsBadRecordMac;
                    <span class="tok-kw">const</span> msg = mem.trimRight(<span class="tok-type">u8</span>, cleartext, <span class="tok-str">&quot;\x00&quot;</span>);
                    <span class="tok-kw">break</span> :cleartext .{ msg[<span class="tok-number">0</span> .. msg.len - <span class="tok-number">1</span>], <span class="tok-builtin">@enumFromInt</span>(msg[msg.len - <span class="tok-number">1</span>]) };
                },
                .tls_1_2 =&gt; {
                    <span class="tok-kw">const</span> pv = &amp;p.tls_1_2;
                    <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*);
                    <span class="tok-kw">const</span> message_len: <span class="tok-type">u16</span> = record_len - P.record_iv_length - P.mac_length;
                    <span class="tok-kw">const</span> ad = std.mem.toBytes(big(c.read_seq)) ++
                        frag[in - tls.record_header_len ..][<span class="tok-number">0</span> .. <span class="tok-number">1</span> + <span class="tok-number">2</span>] ++
                        std.mem.toBytes(big(message_len));
                    <span class="tok-kw">const</span> record_iv = frag[in..][<span class="tok-number">0</span>..P.record_iv_length].*;
                    in += P.record_iv_length;
                    <span class="tok-kw">const</span> masked_read_seq = c.read_seq &amp;
                        <span class="tok-kw">comptime</span> std.math.shl(<span class="tok-type">u64</span>, std.math.maxInt(<span class="tok-type">u64</span>), <span class="tok-number">8</span> * P.record_iv_length);
                    <span class="tok-kw">const</span> nonce: [P.AEAD.nonce_length]<span class="tok-type">u8</span> = nonce: {
                        <span class="tok-kw">const</span> V = <span class="tok-builtin">@Vector</span>(P.AEAD.nonce_length, <span class="tok-type">u8</span>);
                        <span class="tok-kw">const</span> pad = [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** (P.AEAD.nonce_length - <span class="tok-number">8</span>);
                        <span class="tok-kw">const</span> operand: V = pad ++ <span class="tok-builtin">@as</span>([<span class="tok-number">8</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(big(masked_read_seq)));
                        <span class="tok-kw">break</span> :nonce <span class="tok-builtin">@as</span>(V, pv.server_write_IV ++ record_iv) ^ operand;
                    };
                    <span class="tok-kw">const</span> ciphertext = frag[in..][<span class="tok-number">0</span>..message_len];
                    in += message_len;
                    <span class="tok-kw">const</span> auth_tag = frag[in..][<span class="tok-number">0</span>..P.mac_length].*;
                    in += P.mac_length;
                    <span class="tok-kw">const</span> out_buf = vp.peek();
                    <span class="tok-kw">const</span> cleartext_buf = <span class="tok-kw">if</span> (message_len &lt;= out_buf.len)
                        out_buf
                    <span class="tok-kw">else</span>
                        &amp;cleartext_stack_buffer;
                    <span class="tok-kw">const</span> cleartext = cleartext_buf[<span class="tok-number">0</span>..ciphertext.len];
                    P.AEAD.decrypt(cleartext, ciphertext, auth_tag, ad, nonce, pv.server_write_key) <span class="tok-kw">catch</span>
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsBadRecordMac;
                    <span class="tok-kw">break</span> :cleartext .{ cleartext, ct };
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            },
        };
        c.read_seq = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(<span class="tok-type">u64</span>, c.read_seq, <span class="tok-number">1</span>);
        <span class="tok-kw">switch</span> (inner_ct) {
            .alert =&gt; {
                <span class="tok-kw">if</span> (cleartext.len != <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsDecodeError;
                <span class="tok-kw">const</span> level: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.AlertLevel.html">AlertLevel</a> = <span class="tok-builtin">@enumFromInt</span>(cleartext[<span class="tok-number">0</span>]);
                <span class="tok-kw">const</span> desc: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.AlertDescription.html">AlertDescription</a> = <span class="tok-builtin">@enumFromInt</span>(cleartext[<span class="tok-number">1</span>]);
                <span class="tok-kw">if</span> (desc == .close_notify) {
                    c.received_close_notify = <span class="tok-null">true</span>;
                    c.partial_ciphertext_end = c.partial_ciphertext_idx;
                    <span class="tok-kw">return</span> vp.total;
                }
                _ = level;

                <span class="tok-kw">try</span> desc.toError();<span class="tok-comment">
                // TODO: handle server-side closures
                </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
            },
            .handshake =&gt; {
                <span class="tok-kw">var</span> ct_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                    <span class="tok-kw">const</span> handshake_type: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.HandshakeType.html">HandshakeType</a> = <span class="tok-builtin">@enumFromInt</span>(cleartext[ct_i]);
                    ct_i += <span class="tok-number">1</span>;
                    <span class="tok-kw">const</span> handshake_len = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u24</span>, cleartext[ct_i..][<span class="tok-number">0</span>..<span class="tok-number">3</span>], .big);
                    ct_i += <span class="tok-number">3</span>;
                    <span class="tok-kw">const</span> next_handshake_i = ct_i + handshake_len;
                    <span class="tok-kw">if</span> (next_handshake_i &gt; cleartext.len)
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsBadLength;
                    <span class="tok-kw">const</span> handshake = cleartext[ct_i..next_handshake_i];
                    <span class="tok-kw">switch</span> (handshake_type) {
                        .new_session_ticket =&gt; {<span class="tok-comment">
                            // This client implementation ignores new session tickets.
                        </span>},
                        .key_update =&gt; {
                            <span class="tok-kw">switch</span> (c.application_cipher) {
                                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| {
                                    <span class="tok-kw">const</span> pv = &amp;p.tls_1_3;
                                    <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*);
                                    <span class="tok-kw">const</span> server_secret = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, pv.server_secret, <span class="tok-str">&quot;traffic upd&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.Hash.digest_length);
                                    <span class="tok-kw">if</span> (c.ssl_key_log) |*key_log| <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.logSecrets">logSecrets</a>(key_log.file, .{
                                        .counter = key_log.serverCounter(),
                                        .client_random = &amp;key_log.client_random,
                                    }, .{
                                        .SERVER_TRAFFIC_SECRET = &amp;server_secret,
                                    });
                                    pv.server_secret = server_secret;
                                    pv.server_key = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, server_secret, <span class="tok-str">&quot;key&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.key_length);
                                    pv.server_iv = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, server_secret, <span class="tok-str">&quot;iv&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.nonce_length);
                                },
                            }
                            c.read_seq = <span class="tok-number">0</span>;

                            <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.KeyUpdateRequest.html">KeyUpdateRequest</a>, <span class="tok-builtin">@enumFromInt</span>(handshake[<span class="tok-number">0</span>]))) {
                                .update_requested =&gt; {
                                    <span class="tok-kw">switch</span> (c.application_cipher) {
                                        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |*p| {
                                            <span class="tok-kw">const</span> pv = &amp;p.tls_1_3;
                                            <span class="tok-kw">const</span> P = <span class="tok-builtin">@TypeOf</span>(p.*);
                                            <span class="tok-kw">const</span> client_secret = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, pv.client_secret, <span class="tok-str">&quot;traffic upd&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.Hash.digest_length);
                                            <span class="tok-kw">if</span> (c.ssl_key_log) |*key_log| <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.logSecrets">logSecrets</a>(key_log.file, .{
                                                .counter = key_log.clientCounter(),
                                                .client_random = &amp;key_log.client_random,
                                            }, .{
                                                .CLIENT_TRAFFIC_SECRET = &amp;client_secret,
                                            });
                                            pv.client_secret = client_secret;
                                            pv.client_key = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, client_secret, <span class="tok-str">&quot;key&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.key_length);
                                            pv.client_iv = <a href="std.crypto.tls.html#std.crypto.tls.hkdfExpandLabel">hkdfExpandLabel</a>(P.Hkdf, client_secret, <span class="tok-str">&quot;iv&quot;</span>, <span class="tok-str">&quot;&quot;</span>, P.AEAD.nonce_length);
                                        },
                                    }
                                    c.write_seq = <span class="tok-number">0</span>;
                                },
                                .update_not_requested =&gt; {},
                                _ =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter,
                            }
                        },
                        <span class="tok-kw">else</span> =&gt; {
                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage;
                        },
                    }
                    ct_i = next_handshake_i;
                    <span class="tok-kw">if</span> (ct_i &gt;= cleartext.len) <span class="tok-kw">break</span>;
                }
            },
            .application_data =&gt; {<span class="tok-comment">
                // Determine whether the output buffer or a stack
                // buffer was used for storing the cleartext.
                </span><span class="tok-kw">if</span> (cleartext.ptr == &amp;cleartext_stack_buffer) {<span class="tok-comment">
                    // Stack buffer was used, so we must copy to the output buffer.
                    </span><span class="tok-kw">if</span> (c.partial_ciphertext_idx &gt; c.partial_cleartext_idx) {<span class="tok-comment">
                        // We have already run out of room in iovecs. Continue
                        // appending to `partially_read_buffer`.
                        </span><span class="tok-builtin">@memcpy</span>(
                            c.partially_read_buffer[c.partial_ciphertext_idx..][<span class="tok-number">0</span>..cleartext.len],
                            cleartext,
                        );
                        c.partial_ciphertext_idx = <span class="tok-builtin">@intCast</span>(c.partial_ciphertext_idx + cleartext.len);
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">const</span> amt = vp.put(cleartext);
                        <span class="tok-kw">if</span> (amt &lt; cleartext.len) {
                            <span class="tok-kw">const</span> rest = cleartext[amt..];
                            c.partial_cleartext_idx = <span class="tok-number">0</span>;
                            c.partial_ciphertext_idx = <span class="tok-builtin">@intCast</span>(rest.len);
                            <span class="tok-builtin">@memcpy</span>(c.partially_read_buffer[<span class="tok-number">0</span>..rest.len], rest);
                        }
                    }
                } <span class="tok-kw">else</span> {<span class="tok-comment">
                    // Output buffer was used directly which means no
                    // memory copying needs to occur, and we can move
                    // on to the next ciphertext record.
                    </span>vp.next(cleartext.len);
                }
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsUnexpectedMessage,
        }
        in = end;
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">logSecrets</span>(key_log_file: <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>, context: <span class="tok-kw">anytype</span>, secrets: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> locked = <span class="tok-kw">if</span> (key_log_file.lock(.exclusive)) |_| <span class="tok-null">true</span> <span class="tok-kw">else</span> |_| <span class="tok-null">false</span>;
    <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (locked) key_log_file.unlock();
    key_log_file.seekFromEnd(<span class="tok-number">0</span>) <span class="tok-kw">catch</span> {};
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(secrets)).@&quot;struct&quot;.fields) |field| key_log_file.writer().print(<span class="tok-str">&quot;{s}&quot;</span> ++
        (<span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<span class="tok-builtin">@TypeOf</span>(context), <span class="tok-str">&quot;counter&quot;</span>)) <span class="tok-str">&quot;_{d}&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;&quot;</span>) ++ <span class="tok-str">&quot; {} {}\n&quot;</span>, .{field.name} ++
        (<span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<span class="tok-builtin">@TypeOf</span>(context), <span class="tok-str">&quot;counter&quot;</span>)) .{context.counter} <span class="tok-kw">else</span> .{}) ++ .{
        <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.fmtSliceHexLower">fmtSliceHexLower</a>(context.client_random),
        <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.fmtSliceHexLower">fmtSliceHexLower</a>(<span class="tok-builtin">@field</span>(secrets, field.name)),
    }) <span class="tok-kw">catch</span> {};
}

<span class="tok-kw">fn</span> <span class="tok-fn">finishRead</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, frag: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, in: <span class="tok-type">usize</span>, out: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> saved_buf = frag[in..];
    <span class="tok-kw">if</span> (c.partial_ciphertext_idx &gt; c.partial_cleartext_idx) {<span class="tok-comment">
        // There is cleartext at the beginning already which we need to preserve.
        </span>c.partial_ciphertext_end = <span class="tok-builtin">@intCast</span>(c.partial_ciphertext_idx + saved_buf.len);
        <span class="tok-builtin">@memcpy</span>(c.partially_read_buffer[c.partial_ciphertext_idx..][<span class="tok-number">0</span>..saved_buf.len], saved_buf);
    } <span class="tok-kw">else</span> {
        c.partial_cleartext_idx = <span class="tok-number">0</span>;
        c.partial_ciphertext_idx = <span class="tok-number">0</span>;
        c.partial_ciphertext_end = <span class="tok-builtin">@intCast</span>(saved_buf.len);
        <span class="tok-builtin">@memcpy</span>(c.partially_read_buffer[<span class="tok-number">0</span>..saved_buf.len], saved_buf);
    }
    <span class="tok-kw">return</span> out;
}

<span class="tok-comment">/// Note that `first` usually overlaps with `c.partially_read_buffer`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">finishRead2</span>(c: *<a href="std.crypto.tls.Client.html">Client</a>, first: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, frag1: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (c.partial_ciphertext_idx &gt; c.partial_cleartext_idx) {<span class="tok-comment">
        // There is cleartext at the beginning already which we need to preserve.
        </span>c.partial_ciphertext_end = <span class="tok-builtin">@intCast</span>(c.partial_ciphertext_idx + first.len + frag1.len);<span class="tok-comment">
        // TODO: eliminate this call to copyForwards
        </span><a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyForwards">copyForwards</a>(<span class="tok-type">u8</span>, c.partially_read_buffer[c.partial_ciphertext_idx..][<span class="tok-number">0</span>..first.len], first);
        <span class="tok-builtin">@memcpy</span>(c.partially_read_buffer[c.partial_ciphertext_idx + first.len ..][<span class="tok-number">0</span>..frag1.len], frag1);
    } <span class="tok-kw">else</span> {
        c.partial_cleartext_idx = <span class="tok-number">0</span>;
        c.partial_ciphertext_idx = <span class="tok-number">0</span>;
        c.partial_ciphertext_end = <span class="tok-builtin">@intCast</span>(first.len + frag1.len);<span class="tok-comment">
        // TODO: eliminate this call to copyForwards
        </span><a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyForwards">copyForwards</a>(<span class="tok-type">u8</span>, c.partially_read_buffer[<span class="tok-number">0</span>..first.len], first);
        <span class="tok-builtin">@memcpy</span>(c.partially_read_buffer[first.len..][<span class="tok-number">0</span>..frag1.len], frag1);
    }
    <span class="tok-kw">return</span> out;
}

<span class="tok-kw">fn</span> <span class="tok-fn">limitedOverlapCopy</span>(frag: []<span class="tok-type">u8</span>, in: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> first = frag[in..];
    <span class="tok-kw">if</span> (first.len &lt;= in) {<span class="tok-comment">
        // A single, non-overlapping memcpy suffices.
        </span><span class="tok-builtin">@memcpy</span>(frag[<span class="tok-number">0</span>..first.len], first);
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // One memcpy call would overlap, so just do this instead.
        </span><a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyForwards">copyForwards</a>(<span class="tok-type">u8</span>, frag, first);
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">straddleByte</span>(s1: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, s2: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, index: <span class="tok-type">usize</span>) <span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (index &lt; s1.len) {
        <span class="tok-kw">return</span> s1[index];
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> s2[index - s1.len];
    }
}

<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> native_endian = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>.<a href="#">endian</a>();

<span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">big</span>(x: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(x) {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.crypto.tls.Client.html#std.crypto.tls.Client.native_endian">native_endian</a>) {
        .big =&gt; x,
        .little =&gt; <span class="tok-builtin">@byteSwap</span>(x),
    };
}

<span class="tok-kw">const</span> KeyShare = <span class="tok-kw">struct</span> {
    ml_kem768_kp: <a href="std.crypto.html">crypto</a>.<a href="std.crypto.kem.html">kem</a>.<a href="std.crypto.ml_kem.nist.html">ml_kem</a>.<a href="std.crypto.ml_kem.nist.html#std.crypto.ml_kem.nist.MLKem768">MLKem768</a>.<a href="#">KeyPair</a>,
    secp256r1_kp: <a href="std.crypto.html">crypto</a>.<a href="std.crypto.sign.html">sign</a>.<a href="std.crypto.ecdsa.html">ecdsa</a>.<a href="std.crypto.ecdsa.html#std.crypto.ecdsa.EcdsaP256Sha256">EcdsaP256Sha256</a>.<a href="#">KeyPair</a>,
    secp384r1_kp: <a href="std.crypto.html">crypto</a>.<a href="std.crypto.sign.html">sign</a>.<a href="std.crypto.ecdsa.html">ecdsa</a>.<a href="std.crypto.ecdsa.html#std.crypto.ecdsa.EcdsaP384Sha384">EcdsaP384Sha384</a>.<a href="#">KeyPair</a>,
    x25519_kp: <a href="std.crypto.html">crypto</a>.<a href="std.crypto.dh.html">dh</a>.<a href="std.crypto.25519.x25519.X25519.html">X25519</a>.<a href="std.crypto.25519.x25519.X25519.KeyPair.html">KeyPair</a>,
    sk_buf: [<a href="std.crypto.tls.Client.KeyShare.html#std.crypto.tls.Client.KeyShare.sk_max_len">sk_max_len</a>]<span class="tok-type">u8</span>,
    sk_len: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.IntFittingRange">IntFittingRange</a>(<span class="tok-number">0</span>, <a href="std.crypto.tls.Client.KeyShare.html#std.crypto.tls.Client.KeyShare.sk_max_len">sk_max_len</a>),

    <span class="tok-kw">const</span> sk_max_len = <span class="tok-builtin">@max</span>(
        <a href="std.crypto.html">crypto</a>.<a href="std.crypto.dh.html">dh</a>.<a href="std.crypto.25519.x25519.X25519.html">X25519</a>.<a href="std.crypto.25519.x25519.X25519.html#std.crypto.25519.x25519.X25519.shared_length">shared_length</a> + <a href="std.crypto.html">crypto</a>.<a href="std.crypto.kem.html">kem</a>.<a href="std.crypto.ml_kem.nist.html">ml_kem</a>.<a href="std.crypto.ml_kem.nist.html#std.crypto.ml_kem.nist.MLKem768">MLKem768</a>.<a href="#">shared_length</a>,
        <a href="std.crypto.html">crypto</a>.<a href="std.crypto.ecc.html">ecc</a>.<a href="std.crypto.pcurves.p256.P256.html">P256</a>.<a href="std.crypto.pcurves.p256.scalar.html">scalar</a>.<a href="std.crypto.pcurves.p256.scalar.html#std.crypto.pcurves.p256.scalar.encoded_length">encoded_length</a>,
        <a href="std.crypto.html">crypto</a>.<a href="std.crypto.ecc.html">ecc</a>.<a href="std.crypto.pcurves.p384.P384.html">P384</a>.<a href="std.crypto.pcurves.p384.scalar.html">scalar</a>.<a href="std.crypto.pcurves.p384.scalar.html#std.crypto.pcurves.p384.scalar.encoded_length">encoded_length</a>,
        <a href="std.crypto.html">crypto</a>.<a href="std.crypto.dh.html">dh</a>.<a href="std.crypto.25519.x25519.X25519.html">X25519</a>.<a href="std.crypto.25519.x25519.X25519.html#std.crypto.25519.x25519.X25519.shared_length">shared_length</a>,
    );

    <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(seed: [<span class="tok-number">112</span>]<span class="tok-type">u8</span>) <span class="tok-kw">error</span>{IdentityElement}!<a href="std.crypto.tls.Client.KeyShare.html">KeyShare</a> {
        <span class="tok-kw">return</span> .{
            .ml_kem768_kp = .generate(),
            .secp256r1_kp = <span class="tok-kw">try</span> .generateDeterministic(seed[<span class="tok-number">0</span>..<span class="tok-number">32</span>].*),
            .secp384r1_kp = <span class="tok-kw">try</span> .generateDeterministic(seed[<span class="tok-number">32</span>..<span class="tok-number">80</span>].*),
            .x25519_kp = <span class="tok-kw">try</span> .generateDeterministic(seed[<span class="tok-number">80</span>..<span class="tok-number">112</span>].*),
            .sk_buf = <span class="tok-null">undefined</span>,
            .sk_len = <span class="tok-number">0</span>,
        };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">exchange</span>(
        ks: *<a href="std.crypto.tls.Client.KeyShare.html">KeyShare</a>,
        named_group: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.NamedGroup.html">NamedGroup</a>,
        server_pub_key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <span class="tok-kw">error</span>{ TlsIllegalParameter, TlsDecryptFailure }!<span class="tok-type">void</span> {
        <span class="tok-kw">switch</span> (named_group) {
            .x25519_ml_kem768 =&gt; {
                <span class="tok-kw">const</span> hksl = <a href="std.crypto.html">crypto</a>.<a href="std.crypto.kem.html">kem</a>.<a href="std.crypto.ml_kem.nist.html">ml_kem</a>.<a href="std.crypto.ml_kem.nist.html#std.crypto.ml_kem.nist.MLKem768">MLKem768</a>.<a href="#">ciphertext_length</a>;
                <span class="tok-kw">const</span> xksl = hksl + <a href="std.crypto.html">crypto</a>.<a href="std.crypto.dh.html">dh</a>.<a href="std.crypto.25519.x25519.X25519.html">X25519</a>.<a href="std.crypto.25519.x25519.X25519.html#std.crypto.25519.x25519.X25519.public_length">public_length</a>;
                <span class="tok-kw">if</span> (server_pub_key.len != xksl) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter;

                <span class="tok-kw">const</span> hsk = ks.ml_kem768_kp.secret_key.decaps(server_pub_key[<span class="tok-number">0</span>..hksl]) <span class="tok-kw">catch</span>
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsDecryptFailure;
                <span class="tok-kw">const</span> xsk = <a href="std.crypto.html">crypto</a>.<a href="std.crypto.dh.html">dh</a>.<a href="std.crypto.25519.x25519.X25519.html">X25519</a>.<a href="std.crypto.25519.x25519.X25519.html#std.crypto.25519.x25519.X25519.scalarmult">scalarmult</a>(ks.x25519_kp.secret_key, server_pub_key[hksl..xksl].*) <span class="tok-kw">catch</span>
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsDecryptFailure;
                <span class="tok-builtin">@memcpy</span>(ks.sk_buf[<span class="tok-number">0</span>..hsk.len], &amp;hsk);
                <span class="tok-builtin">@memcpy</span>(ks.sk_buf[hsk.len..][<span class="tok-number">0</span>..xsk.len], &amp;xsk);
                ks.sk_len = hsk.len + xsk.len;
            },
            .secp256r1 =&gt; {
                <span class="tok-kw">const</span> PublicKey = <a href="std.crypto.html">crypto</a>.<a href="std.crypto.sign.html">sign</a>.<a href="std.crypto.ecdsa.html">ecdsa</a>.<a href="std.crypto.ecdsa.html#std.crypto.ecdsa.EcdsaP256Sha256">EcdsaP256Sha256</a>.<a href="#">PublicKey</a>;
                <span class="tok-kw">const</span> pk = PublicKey.fromSec1(server_pub_key) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsDecryptFailure;
                <span class="tok-kw">const</span> mul = pk.p.mulPublic(ks.secp256r1_kp.secret_key.bytes, .big) <span class="tok-kw">catch</span>
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsDecryptFailure;
                <span class="tok-kw">const</span> sk = mul.affineCoordinates().x.toBytes(.big);
                <span class="tok-builtin">@memcpy</span>(ks.sk_buf[<span class="tok-number">0</span>..sk.len], &amp;sk);
                ks.sk_len = sk.len;
            },
            .secp384r1 =&gt; {
                <span class="tok-kw">const</span> PublicKey = <a href="std.crypto.html">crypto</a>.<a href="std.crypto.sign.html">sign</a>.<a href="std.crypto.ecdsa.html">ecdsa</a>.<a href="std.crypto.ecdsa.html#std.crypto.ecdsa.EcdsaP384Sha384">EcdsaP384Sha384</a>.<a href="#">PublicKey</a>;
                <span class="tok-kw">const</span> pk = PublicKey.fromSec1(server_pub_key) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsDecryptFailure;
                <span class="tok-kw">const</span> mul = pk.p.mulPublic(ks.secp384r1_kp.secret_key.bytes, .big) <span class="tok-kw">catch</span>
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsDecryptFailure;
                <span class="tok-kw">const</span> sk = mul.affineCoordinates().x.toBytes(.big);
                <span class="tok-builtin">@memcpy</span>(ks.sk_buf[<span class="tok-number">0</span>..sk.len], &amp;sk);
                ks.sk_len = sk.len;
            },
            .x25519 =&gt; {
                <span class="tok-kw">const</span> ksl = <a href="std.crypto.html">crypto</a>.<a href="std.crypto.dh.html">dh</a>.<a href="std.crypto.25519.x25519.X25519.html">X25519</a>.<a href="std.crypto.25519.x25519.X25519.html#std.crypto.25519.x25519.X25519.public_length">public_length</a>;
                <span class="tok-kw">if</span> (server_pub_key.len != ksl) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter;
                <span class="tok-kw">const</span> sk = <a href="std.crypto.html">crypto</a>.<a href="std.crypto.dh.html">dh</a>.<a href="std.crypto.25519.x25519.X25519.html">X25519</a>.<a href="std.crypto.25519.x25519.X25519.html#std.crypto.25519.x25519.X25519.scalarmult">scalarmult</a>(ks.x25519_kp.secret_key, server_pub_key[<span class="tok-number">0</span>..ksl].*) <span class="tok-kw">catch</span>
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsDecryptFailure;
                <span class="tok-builtin">@memcpy</span>(ks.sk_buf[<span class="tok-number">0</span>..sk.len], &amp;sk);
                ks.sk_len = sk.len;
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsIllegalParameter,
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">getSharedSecret</span>(ks: *<span class="tok-kw">const</span> <a href="std.crypto.tls.Client.KeyShare.html">KeyShare</a>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (ks.sk_len &gt; <span class="tok-number">0</span>) ks.sk_buf[<span class="tok-number">0</span>..ks.sk_len] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
    }
};

<span class="tok-kw">fn</span> <span class="tok-fn">SchemeEcdsa</span>(<span class="tok-kw">comptime</span> scheme: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.SignatureScheme.html">SignatureScheme</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (scheme) {
        .ecdsa_secp256r1_sha256 =&gt; <a href="std.crypto.html">crypto</a>.<a href="std.crypto.sign.html">sign</a>.<a href="std.crypto.ecdsa.html">ecdsa</a>.<a href="std.crypto.ecdsa.html#std.crypto.ecdsa.EcdsaP256Sha256">EcdsaP256Sha256</a>,
        .ecdsa_secp384r1_sha384 =&gt; <a href="std.crypto.html">crypto</a>.<a href="std.crypto.sign.html">sign</a>.<a href="std.crypto.ecdsa.html">ecdsa</a>.<a href="std.crypto.ecdsa.html#std.crypto.ecdsa.EcdsaP384Sha384">EcdsaP384Sha384</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad scheme&quot;</span>),
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">SchemeRsa</span>(<span class="tok-kw">comptime</span> scheme: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.SignatureScheme.html">SignatureScheme</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (scheme) {
        .rsa_pkcs1_sha256,
        .rsa_pkcs1_sha384,
        .rsa_pkcs1_sha512,
        .rsa_pkcs1_sha1,
        =&gt; <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.rsa.html">rsa</a>.<a href="std.crypto.Certificate.rsa.PKCS1v1_5Signature.html">PKCS1v1_5Signature</a>,
        .rsa_pss_rsae_sha256,
        .rsa_pss_rsae_sha384,
        .rsa_pss_rsae_sha512,
        .rsa_pss_pss_sha256,
        .rsa_pss_pss_sha384,
        .rsa_pss_pss_sha512,
        =&gt; <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.rsa.html">rsa</a>.<a href="std.crypto.Certificate.rsa.PSSSignature.html">PSSSignature</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad scheme&quot;</span>),
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">SchemeEddsa</span>(<span class="tok-kw">comptime</span> scheme: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.SignatureScheme.html">SignatureScheme</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (scheme) {
        .ed25519 =&gt; <a href="std.crypto.html">crypto</a>.<a href="std.crypto.sign.html">sign</a>.<a href="std.crypto.25519.ed25519.Ed25519.html">Ed25519</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad scheme&quot;</span>),
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">SchemeHash</span>(<span class="tok-kw">comptime</span> scheme: <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.SignatureScheme.html">SignatureScheme</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (scheme) {
        .rsa_pkcs1_sha256,
        .ecdsa_secp256r1_sha256,
        .rsa_pss_rsae_sha256,
        .rsa_pss_pss_sha256,
        =&gt; <a href="std.crypto.html">crypto</a>.<a href="std.crypto.hash.html">hash</a>.<a href="std.crypto.sha2.html">sha2</a>.<a href="std.crypto.sha2.html#std.crypto.sha2.Sha256">Sha256</a>,
        .rsa_pkcs1_sha384,
        .ecdsa_secp384r1_sha384,
        .rsa_pss_rsae_sha384,
        .rsa_pss_pss_sha384,
        =&gt; <a href="std.crypto.html">crypto</a>.<a href="std.crypto.hash.html">hash</a>.<a href="std.crypto.sha2.html">sha2</a>.<a href="std.crypto.sha2.html#std.crypto.sha2.Sha384">Sha384</a>,
        .rsa_pkcs1_sha512,
        .ecdsa_secp521r1_sha512,
        .rsa_pss_rsae_sha512,
        .rsa_pss_pss_sha512,
        =&gt; <a href="std.crypto.html">crypto</a>.<a href="std.crypto.hash.html">hash</a>.<a href="std.crypto.sha2.html">sha2</a>.<a href="std.crypto.sha2.html#std.crypto.sha2.Sha512">Sha512</a>,
        .rsa_pkcs1_sha1,
        .ecdsa_sha1,
        =&gt; <a href="std.crypto.html">crypto</a>.<a href="std.crypto.hash.html">hash</a>.<a href="std.crypto.sha1.Sha1.html">Sha1</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad scheme&quot;</span>),
    };
}

<span class="tok-kw">const</span> CertificatePublicKey = <span class="tok-kw">struct</span> {
    algo: <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.AlgorithmCategory.html">AlgorithmCategory</a>,
    buf: [<span class="tok-number">600</span>]<span class="tok-type">u8</span>,
    len: <span class="tok-type">u16</span>,

    <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(
        cert_pub_key: *<a href="std.crypto.tls.Client.CertificatePublicKey.html">CertificatePublicKey</a>,
        algo: <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.AlgorithmCategory.html">AlgorithmCategory</a>,
        pub_key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <span class="tok-kw">error</span>{CertificatePublicKeyInvalid}!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (pub_key.len &gt; cert_pub_key.buf.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificatePublicKeyInvalid;
        cert_pub_key.algo = algo;
        <span class="tok-builtin">@memcpy</span>(cert_pub_key.buf[<span class="tok-number">0</span>..pub_key.len], pub_key);
        cert_pub_key.len = <span class="tok-builtin">@intCast</span>(pub_key.len);
    }

    <span class="tok-kw">const</span> VerifyError = <span class="tok-kw">error</span>{ TlsDecodeError, TlsBadSignatureScheme, InvalidEncoding } ||<span class="tok-comment">
        // ecdsa
        </span><a href="std.crypto.html">crypto</a>.<a href="std.crypto.errors.html">errors</a>.<a href="std.crypto.errors.html#std.crypto.errors.EncodingError">EncodingError</a> ||
        <a href="std.crypto.html">crypto</a>.<a href="std.crypto.errors.html">errors</a>.<a href="std.crypto.errors.html#std.crypto.errors.NotSquareError">NotSquareError</a> ||
        <a href="std.crypto.html">crypto</a>.<a href="std.crypto.errors.html">errors</a>.<a href="std.crypto.errors.html#std.crypto.errors.NonCanonicalError">NonCanonicalError</a> ||
        <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.SchemeEcdsa">SchemeEcdsa</a>(.ecdsa_secp256r1_sha256).Signature.VerifyError ||
        <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.SchemeEcdsa">SchemeEcdsa</a>(.ecdsa_secp384r1_sha384).Signature.VerifyError ||<span class="tok-comment">
        // rsa
        </span><span class="tok-kw">error</span>{TlsBadRsaSignatureBitCount} ||
        <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.rsa.html">rsa</a>.<a href="std.crypto.Certificate.rsa.PublicKey.html">PublicKey</a>.<a href="std.crypto.Certificate.rsa.PublicKey.html#std.crypto.Certificate.rsa.PublicKey.ParseDerError">ParseDerError</a> ||
        <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.rsa.html">rsa</a>.<a href="std.crypto.Certificate.rsa.PublicKey.html">PublicKey</a>.<a href="std.crypto.Certificate.rsa.PublicKey.html#std.crypto.Certificate.rsa.PublicKey.FromBytesError">FromBytesError</a> ||
        <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.rsa.html">rsa</a>.<a href="std.crypto.Certificate.rsa.PSSSignature.html">PSSSignature</a>.<a href="std.crypto.Certificate.rsa.PSSSignature.html#std.crypto.Certificate.rsa.PSSSignature.VerifyError">VerifyError</a> ||
        <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.rsa.html">rsa</a>.<a href="std.crypto.Certificate.rsa.PKCS1v1_5Signature.html">PKCS1v1_5Signature</a>.<a href="std.crypto.Certificate.rsa.PKCS1v1_5Signature.html#std.crypto.Certificate.rsa.PKCS1v1_5Signature.VerifyError">VerifyError</a> ||<span class="tok-comment">
        // eddsa
        </span><a href="std.crypto.tls.Client.html#std.crypto.tls.Client.SchemeEddsa">SchemeEddsa</a>(.ed25519).Signature.VerifyError;

    <span class="tok-kw">fn</span> <span class="tok-fn">verifySignature</span>(
        cert_pub_key: *<span class="tok-kw">const</span> <a href="std.crypto.tls.Client.CertificatePublicKey.html">CertificatePublicKey</a>,
        sigd: *<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.Decoder.html">Decoder</a>,
        msg: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.crypto.tls.Client.CertificatePublicKey.html#std.crypto.tls.Client.CertificatePublicKey.VerifyError">VerifyError</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> pub_key = cert_pub_key.buf[<span class="tok-number">0</span>..cert_pub_key.len];

        <span class="tok-kw">try</span> sigd.ensure(<span class="tok-number">2</span> + <span class="tok-number">2</span>);
        <span class="tok-kw">const</span> scheme = sigd.decode(<a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.SignatureScheme.html">SignatureScheme</a>);
        <span class="tok-kw">const</span> sig_len = sigd.decode(<span class="tok-type">u16</span>);
        <span class="tok-kw">try</span> sigd.ensure(sig_len);
        <span class="tok-kw">const</span> encoded_sig = sigd.slice(sig_len);

        <span class="tok-kw">if</span> (cert_pub_key.algo != <span class="tok-builtin">@as</span>(<a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.AlgorithmCategory.html">AlgorithmCategory</a>, <span class="tok-kw">switch</span> (scheme) {
            .ecdsa_secp256r1_sha256,
            .ecdsa_secp384r1_sha384,
            =&gt; .X9_62_id_ecPublicKey,
            .rsa_pkcs1_sha256,
            .rsa_pkcs1_sha384,
            .rsa_pkcs1_sha512,
            .rsa_pss_rsae_sha256,
            .rsa_pss_rsae_sha384,
            .rsa_pss_rsae_sha512,
            .rsa_pkcs1_sha1,
            =&gt; .rsaEncryption,
            .rsa_pss_pss_sha256,
            .rsa_pss_pss_sha384,
            .rsa_pss_pss_sha512,
            =&gt; .rsassa_pss,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsBadSignatureScheme,
        })) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsBadSignatureScheme;

        <span class="tok-kw">switch</span> (scheme) {
            <span class="tok-kw">inline</span> .ecdsa_secp256r1_sha256,
            .ecdsa_secp384r1_sha384,
            =&gt; |comptime_scheme| {
                <span class="tok-kw">const</span> Ecdsa = <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.SchemeEcdsa">SchemeEcdsa</a>(comptime_scheme);
                <span class="tok-kw">const</span> sig = <span class="tok-kw">try</span> Ecdsa.Signature.fromDer(encoded_sig);
                <span class="tok-kw">const</span> key = <span class="tok-kw">try</span> Ecdsa.PublicKey.fromSec1(pub_key);
                <span class="tok-kw">var</span> ver = <span class="tok-kw">try</span> sig.verifier(key);
                <span class="tok-kw">for</span> (msg) |part| ver.update(part);
                <span class="tok-kw">try</span> ver.verify();
            },
            <span class="tok-kw">inline</span> .rsa_pkcs1_sha256,
            .rsa_pkcs1_sha384,
            .rsa_pkcs1_sha512,
            .rsa_pss_rsae_sha256,
            .rsa_pss_rsae_sha384,
            .rsa_pss_rsae_sha512,
            .rsa_pss_pss_sha256,
            .rsa_pss_pss_sha384,
            .rsa_pss_pss_sha512,
            .rsa_pkcs1_sha1,
            =&gt; |comptime_scheme| {
                <span class="tok-kw">const</span> RsaSignature = <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.SchemeRsa">SchemeRsa</a>(comptime_scheme);
                <span class="tok-kw">const</span> Hash = <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.SchemeHash">SchemeHash</a>(comptime_scheme);
                <span class="tok-kw">const</span> PublicKey = <a href="std.crypto.Certificate.html">Certificate</a>.<a href="std.crypto.Certificate.rsa.html">rsa</a>.<a href="std.crypto.Certificate.rsa.PublicKey.html">PublicKey</a>;
                <span class="tok-kw">const</span> components = <span class="tok-kw">try</span> PublicKey.parseDer(pub_key);
                <span class="tok-kw">const</span> exponent = components.exponent;
                <span class="tok-kw">const</span> modulus = components.modulus;
                <span class="tok-kw">switch</span> (modulus.len) {
                    <span class="tok-kw">inline</span> <span class="tok-number">128</span>, <span class="tok-number">256</span>, <span class="tok-number">384</span>, <span class="tok-number">512</span> =&gt; |modulus_len| {
                        <span class="tok-kw">const</span> key: PublicKey = <span class="tok-kw">try</span> .fromBytes(exponent, modulus);
                        <span class="tok-kw">const</span> sig = RsaSignature.fromBytes(modulus_len, encoded_sig);
                        <span class="tok-kw">try</span> RsaSignature.concatVerify(modulus_len, sig, msg, key, Hash);
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TlsBadRsaSignatureBitCount,
                }
            },
            <span class="tok-kw">inline</span> .ed25519 =&gt; |comptime_scheme| {
                <span class="tok-kw">const</span> Eddsa = <a href="std.crypto.tls.Client.html#std.crypto.tls.Client.SchemeEddsa">SchemeEddsa</a>(comptime_scheme);
                <span class="tok-kw">if</span> (encoded_sig.len != Eddsa.Signature.encoded_length) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEncoding;
                <span class="tok-kw">const</span> sig = Eddsa.Signature.fromBytes(encoded_sig[<span class="tok-number">0</span>..Eddsa.Signature.encoded_length].*);
                <span class="tok-kw">if</span> (pub_key.len != Eddsa.PublicKey.encoded_length) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEncoding;
                <span class="tok-kw">const</span> key = <span class="tok-kw">try</span> Eddsa.PublicKey.fromBytes(pub_key[<span class="tok-number">0</span>..Eddsa.PublicKey.encoded_length].*);
                <span class="tok-kw">var</span> ver = <span class="tok-kw">try</span> sig.verifier(key);
                <span class="tok-kw">for</span> (msg) |part| ver.update(part);
                <span class="tok-kw">try</span> ver.verify();
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
};

<span class="tok-comment">/// Abstraction for sending multiple byte buffers to a slice of iovecs.</span>
<span class="tok-kw">const</span> VecPut = <span class="tok-kw">struct</span> {
    iovecs: []<span class="tok-kw">const</span> <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>,
    idx: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
    off: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
    total: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,

    <span class="tok-comment">/// Returns the amount actually put which is always equal to bytes.len</span>
    <span class="tok-comment">/// unless the vectors ran out of space.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(vp: *<a href="std.crypto.tls.Client.VecPut.html">VecPut</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">usize</span> {
        <span class="tok-kw">if</span> (vp.idx &gt;= vp.iovecs.len) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> bytes_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">const</span> v = vp.iovecs[vp.idx];
            <span class="tok-kw">const</span> dest = v.base[vp.off..v.len];
            <span class="tok-kw">const</span> src = bytes[bytes_i..][<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(dest.len, bytes.len - bytes_i)];
            <span class="tok-builtin">@memcpy</span>(dest[<span class="tok-number">0</span>..src.len], src);
            bytes_i += src.len;
            vp.off += src.len;
            <span class="tok-kw">if</span> (vp.off &gt;= v.len) {
                vp.off = <span class="tok-number">0</span>;
                vp.idx += <span class="tok-number">1</span>;
                <span class="tok-kw">if</span> (vp.idx &gt;= vp.iovecs.len) {
                    vp.total += bytes_i;
                    <span class="tok-kw">return</span> bytes_i;
                }
            }
            <span class="tok-kw">if</span> (bytes_i &gt;= bytes.len) {
                vp.total += bytes_i;
                <span class="tok-kw">return</span> bytes_i;
            }
        }
    }

    <span class="tok-comment">/// Returns the next buffer that consecutive bytes can go into.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">peek</span>(vp: <a href="std.crypto.tls.Client.VecPut.html">VecPut</a>) []<span class="tok-type">u8</span> {
        <span class="tok-kw">if</span> (vp.idx &gt;= vp.iovecs.len) <span class="tok-kw">return</span> &amp;.{};
        <span class="tok-kw">const</span> v = vp.iovecs[vp.idx];
        <span class="tok-kw">return</span> v.base[vp.off..v.len];
    }<span class="tok-comment">

    // After writing to the result of peek(), one can call next() to
    // advance the cursor.
    </span><span class="tok-kw">fn</span> <span class="tok-fn">next</span>(vp: *<a href="std.crypto.tls.Client.VecPut.html">VecPut</a>, len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        vp.total += len;
        vp.off += len;
        <span class="tok-kw">if</span> (vp.off &gt;= vp.iovecs[vp.idx].len) {
            vp.off = <span class="tok-number">0</span>;
            vp.idx += <span class="tok-number">1</span>;
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">freeSize</span>(vp: <a href="std.crypto.tls.Client.VecPut.html">VecPut</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">if</span> (vp.idx &gt;= vp.iovecs.len) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> total: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        total += vp.iovecs[vp.idx].len - vp.off;
        <span class="tok-kw">if</span> (vp.idx + <span class="tok-number">1</span> &gt;= vp.iovecs.len) <span class="tok-kw">return</span> total;
        <span class="tok-kw">for</span> (vp.iovecs[vp.idx + <span class="tok-number">1</span> ..]) |v| total += v.len;
        <span class="tok-kw">return</span> total;
    }
};

<span class="tok-comment">/// Limit iovecs to a specific byte size.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">limitVecs</span>(iovecs: []<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>, len: <span class="tok-type">usize</span>) []<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a> {
    <span class="tok-kw">var</span> bytes_left: <span class="tok-type">usize</span> = len;
    <span class="tok-kw">for</span> (iovecs, <span class="tok-number">0</span>..) |*iovec, vec_i| {
        <span class="tok-kw">if</span> (bytes_left &lt;= iovec.len) {
            iovec.len = bytes_left;
            <span class="tok-kw">return</span> iovecs[<span class="tok-number">0</span> .. vec_i + <span class="tok-number">1</span>];
        }
        bytes_left -= iovec.len;
    }
    <span class="tok-kw">return</span> iovecs;
}

<span class="tok-comment">/// The priority order here is chosen based on what crypto algorithms Zig has</span>
<span class="tok-comment">/// available in the standard library as well as what is faster. Following are</span>
<span class="tok-comment">/// a few data points on the relative performance of these algorithms.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Measurement taken with 0.11.0-dev.810+c2f5848fe</span>
<span class="tok-comment">/// on x86_64-linux Intel(R) Core(TM) i9-9980HK CPU @ 2.40GHz:</span>
<span class="tok-comment">/// zig run .lib/std/crypto/benchmark.zig -OReleaseFast</span>
<span class="tok-comment">///       aegis-128l:      15382 MiB/s</span>
<span class="tok-comment">///        aegis-256:       9553 MiB/s</span>
<span class="tok-comment">///       aes128-gcm:       3721 MiB/s</span>
<span class="tok-comment">///       aes256-gcm:       3010 MiB/s</span>
<span class="tok-comment">/// chacha20Poly1305:        597 MiB/s</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Measurement taken with 0.11.0-dev.810+c2f5848fe</span>
<span class="tok-comment">/// on x86_64-linux Intel(R) Core(TM) i9-9980HK CPU @ 2.40GHz:</span>
<span class="tok-comment">/// zig run .lib/std/crypto/benchmark.zig -OReleaseFast -mcpu=baseline</span>
<span class="tok-comment">///       aegis-128l:        629 MiB/s</span>
<span class="tok-comment">/// chacha20Poly1305:        529 MiB/s</span>
<span class="tok-comment">///        aegis-256:        461 MiB/s</span>
<span class="tok-comment">///       aes128-gcm:        138 MiB/s</span>
<span class="tok-comment">///       aes256-gcm:        120 MiB/s</span>
<span class="tok-kw">const</span> cipher_suites = <span class="tok-kw">if</span> (<a href="std.crypto.html">crypto</a>.<a href="std.crypto.core.html">core</a>.<a href="std.crypto.aes.html">aes</a>.<a href="std.crypto.aes.html#std.crypto.aes.has_hardware_support">has_hardware_support</a>)
    <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.CipherSuite.html">CipherSuite</a>, .{
        .AEGIS_128L_SHA256,
        .AEGIS_256_SHA512,
        .AES_128_GCM_SHA256,
        .ECDHE_RSA_WITH_AES_128_GCM_SHA256,
        .AES_256_GCM_SHA384,
        .ECDHE_RSA_WITH_AES_256_GCM_SHA384,
        .CHACHA20_POLY1305_SHA256,
        .ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
    })
<span class="tok-kw">else</span>
    <a href="std.crypto.tls.html#std.crypto.tls.array">array</a>(<span class="tok-type">u16</span>, <a href="std.crypto.tls.html">tls</a>.<a href="std.crypto.tls.CipherSuite.html">CipherSuite</a>, .{
        .CHACHA20_POLY1305_SHA256,
        .ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
        .AEGIS_128L_SHA256,
        .AEGIS_256_SHA512,
        .AES_128_GCM_SHA256,
        .ECDHE_RSA_WITH_AES_128_GCM_SHA256,
        .AES_256_GCM_SHA384,
        .ECDHE_RSA_WITH_AES_256_GCM_SHA384,
    });

<span class="tok-kw">test</span> {
    _ = <a href="std.crypto.tls.Client.StreamInterface.html">StreamInterface</a>;
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
