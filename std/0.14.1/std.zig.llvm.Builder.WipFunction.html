<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">zig</a></li><li><a href="std.zig.html" class="">llvm</a></li><li><a href="std.zig.llvm.Builder.html" class="">Builder</a></li><li><a href="std.zig.llvm.Builder.WipFunction.html" class="active">WipFunction</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.zig.llvm.Builder.WipFunction" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.zig.llvm.Builder.WipFunction</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction">[src]</a></h1><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.zig.llvm.Builder.WipFunction.Cursor.html">std.zig.llvm.Builder.WipFunction.Cursor</a></li><li><a href="std.zig.llvm.Builder.WipFunction.Block.html">std.zig.llvm.Builder.WipFunction.Block</a></li><li><a href="std.zig.llvm.Builder.Function.Instruction.html">std.zig.llvm.Builder.Function.Instruction</a></li><li><a href="std.zig.llvm.Builder.WipFunction.WipSwitch.html">std.zig.llvm.Builder.WipFunction.WipSwitch</a></li><li><a href="std.zig.llvm.Builder.WipFunction.WipPhi.html">std.zig.llvm.Builder.WipFunction.WipPhi</a></li></ul></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>builder: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a></code></pre></div><div><pre><code>prev_debug_location: <a href="std.zig.llvm.Builder.DebugLocation.html">DebugLocation</a></code></pre></div><div><pre><code>debug_location: <a href="std.zig.llvm.Builder.DebugLocation.html">DebugLocation</a></code></pre></div><div><pre><code>cursor: <a href="std.zig.llvm.Builder.WipFunction.Cursor.html">Cursor</a></code></pre></div><div><pre><code>blocks: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>)</code></pre></div><div><pre><code>instructions: <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>)</code></pre></div><div><pre><code>names: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.llvm.Builder.String.html">String</a>)</code></pre></div><div><pre><code>strip: <span class="tok-type">bool</span></code></pre></div><div><pre><code>debug_locations: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, <a href="std.zig.llvm.Builder.DebugLocation.html">DebugLocation</a>)</code></pre></div><div><pre><code>debug_values: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, <span class="tok-type">void</span>)</code></pre></div><div><pre><code>extra: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>)</code></pre></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.init">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(builder: *<a href="std.zig.llvm.Builder.html">Builder</a>, options: <span class="tok-kw">struct</span> { function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, strip: <span class="tok-type">bool</span>, }) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>builder: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>options: <span class="tok-kw">struct</span> {
    function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>,
    strip: <span class="tok-type">bool</span>,
}</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.init">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(builder: *<a href="std.zig.llvm.Builder.html">Builder</a>, options: <span class="tok-kw">struct</span> {
    function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>,
    strip: <span class="tok-type">bool</span>,
}) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a> {
    <span class="tok-kw">var</span> self: <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a> = .{
        .builder = builder,
        .function = options.function,
        .prev_debug_location = .no_location,
        .debug_location = .no_location,
        .cursor = <span class="tok-null">undefined</span>,
        .blocks = .{},
        .instructions = .{},
        .names = .{},
        .strip = options.strip,
        .debug_locations = .{},
        .debug_values = .{},
        .extra = .{},
    };
    <span class="tok-kw">errdefer</span> self.deinit();

    <span class="tok-kw">const</span> params_len = options.function.typeOf(self.builder).functionParameters(self.builder).len;
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(params_len, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> self.instructions.ensureUnusedCapacity(self.builder.gpa, params_len);
    <span class="tok-kw">if</span> (!self.strip) {
        <span class="tok-kw">try</span> self.names.ensureUnusedCapacity(self.builder.gpa, params_len);
    }
    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..params_len) |param_index| {
        self.instructions.appendAssumeCapacity(.{ .tag = .arg, .data = <span class="tok-builtin">@intCast</span>(param_index) });
        <span class="tok-kw">if</span> (!self.strip) {
            self.names.appendAssumeCapacity(.empty);<span class="tok-comment"> // TODO: param names
        </span>}
    }

    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.arg" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">arg</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.arg">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arg</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, index: <span class="tok-type">u32</span>) <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>index: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.arg">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arg</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, index: <span class="tok-type">u32</span>) <a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">const</span> argument = self.instructions.get(index);
    <a href="std.debug.html#std.debug.assert">assert</a>(argument.tag == .arg);
    <a href="std.debug.html#std.debug.assert">assert</a>(argument.data == index);

    <span class="tok-kw">const</span> argument_index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(index);
    <span class="tok-kw">return</span> argument_index.toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.block" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">block</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.block">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">block</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, incoming: <span class="tok-type">u32</span>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>incoming: <span class="tok-type">u32</span></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.block">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">block</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, incoming: <span class="tok-type">u32</span>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a> {
    <span class="tok-kw">try</span> self.blocks.ensureUnusedCapacity(self.builder.gpa, <span class="tok-number">1</span>);

    <span class="tok-kw">const</span> index: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(self.blocks.items.len);
    <span class="tok-kw">const</span> final_name = <span class="tok-kw">if</span> (self.strip) .empty <span class="tok-kw">else</span> <span class="tok-kw">try</span> self.builder.string(name);
    self.blocks.appendAssumeCapacity(.{
        .name = final_name,
        .incoming = incoming,
        .instructions = .{},
    });
    <span class="tok-kw">return</span> index;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.ret" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ret</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.ret">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ret</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.ret">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ret</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(val.typeOfWip(self) == self.function.typeOf(self.builder).functionReturn(self.builder));
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{ .tag = .ret, .data = <span class="tok-builtin">@intFromEnum</span>(val) });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.retVoid" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">retVoid</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.retVoid">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">retVoid</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.retVoid">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">retVoid</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{ .tag = .@&quot;ret void&quot;, .data = <span class="tok-null">undefined</span> });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.br" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">br</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.br">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">br</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, dest: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>dest: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.br">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">br</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, dest: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{ .tag = .br, .data = <span class="tok-builtin">@intFromEnum</span>(dest) });
    dest.ptr(self).branches += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> instruction;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.brCond" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">brCond</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.brCond">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">brCond</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, cond: <a href="std.zig.llvm.Builder.Value.html">Value</a>, then: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, @&quot;else&quot;: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, weights: <span class="tok-kw">enum</span> { none, unpredictable, then_likely, else_likely }, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>cond: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>then: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a></code></pre></div><div><pre><code>@&quot;else&quot;: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a></code></pre></div><div><pre><code>weights: <span class="tok-kw">enum</span> { none, unpredictable, then_likely, else_likely }</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.brCond">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">brCond</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    cond: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    then: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
    @&quot;else&quot;: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
    weights: <span class="tok-kw">enum</span> { none, unpredictable, then_likely, else_likely },
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(cond.typeOfWip(self) == .<span class="tok-type">i1</span>);
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{
        .tag = .br_cond,
        .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>{
            .cond = cond,
            .then = then,
            .@&quot;else&quot; = @&quot;else&quot;,
            .weights = <span class="tok-kw">switch</span> (weights) {
                .none =&gt; .none,
                .unpredictable =&gt; .unpredictable,
                .then_likely, .else_likely =&gt; w: {
                    <span class="tok-kw">const</span> branch_weights_str = <span class="tok-kw">try</span> self.builder.metadataString(<span class="tok-str">&quot;branch_weights&quot;</span>);
                    <span class="tok-kw">const</span> unlikely_const = <span class="tok-kw">try</span> self.builder.metadataConstant(<span class="tok-kw">try</span> self.builder.intConst(.<span class="tok-type">i32</span>, <span class="tok-number">1</span>));
                    <span class="tok-kw">const</span> likely_const = <span class="tok-kw">try</span> self.builder.metadataConstant(<span class="tok-kw">try</span> self.builder.intConst(.<span class="tok-type">i32</span>, <span class="tok-number">2000</span>));
                    <span class="tok-kw">const</span> weight_vals: [<span class="tok-number">2</span>]<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> = <span class="tok-kw">switch</span> (weights) {
                        .none, .unpredictable =&gt; <span class="tok-kw">unreachable</span>,
                        .then_likely =&gt; .{ likely_const, unlikely_const },
                        .else_likely =&gt; .{ unlikely_const, likely_const },
                    };
                    <span class="tok-kw">const</span> tuple = <span class="tok-kw">try</span> self.builder.strTuple(branch_weights_str, &amp;weight_vals);
                    <span class="tok-kw">break</span> :w <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(tuple));
                },
            },
        }),
    });
    then.ptr(self).branches += <span class="tok-number">1</span>;
    @&quot;else&quot;.ptr(self).branches += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> instruction;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.@%22switch%22" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">@"switch"</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.@%22switch%22">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">@&quot;switch&quot;</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>, default: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, cases_len: <span class="tok-type">u32</span>, weights: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.Weights.html">Weights</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.WipSwitch.html">WipSwitch</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>default: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a></code></pre></div><div><pre><code>cases_len: <span class="tok-type">u32</span></code></pre></div><div><pre><code>weights: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.Weights.html">Weights</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.@%22switch%22">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">@&quot;switch&quot;</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    default: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
    cases_len: <span class="tok-type">u32</span>,
    weights: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.Weights.html">Weights</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.WipSwitch.html">WipSwitch</a> {
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>, cases_len * <span class="tok-number">2</span>);
    <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{
        .tag = .@&quot;switch&quot;,
        .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>{
            .val = val,
            .default = default,
            .cases_len = cases_len,
            .weights = weights,
        }),
    });
    _ = self.extra.addManyAsSliceAssumeCapacity(cases_len * <span class="tok-number">2</span>);
    default.ptr(self).branches += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> .{ .index = <span class="tok-number">0</span>, .instruction = instruction };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.indirectbr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">indirectbr</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.indirectbr">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indirectbr</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, addr: <a href="std.zig.llvm.Builder.Value.html">Value</a>, targets: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>addr: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>targets: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.indirectbr">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indirectbr</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    addr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    targets: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.IndirectBr.html">IndirectBr</a>, targets.len);
    <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{
        .tag = .indirectbr,
        .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.IndirectBr.html">IndirectBr</a>{
            .addr = addr,
            .targets_len = <span class="tok-builtin">@intCast</span>(targets.len),
        }),
    });
    _ = self.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(targets));
    <span class="tok-kw">for</span> (targets) |target| target.ptr(self).branches += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> instruction;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.@%22unreachable%22" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">@"unreachable"</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.@%22unreachable%22">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">@&quot;unreachable&quot;</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.@%22unreachable%22">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">@&quot;unreachable&quot;</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{ .tag = .@&quot;unreachable&quot;, .data = <span class="tok-null">undefined</span> });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.un" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">un</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.un">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">un</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.un">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">un</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>,
    val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">switch</span> (tag) {
        .fneg,
        .@&quot;fneg fast&quot;,
        =&gt; <a href="std.debug.html#std.debug.assert">assert</a>(val.typeOfWip(self).scalarType(self.builder).isFloatingPoint()),
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{ .tag = tag, .data = <span class="tok-builtin">@intFromEnum</span>(val) });
    <span class="tok-kw">return</span> instruction.toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.not" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">not</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.not">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">not</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.not">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">not</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">const</span> ty = val.typeOfWip(self);
    <span class="tok-kw">const</span> all_ones = <span class="tok-kw">try</span> self.builder.splatValue(
        ty,
        <span class="tok-kw">try</span> self.builder.intConst(ty.scalarType(self.builder), -<span class="tok-number">1</span>),
    );
    <span class="tok-kw">return</span> self.bin(.xor, val, all_ones, name);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.neg" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">neg</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.neg">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">neg</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.neg">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">neg</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> self.bin(.sub, <span class="tok-kw">try</span> self.builder.zeroInitValue(val.typeOfWip(self)), val, name);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.bin" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bin</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.bin">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bin</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>, lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>, rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a></code></pre></div><div><pre><code>lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.bin">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bin</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>,
    lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">switch</span> (tag) {
        .add,
        .@&quot;add nsw&quot;,
        .@&quot;add nuw&quot;,
        .@&quot;and&quot;,
        .ashr,
        .@&quot;ashr exact&quot;,
        .fadd,
        .@&quot;fadd fast&quot;,
        .fdiv,
        .@&quot;fdiv fast&quot;,
        .fmul,
        .@&quot;fmul fast&quot;,
        .frem,
        .@&quot;frem fast&quot;,
        .fsub,
        .@&quot;fsub fast&quot;,
        .lshr,
        .@&quot;lshr exact&quot;,
        .mul,
        .@&quot;mul nsw&quot;,
        .@&quot;mul nuw&quot;,
        .@&quot;or&quot;,
        .sdiv,
        .@&quot;sdiv exact&quot;,
        .shl,
        .@&quot;shl nsw&quot;,
        .@&quot;shl nuw&quot;,
        .srem,
        .sub,
        .@&quot;sub nsw&quot;,
        .@&quot;sub nuw&quot;,
        .udiv,
        .@&quot;udiv exact&quot;,
        .urem,
        .xor,
        =&gt; <a href="std.debug.html#std.debug.assert">assert</a>(lhs.typeOfWip(self) == rhs.typeOfWip(self)),
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
        .tag = tag,
        .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>{ .lhs = lhs, .rhs = rhs }),
    });
    <span class="tok-kw">return</span> instruction.toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.extractElement" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">extractElement</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.extractElement">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">extractElement</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>, index: <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>index: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.extractElement">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">extractElement</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    index: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(val.typeOfWip(self).isVector(self.builder));
    <a href="std.debug.html#std.debug.assert">assert</a>(index.typeOfWip(self).isInteger(self.builder));
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractElement.html">ExtractElement</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
        .tag = .extractelement,
        .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractElement.html">ExtractElement</a>{
            .val = val,
            .index = index,
        }),
    });
    <span class="tok-kw">return</span> instruction.toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.insertElement" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insertElement</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.insertElement">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertElement</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>, elem: <a href="std.zig.llvm.Builder.Value.html">Value</a>, index: <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>elem: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>index: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.insertElement">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertElement</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    elem: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    index: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(val.typeOfWip(self).scalarType(self.builder) == elem.typeOfWip(self));
    <a href="std.debug.html#std.debug.assert">assert</a>(index.typeOfWip(self).isInteger(self.builder));
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertElement.html">InsertElement</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
        .tag = .insertelement,
        .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertElement.html">InsertElement</a>{
            .val = val,
            .elem = elem,
            .index = index,
        }),
    });
    <span class="tok-kw">return</span> instruction.toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.shuffleVector" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shuffleVector</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.shuffleVector">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shuffleVector</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>, rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>, mask: <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>mask: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.shuffleVector">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shuffleVector</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    mask: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(lhs.typeOfWip(self).isVector(self.builder));
    <a href="std.debug.html#std.debug.assert">assert</a>(lhs.typeOfWip(self) == rhs.typeOfWip(self));
    <a href="std.debug.html#std.debug.assert">assert</a>(mask.typeOfWip(self).scalarType(self.builder).isInteger(self.builder));
    _ = <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ShuffleVector.html">ShuffleVector</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
        .tag = .shufflevector,
        .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ShuffleVector.html">ShuffleVector</a>{
            .lhs = lhs,
            .rhs = rhs,
            .mask = mask,
        }),
    });
    <span class="tok-kw">return</span> instruction.toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.splatVector" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">splatVector</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.splatVector">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splatVector</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, elem: <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>elem: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.splatVector">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splatVector</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    elem: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">const</span> scalar_ty = <span class="tok-kw">try</span> ty.changeLength(<span class="tok-number">1</span>, self.builder);
    <span class="tok-kw">const</span> mask_ty = <span class="tok-kw">try</span> ty.changeScalar(.<span class="tok-type">i32</span>, self.builder);
    <span class="tok-kw">const</span> poison = <span class="tok-kw">try</span> self.builder.poisonValue(scalar_ty);
    <span class="tok-kw">const</span> mask = <span class="tok-kw">try</span> self.builder.splatValue(mask_ty, .@&quot;0&quot;);
    <span class="tok-kw">const</span> scalar = <span class="tok-kw">try</span> self.insertElement(poison, elem, .@&quot;0&quot;, name);
    <span class="tok-kw">return</span> self.shuffleVector(scalar, poison, mask, name);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.extractValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">extractValue</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.extractValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">extractValue</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>, indices: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>indices: []<span class="tok-kw">const</span> <span class="tok-type">u32</span></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.extractValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">extractValue</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    indices: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(indices.len &gt; <span class="tok-number">0</span>);
    _ = val.typeOfWip(self).childTypeAt(indices, self.builder);
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractValue.html">ExtractValue</a>, indices.len);
    <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
        .tag = .extractvalue,
        .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractValue.html">ExtractValue</a>{
            .val = val,
            .indices_len = <span class="tok-builtin">@intCast</span>(indices.len),
        }),
    });
    self.extra.appendSliceAssumeCapacity(indices);
    <span class="tok-kw">return</span> instruction.toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.insertValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insertValue</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.insertValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertValue</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>, elem: <a href="std.zig.llvm.Builder.Value.html">Value</a>, indices: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>elem: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>indices: []<span class="tok-kw">const</span> <span class="tok-type">u32</span></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.insertValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertValue</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    elem: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    indices: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(indices.len &gt; <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(val.typeOfWip(self).childTypeAt(indices, self.builder) == elem.typeOfWip(self));
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertValue.html">InsertValue</a>, indices.len);
    <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
        .tag = .insertvalue,
        .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertValue.html">InsertValue</a>{
            .val = val,
            .elem = elem,
            .indices_len = <span class="tok-builtin">@intCast</span>(indices.len),
        }),
    });
    self.extra.appendSliceAssumeCapacity(indices);
    <span class="tok-kw">return</span> instruction.toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.buildAggregate" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">buildAggregate</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.buildAggregate">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">buildAggregate</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, elems: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>elems: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.buildAggregate">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">buildAggregate</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    elems: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(ty.aggregateLen(self.builder) == elems.len);
    <span class="tok-kw">var</span> cur = <span class="tok-kw">try</span> self.builder.poisonValue(ty);
    <span class="tok-kw">for</span> (elems, <span class="tok-number">0</span>..) |elem, index|
        cur = <span class="tok-kw">try</span> self.insertValue(cur, elem, &amp;[_]<span class="tok-type">u32</span>{<span class="tok-builtin">@intCast</span>(index)}, name);
    <span class="tok-kw">return</span> cur;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.alloca" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">alloca</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.alloca">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alloca</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.Kind.html">Kind</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, len: <a href="std.zig.llvm.Builder.Value.html">Value</a>, alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>, addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.Kind.html">Kind</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>len: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a></code></pre></div><div><pre><code>addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.alloca">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alloca</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.Kind.html">Kind</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    len: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
    addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(len == .none <span class="tok-kw">or</span> len.typeOfWip(self).isInteger(self.builder));
    _ = <span class="tok-kw">try</span> self.builder.ptrType(addr_space);
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
        .tag = <span class="tok-kw">switch</span> (kind) {
            .normal =&gt; .alloca,
            .inalloca =&gt; .@&quot;alloca inalloca&quot;,
        },
        .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>{
            .<span class="tok-type">type</span> = ty,
            .len = <span class="tok-kw">switch</span> (len) {
                .none =&gt; .@&quot;1&quot;,
                <span class="tok-kw">else</span> =&gt; len,
            },
            .info = .{ .alignment = alignment, .addr_space = addr_space },
        }),
    });
    <span class="tok-kw">return</span> instruction.toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.load" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">load</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.load">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">load</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>, alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.load">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">load</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> self.loadAtomic(access_kind, ty, ptr, .system, .none, alignment, name);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.loadAtomic" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">loadAtomic</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.loadAtomic">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">loadAtomic</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>, sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>, ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>, alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a></code></pre></div><div><pre><code>ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a></code></pre></div><div><pre><code>alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.loadAtomic">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">loadAtomic</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>,
    ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
    alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(ptr.typeOfWip(self).isPointer(self.builder));
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Load.html">Load</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
        .tag = <span class="tok-kw">switch</span> (ordering) {
            .none =&gt; .load,
            <span class="tok-kw">else</span> =&gt; .@&quot;load atomic&quot;,
        },
        .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Load.html">Load</a>{
            .info = .{
                .access_kind = access_kind,
                .sync_scope = <span class="tok-kw">switch</span> (ordering) {
                    .none =&gt; .system,
                    <span class="tok-kw">else</span> =&gt; sync_scope,
                },
                .success_ordering = ordering,
                .alignment = alignment,
            },
            .<span class="tok-type">type</span> = ty,
            .ptr = ptr,
        }),
    });
    <span class="tok-kw">return</span> instruction.toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.store" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">store</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.store">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">store</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>, ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>, alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.store">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">store</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
    val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
    <span class="tok-kw">return</span> self.storeAtomic(kind, val, ptr, .system, .none, alignment);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.storeAtomic" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">storeAtomic</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.storeAtomic">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">storeAtomic</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>, ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>, sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>, ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>, alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a></code></pre></div><div><pre><code>ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a></code></pre></div><div><pre><code>alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.storeAtomic">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">storeAtomic</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
    val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>,
    ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
    alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(ptr.typeOfWip(self).isPointer(self.builder));
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Store.html">Store</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{
        .tag = <span class="tok-kw">switch</span> (ordering) {
            .none =&gt; .store,
            <span class="tok-kw">else</span> =&gt; .@&quot;store atomic&quot;,
        },
        .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Store.html">Store</a>{
            .info = .{
                .access_kind = access_kind,
                .sync_scope = <span class="tok-kw">switch</span> (ordering) {
                    .none =&gt; .system,
                    <span class="tok-kw">else</span> =&gt; sync_scope,
                },
                .success_ordering = ordering,
                .alignment = alignment,
            },
            .val = val,
            .ptr = ptr,
        }),
    });
    <span class="tok-kw">return</span> instruction;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.fence" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fence</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.fence">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fence</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>, ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a></code></pre></div><div><pre><code>ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.fence">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fence</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>,
    ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(ordering != .none);
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{
        .tag = .fence,
        .data = <span class="tok-builtin">@bitCast</span>(<a href="std.zig.llvm.Builder.MemoryAccessInfo.html">MemoryAccessInfo</a>{
            .sync_scope = sync_scope,
            .success_ordering = ordering,
        }),
    });
    <span class="tok-kw">return</span> instruction;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.cmpxchg" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cmpxchg</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.cmpxchg">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cmpxchg</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.Kind.html">Kind</a>, access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>, ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>, cmp: <a href="std.zig.llvm.Builder.Value.html">Value</a>, new: <a href="std.zig.llvm.Builder.Value.html">Value</a>, sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>, success_ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>, failure_ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>, alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.Kind.html">Kind</a></code></pre></div><div><pre><code>access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a></code></pre></div><div><pre><code>ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>cmp: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>new: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a></code></pre></div><div><pre><code>success_ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a></code></pre></div><div><pre><code>failure_ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a></code></pre></div><div><pre><code>alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.cmpxchg">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cmpxchg</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.Kind.html">Kind</a>,
    access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
    ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    cmp: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    new: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>,
    success_ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
    failure_ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
    alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(ptr.typeOfWip(self).isPointer(self.builder));
    <span class="tok-kw">const</span> ty = cmp.typeOfWip(self);
    <a href="std.debug.html#std.debug.assert">assert</a>(ty == new.typeOfWip(self));
    <a href="std.debug.html#std.debug.assert">assert</a>(success_ordering != .none);
    <a href="std.debug.html#std.debug.assert">assert</a>(failure_ordering != .none);

    _ = <span class="tok-kw">try</span> self.builder.structType(.normal, &amp;.{ ty, .<span class="tok-type">i1</span> });
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
        .tag = <span class="tok-kw">switch</span> (kind) {
            .strong =&gt; .cmpxchg,
            .weak =&gt; .@&quot;cmpxchg weak&quot;,
        },
        .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>{
            .info = .{
                .access_kind = access_kind,
                .sync_scope = sync_scope,
                .success_ordering = success_ordering,
                .failure_ordering = failure_ordering,
                .alignment = alignment,
            },
            .ptr = ptr,
            .cmp = cmp,
            .new = new,
        }),
    });
    <span class="tok-kw">return</span> instruction.toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.atomicrmw" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">atomicrmw</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.atomicrmw">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">atomicrmw</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>, operation: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.Operation.html">Operation</a>, ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>, sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>, ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>, alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a></code></pre></div><div><pre><code>operation: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.Operation.html">Operation</a></code></pre></div><div><pre><code>ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a></code></pre></div><div><pre><code>ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a></code></pre></div><div><pre><code>alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.atomicrmw">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">atomicrmw</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
    operation: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.Operation.html">Operation</a>,
    ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>,
    ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
    alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(ptr.typeOfWip(self).isPointer(self.builder));
    <a href="std.debug.html#std.debug.assert">assert</a>(ordering != .none);

    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
        .tag = .atomicrmw,
        .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>{
            .info = .{
                .access_kind = access_kind,
                .atomic_rmw_operation = operation,
                .sync_scope = sync_scope,
                .success_ordering = ordering,
                .alignment = alignment,
            },
            .ptr = ptr,
            .val = val,
        }),
    });
    <span class="tok-kw">return</span> instruction.toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.gep" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">gep</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.gep">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gep</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.Kind.html">Kind</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, base: <a href="std.zig.llvm.Builder.Value.html">Value</a>, indices: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.Kind.html">Kind</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>base: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>indices: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.gep">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gep</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.Kind.html">Kind</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    base: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    indices: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">const</span> base_ty = base.typeOfWip(self);
    <span class="tok-kw">const</span> base_is_vector = base_ty.isVector(self.builder);

    <span class="tok-kw">const</span> VectorInfo = <span class="tok-kw">struct</span> {
        kind: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>.<a href="std.zig.llvm.Builder.Type.Vector.Kind.html">Kind</a>,
        len: <span class="tok-type">u32</span>,

        <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(vector_ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-builtin">@This</span>() {
            <span class="tok-kw">return</span> .{ .kind = vector_ty.vectorKind(builder), .len = vector_ty.vectorLen(builder) };
        }
    };
    <span class="tok-kw">var</span> vector_info: ?VectorInfo =
        <span class="tok-kw">if</span> (base_is_vector) VectorInfo.init(base_ty, self.builder) <span class="tok-kw">else</span> <span class="tok-null">null</span>;
    <span class="tok-kw">for</span> (indices) |index| {
        <span class="tok-kw">const</span> index_ty = index.typeOfWip(self);
        <span class="tok-kw">switch</span> (index_ty.tag(self.builder)) {
            .integer =&gt; {},
            .vector, .scalable_vector =&gt; {
                <span class="tok-kw">const</span> index_info = VectorInfo.init(index_ty, self.builder);
                <span class="tok-kw">if</span> (vector_info) |info|
                    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(info, index_info))
                <span class="tok-kw">else</span>
                    vector_info = index_info;
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
    <span class="tok-kw">if</span> (!base_is_vector) <span class="tok-kw">if</span> (vector_info) |info| <span class="tok-kw">switch</span> (info.kind) {
        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |vector_kind| _ = <span class="tok-kw">try</span> self.builder.vectorType(
            vector_kind,
            info.len,
            base_ty,
        ),
    };

    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>, indices.len);
    <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
        .tag = <span class="tok-kw">switch</span> (kind) {
            .normal =&gt; .getelementptr,
            .inbounds =&gt; .@&quot;getelementptr inbounds&quot;,
        },
        .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>{
            .<span class="tok-type">type</span> = ty,
            .base = base,
            .indices_len = <span class="tok-builtin">@intCast</span>(indices.len),
        }),
    });
    self.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(indices));
    <span class="tok-kw">return</span> instruction.toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.gepStruct" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">gepStruct</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.gepStruct">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gepStruct</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, base: <a href="std.zig.llvm.Builder.Value.html">Value</a>, index: <span class="tok-type">usize</span>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>base: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.gepStruct">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gepStruct</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    base: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    index: <span class="tok-type">usize</span>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(ty.isStruct(self.builder));
    <span class="tok-kw">return</span> self.gep(.inbounds, ty, base, &amp;.{ .@&quot;0&quot;, <span class="tok-kw">try</span> self.builder.intValue(.<span class="tok-type">i32</span>, index) }, name);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.conv" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">conv</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.conv">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">conv</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, signedness: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>.<a href="std.zig.llvm.Builder.Constant.Cast.Signedness.html">Signedness</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>signedness: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>.<a href="std.zig.llvm.Builder.Constant.Cast.Signedness.html">Signedness</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.conv">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">conv</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    signedness: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>.<a href="std.zig.llvm.Builder.Constant.Cast.Signedness.html">Signedness</a>,
    val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">const</span> val_ty = val.typeOfWip(self);
    <span class="tok-kw">if</span> (val_ty == ty) <span class="tok-kw">return</span> val;
    <span class="tok-kw">return</span> self.cast(self.builder.convTag(signedness, val_ty, ty), val, ty, name);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.cast" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cast</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.cast">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cast</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.cast">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cast</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>,
    val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">switch</span> (tag) {
        .addrspacecast,
        .bitcast,
        .fpext,
        .fptosi,
        .fptoui,
        .fptrunc,
        .inttoptr,
        .ptrtoint,
        .sext,
        .sitofp,
        .trunc,
        .uitofp,
        .zext,
        =&gt; {},
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
    <span class="tok-kw">if</span> (val.typeOfWip(self) == ty) <span class="tok-kw">return</span> val;
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
        .tag = tag,
        .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>{
            .val = val,
            .<span class="tok-type">type</span> = ty,
        }),
    });
    <span class="tok-kw">return</span> instruction.toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.icmp" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">icmp</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.icmp">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">icmp</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, cond: <a href="std.zig.llvm.Builder.IntegerCondition.html">IntegerCondition</a>, lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>, rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>cond: <a href="std.zig.llvm.Builder.IntegerCondition.html">IntegerCondition</a></code></pre></div><div><pre><code>lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.icmp">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">icmp</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    cond: <a href="std.zig.llvm.Builder.IntegerCondition.html">IntegerCondition</a>,
    lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> self.cmpTag(<span class="tok-kw">switch</span> (cond) {
        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| <span class="tok-builtin">@field</span>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>, <span class="tok-str">&quot;icmp &quot;</span> ++ <span class="tok-builtin">@tagName</span>(tag)),
    }, lhs, rhs, name);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.fcmp" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fcmp</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.fcmp">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fcmp</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, fast: <a href="std.zig.llvm.Builder.FastMathKind.html">FastMathKind</a>, cond: <a href="std.zig.llvm.Builder.FloatCondition.html">FloatCondition</a>, lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>, rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>fast: <a href="std.zig.llvm.Builder.FastMathKind.html">FastMathKind</a></code></pre></div><div><pre><code>cond: <a href="std.zig.llvm.Builder.FloatCondition.html">FloatCondition</a></code></pre></div><div><pre><code>lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.fcmp">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fcmp</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    fast: <a href="std.zig.llvm.Builder.FastMathKind.html">FastMathKind</a>,
    cond: <a href="std.zig.llvm.Builder.FloatCondition.html">FloatCondition</a>,
    lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> self.cmpTag(<span class="tok-kw">switch</span> (fast) {
        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |fast_tag| <span class="tok-kw">switch</span> (cond) {
            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |cond_tag| <span class="tok-builtin">@field</span>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>, <span class="tok-str">&quot;fcmp &quot;</span> ++ <span class="tok-kw">switch</span> (fast_tag) {
                .normal =&gt; <span class="tok-str">&quot;&quot;</span>,
                .fast =&gt; <span class="tok-str">&quot;fast &quot;</span>,
            } ++ <span class="tok-builtin">@tagName</span>(cond_tag)),
        },
    }, lhs, rhs, name);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.phi" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">phi</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.phi">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">phi</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.WipPhi.html">WipPhi</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.phi">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">phi</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.WipPhi.html">WipPhi</a> {
    <span class="tok-kw">return</span> self.phiTag(.phi, ty, name);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.phiFast" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">phiFast</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.phiFast">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">phiFast</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.WipPhi.html">WipPhi</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.phiFast">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">phiFast</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.WipPhi.html">WipPhi</a> {
    <span class="tok-kw">return</span> self.phiTag(.@&quot;phi fast&quot;, ty, name);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.select" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">select</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.select">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">select</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, fast: <a href="std.zig.llvm.Builder.FastMathKind.html">FastMathKind</a>, cond: <a href="std.zig.llvm.Builder.Value.html">Value</a>, lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>, rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>fast: <a href="std.zig.llvm.Builder.FastMathKind.html">FastMathKind</a></code></pre></div><div><pre><code>cond: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.select">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">select</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    fast: <a href="std.zig.llvm.Builder.FastMathKind.html">FastMathKind</a>,
    cond: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> self.selectTag(<span class="tok-kw">switch</span> (fast) {
        .normal =&gt; .select,
        .fast =&gt; .@&quot;select fast&quot;,
    }, cond, lhs, rhs, name);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.call" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">call</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.call">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">call</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.Kind.html">Kind</a>, call_conv: <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a>, function_attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, callee: <a href="std.zig.llvm.Builder.Value.html">Value</a>, args: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.Kind.html">Kind</a></code></pre></div><div><pre><code>call_conv: <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a></code></pre></div><div><pre><code>function_attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>callee: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>args: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.call">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">call</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.Kind.html">Kind</a>,
    call_conv: <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a>,
    function_attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    callee: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    args: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> self.callInner(kind, call_conv, function_attributes, ty, callee, args, name, <span class="tok-null">false</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.callAsm" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">callAsm</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.callAsm">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callAsm</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, function_attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, kind: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.Info.html">Info</a>, assembly: <a href="std.zig.llvm.Builder.String.html">String</a>, constraints: <a href="std.zig.llvm.Builder.String.html">String</a>, args: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>function_attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>kind: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.Info.html">Info</a></code></pre></div><div><pre><code>assembly: <a href="std.zig.llvm.Builder.String.html">String</a></code></pre></div><div><pre><code>constraints: <a href="std.zig.llvm.Builder.String.html">String</a></code></pre></div><div><pre><code>args: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.callAsm">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callAsm</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    function_attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    kind: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.Info.html">Info</a>,
    assembly: <a href="std.zig.llvm.Builder.String.html">String</a>,
    constraints: <a href="std.zig.llvm.Builder.String.html">String</a>,
    args: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">const</span> callee = <span class="tok-kw">try</span> self.builder.asmValue(ty, kind, assembly, constraints);
    <span class="tok-kw">return</span> self.call(.normal, <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a>.<a href="std.zig.llvm.Builder.CallConv.html#std.zig.llvm.Builder.CallConv.default">default</a>, function_attributes, ty, callee, args, name);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.callIntrinsic" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">callIntrinsic</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.callIntrinsic">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callIntrinsic</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, fast: <a href="std.zig.llvm.Builder.FastMathKind.html">FastMathKind</a>, function_attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>, id: <a href="std.zig.llvm.Builder.Intrinsic.html">Intrinsic</a>, overload: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a>, args: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>fast: <a href="std.zig.llvm.Builder.FastMathKind.html">FastMathKind</a></code></pre></div><div><pre><code>function_attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a></code></pre></div><div><pre><code>id: <a href="std.zig.llvm.Builder.Intrinsic.html">Intrinsic</a></code></pre></div><div><pre><code>overload: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>args: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.callIntrinsic">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callIntrinsic</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    fast: <a href="std.zig.llvm.Builder.FastMathKind.html">FastMathKind</a>,
    function_attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
    id: <a href="std.zig.llvm.Builder.Intrinsic.html">Intrinsic</a>,
    overload: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    args: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">const</span> intrinsic = <span class="tok-kw">try</span> self.builder.getIntrinsic(id, overload);
    <span class="tok-kw">return</span> self.call(
        fast.toCallKind(),
        <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a>.<a href="std.zig.llvm.Builder.CallConv.html#std.zig.llvm.Builder.CallConv.default">default</a>,
        function_attributes,
        intrinsic.typeOf(self.builder),
        intrinsic.toValue(self.builder),
        args,
        name,
    );
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.callIntrinsicAssumeCold" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">callIntrinsicAssumeCold</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.callIntrinsicAssumeCold">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callIntrinsicAssumeCold</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.callIntrinsicAssumeCold">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callIntrinsicAssumeCold</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">const</span> intrinsic = <span class="tok-kw">try</span> self.builder.getIntrinsic(.assume, &amp;.{});
    <span class="tok-kw">return</span> self.callInner(
        .normal,
        <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a>.<a href="std.zig.llvm.Builder.CallConv.html#std.zig.llvm.Builder.CallConv.default">default</a>,
        .none,
        intrinsic.typeOf(self.builder),
        intrinsic.toValue(self.builder),
        &amp;.{<span class="tok-kw">try</span> self.builder.intValue(.<span class="tok-type">i1</span>, <span class="tok-number">1</span>)},
        <span class="tok-str">&quot;&quot;</span>,
        <span class="tok-null">true</span>,
    );
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.callMemCpy" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">callMemCpy</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.callMemCpy">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callMemCpy</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, dst: <a href="std.zig.llvm.Builder.Value.html">Value</a>, dst_align: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>, src: <a href="std.zig.llvm.Builder.Value.html">Value</a>, src_align: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>, len: <a href="std.zig.llvm.Builder.Value.html">Value</a>, kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>, @&quot;inline&quot;: <span class="tok-type">bool</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>dst: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>dst_align: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a></code></pre></div><div><pre><code>src: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>src_align: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a></code></pre></div><div><pre><code>len: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a></code></pre></div><div><pre><code>@&quot;inline&quot;: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.callMemCpy">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callMemCpy</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    dst: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    dst_align: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
    src: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    src_align: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
    len: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
    @&quot;inline&quot;: <span class="tok-type">bool</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
    <span class="tok-kw">var</span> dst_attrs = [_]<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>{<span class="tok-kw">try</span> self.builder.attr(.{ .@&quot;align&quot; = dst_align })};
    <span class="tok-kw">var</span> src_attrs = [_]<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>{<span class="tok-kw">try</span> self.builder.attr(.{ .@&quot;align&quot; = src_align })};
    <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> self.callIntrinsic(
        .normal,
        <span class="tok-kw">try</span> self.builder.fnAttrs(&amp;.{
            .none,
            .none,
            <span class="tok-kw">try</span> self.builder.attrs(&amp;dst_attrs),
            <span class="tok-kw">try</span> self.builder.attrs(&amp;src_attrs),
        }),
        <span class="tok-kw">if</span> (@&quot;inline&quot;) .@&quot;memcpy.inline&quot; <span class="tok-kw">else</span> .memcpy,
        &amp;.{ dst.typeOfWip(self), src.typeOfWip(self), len.typeOfWip(self) },
        &amp;.{ dst, src, len, <span class="tok-kw">switch</span> (kind) {
            .normal =&gt; <a href="std.zig.llvm.Builder.Value.html">Value</a>.<span class="tok-null">false</span>,
            .@&quot;volatile&quot; =&gt; <a href="std.zig.llvm.Builder.Value.html">Value</a>.<span class="tok-null">true</span>,
        } },
        <span class="tok-null">undefined</span>,
    );
    <span class="tok-kw">return</span> value.unwrap().instruction;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.callMemSet" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">callMemSet</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.callMemSet">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callMemSet</span>( self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, dst: <a href="std.zig.llvm.Builder.Value.html">Value</a>, dst_align: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>, len: <a href="std.zig.llvm.Builder.Value.html">Value</a>, kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>, @&quot;inline&quot;: <span class="tok-type">bool</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>dst: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>dst_align: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>len: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a></code></pre></div><div><pre><code>@&quot;inline&quot;: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.callMemSet">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callMemSet</span>(
    self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
    dst: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    dst_align: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
    val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    len: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
    kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
    @&quot;inline&quot;: <span class="tok-type">bool</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
    <span class="tok-kw">var</span> dst_attrs = [_]<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>{<span class="tok-kw">try</span> self.builder.attr(.{ .@&quot;align&quot; = dst_align })};
    <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> self.callIntrinsic(
        .normal,
        <span class="tok-kw">try</span> self.builder.fnAttrs(&amp;.{ .none, .none, <span class="tok-kw">try</span> self.builder.attrs(&amp;dst_attrs) }),
        <span class="tok-kw">if</span> (@&quot;inline&quot;) .@&quot;memset.inline&quot; <span class="tok-kw">else</span> .memset,
        &amp;.{ dst.typeOfWip(self), len.typeOfWip(self) },
        &amp;.{ dst, val, len, <span class="tok-kw">switch</span> (kind) {
            .normal =&gt; <a href="std.zig.llvm.Builder.Value.html">Value</a>.<span class="tok-null">false</span>,
            .@&quot;volatile&quot; =&gt; <a href="std.zig.llvm.Builder.Value.html">Value</a>.<span class="tok-null">true</span>,
        } },
        <span class="tok-null">undefined</span>,
    );
    <span class="tok-kw">return</span> value.unwrap().instruction;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.vaArg" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">vaArg</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.vaArg">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">vaArg</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, list: <a href="std.zig.llvm.Builder.Value.html">Value</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>list: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.vaArg">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">vaArg</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, list: <a href="std.zig.llvm.Builder.Value.html">Value</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.VaArg.html">VaArg</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
        .tag = .va_arg,
        .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.VaArg.html">VaArg</a>{
            .list = list,
            .<span class="tok-type">type</span> = ty,
        }),
    });
    <span class="tok-kw">return</span> instruction.toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.debugValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugValue</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.debugValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugValue</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, value: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div><div><pre><code>value: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.debugValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugValue</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, value: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">if</span> (self.strip) <span class="tok-kw">return</span> .none;
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (value.unwrap()) {
        .instruction =&gt; |instr_index| blk: {
            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.debug_values.getOrPut(self.builder.gpa, instr_index);

            <span class="tok-kw">const</span> metadata: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> = <span class="tok-builtin">@enumFromInt</span>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_local_metadata">first_local_metadata</a> + gop.index);
            <span class="tok-kw">if</span> (!gop.found_existing) gop.key_ptr.* = instr_index;

            <span class="tok-kw">break</span> :blk metadata;
        },
        .constant =&gt; |constant| <span class="tok-kw">try</span> self.builder.metadataConstant(constant),
        .metadata =&gt; |metadata| metadata,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.finish" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">finish</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.finish">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finish</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.finish">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finish</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> gpa = self.builder.gpa;
    <span class="tok-kw">const</span> function = self.function.ptr(self.builder);
    <span class="tok-kw">const</span> params_len = self.function.typeOf(self.builder).functionParameters(self.builder).len;
    <span class="tok-kw">const</span> final_instructions_len = self.blocks.items.len + self.instructions.len;

    <span class="tok-kw">const</span> blocks = <span class="tok-kw">try</span> gpa.alloc(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>, self.blocks.items.len);
    <span class="tok-kw">errdefer</span> gpa.free(blocks);

    <span class="tok-kw">const</span> instructions: <span class="tok-kw">struct</span> {
        items: []<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>,

        <span class="tok-kw">fn</span> <span class="tok-fn">map</span>(instructions: <span class="tok-builtin">@This</span>(), val: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <a href="std.zig.llvm.Builder.Value.html">Value</a> {
            <span class="tok-kw">if</span> (val == .none) <span class="tok-kw">return</span> .none;
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (val.unwrap()) {
                .instruction =&gt; |instruction| instructions.items[
                    <span class="tok-builtin">@intFromEnum</span>(instruction)
                ].toValue(),
                .constant =&gt; |constant| constant.toValue(),
                .metadata =&gt; |metadata| metadata.toValue(),
            };
        }
    } = .{ .items = <span class="tok-kw">try</span> gpa.alloc(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, self.instructions.len) };
    <span class="tok-kw">defer</span> gpa.free(instructions.items);

    <span class="tok-kw">const</span> names = <span class="tok-kw">try</span> gpa.alloc(<a href="std.zig.llvm.Builder.String.html">String</a>, final_instructions_len);
    <span class="tok-kw">errdefer</span> gpa.free(names);

    <span class="tok-kw">const</span> value_indices = <span class="tok-kw">try</span> gpa.alloc(<span class="tok-type">u32</span>, final_instructions_len);
    <span class="tok-kw">errdefer</span> gpa.free(value_indices);

    <span class="tok-kw">var</span> debug_locations: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMapUnmanaged">AutoHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, <a href="std.zig.llvm.Builder.DebugLocation.html">DebugLocation</a>) = .empty;
    <span class="tok-kw">errdefer</span> debug_locations.deinit(gpa);
    <span class="tok-kw">try</span> debug_locations.ensureUnusedCapacity(gpa, <span class="tok-builtin">@intCast</span>(self.debug_locations.count()));

    <span class="tok-kw">const</span> debug_values = <span class="tok-kw">try</span> gpa.alloc(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, self.debug_values.count());
    <span class="tok-kw">errdefer</span> gpa.free(debug_values);

    <span class="tok-kw">var</span> wip_extra: <span class="tok-kw">struct</span> {
        index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html#std.zig.llvm.Builder.Function.Instruction.ExtraIndex">ExtraIndex</a> = <span class="tok-number">0</span>,
        items: []<span class="tok-type">u32</span>,

        <span class="tok-kw">fn</span> <span class="tok-fn">addExtra</span>(wip_extra: *<span class="tok-builtin">@This</span>(), extra: <span class="tok-kw">anytype</span>) <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html#std.zig.llvm.Builder.Function.Instruction.ExtraIndex">ExtraIndex</a> {
            <span class="tok-kw">const</span> result = wip_extra.index;
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(extra)).@&quot;struct&quot;.fields) |field| {
                <span class="tok-kw">const</span> value = <span class="tok-builtin">@field</span>(extra, field.name);
                wip_extra.items[wip_extra.index] = <span class="tok-kw">switch</span> (field.<span class="tok-type">type</span>) {
                    <span class="tok-type">u32</span> =&gt; value,
                    <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
                    <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
                    <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
                    <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
                    <a href="std.zig.llvm.Builder.Type.html">Type</a>,
                    <a href="std.zig.llvm.Builder.Value.html">Value</a>,
                    <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.Weights.html">Weights</a>,
                    =&gt; <span class="tok-builtin">@intFromEnum</span>(value),
                    <a href="std.zig.llvm.Builder.MemoryAccessInfo.html">MemoryAccessInfo</a>,
                    <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.Info.html">Info</a>,
                    <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.Info.html">Info</a>,
                    =&gt; <span class="tok-builtin">@bitCast</span>(value),
                    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type: &quot;</span> ++ field.name ++ <span class="tok-str">&quot;: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(field.<span class="tok-type">type</span>)),
                };
                wip_extra.index += <span class="tok-number">1</span>;
            }
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(wip_extra: *<span class="tok-builtin">@This</span>(), slice: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(slice)).pointer.child == <a href="std.zig.llvm.Builder.Value.html">Value</a>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;use appendMappedValues&quot;</span>);
            <span class="tok-kw">const</span> data: []<span class="tok-kw">const</span> <span class="tok-type">u32</span> = <span class="tok-builtin">@ptrCast</span>(slice);
            <span class="tok-builtin">@memcpy</span>(wip_extra.items[wip_extra.index..][<span class="tok-number">0</span>..data.len], data);
            wip_extra.index += <span class="tok-builtin">@intCast</span>(data.len);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">appendMappedValues</span>(wip_extra: *<span class="tok-builtin">@This</span>(), vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">for</span> (wip_extra.items[wip_extra.index..][<span class="tok-number">0</span>..vals.len], vals) |*extra, val|
                extra.* = <span class="tok-builtin">@intFromEnum</span>(ctx.map(val));
            wip_extra.index += <span class="tok-builtin">@intCast</span>(vals.len);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">finish</span>(wip_extra: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) []<span class="tok-kw">const</span> <span class="tok-type">u32</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(wip_extra.index == wip_extra.items.len);
            <span class="tok-kw">return</span> wip_extra.items;
        }
    } = .{ .items = <span class="tok-kw">try</span> gpa.alloc(<span class="tok-type">u32</span>, self.extra.items.len) };
    <span class="tok-kw">errdefer</span> gpa.free(wip_extra.items);

    gpa.free(function.blocks);
    function.blocks = &amp;.{};
    gpa.free(function.names[<span class="tok-number">0</span>..function.instructions.len]);
    function.debug_locations.deinit(gpa);
    function.debug_locations = .{};
    gpa.free(function.debug_values);
    function.debug_values = &amp;.{};
    gpa.free(function.extra);
    function.extra = &amp;.{};

    function.instructions.shrinkRetainingCapacity(<span class="tok-number">0</span>);
    <span class="tok-kw">try</span> function.instructions.setCapacity(gpa, final_instructions_len);
    <span class="tok-kw">errdefer</span> function.instructions.shrinkRetainingCapacity(<span class="tok-number">0</span>);

    {
        <span class="tok-kw">var</span> final_instruction_index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>);
        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..params_len) |param_index| {
            instructions.items[param_index] = final_instruction_index;
            final_instruction_index = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(final_instruction_index) + <span class="tok-number">1</span>);
        }
        <span class="tok-kw">for</span> (blocks, self.blocks.items) |*final_block, current_block| {
            <a href="std.debug.html#std.debug.assert">assert</a>(current_block.incoming == current_block.branches);
            final_block.instruction = final_instruction_index;
            final_instruction_index = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(final_instruction_index) + <span class="tok-number">1</span>);
            <span class="tok-kw">for</span> (current_block.instructions.items) |instruction| {
                instructions.items[<span class="tok-builtin">@intFromEnum</span>(instruction)] = final_instruction_index;
                final_instruction_index = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(final_instruction_index) + <span class="tok-number">1</span>);
            }
        }
    }

    <span class="tok-kw">var</span> wip_name: <span class="tok-kw">struct</span> {
        next_name: <a href="std.zig.llvm.Builder.String.html">String</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>),
        next_unique_name: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<a href="std.zig.llvm.Builder.String.html">String</a>, <a href="std.zig.llvm.Builder.String.html">String</a>),
        builder: *<a href="std.zig.llvm.Builder.html">Builder</a>,

        <span class="tok-kw">fn</span> <span class="tok-fn">map</span>(wip_name: *<span class="tok-builtin">@This</span>(), name: <a href="std.zig.llvm.Builder.String.html">String</a>, sep: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.String.html">String</a> {
            <span class="tok-kw">switch</span> (name) {
                .none =&gt; <span class="tok-kw">return</span> .none,
                .empty =&gt; {
                    <a href="std.debug.html#std.debug.assert">assert</a>(wip_name.next_name != .none);
                    <span class="tok-kw">defer</span> wip_name.next_name = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(wip_name.next_name) + <span class="tok-number">1</span>);
                    <span class="tok-kw">return</span> wip_name.next_name;
                },
                _ =&gt; {
                    <a href="std.debug.html#std.debug.assert">assert</a>(!name.isAnon());
                    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> wip_name.next_unique_name.getOrPut(name);
                    <span class="tok-kw">if</span> (!gop.found_existing) {
                        gop.value_ptr.* = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>);
                        <span class="tok-kw">return</span> name;
                    }

                    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                        gop.value_ptr.* = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(gop.value_ptr.*) + <span class="tok-number">1</span>);
                        <span class="tok-kw">const</span> unique_name = <span class="tok-kw">try</span> wip_name.builder.fmt(<span class="tok-str">&quot;{r}{s}{r}&quot;</span>, .{
                            name.fmt(wip_name.builder),
                            sep,
                            gop.value_ptr.fmt(wip_name.builder),
                        });
                        <span class="tok-kw">const</span> unique_gop = <span class="tok-kw">try</span> wip_name.next_unique_name.getOrPut(unique_name);
                        <span class="tok-kw">if</span> (!unique_gop.found_existing) {
                            unique_gop.value_ptr.* = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>);
                            <span class="tok-kw">return</span> unique_name;
                        }
                    }
                },
            }
        }
    } = .{
        .next_unique_name = <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<a href="std.zig.llvm.Builder.String.html">String</a>, <a href="std.zig.llvm.Builder.String.html">String</a>).init(gpa),
        .builder = self.builder,
    };
    <span class="tok-kw">defer</span> wip_name.next_unique_name.deinit();

    <span class="tok-kw">var</span> value_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..params_len) |param_index| {
        <span class="tok-kw">const</span> old_argument_index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(param_index);
        <span class="tok-kw">const</span> new_argument_index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(function.instructions.len);
        <span class="tok-kw">const</span> argument = self.instructions.get(<span class="tok-builtin">@intFromEnum</span>(old_argument_index));
        <a href="std.debug.html#std.debug.assert">assert</a>(argument.tag == .arg);
        <a href="std.debug.html#std.debug.assert">assert</a>(argument.data == param_index);
        value_indices[function.instructions.len] = value_index;
        value_index += <span class="tok-number">1</span>;
        function.instructions.appendAssumeCapacity(argument);
        names[<span class="tok-builtin">@intFromEnum</span>(new_argument_index)] = <span class="tok-kw">try</span> wip_name.map(
            <span class="tok-kw">if</span> (self.strip) .empty <span class="tok-kw">else</span> self.names.items[<span class="tok-builtin">@intFromEnum</span>(old_argument_index)],
            <span class="tok-str">&quot;.&quot;</span>,
        );
        <span class="tok-kw">if</span> (self.debug_locations.get(old_argument_index)) |location| {
            debug_locations.putAssumeCapacity(new_argument_index, location);
        }
        <span class="tok-kw">if</span> (self.debug_values.getIndex(old_argument_index)) |index| {
            debug_values[index] = new_argument_index;
        }
    }
    <span class="tok-kw">for</span> (self.blocks.items) |current_block| {
        <span class="tok-kw">const</span> new_block_index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(function.instructions.len);
        value_indices[function.instructions.len] = value_index;
        function.instructions.appendAssumeCapacity(.{
            .tag = .block,
            .data = current_block.incoming,
        });
        names[<span class="tok-builtin">@intFromEnum</span>(new_block_index)] = <span class="tok-kw">try</span> wip_name.map(current_block.name, <span class="tok-str">&quot;&quot;</span>);
        <span class="tok-kw">for</span> (current_block.instructions.items) |old_instruction_index| {
            <span class="tok-kw">const</span> new_instruction_index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(function.instructions.len);
            <span class="tok-kw">var</span> instruction = self.instructions.get(<span class="tok-builtin">@intFromEnum</span>(old_instruction_index));
            <span class="tok-kw">switch</span> (instruction.tag) {
                .add,
                .@&quot;add nsw&quot;,
                .@&quot;add nuw&quot;,
                .@&quot;add nuw nsw&quot;,
                .@&quot;and&quot;,
                .ashr,
                .@&quot;ashr exact&quot;,
                .fadd,
                .@&quot;fadd fast&quot;,
                .@&quot;fcmp false&quot;,
                .@&quot;fcmp fast false&quot;,
                .@&quot;fcmp fast oeq&quot;,
                .@&quot;fcmp fast oge&quot;,
                .@&quot;fcmp fast ogt&quot;,
                .@&quot;fcmp fast ole&quot;,
                .@&quot;fcmp fast olt&quot;,
                .@&quot;fcmp fast one&quot;,
                .@&quot;fcmp fast ord&quot;,
                .@&quot;fcmp fast true&quot;,
                .@&quot;fcmp fast ueq&quot;,
                .@&quot;fcmp fast uge&quot;,
                .@&quot;fcmp fast ugt&quot;,
                .@&quot;fcmp fast ule&quot;,
                .@&quot;fcmp fast ult&quot;,
                .@&quot;fcmp fast une&quot;,
                .@&quot;fcmp fast uno&quot;,
                .@&quot;fcmp oeq&quot;,
                .@&quot;fcmp oge&quot;,
                .@&quot;fcmp ogt&quot;,
                .@&quot;fcmp ole&quot;,
                .@&quot;fcmp olt&quot;,
                .@&quot;fcmp one&quot;,
                .@&quot;fcmp ord&quot;,
                .@&quot;fcmp true&quot;,
                .@&quot;fcmp ueq&quot;,
                .@&quot;fcmp uge&quot;,
                .@&quot;fcmp ugt&quot;,
                .@&quot;fcmp ule&quot;,
                .@&quot;fcmp ult&quot;,
                .@&quot;fcmp une&quot;,
                .@&quot;fcmp uno&quot;,
                .fdiv,
                .@&quot;fdiv fast&quot;,
                .fmul,
                .@&quot;fmul fast&quot;,
                .frem,
                .@&quot;frem fast&quot;,
                .fsub,
                .@&quot;fsub fast&quot;,
                .@&quot;icmp eq&quot;,
                .@&quot;icmp ne&quot;,
                .@&quot;icmp sge&quot;,
                .@&quot;icmp sgt&quot;,
                .@&quot;icmp sle&quot;,
                .@&quot;icmp slt&quot;,
                .@&quot;icmp uge&quot;,
                .@&quot;icmp ugt&quot;,
                .@&quot;icmp ule&quot;,
                .@&quot;icmp ult&quot;,
                .lshr,
                .@&quot;lshr exact&quot;,
                .mul,
                .@&quot;mul nsw&quot;,
                .@&quot;mul nuw&quot;,
                .@&quot;mul nuw nsw&quot;,
                .@&quot;or&quot;,
                .sdiv,
                .@&quot;sdiv exact&quot;,
                .shl,
                .@&quot;shl nsw&quot;,
                .@&quot;shl nuw&quot;,
                .@&quot;shl nuw nsw&quot;,
                .srem,
                .sub,
                .@&quot;sub nsw&quot;,
                .@&quot;sub nuw&quot;,
                .@&quot;sub nuw nsw&quot;,
                .udiv,
                .@&quot;udiv exact&quot;,
                .urem,
                .xor,
                =&gt; {
                    <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, instruction.data);
                    instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>{
                        .lhs = instructions.map(extra.lhs),
                        .rhs = instructions.map(extra.rhs),
                    });
                },
                .addrspacecast,
                .bitcast,
                .fpext,
                .fptosi,
                .fptoui,
                .fptrunc,
                .inttoptr,
                .ptrtoint,
                .sext,
                .sitofp,
                .trunc,
                .uitofp,
                .zext,
                =&gt; {
                    <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>, instruction.data);
                    instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>{
                        .val = instructions.map(extra.val),
                        .<span class="tok-type">type</span> = extra.<span class="tok-type">type</span>,
                    });
                },
                .alloca,
                .@&quot;alloca inalloca&quot;,
                =&gt; {
                    <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>, instruction.data);
                    instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>{
                        .<span class="tok-type">type</span> = extra.<span class="tok-type">type</span>,
                        .len = instructions.map(extra.len),
                        .info = extra.info,
                    });
                },
                .arg,
                .block,
                =&gt; <span class="tok-kw">unreachable</span>,
                .atomicrmw =&gt; {
                    <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>, instruction.data);
                    instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>{
                        .info = extra.info,
                        .ptr = instructions.map(extra.ptr),
                        .val = instructions.map(extra.val),
                    });
                },
                .br,
                .fence,
                .@&quot;ret void&quot;,
                .@&quot;unreachable&quot;,
                =&gt; {},
                .br_cond =&gt; {
                    <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>, instruction.data);
                    instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>{
                        .cond = instructions.map(extra.cond),
                        .then = extra.then,
                        .@&quot;else&quot; = extra.@&quot;else&quot;,
                        .weights = extra.weights,
                    });
                },
                .call,
                .@&quot;call fast&quot;,
                .@&quot;musttail call&quot;,
                .@&quot;musttail call fast&quot;,
                .@&quot;notail call&quot;,
                .@&quot;notail call fast&quot;,
                .@&quot;tail call&quot;,
                .@&quot;tail call fast&quot;,
                =&gt; {
                    <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>, instruction.data);
                    <span class="tok-kw">const</span> args = extra.trail.next(extra.data.args_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, self);
                    instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>{
                        .info = extra.data.info,
                        .attributes = extra.data.attributes,
                        .ty = extra.data.ty,
                        .callee = instructions.map(extra.data.callee),
                        .args_len = extra.data.args_len,
                    });
                    wip_extra.appendMappedValues(args, instructions);
                },
                .cmpxchg,
                .@&quot;cmpxchg weak&quot;,
                =&gt; {
                    <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>, instruction.data);
                    instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>{
                        .info = extra.info,
                        .ptr = instructions.map(extra.ptr),
                        .cmp = instructions.map(extra.cmp),
                        .new = instructions.map(extra.new),
                    });
                },
                .extractelement =&gt; {
                    <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractElement.html">ExtractElement</a>, instruction.data);
                    instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractElement.html">ExtractElement</a>{
                        .val = instructions.map(extra.val),
                        .index = instructions.map(extra.index),
                    });
                },
                .extractvalue =&gt; {
                    <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractValue.html">ExtractValue</a>, instruction.data);
                    <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <span class="tok-type">u32</span>, self);
                    instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractValue.html">ExtractValue</a>{
                        .val = instructions.map(extra.data.val),
                        .indices_len = extra.data.indices_len,
                    });
                    wip_extra.appendSlice(indices);
                },
                .fneg,
                .@&quot;fneg fast&quot;,
                .ret,
                =&gt; instruction.data = <span class="tok-builtin">@intFromEnum</span>(instructions.map(<span class="tok-builtin">@enumFromInt</span>(instruction.data))),
                .getelementptr,
                .@&quot;getelementptr inbounds&quot;,
                =&gt; {
                    <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>, instruction.data);
                    <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, self);
                    instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>{
                        .<span class="tok-type">type</span> = extra.data.<span class="tok-type">type</span>,
                        .base = instructions.map(extra.data.base),
                        .indices_len = extra.data.indices_len,
                    });
                    wip_extra.appendMappedValues(indices, instructions);
                },
                .indirectbr =&gt; {
                    <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.IndirectBr.html">IndirectBr</a>, instruction.data);
                    <span class="tok-kw">const</span> targets = extra.trail.next(extra.data.targets_len, <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, self);
                    instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.IndirectBr.html">IndirectBr</a>{
                        .addr = instructions.map(extra.data.addr),
                        .targets_len = extra.data.targets_len,
                    });
                    wip_extra.appendSlice(targets);
                },
                .insertelement =&gt; {
                    <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertElement.html">InsertElement</a>, instruction.data);
                    instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertElement.html">InsertElement</a>{
                        .val = instructions.map(extra.val),
                        .elem = instructions.map(extra.elem),
                        .index = instructions.map(extra.index),
                    });
                },
                .insertvalue =&gt; {
                    <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertValue.html">InsertValue</a>, instruction.data);
                    <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <span class="tok-type">u32</span>, self);
                    instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertValue.html">InsertValue</a>{
                        .val = instructions.map(extra.data.val),
                        .elem = instructions.map(extra.data.elem),
                        .indices_len = extra.data.indices_len,
                    });
                    wip_extra.appendSlice(indices);
                },
                .load,
                .@&quot;load atomic&quot;,
                =&gt; {
                    <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Load.html">Load</a>, instruction.data);
                    instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Load.html">Load</a>{
                        .<span class="tok-type">type</span> = extra.<span class="tok-type">type</span>,
                        .ptr = instructions.map(extra.ptr),
                        .info = extra.info,
                    });
                },
                .phi,
                .@&quot;phi fast&quot;,
                =&gt; {
                    <span class="tok-kw">const</span> incoming_len = current_block.incoming;
                    <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Phi.html">Phi</a>, instruction.data);
                    <span class="tok-kw">const</span> incoming_vals = extra.trail.next(incoming_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, self);
                    <span class="tok-kw">const</span> incoming_blocks = extra.trail.next(incoming_len, <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, self);
                    instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Phi.html">Phi</a>{
                        .<span class="tok-type">type</span> = extra.data.<span class="tok-type">type</span>,
                    });
                    wip_extra.appendMappedValues(incoming_vals, instructions);
                    wip_extra.appendSlice(incoming_blocks);
                },
                .select,
                .@&quot;select fast&quot;,
                =&gt; {
                    <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Select.html">Select</a>, instruction.data);
                    instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Select.html">Select</a>{
                        .cond = instructions.map(extra.cond),
                        .lhs = instructions.map(extra.lhs),
                        .rhs = instructions.map(extra.rhs),
                    });
                },
                .shufflevector =&gt; {
                    <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ShuffleVector.html">ShuffleVector</a>, instruction.data);
                    instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ShuffleVector.html">ShuffleVector</a>{
                        .lhs = instructions.map(extra.lhs),
                        .rhs = instructions.map(extra.rhs),
                        .mask = instructions.map(extra.mask),
                    });
                },
                .store,
                .@&quot;store atomic&quot;,
                =&gt; {
                    <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Store.html">Store</a>, instruction.data);
                    instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Store.html">Store</a>{
                        .val = instructions.map(extra.val),
                        .ptr = instructions.map(extra.ptr),
                        .info = extra.info,
                    });
                },
                .@&quot;switch&quot; =&gt; {
                    <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>, instruction.data);
                    <span class="tok-kw">const</span> case_vals = extra.trail.next(extra.data.cases_len, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, self);
                    <span class="tok-kw">const</span> case_blocks = extra.trail.next(extra.data.cases_len, <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, self);
                    instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>{
                        .val = instructions.map(extra.data.val),
                        .default = extra.data.default,
                        .cases_len = extra.data.cases_len,
                        .weights = extra.data.weights,
                    });
                    wip_extra.appendSlice(case_vals);
                    wip_extra.appendSlice(case_blocks);
                },
                .va_arg =&gt; {
                    <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.VaArg.html">VaArg</a>, instruction.data);
                    instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.VaArg.html">VaArg</a>{
                        .list = instructions.map(extra.list),
                        .<span class="tok-type">type</span> = extra.<span class="tok-type">type</span>,
                    });
                },
            }
            function.instructions.appendAssumeCapacity(instruction);
            names[<span class="tok-builtin">@intFromEnum</span>(new_instruction_index)] = <span class="tok-kw">try</span> wip_name.map(<span class="tok-kw">if</span> (self.strip)
                <span class="tok-kw">if</span> (old_instruction_index.hasResultWip(self)) .empty <span class="tok-kw">else</span> .none
            <span class="tok-kw">else</span>
                self.names.items[<span class="tok-builtin">@intFromEnum</span>(old_instruction_index)], <span class="tok-str">&quot;.&quot;</span>);

            <span class="tok-kw">if</span> (self.debug_locations.get(old_instruction_index)) |location| {
                debug_locations.putAssumeCapacity(new_instruction_index, location);
            }

            <span class="tok-kw">if</span> (self.debug_values.getIndex(old_instruction_index)) |index| {
                debug_values[index] = new_instruction_index;
            }

            value_indices[<span class="tok-builtin">@intFromEnum</span>(new_instruction_index)] = value_index;
            <span class="tok-kw">if</span> (old_instruction_index.hasResultWip(self)) value_index += <span class="tok-number">1</span>;
        }
    }

    <a href="std.debug.html#std.debug.assert">assert</a>(function.instructions.len == final_instructions_len);
    function.extra = wip_extra.finish();
    function.blocks = blocks;
    function.names = names.ptr;
    function.value_indices = value_indices.ptr;
    function.strip = self.strip;
    function.debug_locations = debug_locations;
    function.debug_values = debug_values;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.WipFunction.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.zig.llvm.Builder.WipFunction.deinit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction.deinit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <span class="tok-type">void</span> {
    self.extra.deinit(self.builder.gpa);
    self.debug_values.deinit(self.builder.gpa);
    self.debug_locations.deinit(self.builder.gpa);
    self.names.deinit(self.builder.gpa);
    self.instructions.deinit(self.builder.gpa);
    <span class="tok-kw">for</span> (self.blocks.items) |*b| b.instructions.deinit(self.builder.gpa);
    self.blocks.deinit(self.builder.gpa);
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.WipFunction">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> WipFunction = <span class="tok-kw">struct</span> {
    builder: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>,
    prev_debug_location: <a href="std.zig.llvm.Builder.DebugLocation.html">DebugLocation</a>,
    debug_location: <a href="std.zig.llvm.Builder.DebugLocation.html">DebugLocation</a>,
    cursor: <a href="std.zig.llvm.Builder.WipFunction.Cursor.html">Cursor</a>,
    blocks: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>),
    instructions: <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>),
    names: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.llvm.Builder.String.html">String</a>),
    strip: <span class="tok-type">bool</span>,
    debug_locations: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, <a href="std.zig.llvm.Builder.DebugLocation.html">DebugLocation</a>),
    debug_values: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, <span class="tok-type">void</span>),
    extra: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>),

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Cursor = <span class="tok-kw">struct</span> { block: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, instruction: <span class="tok-type">u32</span> = <span class="tok-number">0</span> };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Block = <span class="tok-kw">struct</span> {
        name: <a href="std.zig.llvm.Builder.String.html">String</a>,
        incoming: <span class="tok-type">u32</span>,
        branches: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,
        instructions: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>),

        <span class="tok-kw">const</span> Index = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
            entry,
            _,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptr</span>(self: <a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, wip: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) *<a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a> {
                <span class="tok-kw">return</span> &amp;wip.blocks.items[<span class="tok-builtin">@intFromEnum</span>(self)];
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrConst</span>(self: <a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, wip: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a> {
                <span class="tok-kw">return</span> &amp;wip.blocks.items[<span class="tok-builtin">@intFromEnum</span>(self)];
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toInst</span>(self: <a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, function: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Function.html">Function</a>) <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
                <span class="tok-kw">return</span> function.blocks[<span class="tok-builtin">@intFromEnum</span>(self)].instruction;
            }
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Instruction = <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>;

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(builder: *<a href="std.zig.llvm.Builder.html">Builder</a>, options: <span class="tok-kw">struct</span> {
        function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>,
        strip: <span class="tok-type">bool</span>,
    }) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a> {
        <span class="tok-kw">var</span> self: <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a> = .{
            .builder = builder,
            .function = options.function,
            .prev_debug_location = .no_location,
            .debug_location = .no_location,
            .cursor = <span class="tok-null">undefined</span>,
            .blocks = .{},
            .instructions = .{},
            .names = .{},
            .strip = options.strip,
            .debug_locations = .{},
            .debug_values = .{},
            .extra = .{},
        };
        <span class="tok-kw">errdefer</span> self.deinit();

        <span class="tok-kw">const</span> params_len = options.function.typeOf(self.builder).functionParameters(self.builder).len;
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(params_len, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> self.instructions.ensureUnusedCapacity(self.builder.gpa, params_len);
        <span class="tok-kw">if</span> (!self.strip) {
            <span class="tok-kw">try</span> self.names.ensureUnusedCapacity(self.builder.gpa, params_len);
        }
        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..params_len) |param_index| {
            self.instructions.appendAssumeCapacity(.{ .tag = .arg, .data = <span class="tok-builtin">@intCast</span>(param_index) });
            <span class="tok-kw">if</span> (!self.strip) {
                self.names.appendAssumeCapacity(.empty);<span class="tok-comment"> // TODO: param names
            </span>}
        }

        <span class="tok-kw">return</span> self;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arg</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, index: <span class="tok-type">u32</span>) <a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">const</span> argument = self.instructions.get(index);
        <a href="std.debug.html#std.debug.assert">assert</a>(argument.tag == .arg);
        <a href="std.debug.html#std.debug.assert">assert</a>(argument.data == index);

        <span class="tok-kw">const</span> argument_index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(index);
        <span class="tok-kw">return</span> argument_index.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">block</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, incoming: <span class="tok-type">u32</span>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a> {
        <span class="tok-kw">try</span> self.blocks.ensureUnusedCapacity(self.builder.gpa, <span class="tok-number">1</span>);

        <span class="tok-kw">const</span> index: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(self.blocks.items.len);
        <span class="tok-kw">const</span> final_name = <span class="tok-kw">if</span> (self.strip) .empty <span class="tok-kw">else</span> <span class="tok-kw">try</span> self.builder.string(name);
        self.blocks.appendAssumeCapacity(.{
            .name = final_name,
            .incoming = incoming,
            .instructions = .{},
        });
        <span class="tok-kw">return</span> index;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ret</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(val.typeOfWip(self) == self.function.typeOf(self.builder).functionReturn(self.builder));
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{ .tag = .ret, .data = <span class="tok-builtin">@intFromEnum</span>(val) });
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">retVoid</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{ .tag = .@&quot;ret void&quot;, .data = <span class="tok-null">undefined</span> });
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">br</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, dest: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{ .tag = .br, .data = <span class="tok-builtin">@intFromEnum</span>(dest) });
        dest.ptr(self).branches += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> instruction;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">brCond</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        cond: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        then: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
        @&quot;else&quot;: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
        weights: <span class="tok-kw">enum</span> { none, unpredictable, then_likely, else_likely },
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(cond.typeOfWip(self) == .<span class="tok-type">i1</span>);
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{
            .tag = .br_cond,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>{
                .cond = cond,
                .then = then,
                .@&quot;else&quot; = @&quot;else&quot;,
                .weights = <span class="tok-kw">switch</span> (weights) {
                    .none =&gt; .none,
                    .unpredictable =&gt; .unpredictable,
                    .then_likely, .else_likely =&gt; w: {
                        <span class="tok-kw">const</span> branch_weights_str = <span class="tok-kw">try</span> self.builder.metadataString(<span class="tok-str">&quot;branch_weights&quot;</span>);
                        <span class="tok-kw">const</span> unlikely_const = <span class="tok-kw">try</span> self.builder.metadataConstant(<span class="tok-kw">try</span> self.builder.intConst(.<span class="tok-type">i32</span>, <span class="tok-number">1</span>));
                        <span class="tok-kw">const</span> likely_const = <span class="tok-kw">try</span> self.builder.metadataConstant(<span class="tok-kw">try</span> self.builder.intConst(.<span class="tok-type">i32</span>, <span class="tok-number">2000</span>));
                        <span class="tok-kw">const</span> weight_vals: [<span class="tok-number">2</span>]<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> = <span class="tok-kw">switch</span> (weights) {
                            .none, .unpredictable =&gt; <span class="tok-kw">unreachable</span>,
                            .then_likely =&gt; .{ likely_const, unlikely_const },
                            .else_likely =&gt; .{ unlikely_const, likely_const },
                        };
                        <span class="tok-kw">const</span> tuple = <span class="tok-kw">try</span> self.builder.strTuple(branch_weights_str, &amp;weight_vals);
                        <span class="tok-kw">break</span> :w <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(tuple));
                    },
                },
            }),
        });
        then.ptr(self).branches += <span class="tok-number">1</span>;
        @&quot;else&quot;.ptr(self).branches += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> instruction;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> WipSwitch = <span class="tok-kw">struct</span> {
        index: <span class="tok-type">u32</span>,
        instruction: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCase</span>(
            self: *<a href="std.zig.llvm.Builder.WipFunction.WipSwitch.html">WipSwitch</a>,
            val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
            dest: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
            wip: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> instruction = wip.instructions.get(<span class="tok-builtin">@intFromEnum</span>(self.instruction));
            <span class="tok-kw">var</span> extra = wip.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>, instruction.data);
            <a href="std.debug.html#std.debug.assert">assert</a>(val.typeOf(wip.builder) == extra.data.val.typeOfWip(wip));
            extra.trail.nextMut(extra.data.cases_len, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, wip)[self.index] = val;
            extra.trail.nextMut(extra.data.cases_len, <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, wip)[self.index] = dest;
            self.index += <span class="tok-number">1</span>;
            dest.ptr(wip).branches += <span class="tok-number">1</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finish</span>(self: <a href="std.zig.llvm.Builder.WipFunction.WipSwitch.html">WipSwitch</a>, wip: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> instruction = wip.instructions.get(<span class="tok-builtin">@intFromEnum</span>(self.instruction));
            <span class="tok-kw">const</span> extra = wip.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>, instruction.data);
            <a href="std.debug.html#std.debug.assert">assert</a>(self.index == extra.cases_len);
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">@&quot;switch&quot;</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        default: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
        cases_len: <span class="tok-type">u32</span>,
        weights: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.Weights.html">Weights</a>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.WipSwitch.html">WipSwitch</a> {
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>, cases_len * <span class="tok-number">2</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{
            .tag = .@&quot;switch&quot;,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>{
                .val = val,
                .default = default,
                .cases_len = cases_len,
                .weights = weights,
            }),
        });
        _ = self.extra.addManyAsSliceAssumeCapacity(cases_len * <span class="tok-number">2</span>);
        default.ptr(self).branches += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> .{ .index = <span class="tok-number">0</span>, .instruction = instruction };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indirectbr</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        addr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        targets: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.IndirectBr.html">IndirectBr</a>, targets.len);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{
            .tag = .indirectbr,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.IndirectBr.html">IndirectBr</a>{
                .addr = addr,
                .targets_len = <span class="tok-builtin">@intCast</span>(targets.len),
            }),
        });
        _ = self.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(targets));
        <span class="tok-kw">for</span> (targets) |target| target.ptr(self).branches += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> instruction;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">@&quot;unreachable&quot;</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{ .tag = .@&quot;unreachable&quot;, .data = <span class="tok-null">undefined</span> });
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">un</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">switch</span> (tag) {
            .fneg,
            .@&quot;fneg fast&quot;,
            =&gt; <a href="std.debug.html#std.debug.assert">assert</a>(val.typeOfWip(self).scalarType(self.builder).isFloatingPoint()),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{ .tag = tag, .data = <span class="tok-builtin">@intFromEnum</span>(val) });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">not</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">const</span> ty = val.typeOfWip(self);
        <span class="tok-kw">const</span> all_ones = <span class="tok-kw">try</span> self.builder.splatValue(
            ty,
            <span class="tok-kw">try</span> self.builder.intConst(ty.scalarType(self.builder), -<span class="tok-number">1</span>),
        );
        <span class="tok-kw">return</span> self.bin(.xor, val, all_ones, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">neg</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">return</span> self.bin(.sub, <span class="tok-kw">try</span> self.builder.zeroInitValue(val.typeOfWip(self)), val, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bin</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>,
        lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">switch</span> (tag) {
            .add,
            .@&quot;add nsw&quot;,
            .@&quot;add nuw&quot;,
            .@&quot;and&quot;,
            .ashr,
            .@&quot;ashr exact&quot;,
            .fadd,
            .@&quot;fadd fast&quot;,
            .fdiv,
            .@&quot;fdiv fast&quot;,
            .fmul,
            .@&quot;fmul fast&quot;,
            .frem,
            .@&quot;frem fast&quot;,
            .fsub,
            .@&quot;fsub fast&quot;,
            .lshr,
            .@&quot;lshr exact&quot;,
            .mul,
            .@&quot;mul nsw&quot;,
            .@&quot;mul nuw&quot;,
            .@&quot;or&quot;,
            .sdiv,
            .@&quot;sdiv exact&quot;,
            .shl,
            .@&quot;shl nsw&quot;,
            .@&quot;shl nuw&quot;,
            .srem,
            .sub,
            .@&quot;sub nsw&quot;,
            .@&quot;sub nuw&quot;,
            .udiv,
            .@&quot;udiv exact&quot;,
            .urem,
            .xor,
            =&gt; <a href="std.debug.html#std.debug.assert">assert</a>(lhs.typeOfWip(self) == rhs.typeOfWip(self)),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = tag,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>{ .lhs = lhs, .rhs = rhs }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">extractElement</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        index: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(val.typeOfWip(self).isVector(self.builder));
        <a href="std.debug.html#std.debug.assert">assert</a>(index.typeOfWip(self).isInteger(self.builder));
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractElement.html">ExtractElement</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = .extractelement,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractElement.html">ExtractElement</a>{
                .val = val,
                .index = index,
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertElement</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        elem: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        index: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(val.typeOfWip(self).scalarType(self.builder) == elem.typeOfWip(self));
        <a href="std.debug.html#std.debug.assert">assert</a>(index.typeOfWip(self).isInteger(self.builder));
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertElement.html">InsertElement</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = .insertelement,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertElement.html">InsertElement</a>{
                .val = val,
                .elem = elem,
                .index = index,
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shuffleVector</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        mask: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(lhs.typeOfWip(self).isVector(self.builder));
        <a href="std.debug.html#std.debug.assert">assert</a>(lhs.typeOfWip(self) == rhs.typeOfWip(self));
        <a href="std.debug.html#std.debug.assert">assert</a>(mask.typeOfWip(self).scalarType(self.builder).isInteger(self.builder));
        _ = <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ShuffleVector.html">ShuffleVector</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = .shufflevector,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ShuffleVector.html">ShuffleVector</a>{
                .lhs = lhs,
                .rhs = rhs,
                .mask = mask,
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splatVector</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        elem: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">const</span> scalar_ty = <span class="tok-kw">try</span> ty.changeLength(<span class="tok-number">1</span>, self.builder);
        <span class="tok-kw">const</span> mask_ty = <span class="tok-kw">try</span> ty.changeScalar(.<span class="tok-type">i32</span>, self.builder);
        <span class="tok-kw">const</span> poison = <span class="tok-kw">try</span> self.builder.poisonValue(scalar_ty);
        <span class="tok-kw">const</span> mask = <span class="tok-kw">try</span> self.builder.splatValue(mask_ty, .@&quot;0&quot;);
        <span class="tok-kw">const</span> scalar = <span class="tok-kw">try</span> self.insertElement(poison, elem, .@&quot;0&quot;, name);
        <span class="tok-kw">return</span> self.shuffleVector(scalar, poison, mask, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">extractValue</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        indices: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(indices.len &gt; <span class="tok-number">0</span>);
        _ = val.typeOfWip(self).childTypeAt(indices, self.builder);
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractValue.html">ExtractValue</a>, indices.len);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = .extractvalue,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractValue.html">ExtractValue</a>{
                .val = val,
                .indices_len = <span class="tok-builtin">@intCast</span>(indices.len),
            }),
        });
        self.extra.appendSliceAssumeCapacity(indices);
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertValue</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        elem: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        indices: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(indices.len &gt; <span class="tok-number">0</span>);
        <a href="std.debug.html#std.debug.assert">assert</a>(val.typeOfWip(self).childTypeAt(indices, self.builder) == elem.typeOfWip(self));
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertValue.html">InsertValue</a>, indices.len);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = .insertvalue,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertValue.html">InsertValue</a>{
                .val = val,
                .elem = elem,
                .indices_len = <span class="tok-builtin">@intCast</span>(indices.len),
            }),
        });
        self.extra.appendSliceAssumeCapacity(indices);
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">buildAggregate</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        elems: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(ty.aggregateLen(self.builder) == elems.len);
        <span class="tok-kw">var</span> cur = <span class="tok-kw">try</span> self.builder.poisonValue(ty);
        <span class="tok-kw">for</span> (elems, <span class="tok-number">0</span>..) |elem, index|
            cur = <span class="tok-kw">try</span> self.insertValue(cur, elem, &amp;[_]<span class="tok-type">u32</span>{<span class="tok-builtin">@intCast</span>(index)}, name);
        <span class="tok-kw">return</span> cur;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alloca</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.Kind.html">Kind</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        len: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
        addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(len == .none <span class="tok-kw">or</span> len.typeOfWip(self).isInteger(self.builder));
        _ = <span class="tok-kw">try</span> self.builder.ptrType(addr_space);
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = <span class="tok-kw">switch</span> (kind) {
                .normal =&gt; .alloca,
                .inalloca =&gt; .@&quot;alloca inalloca&quot;,
            },
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>{
                .<span class="tok-type">type</span> = ty,
                .len = <span class="tok-kw">switch</span> (len) {
                    .none =&gt; .@&quot;1&quot;,
                    <span class="tok-kw">else</span> =&gt; len,
                },
                .info = .{ .alignment = alignment, .addr_space = addr_space },
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">load</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">return</span> self.loadAtomic(access_kind, ty, ptr, .system, .none, alignment, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">loadAtomic</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>,
        ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
        alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(ptr.typeOfWip(self).isPointer(self.builder));
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Load.html">Load</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = <span class="tok-kw">switch</span> (ordering) {
                .none =&gt; .load,
                <span class="tok-kw">else</span> =&gt; .@&quot;load atomic&quot;,
            },
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Load.html">Load</a>{
                .info = .{
                    .access_kind = access_kind,
                    .sync_scope = <span class="tok-kw">switch</span> (ordering) {
                        .none =&gt; .system,
                        <span class="tok-kw">else</span> =&gt; sync_scope,
                    },
                    .success_ordering = ordering,
                    .alignment = alignment,
                },
                .<span class="tok-type">type</span> = ty,
                .ptr = ptr,
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">store</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <span class="tok-kw">return</span> self.storeAtomic(kind, val, ptr, .system, .none, alignment);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">storeAtomic</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>,
        ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
        alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(ptr.typeOfWip(self).isPointer(self.builder));
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Store.html">Store</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{
            .tag = <span class="tok-kw">switch</span> (ordering) {
                .none =&gt; .store,
                <span class="tok-kw">else</span> =&gt; .@&quot;store atomic&quot;,
            },
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Store.html">Store</a>{
                .info = .{
                    .access_kind = access_kind,
                    .sync_scope = <span class="tok-kw">switch</span> (ordering) {
                        .none =&gt; .system,
                        <span class="tok-kw">else</span> =&gt; sync_scope,
                    },
                    .success_ordering = ordering,
                    .alignment = alignment,
                },
                .val = val,
                .ptr = ptr,
            }),
        });
        <span class="tok-kw">return</span> instruction;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fence</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>,
        ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(ordering != .none);
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{
            .tag = .fence,
            .data = <span class="tok-builtin">@bitCast</span>(<a href="std.zig.llvm.Builder.MemoryAccessInfo.html">MemoryAccessInfo</a>{
                .sync_scope = sync_scope,
                .success_ordering = ordering,
            }),
        });
        <span class="tok-kw">return</span> instruction;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cmpxchg</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.Kind.html">Kind</a>,
        access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
        ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        cmp: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        new: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>,
        success_ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
        failure_ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
        alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(ptr.typeOfWip(self).isPointer(self.builder));
        <span class="tok-kw">const</span> ty = cmp.typeOfWip(self);
        <a href="std.debug.html#std.debug.assert">assert</a>(ty == new.typeOfWip(self));
        <a href="std.debug.html#std.debug.assert">assert</a>(success_ordering != .none);
        <a href="std.debug.html#std.debug.assert">assert</a>(failure_ordering != .none);

        _ = <span class="tok-kw">try</span> self.builder.structType(.normal, &amp;.{ ty, .<span class="tok-type">i1</span> });
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = <span class="tok-kw">switch</span> (kind) {
                .strong =&gt; .cmpxchg,
                .weak =&gt; .@&quot;cmpxchg weak&quot;,
            },
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>{
                .info = .{
                    .access_kind = access_kind,
                    .sync_scope = sync_scope,
                    .success_ordering = success_ordering,
                    .failure_ordering = failure_ordering,
                    .alignment = alignment,
                },
                .ptr = ptr,
                .cmp = cmp,
                .new = new,
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">atomicrmw</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
        operation: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.Operation.html">Operation</a>,
        ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>,
        ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
        alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(ptr.typeOfWip(self).isPointer(self.builder));
        <a href="std.debug.html#std.debug.assert">assert</a>(ordering != .none);

        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = .atomicrmw,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>{
                .info = .{
                    .access_kind = access_kind,
                    .atomic_rmw_operation = operation,
                    .sync_scope = sync_scope,
                    .success_ordering = ordering,
                    .alignment = alignment,
                },
                .ptr = ptr,
                .val = val,
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gep</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.Kind.html">Kind</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        base: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        indices: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">const</span> base_ty = base.typeOfWip(self);
        <span class="tok-kw">const</span> base_is_vector = base_ty.isVector(self.builder);

        <span class="tok-kw">const</span> VectorInfo = <span class="tok-kw">struct</span> {
            kind: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>.<a href="std.zig.llvm.Builder.Type.Vector.Kind.html">Kind</a>,
            len: <span class="tok-type">u32</span>,

            <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(vector_ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-builtin">@This</span>() {
                <span class="tok-kw">return</span> .{ .kind = vector_ty.vectorKind(builder), .len = vector_ty.vectorLen(builder) };
            }
        };
        <span class="tok-kw">var</span> vector_info: ?VectorInfo =
            <span class="tok-kw">if</span> (base_is_vector) VectorInfo.init(base_ty, self.builder) <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        <span class="tok-kw">for</span> (indices) |index| {
            <span class="tok-kw">const</span> index_ty = index.typeOfWip(self);
            <span class="tok-kw">switch</span> (index_ty.tag(self.builder)) {
                .integer =&gt; {},
                .vector, .scalable_vector =&gt; {
                    <span class="tok-kw">const</span> index_info = VectorInfo.init(index_ty, self.builder);
                    <span class="tok-kw">if</span> (vector_info) |info|
                        <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(info, index_info))
                    <span class="tok-kw">else</span>
                        vector_info = index_info;
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            }
        }
        <span class="tok-kw">if</span> (!base_is_vector) <span class="tok-kw">if</span> (vector_info) |info| <span class="tok-kw">switch</span> (info.kind) {
            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |vector_kind| _ = <span class="tok-kw">try</span> self.builder.vectorType(
                vector_kind,
                info.len,
                base_ty,
            ),
        };

        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>, indices.len);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = <span class="tok-kw">switch</span> (kind) {
                .normal =&gt; .getelementptr,
                .inbounds =&gt; .@&quot;getelementptr inbounds&quot;,
            },
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>{
                .<span class="tok-type">type</span> = ty,
                .base = base,
                .indices_len = <span class="tok-builtin">@intCast</span>(indices.len),
            }),
        });
        self.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(indices));
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gepStruct</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        base: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        index: <span class="tok-type">usize</span>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(ty.isStruct(self.builder));
        <span class="tok-kw">return</span> self.gep(.inbounds, ty, base, &amp;.{ .@&quot;0&quot;, <span class="tok-kw">try</span> self.builder.intValue(.<span class="tok-type">i32</span>, index) }, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">conv</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        signedness: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>.<a href="std.zig.llvm.Builder.Constant.Cast.Signedness.html">Signedness</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">const</span> val_ty = val.typeOfWip(self);
        <span class="tok-kw">if</span> (val_ty == ty) <span class="tok-kw">return</span> val;
        <span class="tok-kw">return</span> self.cast(self.builder.convTag(signedness, val_ty, ty), val, ty, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cast</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">switch</span> (tag) {
            .addrspacecast,
            .bitcast,
            .fpext,
            .fptosi,
            .fptoui,
            .fptrunc,
            .inttoptr,
            .ptrtoint,
            .sext,
            .sitofp,
            .trunc,
            .uitofp,
            .zext,
            =&gt; {},
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
        <span class="tok-kw">if</span> (val.typeOfWip(self) == ty) <span class="tok-kw">return</span> val;
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = tag,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>{
                .val = val,
                .<span class="tok-type">type</span> = ty,
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">icmp</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        cond: <a href="std.zig.llvm.Builder.IntegerCondition.html">IntegerCondition</a>,
        lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">return</span> self.cmpTag(<span class="tok-kw">switch</span> (cond) {
            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| <span class="tok-builtin">@field</span>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>, <span class="tok-str">&quot;icmp &quot;</span> ++ <span class="tok-builtin">@tagName</span>(tag)),
        }, lhs, rhs, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fcmp</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        fast: <a href="std.zig.llvm.Builder.FastMathKind.html">FastMathKind</a>,
        cond: <a href="std.zig.llvm.Builder.FloatCondition.html">FloatCondition</a>,
        lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">return</span> self.cmpTag(<span class="tok-kw">switch</span> (fast) {
            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |fast_tag| <span class="tok-kw">switch</span> (cond) {
                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |cond_tag| <span class="tok-builtin">@field</span>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>, <span class="tok-str">&quot;fcmp &quot;</span> ++ <span class="tok-kw">switch</span> (fast_tag) {
                    .normal =&gt; <span class="tok-str">&quot;&quot;</span>,
                    .fast =&gt; <span class="tok-str">&quot;fast &quot;</span>,
                } ++ <span class="tok-builtin">@tagName</span>(cond_tag)),
            },
        }, lhs, rhs, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> WipPhi = <span class="tok-kw">struct</span> {
        block: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
        instruction: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toValue</span>(self: <a href="std.zig.llvm.Builder.WipFunction.WipPhi.html">WipPhi</a>) <a href="std.zig.llvm.Builder.Value.html">Value</a> {
            <span class="tok-kw">return</span> self.instruction.toValue();
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finish</span>(
            self: <a href="std.zig.llvm.Builder.WipFunction.WipPhi.html">WipPhi</a>,
            vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            blocks: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
            wip: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        ) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> incoming_len = self.block.ptrConst(wip).incoming;
            <a href="std.debug.html#std.debug.assert">assert</a>(vals.len == incoming_len <span class="tok-kw">and</span> blocks.len == incoming_len);
            <span class="tok-kw">const</span> instruction = wip.instructions.get(<span class="tok-builtin">@intFromEnum</span>(self.instruction));
            <span class="tok-kw">var</span> extra = wip.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Phi.html">Phi</a>, instruction.data);
            <span class="tok-kw">for</span> (vals) |val| <a href="std.debug.html#std.debug.assert">assert</a>(val.typeOfWip(wip) == extra.data.<span class="tok-type">type</span>);
            <span class="tok-builtin">@memcpy</span>(extra.trail.nextMut(incoming_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, wip), vals);
            <span class="tok-builtin">@memcpy</span>(extra.trail.nextMut(incoming_len, <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, wip), blocks);
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">phi</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.WipPhi.html">WipPhi</a> {
        <span class="tok-kw">return</span> self.phiTag(.phi, ty, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">phiFast</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.WipPhi.html">WipPhi</a> {
        <span class="tok-kw">return</span> self.phiTag(.@&quot;phi fast&quot;, ty, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">select</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        fast: <a href="std.zig.llvm.Builder.FastMathKind.html">FastMathKind</a>,
        cond: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">return</span> self.selectTag(<span class="tok-kw">switch</span> (fast) {
            .normal =&gt; .select,
            .fast =&gt; .@&quot;select fast&quot;,
        }, cond, lhs, rhs, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">call</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.Kind.html">Kind</a>,
        call_conv: <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a>,
        function_attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        callee: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        args: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">return</span> self.callInner(kind, call_conv, function_attributes, ty, callee, args, name, <span class="tok-null">false</span>);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">callInner</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.Kind.html">Kind</a>,
        call_conv: <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a>,
        function_attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        callee: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        args: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        has_op_bundle_cold: <span class="tok-type">bool</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">const</span> ret_ty = ty.functionReturn(self.builder);
        <a href="std.debug.html#std.debug.assert">assert</a>(ty.isFunction(self.builder));
        <a href="std.debug.html#std.debug.assert">assert</a>(callee.typeOfWip(self).isPointer(self.builder));
        <span class="tok-kw">const</span> params = ty.functionParameters(self.builder);
        <span class="tok-kw">for</span> (params, args[<span class="tok-number">0</span>..params.len]) |param, arg_val| <a href="std.debug.html#std.debug.assert">assert</a>(param == arg_val.typeOfWip(self));

        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>, args.len);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(<span class="tok-kw">switch</span> (ret_ty) {
            .<span class="tok-type">void</span> =&gt; <span class="tok-null">null</span>,
            <span class="tok-kw">else</span> =&gt; name,
        }, .{
            .tag = <span class="tok-kw">switch</span> (kind) {
                .normal =&gt; .call,
                .fast =&gt; .@&quot;call fast&quot;,
                .musttail =&gt; .@&quot;musttail call&quot;,
                .musttail_fast =&gt; .@&quot;musttail call fast&quot;,
                .notail =&gt; .@&quot;notail call&quot;,
                .notail_fast =&gt; .@&quot;notail call fast&quot;,
                .tail =&gt; .@&quot;tail call&quot;,
                .tail_fast =&gt; .@&quot;tail call fast&quot;,
            },
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>{
                .info = .{
                    .call_conv = call_conv,
                    .has_op_bundle_cold = has_op_bundle_cold,
                },
                .attributes = function_attributes,
                .ty = ty,
                .callee = callee,
                .args_len = <span class="tok-builtin">@intCast</span>(args.len),
            }),
        });
        self.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(args));
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callAsm</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        function_attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        kind: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.Info.html">Info</a>,
        assembly: <a href="std.zig.llvm.Builder.String.html">String</a>,
        constraints: <a href="std.zig.llvm.Builder.String.html">String</a>,
        args: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">const</span> callee = <span class="tok-kw">try</span> self.builder.asmValue(ty, kind, assembly, constraints);
        <span class="tok-kw">return</span> self.call(.normal, <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a>.<a href="std.zig.llvm.Builder.CallConv.html#std.zig.llvm.Builder.CallConv.default">default</a>, function_attributes, ty, callee, args, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callIntrinsic</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        fast: <a href="std.zig.llvm.Builder.FastMathKind.html">FastMathKind</a>,
        function_attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
        id: <a href="std.zig.llvm.Builder.Intrinsic.html">Intrinsic</a>,
        overload: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        args: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">const</span> intrinsic = <span class="tok-kw">try</span> self.builder.getIntrinsic(id, overload);
        <span class="tok-kw">return</span> self.call(
            fast.toCallKind(),
            <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a>.<a href="std.zig.llvm.Builder.CallConv.html#std.zig.llvm.Builder.CallConv.default">default</a>,
            function_attributes,
            intrinsic.typeOf(self.builder),
            intrinsic.toValue(self.builder),
            args,
            name,
        );
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callIntrinsicAssumeCold</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">const</span> intrinsic = <span class="tok-kw">try</span> self.builder.getIntrinsic(.assume, &amp;.{});
        <span class="tok-kw">return</span> self.callInner(
            .normal,
            <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a>.<a href="std.zig.llvm.Builder.CallConv.html#std.zig.llvm.Builder.CallConv.default">default</a>,
            .none,
            intrinsic.typeOf(self.builder),
            intrinsic.toValue(self.builder),
            &amp;.{<span class="tok-kw">try</span> self.builder.intValue(.<span class="tok-type">i1</span>, <span class="tok-number">1</span>)},
            <span class="tok-str">&quot;&quot;</span>,
            <span class="tok-null">true</span>,
        );
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callMemCpy</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        dst: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        dst_align: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
        src: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        src_align: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
        len: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
        @&quot;inline&quot;: <span class="tok-type">bool</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <span class="tok-kw">var</span> dst_attrs = [_]<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>{<span class="tok-kw">try</span> self.builder.attr(.{ .@&quot;align&quot; = dst_align })};
        <span class="tok-kw">var</span> src_attrs = [_]<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>{<span class="tok-kw">try</span> self.builder.attr(.{ .@&quot;align&quot; = src_align })};
        <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> self.callIntrinsic(
            .normal,
            <span class="tok-kw">try</span> self.builder.fnAttrs(&amp;.{
                .none,
                .none,
                <span class="tok-kw">try</span> self.builder.attrs(&amp;dst_attrs),
                <span class="tok-kw">try</span> self.builder.attrs(&amp;src_attrs),
            }),
            <span class="tok-kw">if</span> (@&quot;inline&quot;) .@&quot;memcpy.inline&quot; <span class="tok-kw">else</span> .memcpy,
            &amp;.{ dst.typeOfWip(self), src.typeOfWip(self), len.typeOfWip(self) },
            &amp;.{ dst, src, len, <span class="tok-kw">switch</span> (kind) {
                .normal =&gt; <a href="std.zig.llvm.Builder.Value.html">Value</a>.<span class="tok-null">false</span>,
                .@&quot;volatile&quot; =&gt; <a href="std.zig.llvm.Builder.Value.html">Value</a>.<span class="tok-null">true</span>,
            } },
            <span class="tok-null">undefined</span>,
        );
        <span class="tok-kw">return</span> value.unwrap().instruction;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callMemSet</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        dst: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        dst_align: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        len: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
        @&quot;inline&quot;: <span class="tok-type">bool</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <span class="tok-kw">var</span> dst_attrs = [_]<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>{<span class="tok-kw">try</span> self.builder.attr(.{ .@&quot;align&quot; = dst_align })};
        <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> self.callIntrinsic(
            .normal,
            <span class="tok-kw">try</span> self.builder.fnAttrs(&amp;.{ .none, .none, <span class="tok-kw">try</span> self.builder.attrs(&amp;dst_attrs) }),
            <span class="tok-kw">if</span> (@&quot;inline&quot;) .@&quot;memset.inline&quot; <span class="tok-kw">else</span> .memset,
            &amp;.{ dst.typeOfWip(self), len.typeOfWip(self) },
            &amp;.{ dst, val, len, <span class="tok-kw">switch</span> (kind) {
                .normal =&gt; <a href="std.zig.llvm.Builder.Value.html">Value</a>.<span class="tok-null">false</span>,
                .@&quot;volatile&quot; =&gt; <a href="std.zig.llvm.Builder.Value.html">Value</a>.<span class="tok-null">true</span>,
            } },
            <span class="tok-null">undefined</span>,
        );
        <span class="tok-kw">return</span> value.unwrap().instruction;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">vaArg</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, list: <a href="std.zig.llvm.Builder.Value.html">Value</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.VaArg.html">VaArg</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = .va_arg,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.VaArg.html">VaArg</a>{
                .list = list,
                .<span class="tok-type">type</span> = ty,
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugValue</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, value: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
        <span class="tok-kw">if</span> (self.strip) <span class="tok-kw">return</span> .none;
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (value.unwrap()) {
            .instruction =&gt; |instr_index| blk: {
                <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.debug_values.getOrPut(self.builder.gpa, instr_index);

                <span class="tok-kw">const</span> metadata: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> = <span class="tok-builtin">@enumFromInt</span>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_local_metadata">first_local_metadata</a> + gop.index);
                <span class="tok-kw">if</span> (!gop.found_existing) gop.key_ptr.* = instr_index;

                <span class="tok-kw">break</span> :blk metadata;
            },
            .constant =&gt; |constant| <span class="tok-kw">try</span> self.builder.metadataConstant(constant),
            .metadata =&gt; |metadata| metadata,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finish</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> gpa = self.builder.gpa;
        <span class="tok-kw">const</span> function = self.function.ptr(self.builder);
        <span class="tok-kw">const</span> params_len = self.function.typeOf(self.builder).functionParameters(self.builder).len;
        <span class="tok-kw">const</span> final_instructions_len = self.blocks.items.len + self.instructions.len;

        <span class="tok-kw">const</span> blocks = <span class="tok-kw">try</span> gpa.alloc(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>, self.blocks.items.len);
        <span class="tok-kw">errdefer</span> gpa.free(blocks);

        <span class="tok-kw">const</span> instructions: <span class="tok-kw">struct</span> {
            items: []<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>,

            <span class="tok-kw">fn</span> <span class="tok-fn">map</span>(instructions: <span class="tok-builtin">@This</span>(), val: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <a href="std.zig.llvm.Builder.Value.html">Value</a> {
                <span class="tok-kw">if</span> (val == .none) <span class="tok-kw">return</span> .none;
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (val.unwrap()) {
                    .instruction =&gt; |instruction| instructions.items[
                        <span class="tok-builtin">@intFromEnum</span>(instruction)
                    ].toValue(),
                    .constant =&gt; |constant| constant.toValue(),
                    .metadata =&gt; |metadata| metadata.toValue(),
                };
            }
        } = .{ .items = <span class="tok-kw">try</span> gpa.alloc(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, self.instructions.len) };
        <span class="tok-kw">defer</span> gpa.free(instructions.items);

        <span class="tok-kw">const</span> names = <span class="tok-kw">try</span> gpa.alloc(<a href="std.zig.llvm.Builder.String.html">String</a>, final_instructions_len);
        <span class="tok-kw">errdefer</span> gpa.free(names);

        <span class="tok-kw">const</span> value_indices = <span class="tok-kw">try</span> gpa.alloc(<span class="tok-type">u32</span>, final_instructions_len);
        <span class="tok-kw">errdefer</span> gpa.free(value_indices);

        <span class="tok-kw">var</span> debug_locations: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMapUnmanaged">AutoHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, <a href="std.zig.llvm.Builder.DebugLocation.html">DebugLocation</a>) = .empty;
        <span class="tok-kw">errdefer</span> debug_locations.deinit(gpa);
        <span class="tok-kw">try</span> debug_locations.ensureUnusedCapacity(gpa, <span class="tok-builtin">@intCast</span>(self.debug_locations.count()));

        <span class="tok-kw">const</span> debug_values = <span class="tok-kw">try</span> gpa.alloc(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, self.debug_values.count());
        <span class="tok-kw">errdefer</span> gpa.free(debug_values);

        <span class="tok-kw">var</span> wip_extra: <span class="tok-kw">struct</span> {
            index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html#std.zig.llvm.Builder.Function.Instruction.ExtraIndex">ExtraIndex</a> = <span class="tok-number">0</span>,
            items: []<span class="tok-type">u32</span>,

            <span class="tok-kw">fn</span> <span class="tok-fn">addExtra</span>(wip_extra: *<span class="tok-builtin">@This</span>(), extra: <span class="tok-kw">anytype</span>) <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html#std.zig.llvm.Builder.Function.Instruction.ExtraIndex">ExtraIndex</a> {
                <span class="tok-kw">const</span> result = wip_extra.index;
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(extra)).@&quot;struct&quot;.fields) |field| {
                    <span class="tok-kw">const</span> value = <span class="tok-builtin">@field</span>(extra, field.name);
                    wip_extra.items[wip_extra.index] = <span class="tok-kw">switch</span> (field.<span class="tok-type">type</span>) {
                        <span class="tok-type">u32</span> =&gt; value,
                        <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
                        <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
                        <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
                        <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
                        <a href="std.zig.llvm.Builder.Type.html">Type</a>,
                        <a href="std.zig.llvm.Builder.Value.html">Value</a>,
                        <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.Weights.html">Weights</a>,
                        =&gt; <span class="tok-builtin">@intFromEnum</span>(value),
                        <a href="std.zig.llvm.Builder.MemoryAccessInfo.html">MemoryAccessInfo</a>,
                        <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.Info.html">Info</a>,
                        <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.Info.html">Info</a>,
                        =&gt; <span class="tok-builtin">@bitCast</span>(value),
                        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type: &quot;</span> ++ field.name ++ <span class="tok-str">&quot;: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(field.<span class="tok-type">type</span>)),
                    };
                    wip_extra.index += <span class="tok-number">1</span>;
                }
                <span class="tok-kw">return</span> result;
            }

            <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(wip_extra: *<span class="tok-builtin">@This</span>(), slice: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
                <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(slice)).pointer.child == <a href="std.zig.llvm.Builder.Value.html">Value</a>)
                    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;use appendMappedValues&quot;</span>);
                <span class="tok-kw">const</span> data: []<span class="tok-kw">const</span> <span class="tok-type">u32</span> = <span class="tok-builtin">@ptrCast</span>(slice);
                <span class="tok-builtin">@memcpy</span>(wip_extra.items[wip_extra.index..][<span class="tok-number">0</span>..data.len], data);
                wip_extra.index += <span class="tok-builtin">@intCast</span>(data.len);
            }

            <span class="tok-kw">fn</span> <span class="tok-fn">appendMappedValues</span>(wip_extra: *<span class="tok-builtin">@This</span>(), vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
                <span class="tok-kw">for</span> (wip_extra.items[wip_extra.index..][<span class="tok-number">0</span>..vals.len], vals) |*extra, val|
                    extra.* = <span class="tok-builtin">@intFromEnum</span>(ctx.map(val));
                wip_extra.index += <span class="tok-builtin">@intCast</span>(vals.len);
            }

            <span class="tok-kw">fn</span> <span class="tok-fn">finish</span>(wip_extra: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) []<span class="tok-kw">const</span> <span class="tok-type">u32</span> {
                <a href="std.debug.html#std.debug.assert">assert</a>(wip_extra.index == wip_extra.items.len);
                <span class="tok-kw">return</span> wip_extra.items;
            }
        } = .{ .items = <span class="tok-kw">try</span> gpa.alloc(<span class="tok-type">u32</span>, self.extra.items.len) };
        <span class="tok-kw">errdefer</span> gpa.free(wip_extra.items);

        gpa.free(function.blocks);
        function.blocks = &amp;.{};
        gpa.free(function.names[<span class="tok-number">0</span>..function.instructions.len]);
        function.debug_locations.deinit(gpa);
        function.debug_locations = .{};
        gpa.free(function.debug_values);
        function.debug_values = &amp;.{};
        gpa.free(function.extra);
        function.extra = &amp;.{};

        function.instructions.shrinkRetainingCapacity(<span class="tok-number">0</span>);
        <span class="tok-kw">try</span> function.instructions.setCapacity(gpa, final_instructions_len);
        <span class="tok-kw">errdefer</span> function.instructions.shrinkRetainingCapacity(<span class="tok-number">0</span>);

        {
            <span class="tok-kw">var</span> final_instruction_index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>);
            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..params_len) |param_index| {
                instructions.items[param_index] = final_instruction_index;
                final_instruction_index = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(final_instruction_index) + <span class="tok-number">1</span>);
            }
            <span class="tok-kw">for</span> (blocks, self.blocks.items) |*final_block, current_block| {
                <a href="std.debug.html#std.debug.assert">assert</a>(current_block.incoming == current_block.branches);
                final_block.instruction = final_instruction_index;
                final_instruction_index = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(final_instruction_index) + <span class="tok-number">1</span>);
                <span class="tok-kw">for</span> (current_block.instructions.items) |instruction| {
                    instructions.items[<span class="tok-builtin">@intFromEnum</span>(instruction)] = final_instruction_index;
                    final_instruction_index = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(final_instruction_index) + <span class="tok-number">1</span>);
                }
            }
        }

        <span class="tok-kw">var</span> wip_name: <span class="tok-kw">struct</span> {
            next_name: <a href="std.zig.llvm.Builder.String.html">String</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>),
            next_unique_name: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<a href="std.zig.llvm.Builder.String.html">String</a>, <a href="std.zig.llvm.Builder.String.html">String</a>),
            builder: *<a href="std.zig.llvm.Builder.html">Builder</a>,

            <span class="tok-kw">fn</span> <span class="tok-fn">map</span>(wip_name: *<span class="tok-builtin">@This</span>(), name: <a href="std.zig.llvm.Builder.String.html">String</a>, sep: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.String.html">String</a> {
                <span class="tok-kw">switch</span> (name) {
                    .none =&gt; <span class="tok-kw">return</span> .none,
                    .empty =&gt; {
                        <a href="std.debug.html#std.debug.assert">assert</a>(wip_name.next_name != .none);
                        <span class="tok-kw">defer</span> wip_name.next_name = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(wip_name.next_name) + <span class="tok-number">1</span>);
                        <span class="tok-kw">return</span> wip_name.next_name;
                    },
                    _ =&gt; {
                        <a href="std.debug.html#std.debug.assert">assert</a>(!name.isAnon());
                        <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> wip_name.next_unique_name.getOrPut(name);
                        <span class="tok-kw">if</span> (!gop.found_existing) {
                            gop.value_ptr.* = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>);
                            <span class="tok-kw">return</span> name;
                        }

                        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                            gop.value_ptr.* = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(gop.value_ptr.*) + <span class="tok-number">1</span>);
                            <span class="tok-kw">const</span> unique_name = <span class="tok-kw">try</span> wip_name.builder.fmt(<span class="tok-str">&quot;{r}{s}{r}&quot;</span>, .{
                                name.fmt(wip_name.builder),
                                sep,
                                gop.value_ptr.fmt(wip_name.builder),
                            });
                            <span class="tok-kw">const</span> unique_gop = <span class="tok-kw">try</span> wip_name.next_unique_name.getOrPut(unique_name);
                            <span class="tok-kw">if</span> (!unique_gop.found_existing) {
                                unique_gop.value_ptr.* = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>);
                                <span class="tok-kw">return</span> unique_name;
                            }
                        }
                    },
                }
            }
        } = .{
            .next_unique_name = <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<a href="std.zig.llvm.Builder.String.html">String</a>, <a href="std.zig.llvm.Builder.String.html">String</a>).init(gpa),
            .builder = self.builder,
        };
        <span class="tok-kw">defer</span> wip_name.next_unique_name.deinit();

        <span class="tok-kw">var</span> value_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..params_len) |param_index| {
            <span class="tok-kw">const</span> old_argument_index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(param_index);
            <span class="tok-kw">const</span> new_argument_index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(function.instructions.len);
            <span class="tok-kw">const</span> argument = self.instructions.get(<span class="tok-builtin">@intFromEnum</span>(old_argument_index));
            <a href="std.debug.html#std.debug.assert">assert</a>(argument.tag == .arg);
            <a href="std.debug.html#std.debug.assert">assert</a>(argument.data == param_index);
            value_indices[function.instructions.len] = value_index;
            value_index += <span class="tok-number">1</span>;
            function.instructions.appendAssumeCapacity(argument);
            names[<span class="tok-builtin">@intFromEnum</span>(new_argument_index)] = <span class="tok-kw">try</span> wip_name.map(
                <span class="tok-kw">if</span> (self.strip) .empty <span class="tok-kw">else</span> self.names.items[<span class="tok-builtin">@intFromEnum</span>(old_argument_index)],
                <span class="tok-str">&quot;.&quot;</span>,
            );
            <span class="tok-kw">if</span> (self.debug_locations.get(old_argument_index)) |location| {
                debug_locations.putAssumeCapacity(new_argument_index, location);
            }
            <span class="tok-kw">if</span> (self.debug_values.getIndex(old_argument_index)) |index| {
                debug_values[index] = new_argument_index;
            }
        }
        <span class="tok-kw">for</span> (self.blocks.items) |current_block| {
            <span class="tok-kw">const</span> new_block_index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(function.instructions.len);
            value_indices[function.instructions.len] = value_index;
            function.instructions.appendAssumeCapacity(.{
                .tag = .block,
                .data = current_block.incoming,
            });
            names[<span class="tok-builtin">@intFromEnum</span>(new_block_index)] = <span class="tok-kw">try</span> wip_name.map(current_block.name, <span class="tok-str">&quot;&quot;</span>);
            <span class="tok-kw">for</span> (current_block.instructions.items) |old_instruction_index| {
                <span class="tok-kw">const</span> new_instruction_index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(function.instructions.len);
                <span class="tok-kw">var</span> instruction = self.instructions.get(<span class="tok-builtin">@intFromEnum</span>(old_instruction_index));
                <span class="tok-kw">switch</span> (instruction.tag) {
                    .add,
                    .@&quot;add nsw&quot;,
                    .@&quot;add nuw&quot;,
                    .@&quot;add nuw nsw&quot;,
                    .@&quot;and&quot;,
                    .ashr,
                    .@&quot;ashr exact&quot;,
                    .fadd,
                    .@&quot;fadd fast&quot;,
                    .@&quot;fcmp false&quot;,
                    .@&quot;fcmp fast false&quot;,
                    .@&quot;fcmp fast oeq&quot;,
                    .@&quot;fcmp fast oge&quot;,
                    .@&quot;fcmp fast ogt&quot;,
                    .@&quot;fcmp fast ole&quot;,
                    .@&quot;fcmp fast olt&quot;,
                    .@&quot;fcmp fast one&quot;,
                    .@&quot;fcmp fast ord&quot;,
                    .@&quot;fcmp fast true&quot;,
                    .@&quot;fcmp fast ueq&quot;,
                    .@&quot;fcmp fast uge&quot;,
                    .@&quot;fcmp fast ugt&quot;,
                    .@&quot;fcmp fast ule&quot;,
                    .@&quot;fcmp fast ult&quot;,
                    .@&quot;fcmp fast une&quot;,
                    .@&quot;fcmp fast uno&quot;,
                    .@&quot;fcmp oeq&quot;,
                    .@&quot;fcmp oge&quot;,
                    .@&quot;fcmp ogt&quot;,
                    .@&quot;fcmp ole&quot;,
                    .@&quot;fcmp olt&quot;,
                    .@&quot;fcmp one&quot;,
                    .@&quot;fcmp ord&quot;,
                    .@&quot;fcmp true&quot;,
                    .@&quot;fcmp ueq&quot;,
                    .@&quot;fcmp uge&quot;,
                    .@&quot;fcmp ugt&quot;,
                    .@&quot;fcmp ule&quot;,
                    .@&quot;fcmp ult&quot;,
                    .@&quot;fcmp une&quot;,
                    .@&quot;fcmp uno&quot;,
                    .fdiv,
                    .@&quot;fdiv fast&quot;,
                    .fmul,
                    .@&quot;fmul fast&quot;,
                    .frem,
                    .@&quot;frem fast&quot;,
                    .fsub,
                    .@&quot;fsub fast&quot;,
                    .@&quot;icmp eq&quot;,
                    .@&quot;icmp ne&quot;,
                    .@&quot;icmp sge&quot;,
                    .@&quot;icmp sgt&quot;,
                    .@&quot;icmp sle&quot;,
                    .@&quot;icmp slt&quot;,
                    .@&quot;icmp uge&quot;,
                    .@&quot;icmp ugt&quot;,
                    .@&quot;icmp ule&quot;,
                    .@&quot;icmp ult&quot;,
                    .lshr,
                    .@&quot;lshr exact&quot;,
                    .mul,
                    .@&quot;mul nsw&quot;,
                    .@&quot;mul nuw&quot;,
                    .@&quot;mul nuw nsw&quot;,
                    .@&quot;or&quot;,
                    .sdiv,
                    .@&quot;sdiv exact&quot;,
                    .shl,
                    .@&quot;shl nsw&quot;,
                    .@&quot;shl nuw&quot;,
                    .@&quot;shl nuw nsw&quot;,
                    .srem,
                    .sub,
                    .@&quot;sub nsw&quot;,
                    .@&quot;sub nuw&quot;,
                    .@&quot;sub nuw nsw&quot;,
                    .udiv,
                    .@&quot;udiv exact&quot;,
                    .urem,
                    .xor,
                    =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>{
                            .lhs = instructions.map(extra.lhs),
                            .rhs = instructions.map(extra.rhs),
                        });
                    },
                    .addrspacecast,
                    .bitcast,
                    .fpext,
                    .fptosi,
                    .fptoui,
                    .fptrunc,
                    .inttoptr,
                    .ptrtoint,
                    .sext,
                    .sitofp,
                    .trunc,
                    .uitofp,
                    .zext,
                    =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>{
                            .val = instructions.map(extra.val),
                            .<span class="tok-type">type</span> = extra.<span class="tok-type">type</span>,
                        });
                    },
                    .alloca,
                    .@&quot;alloca inalloca&quot;,
                    =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>{
                            .<span class="tok-type">type</span> = extra.<span class="tok-type">type</span>,
                            .len = instructions.map(extra.len),
                            .info = extra.info,
                        });
                    },
                    .arg,
                    .block,
                    =&gt; <span class="tok-kw">unreachable</span>,
                    .atomicrmw =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>{
                            .info = extra.info,
                            .ptr = instructions.map(extra.ptr),
                            .val = instructions.map(extra.val),
                        });
                    },
                    .br,
                    .fence,
                    .@&quot;ret void&quot;,
                    .@&quot;unreachable&quot;,
                    =&gt; {},
                    .br_cond =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>{
                            .cond = instructions.map(extra.cond),
                            .then = extra.then,
                            .@&quot;else&quot; = extra.@&quot;else&quot;,
                            .weights = extra.weights,
                        });
                    },
                    .call,
                    .@&quot;call fast&quot;,
                    .@&quot;musttail call&quot;,
                    .@&quot;musttail call fast&quot;,
                    .@&quot;notail call&quot;,
                    .@&quot;notail call fast&quot;,
                    .@&quot;tail call&quot;,
                    .@&quot;tail call fast&quot;,
                    =&gt; {
                        <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>, instruction.data);
                        <span class="tok-kw">const</span> args = extra.trail.next(extra.data.args_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, self);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>{
                            .info = extra.data.info,
                            .attributes = extra.data.attributes,
                            .ty = extra.data.ty,
                            .callee = instructions.map(extra.data.callee),
                            .args_len = extra.data.args_len,
                        });
                        wip_extra.appendMappedValues(args, instructions);
                    },
                    .cmpxchg,
                    .@&quot;cmpxchg weak&quot;,
                    =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>{
                            .info = extra.info,
                            .ptr = instructions.map(extra.ptr),
                            .cmp = instructions.map(extra.cmp),
                            .new = instructions.map(extra.new),
                        });
                    },
                    .extractelement =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractElement.html">ExtractElement</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractElement.html">ExtractElement</a>{
                            .val = instructions.map(extra.val),
                            .index = instructions.map(extra.index),
                        });
                    },
                    .extractvalue =&gt; {
                        <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractValue.html">ExtractValue</a>, instruction.data);
                        <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <span class="tok-type">u32</span>, self);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractValue.html">ExtractValue</a>{
                            .val = instructions.map(extra.data.val),
                            .indices_len = extra.data.indices_len,
                        });
                        wip_extra.appendSlice(indices);
                    },
                    .fneg,
                    .@&quot;fneg fast&quot;,
                    .ret,
                    =&gt; instruction.data = <span class="tok-builtin">@intFromEnum</span>(instructions.map(<span class="tok-builtin">@enumFromInt</span>(instruction.data))),
                    .getelementptr,
                    .@&quot;getelementptr inbounds&quot;,
                    =&gt; {
                        <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>, instruction.data);
                        <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, self);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>{
                            .<span class="tok-type">type</span> = extra.data.<span class="tok-type">type</span>,
                            .base = instructions.map(extra.data.base),
                            .indices_len = extra.data.indices_len,
                        });
                        wip_extra.appendMappedValues(indices, instructions);
                    },
                    .indirectbr =&gt; {
                        <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.IndirectBr.html">IndirectBr</a>, instruction.data);
                        <span class="tok-kw">const</span> targets = extra.trail.next(extra.data.targets_len, <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, self);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.IndirectBr.html">IndirectBr</a>{
                            .addr = instructions.map(extra.data.addr),
                            .targets_len = extra.data.targets_len,
                        });
                        wip_extra.appendSlice(targets);
                    },
                    .insertelement =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertElement.html">InsertElement</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertElement.html">InsertElement</a>{
                            .val = instructions.map(extra.val),
                            .elem = instructions.map(extra.elem),
                            .index = instructions.map(extra.index),
                        });
                    },
                    .insertvalue =&gt; {
                        <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertValue.html">InsertValue</a>, instruction.data);
                        <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <span class="tok-type">u32</span>, self);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertValue.html">InsertValue</a>{
                            .val = instructions.map(extra.data.val),
                            .elem = instructions.map(extra.data.elem),
                            .indices_len = extra.data.indices_len,
                        });
                        wip_extra.appendSlice(indices);
                    },
                    .load,
                    .@&quot;load atomic&quot;,
                    =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Load.html">Load</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Load.html">Load</a>{
                            .<span class="tok-type">type</span> = extra.<span class="tok-type">type</span>,
                            .ptr = instructions.map(extra.ptr),
                            .info = extra.info,
                        });
                    },
                    .phi,
                    .@&quot;phi fast&quot;,
                    =&gt; {
                        <span class="tok-kw">const</span> incoming_len = current_block.incoming;
                        <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Phi.html">Phi</a>, instruction.data);
                        <span class="tok-kw">const</span> incoming_vals = extra.trail.next(incoming_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, self);
                        <span class="tok-kw">const</span> incoming_blocks = extra.trail.next(incoming_len, <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, self);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Phi.html">Phi</a>{
                            .<span class="tok-type">type</span> = extra.data.<span class="tok-type">type</span>,
                        });
                        wip_extra.appendMappedValues(incoming_vals, instructions);
                        wip_extra.appendSlice(incoming_blocks);
                    },
                    .select,
                    .@&quot;select fast&quot;,
                    =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Select.html">Select</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Select.html">Select</a>{
                            .cond = instructions.map(extra.cond),
                            .lhs = instructions.map(extra.lhs),
                            .rhs = instructions.map(extra.rhs),
                        });
                    },
                    .shufflevector =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ShuffleVector.html">ShuffleVector</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ShuffleVector.html">ShuffleVector</a>{
                            .lhs = instructions.map(extra.lhs),
                            .rhs = instructions.map(extra.rhs),
                            .mask = instructions.map(extra.mask),
                        });
                    },
                    .store,
                    .@&quot;store atomic&quot;,
                    =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Store.html">Store</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Store.html">Store</a>{
                            .val = instructions.map(extra.val),
                            .ptr = instructions.map(extra.ptr),
                            .info = extra.info,
                        });
                    },
                    .@&quot;switch&quot; =&gt; {
                        <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>, instruction.data);
                        <span class="tok-kw">const</span> case_vals = extra.trail.next(extra.data.cases_len, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, self);
                        <span class="tok-kw">const</span> case_blocks = extra.trail.next(extra.data.cases_len, <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, self);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>{
                            .val = instructions.map(extra.data.val),
                            .default = extra.data.default,
                            .cases_len = extra.data.cases_len,
                            .weights = extra.data.weights,
                        });
                        wip_extra.appendSlice(case_vals);
                        wip_extra.appendSlice(case_blocks);
                    },
                    .va_arg =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.VaArg.html">VaArg</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.VaArg.html">VaArg</a>{
                            .list = instructions.map(extra.list),
                            .<span class="tok-type">type</span> = extra.<span class="tok-type">type</span>,
                        });
                    },
                }
                function.instructions.appendAssumeCapacity(instruction);
                names[<span class="tok-builtin">@intFromEnum</span>(new_instruction_index)] = <span class="tok-kw">try</span> wip_name.map(<span class="tok-kw">if</span> (self.strip)
                    <span class="tok-kw">if</span> (old_instruction_index.hasResultWip(self)) .empty <span class="tok-kw">else</span> .none
                <span class="tok-kw">else</span>
                    self.names.items[<span class="tok-builtin">@intFromEnum</span>(old_instruction_index)], <span class="tok-str">&quot;.&quot;</span>);

                <span class="tok-kw">if</span> (self.debug_locations.get(old_instruction_index)) |location| {
                    debug_locations.putAssumeCapacity(new_instruction_index, location);
                }

                <span class="tok-kw">if</span> (self.debug_values.getIndex(old_instruction_index)) |index| {
                    debug_values[index] = new_instruction_index;
                }

                value_indices[<span class="tok-builtin">@intFromEnum</span>(new_instruction_index)] = value_index;
                <span class="tok-kw">if</span> (old_instruction_index.hasResultWip(self)) value_index += <span class="tok-number">1</span>;
            }
        }

        <a href="std.debug.html#std.debug.assert">assert</a>(function.instructions.len == final_instructions_len);
        function.extra = wip_extra.finish();
        function.blocks = blocks;
        function.names = names.ptr;
        function.value_indices = value_indices.ptr;
        function.strip = self.strip;
        function.debug_locations = debug_locations;
        function.debug_values = debug_values;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <span class="tok-type">void</span> {
        self.extra.deinit(self.builder.gpa);
        self.debug_values.deinit(self.builder.gpa);
        self.debug_locations.deinit(self.builder.gpa);
        self.names.deinit(self.builder.gpa);
        self.instructions.deinit(self.builder.gpa);
        <span class="tok-kw">for</span> (self.blocks.items) |*b| b.instructions.deinit(self.builder.gpa);
        self.blocks.deinit(self.builder.gpa);
        self.* = <span class="tok-null">undefined</span>;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">cmpTag</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>,
        lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">switch</span> (tag) {
            .@&quot;fcmp false&quot;,
            .@&quot;fcmp fast false&quot;,
            .@&quot;fcmp fast oeq&quot;,
            .@&quot;fcmp fast oge&quot;,
            .@&quot;fcmp fast ogt&quot;,
            .@&quot;fcmp fast ole&quot;,
            .@&quot;fcmp fast olt&quot;,
            .@&quot;fcmp fast one&quot;,
            .@&quot;fcmp fast ord&quot;,
            .@&quot;fcmp fast true&quot;,
            .@&quot;fcmp fast ueq&quot;,
            .@&quot;fcmp fast uge&quot;,
            .@&quot;fcmp fast ugt&quot;,
            .@&quot;fcmp fast ule&quot;,
            .@&quot;fcmp fast ult&quot;,
            .@&quot;fcmp fast une&quot;,
            .@&quot;fcmp fast uno&quot;,
            .@&quot;fcmp oeq&quot;,
            .@&quot;fcmp oge&quot;,
            .@&quot;fcmp ogt&quot;,
            .@&quot;fcmp ole&quot;,
            .@&quot;fcmp olt&quot;,
            .@&quot;fcmp one&quot;,
            .@&quot;fcmp ord&quot;,
            .@&quot;fcmp true&quot;,
            .@&quot;fcmp ueq&quot;,
            .@&quot;fcmp uge&quot;,
            .@&quot;fcmp ugt&quot;,
            .@&quot;fcmp ule&quot;,
            .@&quot;fcmp ult&quot;,
            .@&quot;fcmp une&quot;,
            .@&quot;fcmp uno&quot;,
            .@&quot;icmp eq&quot;,
            .@&quot;icmp ne&quot;,
            .@&quot;icmp sge&quot;,
            .@&quot;icmp sgt&quot;,
            .@&quot;icmp sle&quot;,
            .@&quot;icmp slt&quot;,
            .@&quot;icmp uge&quot;,
            .@&quot;icmp ugt&quot;,
            .@&quot;icmp ule&quot;,
            .@&quot;icmp ult&quot;,
            =&gt; <a href="std.debug.html#std.debug.assert">assert</a>(lhs.typeOfWip(self) == rhs.typeOfWip(self)),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
        _ = <span class="tok-kw">try</span> lhs.typeOfWip(self).changeScalar(.<span class="tok-type">i1</span>, self.builder);
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = tag,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>{
                .lhs = lhs,
                .rhs = rhs,
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">phiTag</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.WipPhi.html">WipPhi</a> {
        <span class="tok-kw">switch</span> (tag) {
            .phi, .@&quot;phi fast&quot; =&gt; <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> ty.isSized(self.builder)),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
        <span class="tok-kw">const</span> incoming = self.cursor.block.ptrConst(self).incoming;
        <a href="std.debug.html#std.debug.assert">assert</a>(incoming &gt; <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Phi.html">Phi</a>, incoming * <span class="tok-number">2</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = tag,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Phi.html">Phi</a>{ .<span class="tok-type">type</span> = ty }),
        });
        _ = self.extra.addManyAsSliceAssumeCapacity(incoming * <span class="tok-number">2</span>);
        <span class="tok-kw">return</span> .{ .block = self.cursor.block, .instruction = instruction };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">selectTag</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>,
        cond: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">switch</span> (tag) {
            .select, .@&quot;select fast&quot; =&gt; {
                <a href="std.debug.html#std.debug.assert">assert</a>(cond.typeOfWip(self).scalarType(self.builder) == .<span class="tok-type">i1</span>);
                <a href="std.debug.html#std.debug.assert">assert</a>(lhs.typeOfWip(self) == rhs.typeOfWip(self));
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Select.html">Select</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = tag,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Select.html">Select</a>{
                .cond = cond,
                .lhs = lhs,
                .rhs = rhs,
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedExtraCapacity</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        count: <span class="tok-type">usize</span>,
        <span class="tok-kw">comptime</span> Extra: <span class="tok-type">type</span>,
        trail_len: <span class="tok-type">usize</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> self.extra.ensureUnusedCapacity(
            self.builder.gpa,
            count * (<span class="tok-builtin">@typeInfo</span>(Extra).@&quot;struct&quot;.fields.len + trail_len),
        );
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addInst</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        name: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        instruction: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <span class="tok-kw">const</span> block_instructions = &amp;self.cursor.block.ptr(self).instructions;
        <span class="tok-kw">try</span> self.instructions.ensureUnusedCapacity(self.builder.gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">if</span> (!self.strip) {
            <span class="tok-kw">try</span> self.names.ensureUnusedCapacity(self.builder.gpa, <span class="tok-number">1</span>);
            <span class="tok-kw">try</span> self.debug_locations.ensureUnusedCapacity(self.builder.gpa, <span class="tok-number">1</span>);
        }
        <span class="tok-kw">try</span> block_instructions.ensureUnusedCapacity(self.builder.gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">const</span> final_name = <span class="tok-kw">if</span> (name) |n|
            <span class="tok-kw">if</span> (self.strip) .empty <span class="tok-kw">else</span> <span class="tok-kw">try</span> self.builder.string(n)
        <span class="tok-kw">else</span>
            .none;

        <span class="tok-kw">const</span> index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(self.instructions.len);
        self.instructions.appendAssumeCapacity(instruction);
        <span class="tok-kw">if</span> (!self.strip) {
            self.names.appendAssumeCapacity(final_name);
            <span class="tok-kw">if</span> (block_instructions.items.len == <span class="tok-number">0</span> <span class="tok-kw">or</span>
                !<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(self.debug_location, self.prev_debug_location))
            {
                self.debug_locations.putAssumeCapacity(index, self.debug_location);
                self.prev_debug_location = self.debug_location;
            }
        }
        block_instructions.insertAssumeCapacity(self.cursor.instruction, index);
        self.cursor.instruction += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> index;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addExtraAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, extra: <span class="tok-kw">anytype</span>) <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html#std.zig.llvm.Builder.Function.Instruction.ExtraIndex">ExtraIndex</a> {
        <span class="tok-kw">const</span> result: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html#std.zig.llvm.Builder.Function.Instruction.ExtraIndex">ExtraIndex</a> = <span class="tok-builtin">@intCast</span>(self.extra.items.len);
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(extra)).@&quot;struct&quot;.fields) |field| {
            <span class="tok-kw">const</span> value = <span class="tok-builtin">@field</span>(extra, field.name);
            self.extra.appendAssumeCapacity(<span class="tok-kw">switch</span> (field.<span class="tok-type">type</span>) {
                <span class="tok-type">u32</span> =&gt; value,
                <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
                <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
                <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
                <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
                <a href="std.zig.llvm.Builder.Type.html">Type</a>,
                <a href="std.zig.llvm.Builder.Value.html">Value</a>,
                <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.Weights.html">Weights</a>,
                =&gt; <span class="tok-builtin">@intFromEnum</span>(value),
                <a href="std.zig.llvm.Builder.MemoryAccessInfo.html">MemoryAccessInfo</a>,
                <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.Info.html">Info</a>,
                <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.Info.html">Info</a>,
                =&gt; <span class="tok-builtin">@bitCast</span>(value),
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type: &quot;</span> ++ field.name ++ <span class="tok-str">&quot;: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(field.<span class="tok-type">type</span>)),
            });
        }
        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">const</span> ExtraDataTrail = <span class="tok-kw">struct</span> {
        index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html#std.zig.llvm.Builder.Function.Instruction.ExtraIndex">ExtraIndex</a>,

        <span class="tok-kw">fn</span> <span class="tok-fn">nextMut</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.ExtraDataTrail.html">ExtraDataTrail</a>, len: <span class="tok-type">u32</span>, <span class="tok-kw">comptime</span> Item: <span class="tok-type">type</span>, wip: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) []Item {
            <span class="tok-kw">const</span> items: []Item = <span class="tok-builtin">@ptrCast</span>(wip.extra.items[self.index..][<span class="tok-number">0</span>..len]);
            self.index += <span class="tok-builtin">@intCast</span>(len);
            <span class="tok-kw">return</span> items;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(
            self: *<a href="std.zig.llvm.Builder.WipFunction.ExtraDataTrail.html">ExtraDataTrail</a>,
            len: <span class="tok-type">u32</span>,
            <span class="tok-kw">comptime</span> Item: <span class="tok-type">type</span>,
            wip: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        ) []<span class="tok-kw">const</span> Item {
            <span class="tok-kw">const</span> items: []<span class="tok-kw">const</span> Item = <span class="tok-builtin">@ptrCast</span>(wip.extra.items[self.index..][<span class="tok-number">0</span>..len]);
            self.index += <span class="tok-builtin">@intCast</span>(len);
            <span class="tok-kw">return</span> items;
        }
    };

    <span class="tok-kw">fn</span> <span class="tok-fn">extraDataTrail</span>(
        self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
        index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html#std.zig.llvm.Builder.Function.Instruction.ExtraIndex">ExtraIndex</a>,
    ) <span class="tok-kw">struct</span> { data: T, trail: <a href="std.zig.llvm.Builder.WipFunction.ExtraDataTrail.html">ExtraDataTrail</a> } {
        <span class="tok-kw">var</span> result: T = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> fields = <span class="tok-builtin">@typeInfo</span>(T).@&quot;struct&quot;.fields;
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields, self.extra.items[index..][<span class="tok-number">0</span>..fields.len]) |field, value|
            <span class="tok-builtin">@field</span>(result, field.name) = <span class="tok-kw">switch</span> (field.<span class="tok-type">type</span>) {
                <span class="tok-type">u32</span> =&gt; value,
                <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
                <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
                <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
                <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
                <a href="std.zig.llvm.Builder.Type.html">Type</a>,
                <a href="std.zig.llvm.Builder.Value.html">Value</a>,
                <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.Weights.html">Weights</a>,
                =&gt; <span class="tok-builtin">@enumFromInt</span>(value),
                <a href="std.zig.llvm.Builder.MemoryAccessInfo.html">MemoryAccessInfo</a>,
                <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.Info.html">Info</a>,
                <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.Info.html">Info</a>,
                =&gt; <span class="tok-builtin">@bitCast</span>(value),
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type: &quot;</span> ++ field.name ++ <span class="tok-str">&quot;: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(field.<span class="tok-type">type</span>)),
            };
        <span class="tok-kw">return</span> .{
            .data = result,
            .trail = .{ .index = index + <span class="tok-builtin">@as</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Type.Item.html#std.zig.llvm.Builder.Type.Item.ExtraIndex">ExtraIndex</a>, <span class="tok-builtin">@intCast</span>(fields.len)) },
        };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">extraData</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html#std.zig.llvm.Builder.Function.Instruction.ExtraIndex">ExtraIndex</a>) T {
        <span class="tok-kw">return</span> self.extraDataTrail(T, index).data;
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
