<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">debug</a></li><li><a href="std.debug.Dwarf.html" class="active">Dwarf</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.debug.Dwarf" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.debug.Dwarf</span><a href="#src.zig-std.debug.Dwarf">[src]</a></h1><div class="tldDocs"><p>Implements parsing, decoding, and caching of DWARF information.</p>
<p>This API does not assume the current executable is itself the thing being
debugged, however, it does assume the debug info has the same CPU
architecture and OS as the current executable. It is planned to remove this
limitation.</p>
<p>For unopinionated types and bits, see <code><a href="std.dwarf.html">std.dwarf</a></code>.</p>
</div><div class="sectNamespaces"><h2 class="sectionHeader">Namespaces</h2><ul class="listNamespaces columns"><li><a href="std.debug.Dwarf.expression.html">std.debug.Dwarf.expression</a></li><li><a href="std.debug.Dwarf.abi.html">std.debug.Dwarf.abi</a></li><li><a href="std.debug.Dwarf.call_frame.html">std.debug.Dwarf.call_frame</a></li></ul></div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.debug.Dwarf.Range.html">std.debug.Dwarf.Range</a></li><li><a href="std.debug.Dwarf.Section.html">std.debug.Dwarf.Section</a></li><li><a href="std.debug.Dwarf.Abbrev.html">std.debug.Dwarf.Abbrev</a></li><li><a href="std.debug.Dwarf.CompileUnit.html">std.debug.Dwarf.CompileUnit</a></li><li><a href="std.debug.Dwarf.FormValue.html">std.debug.Dwarf.FormValue</a></li><li><a href="std.debug.Dwarf.Die.html">std.debug.Dwarf.Die</a></li><li><a href="std.debug.Dwarf.ExceptionFrameHeader.html">std.debug.Dwarf.ExceptionFrameHeader</a></li><li><a href="std.debug.Dwarf.EntryHeader.html">std.debug.Dwarf.EntryHeader</a></li><li><a href="std.debug.Dwarf.CommonInformationEntry.html">std.debug.Dwarf.CommonInformationEntry</a></li><li><a href="std.debug.Dwarf.FrameDescriptionEntry.html">std.debug.Dwarf.FrameDescriptionEntry</a></li><li><a href="std.debug.Dwarf.ElfModule.html">std.debug.Dwarf.ElfModule</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.debug.Dwarf.SectionArray" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">SectionArray</span><a href="#src.zig-std.debug.Dwarf.SectionArray">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.SectionArray">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SectionArray = [<a href="std.debug.Dwarf.html#std.debug.Dwarf.num_sections">num_sections</a>]?<a href="std.debug.Dwarf.Section.html">Section</a></code></pre></details></div></div><div class="decl"><h2 id="std.debug.Dwarf.bad" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">bad</span><a href="#src.zig-std.debug.Dwarf.bad">[src]</a></h2><div class="tldDocs"><p>This function is to make it handy to comment out the return and make it
into a crash when working on this file.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.bad">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bad</span>() <span class="tok-kw">error</span>{InvalidDebugInfo} {
    <span class="tok-kw">if</span> (<a href="std.debug.Dwarf.html#std.debug.Dwarf.debug_debug_mode">debug_debug_mode</a>) <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;bad dwarf&quot;</span>);
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;
}</code></pre></details></div></div></div></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a></code></pre></div><div><pre><code>sections: <a href="std.debug.Dwarf.html#std.debug.Dwarf.SectionArray">SectionArray</a> = <a href="std.debug.Dwarf.html#std.debug.Dwarf.null_section_array">null_section_array</a></code></pre></div><div><pre><code>is_macho: <span class="tok-type">bool</span></code></pre></div><div><pre><code>abbrev_table_list: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.debug.Dwarf.Abbrev.html">Abbrev</a>.<a href="std.debug.Dwarf.Abbrev.Table.html">Table</a>) = .empty</code></pre><div class="fieldDocs"><p>Filled later by the initializer</p>
</div></div><div><pre><code>compile_unit_list: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a>) = .empty</code></pre><div class="fieldDocs"><p>Filled later by the initializer</p>
</div></div><div><pre><code>func_list: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.debug.Dwarf.Func.html">Func</a>) = .empty</code></pre><div class="fieldDocs"><p>Filled later by the initializer</p>
</div></div><div><pre><code>eh_frame_hdr: ?<a href="std.debug.Dwarf.ExceptionFrameHeader.html">ExceptionFrameHeader</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>Starts out non-<code>null</code> if the <code>.eh_frame_hdr</code> section is present. May become <code>null</code> later if we
find that <code>.eh_frame_hdr</code> is incomplete.</p>
</div></div><div><pre><code>cie_map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-type">u64</span>, <a href="std.debug.Dwarf.CommonInformationEntry.html">CommonInformationEntry</a>) = .empty</code></pre><div class="fieldDocs"><p>These lookup tables are only used if <code>eh_frame_hdr</code> is null</p>
</div></div><div><pre><code>fde_list: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.debug.Dwarf.FrameDescriptionEntry.html">FrameDescriptionEntry</a>) = .empty</code></pre><div class="fieldDocs"><p>Sorted by start_pc</p>
</div></div><div><pre><code>ranges: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.debug.Dwarf.Range.html">Range</a>) = .empty</code></pre><div class="fieldDocs"><p>Populated by <code><a href="std.debug.Dwarf.html#std.debug.Dwarf.populateRanges">populateRanges</a></code>.</p>
</div></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.debug.Dwarf.null_section_array" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">null_section_array</span><a href="#src.zig-std.debug.Dwarf.null_section_array">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.null_section_array">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> null_section_array = [_]?<a href="std.debug.Dwarf.Section.html">Section</a>{<span class="tok-null">null</span>} ** <a href="std.debug.Dwarf.html#std.debug.Dwarf.num_sections">num_sections</a></code></pre></details></div></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.debug.Dwarf.ScanError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ScanError</span><a href="#src.zig-std.debug.Dwarf.ScanError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>EndOfBuffer <a href="std.debug.FixedBufferReader.html#std.debug.FixedBufferReader.Error">Error</a></dt></div><div><dt>InvalidBuffer <a href="std.debug.FixedBufferReader.html#std.debug.FixedBufferReader.Error">Error</a></dt></div><div><dt>InvalidDebugInfo</dt></div><div><dt>MissingDebugInfo</dt></div><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>Overflow <a href="std.debug.FixedBufferReader.html#std.debug.FixedBufferReader.Error">Error</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.ScanError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ScanError = <span class="tok-kw">error</span>{
    InvalidDebugInfo,
    MissingDebugInfo,
} || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.FixedBufferReader.html">FixedBufferReader</a>.<a href="std.debug.FixedBufferReader.html#std.debug.FixedBufferReader.Error">Error</a></code></pre></details></div></div><div class="decl"><h2 id="std.debug.Dwarf.ScanError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ScanError</span><a href="#src.zig-std.debug.Dwarf.ScanError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>EndOfBuffer <a href="std.debug.FixedBufferReader.html#std.debug.FixedBufferReader.Error">Error</a></dt></div><div><dt>InvalidBuffer <a href="std.debug.FixedBufferReader.html#std.debug.FixedBufferReader.Error">Error</a></dt></div><div><dt>InvalidDebugInfo</dt></div><div><dt>MissingDebugInfo</dt></div><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>Overflow <a href="std.debug.FixedBufferReader.html#std.debug.FixedBufferReader.Error">Error</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.ScanError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ScanError = <span class="tok-kw">error</span>{
    InvalidDebugInfo,
    MissingDebugInfo,
} || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.FixedBufferReader.html">FixedBufferReader</a>.<a href="std.debug.FixedBufferReader.html#std.debug.FixedBufferReader.Error">Error</a></code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.debug.Dwarf.open" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">open</span><a href="#src.zig-std.debug.Dwarf.open">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">open</span>(d: *<a href="std.debug.Dwarf.html">Dwarf</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.debug.Dwarf.html#std.debug.Dwarf.ScanError">OpenError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Initialize DWARF info. The caller has the responsibility to initialize most
the <code><a href="std.debug.Dwarf.html">Dwarf</a></code> fields before calling. <code>binary_mem</code> is the raw bytes of the
main binary file (not the secondary debug info file).</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>d: *<a href="std.debug.Dwarf.html">Dwarf</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.open">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">open</span>(d: *<a href="std.debug.Dwarf.html">Dwarf</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.debug.Dwarf.html#std.debug.Dwarf.ScanError">OpenError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> d.scanAllFunctions(gpa);
    <span class="tok-kw">try</span> d.scanAllCompileUnits(gpa);
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.Dwarf.section" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">section</span><a href="#src.zig-std.debug.Dwarf.section">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">section</span>(di: <a href="std.debug.Dwarf.html">Dwarf</a>, dwarf_section: <a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>di: <a href="std.debug.Dwarf.html">Dwarf</a></code></pre></div><div><pre><code>dwarf_section: <a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.section">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">section</span>(di: <a href="std.debug.Dwarf.html">Dwarf</a>, dwarf_section: <a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (di.sections[<span class="tok-builtin">@intFromEnum</span>(dwarf_section)]) |s| s.data <span class="tok-kw">else</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.Dwarf.sectionVirtualOffset" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sectionVirtualOffset</span><a href="#src.zig-std.debug.Dwarf.sectionVirtualOffset">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sectionVirtualOffset</span>(di: <a href="std.debug.Dwarf.html">Dwarf</a>, dwarf_section: <a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>, base_address: <span class="tok-type">usize</span>) ?<span class="tok-type">i64</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>di: <a href="std.debug.Dwarf.html">Dwarf</a></code></pre></div><div><pre><code>dwarf_section: <a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a></code></pre></div><div><pre><code>base_address: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.sectionVirtualOffset">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sectionVirtualOffset</span>(di: <a href="std.debug.Dwarf.html">Dwarf</a>, dwarf_section: <a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>, base_address: <span class="tok-type">usize</span>) ?<span class="tok-type">i64</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (di.sections[<span class="tok-builtin">@intFromEnum</span>(dwarf_section)]) |s| s.virtualOffset(base_address) <span class="tok-kw">else</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.Dwarf.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.debug.Dwarf.deinit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(di: *<a href="std.debug.Dwarf.html">Dwarf</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>di: *<a href="std.debug.Dwarf.html">Dwarf</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.deinit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(di: *<a href="std.debug.Dwarf.html">Dwarf</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">for</span> (di.sections) |opt_section| {
        <span class="tok-kw">if</span> (opt_section) |s| <span class="tok-kw">if</span> (s.owned) gpa.free(s.data);
    }
    <span class="tok-kw">for</span> (di.abbrev_table_list.items) |*abbrev| {
        abbrev.deinit(gpa);
    }
    di.abbrev_table_list.deinit(gpa);
    <span class="tok-kw">for</span> (di.compile_unit_list.items) |*cu| {
        <span class="tok-kw">if</span> (cu.src_loc_cache) |*slc| {
            slc.line_table.deinit(gpa);
            gpa.free(slc.directories);
            gpa.free(slc.files);
        }
        cu.die.deinit(gpa);
    }
    di.compile_unit_list.deinit(gpa);
    di.func_list.deinit(gpa);
    di.cie_map.deinit(gpa);
    di.fde_list.deinit(gpa);
    di.ranges.deinit(gpa);
    di.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.Dwarf.getSymbolName" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getSymbolName</span><a href="#src.zig-std.debug.Dwarf.getSymbolName">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolName</span>(di: *<a href="std.debug.Dwarf.html">Dwarf</a>, address: <span class="tok-type">u64</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>di: *<a href="std.debug.Dwarf.html">Dwarf</a></code></pre></div><div><pre><code>address: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.getSymbolName">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolName</span>(di: *<a href="std.debug.Dwarf.html">Dwarf</a>, address: <span class="tok-type">u64</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">for</span> (di.func_list.items) |*func| {
        <span class="tok-kw">if</span> (func.pc_range) |range| {
            <span class="tok-kw">if</span> (address &gt;= range.start <span class="tok-kw">and</span> address &lt; range.end) {
                <span class="tok-kw">return</span> func.name;
            }
        }
    }

    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.Dwarf.populateRanges" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">populateRanges</span><a href="#src.zig-std.debug.Dwarf.populateRanges">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">populateRanges</span>(d: *<a href="std.debug.Dwarf.html">Dwarf</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.debug.Dwarf.html#std.debug.Dwarf.ScanError">ScanError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>d: *<a href="std.debug.Dwarf.html">Dwarf</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.debug.Dwarf.populateRanges.lessThan" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lessThan</span><a href="#src.zig-std.debug.Dwarf.populateRanges.lessThan">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-type">void</span>, a: <a href="std.debug.Dwarf.Range.html">Range</a>, b: <a href="std.debug.Dwarf.Range.html">Range</a>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>ctx: <span class="tok-type">void</span></code></pre></div><div><pre><code>a: <a href="std.debug.Dwarf.Range.html">Range</a></code></pre></div><div><pre><code>b: <a href="std.debug.Dwarf.Range.html">Range</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.populateRanges.lessThan">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-type">void</span>, a: <a href="std.debug.Dwarf.Range.html">Range</a>, b: <a href="std.debug.Dwarf.Range.html">Range</a>) <span class="tok-type">bool</span> {
    _ = ctx;
    <span class="tok-kw">return</span> a.start &lt; b.start;
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.populateRanges">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">populateRanges</span>(d: *<a href="std.debug.Dwarf.html">Dwarf</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.debug.Dwarf.html#std.debug.Dwarf.ScanError">ScanError</a>!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(d.ranges.items.len == <span class="tok-number">0</span>);

    <span class="tok-kw">for</span> (d.compile_unit_list.items, <span class="tok-number">0</span>..) |*cu, cu_index| {
        <span class="tok-kw">if</span> (cu.pc_range) |range| {
            <span class="tok-kw">try</span> d.ranges.append(gpa, .{
                .start = range.start,
                .end = range.end,
                .compile_unit_index = cu_index,
            });
            <span class="tok-kw">continue</span>;
        }
        <span class="tok-kw">const</span> ranges_value = cu.die.getAttr(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.ranges">ranges</a>) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
        <span class="tok-kw">var</span> iter = <a href="std.debug.Dwarf.DebugRangeIterator.html">DebugRangeIterator</a>.<a href="std.debug.Dwarf.DebugRangeIterator.html#std.debug.Dwarf.DebugRangeIterator.init">init</a>(ranges_value, d, cu) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;
        <span class="tok-kw">while</span> (<span class="tok-kw">try</span> iter.next()) |range| {<span class="tok-comment">
            // Not sure why LLVM thinks it's OK to emit these...
            </span><span class="tok-kw">if</span> (range.start == range.end) <span class="tok-kw">continue</span>;

            <span class="tok-kw">try</span> d.ranges.append(gpa, .{
                .start = range.start,
                .end = range.end,
                .compile_unit_index = cu_index,
            });
        }
    }

    <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sortUnstable">sortUnstable</a>(<a href="std.debug.Dwarf.Range.html">Range</a>, d.ranges.items, {}, <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-type">void</span>, a: <a href="std.debug.Dwarf.Range.html">Range</a>, b: <a href="std.debug.Dwarf.Range.html">Range</a>) <span class="tok-type">bool</span> {
            _ = ctx;
            <span class="tok-kw">return</span> a.start &lt; b.start;
        }
    }.lessThan);
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.Dwarf.findCompileUnit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">findCompileUnit</span><a href="#src.zig-std.debug.Dwarf.findCompileUnit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findCompileUnit</span>(di: *<span class="tok-kw">const</span> <a href="std.debug.Dwarf.html">Dwarf</a>, target_address: <span class="tok-type">u64</span>) !*<a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a></code></pre></div><div class="tldDocs"><p>TODO: change this to binary searching the sorted compile unit list</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>di: *<span class="tok-kw">const</span> <a href="std.debug.Dwarf.html">Dwarf</a></code></pre></div><div><pre><code>target_address: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.findCompileUnit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findCompileUnit</span>(di: *<span class="tok-kw">const</span> <a href="std.debug.Dwarf.html">Dwarf</a>, target_address: <span class="tok-type">u64</span>) !*<a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a> {
    <span class="tok-kw">for</span> (di.compile_unit_list.items) |*compile_unit| {
        <span class="tok-kw">if</span> (compile_unit.pc_range) |range| {
            <span class="tok-kw">if</span> (target_address &gt;= range.start <span class="tok-kw">and</span> target_address &lt; range.end) <span class="tok-kw">return</span> compile_unit;
        }

        <span class="tok-kw">const</span> ranges_value = compile_unit.die.getAttr(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.ranges">ranges</a>) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
        <span class="tok-kw">var</span> iter = <a href="std.debug.Dwarf.DebugRangeIterator.html">DebugRangeIterator</a>.<a href="std.debug.Dwarf.DebugRangeIterator.html#std.debug.Dwarf.DebugRangeIterator.init">init</a>(ranges_value, di, compile_unit) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;
        <span class="tok-kw">while</span> (<span class="tok-kw">try</span> iter.next()) |range| {
            <span class="tok-kw">if</span> (target_address &gt;= range.start <span class="tok-kw">and</span> target_address &lt; range.end) <span class="tok-kw">return</span> compile_unit;
        }
    }

    <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.missing">missing</a>();
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.Dwarf.populateSrcLocCache" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">populateSrcLocCache</span><a href="#src.zig-std.debug.Dwarf.populateSrcLocCache">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">populateSrcLocCache</span>(d: *<a href="std.debug.Dwarf.html">Dwarf</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, cu: *<a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a>) <a href="std.debug.Dwarf.html#std.debug.Dwarf.ScanError">ScanError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>d: *<a href="std.debug.Dwarf.html">Dwarf</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>cu: *<a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.populateSrcLocCache">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">populateSrcLocCache</span>(d: *<a href="std.debug.Dwarf.html">Dwarf</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, cu: *<a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a>) <a href="std.debug.Dwarf.html#std.debug.Dwarf.ScanError">ScanError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (cu.src_loc_cache != <span class="tok-null">null</span>) <span class="tok-kw">return</span>;
    cu.src_loc_cache = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.runLineNumberProgram">runLineNumberProgram</a>(d, gpa, cu);
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.Dwarf.getLineNumberInfo" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getLineNumberInfo</span><a href="#src.zig-std.debug.Dwarf.getLineNumberInfo">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLineNumberInfo</span>( d: *<a href="std.debug.Dwarf.html">Dwarf</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, compile_unit: *<a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a>, target_address: <span class="tok-type">u64</span>, ) !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SourceLocation.html">SourceLocation</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>d: *<a href="std.debug.Dwarf.html">Dwarf</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>compile_unit: *<a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a></code></pre></div><div><pre><code>target_address: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.getLineNumberInfo">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLineNumberInfo</span>(
    d: *<a href="std.debug.Dwarf.html">Dwarf</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    compile_unit: *<a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a>,
    target_address: <span class="tok-type">u64</span>,
) !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SourceLocation.html">SourceLocation</a> {
    <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.populateSrcLocCache">populateSrcLocCache</a>(d, gpa, compile_unit);
    <span class="tok-kw">const</span> slc = &amp;compile_unit.src_loc_cache.?;
    <span class="tok-kw">const</span> entry = <span class="tok-kw">try</span> slc.findSource(target_address);
    <span class="tok-kw">const</span> file_index = entry.file - <span class="tok-builtin">@intFromBool</span>(slc.version &lt; <span class="tok-number">5</span>);
    <span class="tok-kw">if</span> (file_index &gt;= slc.files.len) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
    <span class="tok-kw">const</span> file_entry = &amp;slc.files[file_index];
    <span class="tok-kw">if</span> (file_entry.dir_index &gt;= slc.directories.len) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
    <span class="tok-kw">const</span> dir_name = slc.directories[file_entry.dir_index].path;
    <span class="tok-kw">const</span> file_name = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>(gpa, &amp;.{ dir_name, file_entry.path });
    <span class="tok-kw">return</span> .{
        .line = entry.line,
        .column = entry.column,
        .file_name = file_name,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.Dwarf.scanAllUnwindInfo" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">scanAllUnwindInfo</span><a href="#src.zig-std.debug.Dwarf.scanAllUnwindInfo">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">scanAllUnwindInfo</span>(di: *<a href="std.debug.Dwarf.html">Dwarf</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, base_address: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>If <code>.eh_frame_hdr</code> is present, then only the header needs to be parsed. Otherwise, <code>.eh_frame</code>
and <code>.debug_frame</code> are scanned and a sorted list of FDEs is built for binary searching during
unwinding. Even if <code>.eh_frame_hdr</code> is used, we may find during unwinding that it's incomplete,
in which case we build the sorted list of FDEs at that point.</p>
<p>See also <code><a href="std.debug.Dwarf.html#std.debug.Dwarf.scanCieFdeInfo">scanCieFdeInfo</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>di: *<a href="std.debug.Dwarf.html">Dwarf</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>base_address: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.scanAllUnwindInfo">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">scanAllUnwindInfo</span>(di: *<a href="std.debug.Dwarf.html">Dwarf</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, base_address: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (di.section(.eh_frame_hdr)) |eh_frame_hdr| blk: {
        <span class="tok-kw">var</span> fbr: <a href="std.debug.FixedBufferReader.html">FixedBufferReader</a> = .{ .buf = eh_frame_hdr, .endian = <a href="std.debug.Dwarf.html#std.debug.Dwarf.native_endian">native_endian</a> };

        <span class="tok-kw">const</span> version = <span class="tok-kw">try</span> fbr.readByte();
        <span class="tok-kw">if</span> (version != <span class="tok-number">1</span>) <span class="tok-kw">break</span> :blk;

        <span class="tok-kw">const</span> eh_frame_ptr_enc = <span class="tok-kw">try</span> fbr.readByte();
        <span class="tok-kw">if</span> (eh_frame_ptr_enc == <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.omit">omit</a>) <span class="tok-kw">break</span> :blk;
        <span class="tok-kw">const</span> fde_count_enc = <span class="tok-kw">try</span> fbr.readByte();
        <span class="tok-kw">if</span> (fde_count_enc == <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.omit">omit</a>) <span class="tok-kw">break</span> :blk;
        <span class="tok-kw">const</span> table_enc = <span class="tok-kw">try</span> fbr.readByte();
        <span class="tok-kw">if</span> (table_enc == <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.omit">omit</a>) <span class="tok-kw">break</span> :blk;

        <span class="tok-kw">const</span> eh_frame_ptr = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.readEhPointer">readEhPointer</a>(&amp;fbr, eh_frame_ptr_enc, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>), .{
            .pc_rel_base = <span class="tok-builtin">@intFromPtr</span>(&amp;eh_frame_hdr[fbr.pos]),
            .follow_indirect = <span class="tok-null">true</span>,
        }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>()) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

        <span class="tok-kw">const</span> fde_count = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.readEhPointer">readEhPointer</a>(&amp;fbr, fde_count_enc, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>), .{
            .pc_rel_base = <span class="tok-builtin">@intFromPtr</span>(&amp;eh_frame_hdr[fbr.pos]),
            .follow_indirect = <span class="tok-null">true</span>,
        }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>()) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

        <span class="tok-kw">const</span> entry_size = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.ExceptionFrameHeader.html">ExceptionFrameHeader</a>.<a href="std.debug.Dwarf.ExceptionFrameHeader.html#std.debug.Dwarf.ExceptionFrameHeader.entrySize">entrySize</a>(table_enc);
        <span class="tok-kw">const</span> entries_len = fde_count * entry_size;
        <span class="tok-kw">if</span> (entries_len &gt; eh_frame_hdr.len - fbr.pos) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

        di.eh_frame_hdr = .{
            .eh_frame_ptr = eh_frame_ptr,
            .table_enc = table_enc,
            .fde_count = fde_count,
            .entries = eh_frame_hdr[fbr.pos..][<span class="tok-number">0</span>..entries_len],
        };<span class="tok-comment">

        // No need to scan .eh_frame, we have a binary search table already
        </span><span class="tok-kw">return</span>;
    }

    <span class="tok-kw">try</span> di.scanCieFdeInfo(allocator, base_address);
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.Dwarf.scanCieFdeInfo" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">scanCieFdeInfo</span><a href="#src.zig-std.debug.Dwarf.scanCieFdeInfo">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">scanCieFdeInfo</span>(di: *<a href="std.debug.Dwarf.html">Dwarf</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, base_address: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Scan <code>.eh_frame</code> and <code>.debug_frame</code> and build a sorted list of FDEs for binary searching during
unwinding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>di: *<a href="std.debug.Dwarf.html">Dwarf</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>base_address: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.scanCieFdeInfo">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">scanCieFdeInfo</span>(di: *<a href="std.debug.Dwarf.html">Dwarf</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, base_address: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> frame_sections = [<span class="tok-number">2</span>]<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>{ .eh_frame, .debug_frame };
    <span class="tok-kw">for</span> (frame_sections) |frame_section| {
        <span class="tok-kw">if</span> (di.section(frame_section)) |section_data| {
            <span class="tok-kw">var</span> fbr: <a href="std.debug.FixedBufferReader.html">FixedBufferReader</a> = .{ .buf = section_data, .endian = di.endian };
            <span class="tok-kw">while</span> (fbr.pos &lt; fbr.buf.len) {
                <span class="tok-kw">const</span> entry_header = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.EntryHeader.html">EntryHeader</a>.<a href="std.debug.Dwarf.EntryHeader.html#std.debug.Dwarf.EntryHeader.read">read</a>(&amp;fbr, <span class="tok-null">null</span>, frame_section);
                <span class="tok-kw">switch</span> (entry_header.<span class="tok-type">type</span>) {
                    .cie =&gt; {
                        <span class="tok-kw">const</span> cie = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.CommonInformationEntry.html">CommonInformationEntry</a>.<a href="std.debug.Dwarf.CommonInformationEntry.html#std.debug.Dwarf.CommonInformationEntry.parse">parse</a>(
                            entry_header.entry_bytes,
                            di.sectionVirtualOffset(frame_section, base_address).?,
                            <span class="tok-null">true</span>,
                            entry_header.format,
                            frame_section,
                            entry_header.length_offset,
                            <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),
                            di.endian,
                        );
                        <span class="tok-kw">try</span> di.cie_map.put(allocator, entry_header.length_offset, cie);
                    },
                    .fde =&gt; |cie_offset| {
                        <span class="tok-kw">const</span> cie = di.cie_map.get(cie_offset) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
                        <span class="tok-kw">const</span> fde = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.FrameDescriptionEntry.html">FrameDescriptionEntry</a>.<a href="std.debug.Dwarf.FrameDescriptionEntry.html#std.debug.Dwarf.FrameDescriptionEntry.parse">parse</a>(
                            entry_header.entry_bytes,
                            di.sectionVirtualOffset(frame_section, base_address).?,
                            <span class="tok-null">true</span>,
                            cie,
                            <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),
                            di.endian,
                        );
                        <span class="tok-kw">try</span> di.fde_list.append(allocator, fde);
                    },
                    .terminator =&gt; <span class="tok-kw">break</span>,
                }
            }

            <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sortUnstable">sortUnstable</a>(<a href="std.debug.Dwarf.FrameDescriptionEntry.html">FrameDescriptionEntry</a>, di.fde_list.items, {}, <span class="tok-kw">struct</span> {
                <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-type">void</span>, a: <a href="std.debug.Dwarf.FrameDescriptionEntry.html">FrameDescriptionEntry</a>, b: <a href="std.debug.Dwarf.FrameDescriptionEntry.html">FrameDescriptionEntry</a>) <span class="tok-type">bool</span> {
                    _ = ctx;
                    <span class="tok-kw">return</span> a.pc_begin &lt; b.pc_begin;
                }
            }.lessThan);
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.Dwarf.compactUnwindToDwarfRegNumber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">compactUnwindToDwarfRegNumber</span><a href="#src.zig-std.debug.Dwarf.compactUnwindToDwarfRegNumber">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">compactUnwindToDwarfRegNumber</span>(unwind_reg_number: <span class="tok-type">u3</span>) !<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Returns the DWARF register number for an x86_64 register number found in compact unwind info</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>unwind_reg_number: <span class="tok-type">u3</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.compactUnwindToDwarfRegNumber">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">compactUnwindToDwarfRegNumber</span>(unwind_reg_number: <span class="tok-type">u3</span>) !<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (unwind_reg_number) {
        <span class="tok-number">1</span> =&gt; <span class="tok-number">3</span>,<span class="tok-comment"> // RBX
        </span><span class="tok-number">2</span> =&gt; <span class="tok-number">12</span>,<span class="tok-comment"> // R12
        </span><span class="tok-number">3</span> =&gt; <span class="tok-number">13</span>,<span class="tok-comment"> // R13
        </span><span class="tok-number">4</span> =&gt; <span class="tok-number">14</span>,<span class="tok-comment"> // R14
        </span><span class="tok-number">5</span> =&gt; <span class="tok-number">15</span>,<span class="tok-comment"> // R15
        </span><span class="tok-number">6</span> =&gt; <span class="tok-number">6</span>,<span class="tok-comment"> // RBP
        </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">error</span>.InvalidUnwindRegisterNumber,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.Dwarf.getSymbol" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getSymbol</span><a href="#src.zig-std.debug.Dwarf.getSymbol">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbol</span>(di: *<a href="std.debug.Dwarf.html">Dwarf</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">u64</span>) !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Symbol.html">Symbol</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>di: *<a href="std.debug.Dwarf.html">Dwarf</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>address: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.getSymbol">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbol</span>(di: *<a href="std.debug.Dwarf.html">Dwarf</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">u64</span>) !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Symbol.html">Symbol</a> {
    <span class="tok-kw">if</span> (di.findCompileUnit(address)) |compile_unit| {
        <span class="tok-kw">return</span> .{
            .name = di.getSymbolName(address) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>,
            .compile_unit_name = compile_unit.die.getAttrString(di, <a href="std.html">std</a>.<a href="std.dwarf.html">dwarf</a>.<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.name">name</a>, di.section(.debug_str), compile_unit.*) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-str">&quot;???&quot;</span>,
            },
            .source_location = di.getLineNumberInfo(allocator, compile_unit, address) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-null">null</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
            },
        };
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-kw">return</span> .{},
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.Dwarf.chopSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">chopSlice</span><a href="#src.zig-std.debug.Dwarf.chopSlice">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chopSlice</span>(ptr: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>, size: <span class="tok-type">u64</span>) <span class="tok-kw">error</span>{Overflow}![]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>ptr: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div><div><pre><code>size: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.chopSlice">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chopSlice</span>(ptr: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>, size: <span class="tok-type">u64</span>) <span class="tok-kw">error</span>{Overflow}![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> start = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, offset) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
    <span class="tok-kw">const</span> end = start + (<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, size) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow);
    <span class="tok-kw">return</span> ptr[start..end];
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.debug.Dwarf">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! Implements parsing, decoding, and caching of DWARF information.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! This API does not assume the current executable is itself the thing being</span>
<span class="tok-comment">//! debugged, however, it does assume the debug info has the same CPU</span>
<span class="tok-comment">//! architecture and OS as the current executable. It is planned to remove this</span>
<span class="tok-comment">//! limitation.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! For unopinionated types and bits, see `std.dwarf`.</span>

<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> native_endian = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>.<a href="#">endian</a>();

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../std.zig&quot;</span>);
<span class="tok-kw">const</span> Allocator = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> elf = <a href="std.html">std</a>.<a href="std.elf.html">elf</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> DW = <a href="std.html">std</a>.<a href="std.dwarf.html">dwarf</a>;
<span class="tok-kw">const</span> AT = <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.AT.html">AT</a>;
<span class="tok-kw">const</span> EH = <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.EH.html">EH</a>;
<span class="tok-kw">const</span> FORM = <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.FORM.html">FORM</a>;
<span class="tok-kw">const</span> Format = <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.Format.html">Format</a>;
<span class="tok-kw">const</span> RLE = <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.RLE.html">RLE</a>;
<span class="tok-kw">const</span> UT = <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.UT.html">UT</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> cast = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>;
<span class="tok-kw">const</span> maxInt = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>;
<span class="tok-kw">const</span> MemoryAccessor = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.MemoryAccessor.html">MemoryAccessor</a>;
<span class="tok-kw">const</span> Path = <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Path.html">Path</a>;
<span class="tok-kw">const</span> FixedBufferReader = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.FixedBufferReader.html">FixedBufferReader</a>;

<span class="tok-kw">const</span> Dwarf = <span class="tok-builtin">@This</span>();

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> expression = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Dwarf/expression.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> abi = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Dwarf/abi.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> call_frame = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Dwarf/call_frame.zig&quot;</span>);

<span class="tok-comment">/// Useful to temporarily enable while working on this file.</span>
<span class="tok-kw">const</span> debug_debug_mode = <span class="tok-null">false</span>;

endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>,
sections: <a href="std.debug.Dwarf.html#std.debug.Dwarf.SectionArray">SectionArray</a> = <a href="std.debug.Dwarf.html#std.debug.Dwarf.null_section_array">null_section_array</a>,
is_macho: <span class="tok-type">bool</span>,

<span class="tok-comment">/// Filled later by the initializer</span>
abbrev_table_list: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.debug.Dwarf.Abbrev.html">Abbrev</a>.<a href="std.debug.Dwarf.Abbrev.Table.html">Table</a>) = .empty,
<span class="tok-comment">/// Filled later by the initializer</span>
compile_unit_list: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a>) = .empty,
<span class="tok-comment">/// Filled later by the initializer</span>
func_list: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.debug.Dwarf.Func.html">Func</a>) = .empty,

<span class="tok-comment">/// Starts out non-`null` if the `.eh_frame_hdr` section is present. May become `null` later if we</span>
<span class="tok-comment">/// find that `.eh_frame_hdr` is incomplete.</span>
eh_frame_hdr: ?<a href="std.debug.Dwarf.ExceptionFrameHeader.html">ExceptionFrameHeader</a> = <span class="tok-null">null</span>,
<span class="tok-comment">/// These lookup tables are only used if `eh_frame_hdr` is null</span>
cie_map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-type">u64</span>, <a href="std.debug.Dwarf.CommonInformationEntry.html">CommonInformationEntry</a>) = .empty,
<span class="tok-comment">/// Sorted by start_pc</span>
fde_list: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.debug.Dwarf.FrameDescriptionEntry.html">FrameDescriptionEntry</a>) = .empty,

<span class="tok-comment">/// Populated by `populateRanges`.</span>
ranges: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.debug.Dwarf.Range.html">Range</a>) = .empty,

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Range = <span class="tok-kw">struct</span> {
    start: <span class="tok-type">u64</span>,
    end: <span class="tok-type">u64</span>,
    <span class="tok-comment">/// Index into `compile_unit_list`.</span>
    compile_unit_index: <span class="tok-type">usize</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Section = <span class="tok-kw">struct</span> {
    data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,<span class="tok-comment">
    // Module-relative virtual address.
    // Only set if the section data was loaded from disk.
    </span>virtual_address: ?<span class="tok-type">usize</span> = <span class="tok-null">null</span>,<span class="tok-comment">
    // If `data` is owned by this Dwarf.
    </span>owned: <span class="tok-type">bool</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Id = <span class="tok-kw">enum</span> {
        debug_info,
        debug_abbrev,
        debug_str,
        debug_str_offsets,
        debug_line,
        debug_line_str,
        debug_ranges,
        debug_loclists,
        debug_rnglists,
        debug_addr,
        debug_names,
        debug_frame,
        eh_frame,
        eh_frame_hdr,
    };<span class="tok-comment">

    // For sections that are not memory mapped by the loader, this is an offset
    // from `data.ptr` to where the section would have been mapped. Otherwise,
    // `data` is directly backed by the section and the offset is zero.
    </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">virtualOffset</span>(self: <a href="std.debug.Dwarf.Section.html">Section</a>, base_address: <span class="tok-type">usize</span>) <span class="tok-type">i64</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.virtual_address) |va|
            <span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-builtin">@intCast</span>(base_address + va)) -
                <span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromPtr</span>(self.data.ptr)))
        <span class="tok-kw">else</span>
            <span class="tok-number">0</span>;
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Abbrev = <span class="tok-kw">struct</span> {
    code: <span class="tok-type">u64</span>,
    tag_id: <span class="tok-type">u64</span>,
    has_children: <span class="tok-type">bool</span>,
    attrs: []<a href="std.debug.Dwarf.Abbrev.Attr.html">Attr</a>,

    <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(abbrev: *<a href="std.debug.Dwarf.Abbrev.html">Abbrev</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
        allocator.free(abbrev.attrs);
        abbrev.* = <span class="tok-null">undefined</span>;
    }

    <span class="tok-kw">const</span> Attr = <span class="tok-kw">struct</span> {
        id: <span class="tok-type">u64</span>,
        form_id: <span class="tok-type">u64</span>,
        <span class="tok-comment">/// Only valid if form_id is .implicit_const</span>
        payload: <span class="tok-type">i64</span>,
    };

    <span class="tok-kw">const</span> Table = <span class="tok-kw">struct</span> {<span class="tok-comment">
        // offset from .debug_abbrev
        </span>offset: <span class="tok-type">u64</span>,
        abbrevs: []<a href="std.debug.Dwarf.Abbrev.html">Abbrev</a>,

        <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(table: *<a href="std.debug.Dwarf.Abbrev.Table.html">Table</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">for</span> (table.abbrevs) |*abbrev| {
                abbrev.deinit(allocator);
            }
            allocator.free(table.abbrevs);
            table.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(table: *<span class="tok-kw">const</span> <a href="std.debug.Dwarf.Abbrev.Table.html">Table</a>, abbrev_code: <span class="tok-type">u64</span>) ?*<span class="tok-kw">const</span> <a href="std.debug.Dwarf.Abbrev.html">Abbrev</a> {
            <span class="tok-kw">return</span> <span class="tok-kw">for</span> (table.abbrevs) |*abbrev| {
                <span class="tok-kw">if</span> (abbrev.code == abbrev_code) <span class="tok-kw">break</span> abbrev;
            } <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        }
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> CompileUnit = <span class="tok-kw">struct</span> {
    version: <span class="tok-type">u16</span>,
    format: <a href="std.dwarf.Format.html">Format</a>,
    die: <a href="std.debug.Dwarf.Die.html">Die</a>,
    pc_range: ?<a href="std.debug.Dwarf.PcRange.html">PcRange</a>,

    str_offsets_base: <span class="tok-type">usize</span>,
    addr_base: <span class="tok-type">usize</span>,
    rnglists_base: <span class="tok-type">usize</span>,
    loclists_base: <span class="tok-type">usize</span>,
    frame_base: ?*<span class="tok-kw">const</span> <a href="std.debug.Dwarf.FormValue.html">FormValue</a>,

    src_loc_cache: ?<a href="std.debug.Dwarf.CompileUnit.SrcLocCache.html">SrcLocCache</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SrcLocCache = <span class="tok-kw">struct</span> {
        line_table: <a href="std.debug.Dwarf.CompileUnit.SrcLocCache.html#std.debug.Dwarf.CompileUnit.SrcLocCache.LineTable">LineTable</a>,
        directories: []<span class="tok-kw">const</span> <a href="std.debug.Dwarf.FileEntry.html">FileEntry</a>,
        files: []<a href="std.debug.Dwarf.FileEntry.html">FileEntry</a>,
        version: <span class="tok-type">u16</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> LineTable = <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-type">u64</span>, <a href="std.debug.Dwarf.CompileUnit.SrcLocCache.LineEntry.html">LineEntry</a>);

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> LineEntry = <span class="tok-kw">struct</span> {
            line: <span class="tok-type">u32</span>,
            column: <span class="tok-type">u32</span>,
            <span class="tok-comment">/// Offset by 1 depending on whether Dwarf version is &gt;= 5.</span>
            file: <span class="tok-type">u32</span>,

            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> invalid: <a href="std.debug.Dwarf.CompileUnit.SrcLocCache.LineEntry.html">LineEntry</a> = .{
                .line = <span class="tok-null">undefined</span>,
                .column = <span class="tok-null">undefined</span>,
                .file = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>),
            };

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isInvalid</span>(le: <a href="std.debug.Dwarf.CompileUnit.SrcLocCache.LineEntry.html">LineEntry</a>) <span class="tok-type">bool</span> {
                <span class="tok-kw">return</span> le.file == <a href="std.debug.Dwarf.CompileUnit.SrcLocCache.LineEntry.html#std.debug.Dwarf.CompileUnit.SrcLocCache.LineEntry.invalid">invalid</a>.<a href="#">file</a>;
            }
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findSource</span>(slc: *<span class="tok-kw">const</span> <a href="std.debug.Dwarf.CompileUnit.SrcLocCache.html">SrcLocCache</a>, address: <span class="tok-type">u64</span>) !<a href="std.debug.Dwarf.CompileUnit.SrcLocCache.LineEntry.html">LineEntry</a> {
            <span class="tok-kw">const</span> index = <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">u64</span>, slc.line_table.keys(), address, <span class="tok-kw">struct</span> {
                <span class="tok-kw">fn</span> <span class="tok-fn">order</span>(context: <span class="tok-type">u64</span>, item: <span class="tok-type">u64</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
                    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
                }
            }.order);
            <span class="tok-kw">if</span> (index == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.missing">missing</a>();
            <span class="tok-kw">return</span> slc.line_table.values()[index - <span class="tok-number">1</span>];
        }
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FormValue = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    addr: <span class="tok-type">u64</span>,
    addrx: <span class="tok-type">usize</span>,
    block: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    udata: <span class="tok-type">u64</span>,
    data16: *<span class="tok-kw">const</span> [<span class="tok-number">16</span>]<span class="tok-type">u8</span>,
    sdata: <span class="tok-type">i64</span>,
    exprloc: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flag: <span class="tok-type">bool</span>,
    sec_offset: <span class="tok-type">u64</span>,
    ref: <span class="tok-type">u64</span>,
    ref_addr: <span class="tok-type">u64</span>,
    string: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    strp: <span class="tok-type">u64</span>,
    strx: <span class="tok-type">usize</span>,
    line_strp: <span class="tok-type">u64</span>,
    loclistx: <span class="tok-type">u64</span>,
    rnglistx: <span class="tok-type">u64</span>,

    <span class="tok-kw">fn</span> <span class="tok-fn">getString</span>(fv: <a href="std.debug.Dwarf.FormValue.html">FormValue</a>, di: <a href="std.debug.Dwarf.html">Dwarf</a>) ![:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">switch</span> (fv) {
            .string =&gt; |s| <span class="tok-kw">return</span> s,
            .strp =&gt; |off| <span class="tok-kw">return</span> di.getString(off),
            .line_strp =&gt; |off| <span class="tok-kw">return</span> di.getLineString(off),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">getUInt</span>(fv: <a href="std.debug.Dwarf.FormValue.html">FormValue</a>, <span class="tok-kw">comptime</span> U: <span class="tok-type">type</span>) !U {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (fv) {
            <span class="tok-kw">inline</span> .udata,
            .sdata,
            .sec_offset,
            =&gt; |c| <a href="std.math.html#std.math.cast">cast</a>(U, c) <span class="tok-kw">orelse</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
            <span class="tok-kw">else</span> =&gt; <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
        };
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Die = <span class="tok-kw">struct</span> {
    tag_id: <span class="tok-type">u64</span>,
    has_children: <span class="tok-type">bool</span>,
    attrs: []<a href="std.debug.Dwarf.Die.Attr.html">Attr</a>,

    <span class="tok-kw">const</span> Attr = <span class="tok-kw">struct</span> {
        id: <span class="tok-type">u64</span>,
        value: <a href="std.debug.Dwarf.FormValue.html">FormValue</a>,
    };

    <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.debug.Dwarf.Die.html">Die</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
        allocator.free(self.attrs);
        self.* = <span class="tok-null">undefined</span>;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">getAttr</span>(self: *<span class="tok-kw">const</span> <a href="std.debug.Dwarf.Die.html">Die</a>, id: <span class="tok-type">u64</span>) ?*<span class="tok-kw">const</span> <a href="std.debug.Dwarf.FormValue.html">FormValue</a> {
        <span class="tok-kw">for</span> (self.attrs) |*attr| {
            <span class="tok-kw">if</span> (attr.id == id) <span class="tok-kw">return</span> &amp;attr.value;
        }
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">getAttrAddr</span>(
        self: *<span class="tok-kw">const</span> <a href="std.debug.Dwarf.Die.html">Die</a>,
        di: *<span class="tok-kw">const</span> <a href="std.debug.Dwarf.html">Dwarf</a>,
        id: <span class="tok-type">u64</span>,
        compile_unit: <a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a>,
    ) <span class="tok-kw">error</span>{ InvalidDebugInfo, MissingDebugInfo }!<span class="tok-type">u64</span> {
        <span class="tok-kw">const</span> form_value = self.getAttr(id) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (form_value.*) {
            .addr =&gt; |value| value,
            .addrx =&gt; |index| di.readDebugAddr(compile_unit, index),
            <span class="tok-kw">else</span> =&gt; <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
        };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">getAttrSecOffset</span>(self: *<span class="tok-kw">const</span> <a href="std.debug.Dwarf.Die.html">Die</a>, id: <span class="tok-type">u64</span>) !<span class="tok-type">u64</span> {
        <span class="tok-kw">const</span> form_value = self.getAttr(id) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
        <span class="tok-kw">return</span> form_value.getUInt(<span class="tok-type">u64</span>);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">getAttrUnsignedLe</span>(self: *<span class="tok-kw">const</span> <a href="std.debug.Dwarf.Die.html">Die</a>, id: <span class="tok-type">u64</span>) !<span class="tok-type">u64</span> {
        <span class="tok-kw">const</span> form_value = self.getAttr(id) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (form_value.*) {
            .Const =&gt; |value| value.asUnsignedLe(),
            <span class="tok-kw">else</span> =&gt; <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
        };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">getAttrRef</span>(self: *<span class="tok-kw">const</span> <a href="std.debug.Dwarf.Die.html">Die</a>, id: <span class="tok-type">u64</span>, unit_offset: <span class="tok-type">u64</span>, unit_len: <span class="tok-type">u64</span>) !<span class="tok-type">u64</span> {
        <span class="tok-kw">const</span> form_value = self.getAttr(id) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (form_value.*) {
            .ref =&gt; |offset| <span class="tok-kw">if</span> (offset &lt; unit_len) unit_offset + offset <span class="tok-kw">else</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
            .ref_addr =&gt; |addr| addr,
            <span class="tok-kw">else</span> =&gt; <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAttrString</span>(
        self: *<span class="tok-kw">const</span> <a href="std.debug.Dwarf.Die.html">Die</a>,
        di: *<a href="std.debug.Dwarf.html">Dwarf</a>,
        id: <span class="tok-type">u64</span>,
        opt_str: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        compile_unit: <a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a>,
    ) <span class="tok-kw">error</span>{ InvalidDebugInfo, MissingDebugInfo }![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">const</span> form_value = self.getAttr(id) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
        <span class="tok-kw">switch</span> (form_value.*) {
            .string =&gt; |value| <span class="tok-kw">return</span> value,
            .strp =&gt; |offset| <span class="tok-kw">return</span> di.getString(offset),
            .strx =&gt; |index| {
                <span class="tok-kw">const</span> debug_str_offsets = di.section(.debug_str_offsets) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
                <span class="tok-kw">if</span> (compile_unit.str_offsets_base == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
                <span class="tok-kw">switch</span> (compile_unit.format) {
                    .@&quot;32&quot; =&gt; {
                        <span class="tok-kw">const</span> byte_offset = compile_unit.str_offsets_base + <span class="tok-number">4</span> * index;
                        <span class="tok-kw">if</span> (byte_offset + <span class="tok-number">4</span> &gt; debug_str_offsets.len) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
                        <span class="tok-kw">const</span> offset = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, debug_str_offsets[byte_offset..][<span class="tok-number">0</span>..<span class="tok-number">4</span>], di.endian);
                        <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.getStringGeneric">getStringGeneric</a>(opt_str, offset);
                    },
                    .@&quot;64&quot; =&gt; {
                        <span class="tok-kw">const</span> byte_offset = compile_unit.str_offsets_base + <span class="tok-number">8</span> * index;
                        <span class="tok-kw">if</span> (byte_offset + <span class="tok-number">8</span> &gt; debug_str_offsets.len) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
                        <span class="tok-kw">const</span> offset = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u64</span>, debug_str_offsets[byte_offset..][<span class="tok-number">0</span>..<span class="tok-number">8</span>], di.endian);
                        <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.getStringGeneric">getStringGeneric</a>(opt_str, offset);
                    },
                }
            },
            .line_strp =&gt; |offset| <span class="tok-kw">return</span> di.getLineString(offset),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
        }
    }
};

<span class="tok-comment">/// This represents the decoded .eh_frame_hdr header</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExceptionFrameHeader = <span class="tok-kw">struct</span> {
    eh_frame_ptr: <span class="tok-type">usize</span>,
    table_enc: <span class="tok-type">u8</span>,
    fde_count: <span class="tok-type">usize</span>,
    entries: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">entrySize</span>(table_enc: <span class="tok-type">u8</span>) !<span class="tok-type">u8</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (table_enc &amp; <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.type_mask">type_mask</a>) {
            <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.udata2">udata2</a>,
            <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.sdata2">sdata2</a>,
            =&gt; <span class="tok-number">4</span>,
            <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.udata4">udata4</a>,
            <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.sdata4">sdata4</a>,
            =&gt; <span class="tok-number">8</span>,
            <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.udata8">udata8</a>,
            <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.sdata8">sdata8</a>,
            =&gt; <span class="tok-number">16</span>,<span class="tok-comment">
            // This is a binary search table, so all entries must be the same length
            </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
        };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">isValidPtr</span>(
        self: <a href="std.debug.Dwarf.ExceptionFrameHeader.html">ExceptionFrameHeader</a>,
        <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
        ptr: <span class="tok-type">usize</span>,
        ma: *<a href="std.debug.MemoryAccessor.html">MemoryAccessor</a>,
        eh_frame_len: ?<span class="tok-type">usize</span>,
    ) <span class="tok-type">bool</span> {
        <span class="tok-kw">if</span> (eh_frame_len) |len| {
            <span class="tok-kw">return</span> ptr &gt;= self.eh_frame_ptr <span class="tok-kw">and</span> ptr &lt;= self.eh_frame_ptr + len - <span class="tok-builtin">@sizeOf</span>(T);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> ma.load(T, ptr) != <span class="tok-null">null</span>;
        }
    }

    <span class="tok-comment">/// Find an entry by binary searching the eh_frame_hdr section.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Since the length of the eh_frame section (`eh_frame_len`) may not be known by the caller,</span>
    <span class="tok-comment">/// MemoryAccessor will be used to verify readability of the header entries.</span>
    <span class="tok-comment">/// If `eh_frame_len` is provided, then these checks can be skipped.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findEntry</span>(
        self: <a href="std.debug.Dwarf.ExceptionFrameHeader.html">ExceptionFrameHeader</a>,
        ma: *<a href="std.debug.MemoryAccessor.html">MemoryAccessor</a>,
        eh_frame_len: ?<span class="tok-type">usize</span>,
        eh_frame_hdr_ptr: <span class="tok-type">usize</span>,
        pc: <span class="tok-type">usize</span>,
        cie: *<a href="std.debug.Dwarf.CommonInformationEntry.html">CommonInformationEntry</a>,
        fde: *<a href="std.debug.Dwarf.FrameDescriptionEntry.html">FrameDescriptionEntry</a>,
    ) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> entry_size = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.ExceptionFrameHeader.html#std.debug.Dwarf.ExceptionFrameHeader.entrySize">entrySize</a>(self.table_enc);

        <span class="tok-kw">var</span> left: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = self.fde_count;

        <span class="tok-kw">var</span> fbr: <a href="std.debug.FixedBufferReader.html">FixedBufferReader</a> = .{ .buf = self.entries, .endian = <a href="std.debug.Dwarf.html#std.debug.Dwarf.native_endian">native_endian</a> };

        <span class="tok-kw">while</span> (len &gt; <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> mid = left + len / <span class="tok-number">2</span>;

            fbr.pos = mid * entry_size;
            <span class="tok-kw">const</span> pc_begin = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.readEhPointer">readEhPointer</a>(&amp;fbr, self.table_enc, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>), .{
                .pc_rel_base = <span class="tok-builtin">@intFromPtr</span>(&amp;self.entries[fbr.pos]),
                .follow_indirect = <span class="tok-null">true</span>,
                .data_rel_base = eh_frame_hdr_ptr,
            }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

            <span class="tok-kw">if</span> (pc &lt; pc_begin) {
                len /= <span class="tok-number">2</span>;
            } <span class="tok-kw">else</span> {
                left = mid;
                <span class="tok-kw">if</span> (pc == pc_begin) <span class="tok-kw">break</span>;
                len -= len / <span class="tok-number">2</span>;
            }
        }

        <span class="tok-kw">if</span> (len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
        fbr.pos = left * entry_size;<span class="tok-comment">

        // Read past the pc_begin field of the entry
        </span>_ = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.readEhPointer">readEhPointer</a>(&amp;fbr, self.table_enc, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>), .{
            .pc_rel_base = <span class="tok-builtin">@intFromPtr</span>(&amp;self.entries[fbr.pos]),
            .follow_indirect = <span class="tok-null">true</span>,
            .data_rel_base = eh_frame_hdr_ptr,
        }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

        <span class="tok-kw">const</span> fde_ptr = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.readEhPointer">readEhPointer</a>(&amp;fbr, self.table_enc, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>), .{
            .pc_rel_base = <span class="tok-builtin">@intFromPtr</span>(&amp;self.entries[fbr.pos]),
            .follow_indirect = <span class="tok-null">true</span>,
            .data_rel_base = eh_frame_hdr_ptr,
        }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>()) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

        <span class="tok-kw">if</span> (fde_ptr &lt; self.eh_frame_ptr) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();<span class="tok-comment">

        // Even if eh_frame_len is not specified, all ranges accssed are checked via MemoryAccessor
        </span><span class="tok-kw">const</span> eh_frame = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(self.eh_frame_ptr))[<span class="tok-number">0</span> .. eh_frame_len <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>)];

        <span class="tok-kw">const</span> fde_offset = fde_ptr - self.eh_frame_ptr;
        <span class="tok-kw">var</span> eh_frame_fbr: <a href="std.debug.FixedBufferReader.html">FixedBufferReader</a> = .{
            .buf = eh_frame,
            .pos = fde_offset,
            .endian = <a href="std.debug.Dwarf.html#std.debug.Dwarf.native_endian">native_endian</a>,
        };

        <span class="tok-kw">const</span> fde_entry_header = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.EntryHeader.html">EntryHeader</a>.<a href="std.debug.Dwarf.EntryHeader.html#std.debug.Dwarf.EntryHeader.read">read</a>(&amp;eh_frame_fbr, <span class="tok-kw">if</span> (eh_frame_len == <span class="tok-null">null</span>) ma <span class="tok-kw">else</span> <span class="tok-null">null</span>, .eh_frame);
        <span class="tok-kw">if</span> (fde_entry_header.entry_bytes.len &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> !self.isValidPtr(<span class="tok-type">u8</span>, <span class="tok-builtin">@intFromPtr</span>(&amp;fde_entry_header.entry_bytes[fde_entry_header.entry_bytes.len - <span class="tok-number">1</span>]), ma, eh_frame_len)) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
        <span class="tok-kw">if</span> (fde_entry_header.<span class="tok-type">type</span> != .fde) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();<span class="tok-comment">

        // CIEs always come before FDEs (the offset is a subtraction), so we can assume this memory is readable
        </span><span class="tok-kw">const</span> cie_offset = fde_entry_header.<span class="tok-type">type</span>.fde;
        <span class="tok-kw">try</span> eh_frame_fbr.seekTo(cie_offset);
        <span class="tok-kw">const</span> cie_entry_header = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.EntryHeader.html">EntryHeader</a>.<a href="std.debug.Dwarf.EntryHeader.html#std.debug.Dwarf.EntryHeader.read">read</a>(&amp;eh_frame_fbr, <span class="tok-kw">if</span> (eh_frame_len == <span class="tok-null">null</span>) ma <span class="tok-kw">else</span> <span class="tok-null">null</span>, .eh_frame);
        <span class="tok-kw">if</span> (cie_entry_header.entry_bytes.len &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> !self.isValidPtr(<span class="tok-type">u8</span>, <span class="tok-builtin">@intFromPtr</span>(&amp;cie_entry_header.entry_bytes[cie_entry_header.entry_bytes.len - <span class="tok-number">1</span>]), ma, eh_frame_len)) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
        <span class="tok-kw">if</span> (cie_entry_header.<span class="tok-type">type</span> != .cie) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

        cie.* = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.CommonInformationEntry.html">CommonInformationEntry</a>.<a href="std.debug.Dwarf.CommonInformationEntry.html#std.debug.Dwarf.CommonInformationEntry.parse">parse</a>(
            cie_entry_header.entry_bytes,
            <span class="tok-number">0</span>,
            <span class="tok-null">true</span>,
            cie_entry_header.format,
            .eh_frame,
            cie_entry_header.length_offset,
            <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),
            <a href="std.debug.Dwarf.html#std.debug.Dwarf.native_endian">native_endian</a>,
        );

        fde.* = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.FrameDescriptionEntry.html">FrameDescriptionEntry</a>.<a href="std.debug.Dwarf.FrameDescriptionEntry.html#std.debug.Dwarf.FrameDescriptionEntry.parse">parse</a>(
            fde_entry_header.entry_bytes,
            <span class="tok-number">0</span>,
            <span class="tok-null">true</span>,
            cie.*,
            <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),
            <a href="std.debug.Dwarf.html#std.debug.Dwarf.native_endian">native_endian</a>,
        );
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> EntryHeader = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// Offset of the length field in the backing buffer</span>
    length_offset: <span class="tok-type">usize</span>,
    format: <a href="std.dwarf.Format.html">Format</a>,
    <span class="tok-type">type</span>: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        cie,
        <span class="tok-comment">/// Value is the offset of the corresponding CIE</span>
        fde: <span class="tok-type">u64</span>,
        terminator,
    },
    <span class="tok-comment">/// The entry's contents, not including the ID field</span>
    entry_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,

    <span class="tok-comment">/// The length of the entry including the ID field, but not the length field itself</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">entryLength</span>(self: <a href="std.debug.Dwarf.EntryHeader.html">EntryHeader</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> self.entry_bytes.len + <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-kw">if</span> (self.format == .@&quot;64&quot;) <span class="tok-number">8</span> <span class="tok-kw">else</span> <span class="tok-number">4</span>);
    }

    <span class="tok-comment">/// Reads a header for either an FDE or a CIE, then advances the fbr to the position after the trailing structure.</span>
    <span class="tok-comment">/// `fbr` must be a FixedBufferReader backed by either the .eh_frame or .debug_frame sections.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(
        fbr: *<a href="std.debug.FixedBufferReader.html">FixedBufferReader</a>,
        opt_ma: ?*<a href="std.debug.MemoryAccessor.html">MemoryAccessor</a>,
        dwarf_section: <a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>,
    ) !<a href="std.debug.Dwarf.EntryHeader.html">EntryHeader</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(dwarf_section == .eh_frame <span class="tok-kw">or</span> dwarf_section == .debug_frame);

        <span class="tok-kw">const</span> length_offset = fbr.pos;
        <span class="tok-kw">const</span> unit_header = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.readUnitHeader">readUnitHeader</a>(fbr, opt_ma);
        <span class="tok-kw">const</span> unit_length = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, unit_header.unit_length) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
        <span class="tok-kw">if</span> (unit_length == <span class="tok-number">0</span>) <span class="tok-kw">return</span> .{
            .length_offset = length_offset,
            .format = unit_header.format,
            .<span class="tok-type">type</span> = .terminator,
            .entry_bytes = &amp;.{},
        };
        <span class="tok-kw">const</span> start_offset = fbr.pos;
        <span class="tok-kw">const</span> end_offset = start_offset + unit_length;
        <span class="tok-kw">defer</span> fbr.pos = end_offset;

        <span class="tok-kw">const</span> id = <span class="tok-kw">try</span> <span class="tok-kw">if</span> (opt_ma) |ma|
            fbr.readAddressChecked(unit_header.format, ma)
        <span class="tok-kw">else</span>
            fbr.readAddress(unit_header.format);
        <span class="tok-kw">const</span> entry_bytes = fbr.buf[fbr.pos..end_offset];
        <span class="tok-kw">const</span> cie_id: <span class="tok-type">u64</span> = <span class="tok-kw">switch</span> (dwarf_section) {
            .eh_frame =&gt; <a href="std.debug.Dwarf.CommonInformationEntry.html">CommonInformationEntry</a>.<a href="std.debug.Dwarf.CommonInformationEntry.html#std.debug.Dwarf.CommonInformationEntry.eh_id">eh_id</a>,
            .debug_frame =&gt; <span class="tok-kw">switch</span> (unit_header.format) {
                .@&quot;32&quot; =&gt; <a href="std.debug.Dwarf.CommonInformationEntry.html">CommonInformationEntry</a>.<a href="std.debug.Dwarf.CommonInformationEntry.html#std.debug.Dwarf.CommonInformationEntry.dwarf32_id">dwarf32_id</a>,
                .@&quot;64&quot; =&gt; <a href="std.debug.Dwarf.CommonInformationEntry.html">CommonInformationEntry</a>.<a href="std.debug.Dwarf.CommonInformationEntry.html#std.debug.Dwarf.CommonInformationEntry.dwarf64_id">dwarf64_id</a>,
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };

        <span class="tok-kw">return</span> .{
            .length_offset = length_offset,
            .format = unit_header.format,
            .<span class="tok-type">type</span> = <span class="tok-kw">if</span> (id == cie_id) .cie <span class="tok-kw">else</span> .{ .fde = <span class="tok-kw">switch</span> (dwarf_section) {
                .eh_frame =&gt; <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.sub">sub</a>(<span class="tok-type">u64</span>, start_offset, id),
                .debug_frame =&gt; id,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            } },
            .entry_bytes = entry_bytes,
        };
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> CommonInformationEntry = <span class="tok-kw">struct</span> {<span class="tok-comment">
    // Used in .eh_frame
    </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> eh_id = <span class="tok-number">0</span>;<span class="tok-comment">

    // Used in .debug_frame (DWARF32)
    </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> dwarf32_id = <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>);<span class="tok-comment">

    // Used in .debug_frame (DWARF64)
    </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> dwarf64_id = <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u64</span>);<span class="tok-comment">

    // Offset of the length field of this entry in the eh_frame section.
    // This is the key that FDEs use to reference CIEs.
    </span>length_offset: <span class="tok-type">u64</span>,
    version: <span class="tok-type">u8</span>,
    address_size: <span class="tok-type">u8</span>,
    format: <a href="std.dwarf.Format.html">Format</a>,<span class="tok-comment">

    // Only present in version 4
    </span>segment_selector_size: ?<span class="tok-type">u8</span>,

    code_alignment_factor: <span class="tok-type">u32</span>,
    data_alignment_factor: <span class="tok-type">i32</span>,
    return_address_register: <span class="tok-type">u8</span>,

    aug_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    aug_data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    lsda_pointer_enc: <span class="tok-type">u8</span>,
    personality_enc: ?<span class="tok-type">u8</span>,
    personality_routine_pointer: ?<span class="tok-type">u64</span>,
    fde_pointer_enc: <span class="tok-type">u8</span>,
    initial_instructions: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSignalFrame</span>(self: <a href="std.debug.Dwarf.CommonInformationEntry.html">CommonInformationEntry</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">for</span> (self.aug_str) |c| <span class="tok-kw">if</span> (c == <span class="tok-str">'S'</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addressesSignedWithBKey</span>(self: <a href="std.debug.Dwarf.CommonInformationEntry.html">CommonInformationEntry</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">for</span> (self.aug_str) |c| <span class="tok-kw">if</span> (c == <span class="tok-str">'B'</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mteTaggedFrame</span>(self: <a href="std.debug.Dwarf.CommonInformationEntry.html">CommonInformationEntry</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">for</span> (self.aug_str) |c| <span class="tok-kw">if</span> (c == <span class="tok-str">'G'</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }

    <span class="tok-comment">/// This function expects to read the CIE starting with the version field.</span>
    <span class="tok-comment">/// The returned struct references memory backed by cie_bytes.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// See the FrameDescriptionEntry.parse documentation for the description</span>
    <span class="tok-comment">/// of `pc_rel_offset` and `is_runtime`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `length_offset` specifies the offset of this CIE's length field in the</span>
    <span class="tok-comment">/// .eh_frame / .debug_frame section.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parse</span>(
        cie_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        pc_rel_offset: <span class="tok-type">i64</span>,
        is_runtime: <span class="tok-type">bool</span>,
        format: <a href="std.dwarf.Format.html">Format</a>,
        dwarf_section: <a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>,
        length_offset: <span class="tok-type">u64</span>,
        addr_size_bytes: <span class="tok-type">u8</span>,
        endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>,
    ) !<a href="std.debug.Dwarf.CommonInformationEntry.html">CommonInformationEntry</a> {
        <span class="tok-kw">if</span> (addr_size_bytes &gt; <span class="tok-number">8</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedAddrSize;

        <span class="tok-kw">var</span> fbr: <a href="std.debug.FixedBufferReader.html">FixedBufferReader</a> = .{ .buf = cie_bytes, .endian = endian };

        <span class="tok-kw">const</span> version = <span class="tok-kw">try</span> fbr.readByte();
        <span class="tok-kw">switch</span> (dwarf_section) {
            .eh_frame =&gt; <span class="tok-kw">if</span> (version != <span class="tok-number">1</span> <span class="tok-kw">and</span> version != <span class="tok-number">3</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedDwarfVersion,
            .debug_frame =&gt; <span class="tok-kw">if</span> (version != <span class="tok-number">4</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedDwarfVersion,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedDwarfSection,
        }

        <span class="tok-kw">var</span> has_eh_data = <span class="tok-null">false</span>;
        <span class="tok-kw">var</span> has_aug_data = <span class="tok-null">false</span>;

        <span class="tok-kw">var</span> aug_str_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> aug_str_start = fbr.pos;
        <span class="tok-kw">var</span> aug_byte = <span class="tok-kw">try</span> fbr.readByte();
        <span class="tok-kw">while</span> (aug_byte != <span class="tok-number">0</span>) : (aug_byte = <span class="tok-kw">try</span> fbr.readByte()) {
            <span class="tok-kw">switch</span> (aug_byte) {
                <span class="tok-str">'z'</span> =&gt; {
                    <span class="tok-kw">if</span> (aug_str_len != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
                    has_aug_data = <span class="tok-null">true</span>;
                },
                <span class="tok-str">'e'</span> =&gt; {
                    <span class="tok-kw">if</span> (has_aug_data <span class="tok-kw">or</span> aug_str_len != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
                    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> fbr.readByte() != <span class="tok-str">'h'</span>) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
                    has_eh_data = <span class="tok-null">true</span>;
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (has_eh_data) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
            }

            aug_str_len += <span class="tok-number">1</span>;
        }

        <span class="tok-kw">if</span> (has_eh_data) {<span class="tok-comment">
            // legacy data created by older versions of gcc - unsupported here
            </span><span class="tok-kw">for</span> (<span class="tok-number">0</span>..addr_size_bytes) |_| _ = <span class="tok-kw">try</span> fbr.readByte();
        }

        <span class="tok-kw">const</span> address_size = <span class="tok-kw">if</span> (version == <span class="tok-number">4</span>) <span class="tok-kw">try</span> fbr.readByte() <span class="tok-kw">else</span> addr_size_bytes;
        <span class="tok-kw">const</span> segment_selector_size = <span class="tok-kw">if</span> (version == <span class="tok-number">4</span>) <span class="tok-kw">try</span> fbr.readByte() <span class="tok-kw">else</span> <span class="tok-null">null</span>;

        <span class="tok-kw">const</span> code_alignment_factor = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u32</span>);
        <span class="tok-kw">const</span> data_alignment_factor = <span class="tok-kw">try</span> fbr.readIleb128(<span class="tok-type">i32</span>);
        <span class="tok-kw">const</span> return_address_register = <span class="tok-kw">if</span> (version == <span class="tok-number">1</span>) <span class="tok-kw">try</span> fbr.readByte() <span class="tok-kw">else</span> <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u8</span>);

        <span class="tok-kw">var</span> lsda_pointer_enc: <span class="tok-type">u8</span> = <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.omit">omit</a>;
        <span class="tok-kw">var</span> personality_enc: ?<span class="tok-type">u8</span> = <span class="tok-null">null</span>;
        <span class="tok-kw">var</span> personality_routine_pointer: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>;
        <span class="tok-kw">var</span> fde_pointer_enc: <span class="tok-type">u8</span> = <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.absptr">absptr</a>;

        <span class="tok-kw">var</span> aug_data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;[_]<span class="tok-type">u8</span>{};
        <span class="tok-kw">const</span> aug_str = <span class="tok-kw">if</span> (has_aug_data) blk: {
            <span class="tok-kw">const</span> aug_data_len = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">usize</span>);
            <span class="tok-kw">const</span> aug_data_start = fbr.pos;
            aug_data = cie_bytes[aug_data_start..][<span class="tok-number">0</span>..aug_data_len];

            <span class="tok-kw">const</span> aug_str = cie_bytes[aug_str_start..][<span class="tok-number">0</span>..aug_str_len];
            <span class="tok-kw">for</span> (aug_str[<span class="tok-number">1</span>..]) |byte| {
                <span class="tok-kw">switch</span> (byte) {
                    <span class="tok-str">'L'</span> =&gt; {
                        lsda_pointer_enc = <span class="tok-kw">try</span> fbr.readByte();
                    },
                    <span class="tok-str">'P'</span> =&gt; {
                        personality_enc = <span class="tok-kw">try</span> fbr.readByte();
                        personality_routine_pointer = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.readEhPointer">readEhPointer</a>(&amp;fbr, personality_enc.?, addr_size_bytes, .{
                            .pc_rel_base = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.pcRelBase">pcRelBase</a>(<span class="tok-builtin">@intFromPtr</span>(&amp;cie_bytes[fbr.pos]), pc_rel_offset),
                            .follow_indirect = is_runtime,
                        });
                    },
                    <span class="tok-str">'R'</span> =&gt; {
                        fde_pointer_enc = <span class="tok-kw">try</span> fbr.readByte();
                    },
                    <span class="tok-str">'S'</span>, <span class="tok-str">'B'</span>, <span class="tok-str">'G'</span> =&gt; {},
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
                }
            }<span class="tok-comment">

            // aug_data_len can include padding so the CIE ends on an address boundary
            </span>fbr.pos = aug_data_start + aug_data_len;
            <span class="tok-kw">break</span> :blk aug_str;
        } <span class="tok-kw">else</span> &amp;[_]<span class="tok-type">u8</span>{};

        <span class="tok-kw">const</span> initial_instructions = cie_bytes[fbr.pos..];
        <span class="tok-kw">return</span> .{
            .length_offset = length_offset,
            .version = version,
            .address_size = address_size,
            .format = format,
            .segment_selector_size = segment_selector_size,
            .code_alignment_factor = code_alignment_factor,
            .data_alignment_factor = data_alignment_factor,
            .return_address_register = return_address_register,
            .aug_str = aug_str,
            .aug_data = aug_data,
            .lsda_pointer_enc = lsda_pointer_enc,
            .personality_enc = personality_enc,
            .personality_routine_pointer = personality_routine_pointer,
            .fde_pointer_enc = fde_pointer_enc,
            .initial_instructions = initial_instructions,
        };
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FrameDescriptionEntry = <span class="tok-kw">struct</span> {<span class="tok-comment">
    // Offset into eh_frame where the CIE for this FDE is stored
    </span>cie_length_offset: <span class="tok-type">u64</span>,

    pc_begin: <span class="tok-type">u64</span>,
    pc_range: <span class="tok-type">u64</span>,
    lsda_pointer: ?<span class="tok-type">u64</span>,
    aug_data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    instructions: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,

    <span class="tok-comment">/// This function expects to read the FDE starting at the PC Begin field.</span>
    <span class="tok-comment">/// The returned struct references memory backed by `fde_bytes`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `pc_rel_offset` specifies an offset to be applied to pc_rel_base values</span>
    <span class="tok-comment">/// used when decoding pointers. This should be set to zero if fde_bytes is</span>
    <span class="tok-comment">/// backed by the memory of a .eh_frame / .debug_frame section in the running executable.</span>
    <span class="tok-comment">/// Otherwise, it should be the relative offset to translate addresses from</span>
    <span class="tok-comment">/// where the section is currently stored in memory, to where it *would* be</span>
    <span class="tok-comment">/// stored at runtime: section base addr - backing data base ptr.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Similarly, `is_runtime` specifies this function is being called on a runtime</span>
    <span class="tok-comment">/// section, and so indirect pointers can be followed.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parse</span>(
        fde_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        pc_rel_offset: <span class="tok-type">i64</span>,
        is_runtime: <span class="tok-type">bool</span>,
        cie: <a href="std.debug.Dwarf.CommonInformationEntry.html">CommonInformationEntry</a>,
        addr_size_bytes: <span class="tok-type">u8</span>,
        endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>,
    ) !<a href="std.debug.Dwarf.FrameDescriptionEntry.html">FrameDescriptionEntry</a> {
        <span class="tok-kw">if</span> (addr_size_bytes &gt; <span class="tok-number">8</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidAddrSize;

        <span class="tok-kw">var</span> fbr: <a href="std.debug.FixedBufferReader.html">FixedBufferReader</a> = .{ .buf = fde_bytes, .endian = endian };

        <span class="tok-kw">const</span> pc_begin = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.readEhPointer">readEhPointer</a>(&amp;fbr, cie.fde_pointer_enc, addr_size_bytes, .{
            .pc_rel_base = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.pcRelBase">pcRelBase</a>(<span class="tok-builtin">@intFromPtr</span>(&amp;fde_bytes[fbr.pos]), pc_rel_offset),
            .follow_indirect = is_runtime,
        }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

        <span class="tok-kw">const</span> pc_range = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.readEhPointer">readEhPointer</a>(&amp;fbr, cie.fde_pointer_enc, addr_size_bytes, .{
            .pc_rel_base = <span class="tok-number">0</span>,
            .follow_indirect = <span class="tok-null">false</span>,
        }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

        <span class="tok-kw">var</span> aug_data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;[_]<span class="tok-type">u8</span>{};
        <span class="tok-kw">const</span> lsda_pointer = <span class="tok-kw">if</span> (cie.aug_str.len &gt; <span class="tok-number">0</span>) blk: {
            <span class="tok-kw">const</span> aug_data_len = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">usize</span>);
            <span class="tok-kw">const</span> aug_data_start = fbr.pos;
            aug_data = fde_bytes[aug_data_start..][<span class="tok-number">0</span>..aug_data_len];

            <span class="tok-kw">const</span> lsda_pointer = <span class="tok-kw">if</span> (cie.lsda_pointer_enc != <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.omit">omit</a>)
                <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.readEhPointer">readEhPointer</a>(&amp;fbr, cie.lsda_pointer_enc, addr_size_bytes, .{
                    .pc_rel_base = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.pcRelBase">pcRelBase</a>(<span class="tok-builtin">@intFromPtr</span>(&amp;fde_bytes[fbr.pos]), pc_rel_offset),
                    .follow_indirect = is_runtime,
                })
            <span class="tok-kw">else</span>
                <span class="tok-null">null</span>;

            fbr.pos = aug_data_start + aug_data_len;
            <span class="tok-kw">break</span> :blk lsda_pointer;
        } <span class="tok-kw">else</span> <span class="tok-null">null</span>;

        <span class="tok-kw">const</span> instructions = fde_bytes[fbr.pos..];
        <span class="tok-kw">return</span> .{
            .cie_length_offset = cie.length_offset,
            .pc_begin = pc_begin,
            .pc_range = pc_range,
            .lsda_pointer = lsda_pointer,
            .aug_data = aug_data,
            .instructions = instructions,
        };
    }
};

<span class="tok-kw">const</span> num_sections = <a href="std.html">std</a>.<a href="std.enums.html">enums</a>.<a href="std.enums.html#std.enums.directEnumArrayLen">directEnumArrayLen</a>(<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>, <span class="tok-number">0</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SectionArray = [<a href="std.debug.Dwarf.html#std.debug.Dwarf.num_sections">num_sections</a>]?<a href="std.debug.Dwarf.Section.html">Section</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> null_section_array = [_]?<a href="std.debug.Dwarf.Section.html">Section</a>{<span class="tok-null">null</span>} ** <a href="std.debug.Dwarf.html#std.debug.Dwarf.num_sections">num_sections</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenError = <a href="std.debug.Dwarf.html#std.debug.Dwarf.ScanError">ScanError</a>;

<span class="tok-comment">/// Initialize DWARF info. The caller has the responsibility to initialize most</span>
<span class="tok-comment">/// the `Dwarf` fields before calling. `binary_mem` is the raw bytes of the</span>
<span class="tok-comment">/// main binary file (not the secondary debug info file).</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">open</span>(d: *<a href="std.debug.Dwarf.html">Dwarf</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.debug.Dwarf.html#std.debug.Dwarf.ScanError">OpenError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> d.scanAllFunctions(gpa);
    <span class="tok-kw">try</span> d.scanAllCompileUnits(gpa);
}

<span class="tok-kw">const</span> PcRange = <span class="tok-kw">struct</span> {
    start: <span class="tok-type">u64</span>,
    end: <span class="tok-type">u64</span>,
};

<span class="tok-kw">const</span> Func = <span class="tok-kw">struct</span> {
    pc_range: ?<a href="std.debug.Dwarf.PcRange.html">PcRange</a>,
    name: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">section</span>(di: <a href="std.debug.Dwarf.html">Dwarf</a>, dwarf_section: <a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (di.sections[<span class="tok-builtin">@intFromEnum</span>(dwarf_section)]) |s| s.data <span class="tok-kw">else</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sectionVirtualOffset</span>(di: <a href="std.debug.Dwarf.html">Dwarf</a>, dwarf_section: <a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>, base_address: <span class="tok-type">usize</span>) ?<span class="tok-type">i64</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (di.sections[<span class="tok-builtin">@intFromEnum</span>(dwarf_section)]) |s| s.virtualOffset(base_address) <span class="tok-kw">else</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(di: *<a href="std.debug.Dwarf.html">Dwarf</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">for</span> (di.sections) |opt_section| {
        <span class="tok-kw">if</span> (opt_section) |s| <span class="tok-kw">if</span> (s.owned) gpa.free(s.data);
    }
    <span class="tok-kw">for</span> (di.abbrev_table_list.items) |*abbrev| {
        abbrev.deinit(gpa);
    }
    di.abbrev_table_list.deinit(gpa);
    <span class="tok-kw">for</span> (di.compile_unit_list.items) |*cu| {
        <span class="tok-kw">if</span> (cu.src_loc_cache) |*slc| {
            slc.line_table.deinit(gpa);
            gpa.free(slc.directories);
            gpa.free(slc.files);
        }
        cu.die.deinit(gpa);
    }
    di.compile_unit_list.deinit(gpa);
    di.func_list.deinit(gpa);
    di.cie_map.deinit(gpa);
    di.fde_list.deinit(gpa);
    di.ranges.deinit(gpa);
    di.* = <span class="tok-null">undefined</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolName</span>(di: *<a href="std.debug.Dwarf.html">Dwarf</a>, address: <span class="tok-type">u64</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">for</span> (di.func_list.items) |*func| {
        <span class="tok-kw">if</span> (func.pc_range) |range| {
            <span class="tok-kw">if</span> (address &gt;= range.start <span class="tok-kw">and</span> address &lt; range.end) {
                <span class="tok-kw">return</span> func.name;
            }
        }
    }

    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ScanError = <span class="tok-kw">error</span>{
    InvalidDebugInfo,
    MissingDebugInfo,
} || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.FixedBufferReader.html">FixedBufferReader</a>.<a href="std.debug.FixedBufferReader.html#std.debug.FixedBufferReader.Error">Error</a>;

<span class="tok-kw">fn</span> <span class="tok-fn">scanAllFunctions</span>(di: *<a href="std.debug.Dwarf.html">Dwarf</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.debug.Dwarf.html#std.debug.Dwarf.ScanError">ScanError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> fbr: <a href="std.debug.FixedBufferReader.html">FixedBufferReader</a> = .{ .buf = di.section(.debug_info).?, .endian = di.endian };
    <span class="tok-kw">var</span> this_unit_offset: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">while</span> (this_unit_offset &lt; fbr.buf.len) {
        <span class="tok-kw">try</span> fbr.seekTo(this_unit_offset);

        <span class="tok-kw">const</span> unit_header = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.readUnitHeader">readUnitHeader</a>(&amp;fbr, <span class="tok-null">null</span>);
        <span class="tok-kw">if</span> (unit_header.unit_length == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;
        <span class="tok-kw">const</span> next_offset = unit_header.header_length + unit_header.unit_length;

        <span class="tok-kw">const</span> version = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>);
        <span class="tok-kw">if</span> (version &lt; <span class="tok-number">2</span> <span class="tok-kw">or</span> version &gt; <span class="tok-number">5</span>) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

        <span class="tok-kw">var</span> address_size: <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> debug_abbrev_offset: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">if</span> (version &gt;= <span class="tok-number">5</span>) {
            <span class="tok-kw">const</span> unit_type = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u8</span>);
            <span class="tok-kw">if</span> (unit_type != <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.UT.html">UT</a>.<a href="std.dwarf.UT.html#std.dwarf.UT.compile">compile</a>) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
            address_size = <span class="tok-kw">try</span> fbr.readByte();
            debug_abbrev_offset = <span class="tok-kw">try</span> fbr.readAddress(unit_header.format);
        } <span class="tok-kw">else</span> {
            debug_abbrev_offset = <span class="tok-kw">try</span> fbr.readAddress(unit_header.format);
            address_size = <span class="tok-kw">try</span> fbr.readByte();
        }
        <span class="tok-kw">if</span> (address_size != <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

        <span class="tok-kw">const</span> abbrev_table = <span class="tok-kw">try</span> di.getAbbrevTable(allocator, debug_abbrev_offset);

        <span class="tok-kw">var</span> max_attrs: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> zig_padding_abbrev_code: <span class="tok-type">u7</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> (abbrev_table.abbrevs) |abbrev| {
            max_attrs = <span class="tok-builtin">@max</span>(max_attrs, abbrev.attrs.len);
            <span class="tok-kw">if</span> (<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u7</span>, abbrev.code)) |code| {
                <span class="tok-kw">if</span> (abbrev.tag_id == <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.TAG.html">TAG</a>.<a href="std.dwarf.TAG.html#std.dwarf.TAG.ZIG_padding">ZIG_padding</a> <span class="tok-kw">and</span>
                    !abbrev.has_children <span class="tok-kw">and</span>
                    abbrev.attrs.len == <span class="tok-number">0</span>)
                {
                    zig_padding_abbrev_code = code;
                }
            }
        }
        <span class="tok-kw">const</span> attrs_buf = <span class="tok-kw">try</span> allocator.alloc(<a href="std.debug.Dwarf.Die.html">Die</a>.<a href="std.debug.Dwarf.Die.Attr.html">Attr</a>, max_attrs * <span class="tok-number">3</span>);
        <span class="tok-kw">defer</span> allocator.free(attrs_buf);
        <span class="tok-kw">var</span> attrs_bufs: [<span class="tok-number">3</span>][]<a href="std.debug.Dwarf.Die.html">Die</a>.<a href="std.debug.Dwarf.Die.Attr.html">Attr</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">for</span> (&amp;attrs_bufs, <span class="tok-number">0</span>..) |*buf, index| buf.* = attrs_buf[index * max_attrs ..][<span class="tok-number">0</span>..max_attrs];

        <span class="tok-kw">const</span> next_unit_pos = this_unit_offset + next_offset;

        <span class="tok-kw">var</span> compile_unit: <a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a> = .{
            .version = version,
            .format = unit_header.format,
            .die = <span class="tok-null">undefined</span>,
            .pc_range = <span class="tok-null">null</span>,

            .str_offsets_base = <span class="tok-number">0</span>,
            .addr_base = <span class="tok-number">0</span>,
            .rnglists_base = <span class="tok-number">0</span>,
            .loclists_base = <span class="tok-number">0</span>,
            .frame_base = <span class="tok-null">null</span>,
            .src_loc_cache = <span class="tok-null">null</span>,
        };

        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            fbr.pos = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfNonePos">indexOfNonePos</a>(<span class="tok-type">u8</span>, fbr.buf, fbr.pos, &amp;.{
                zig_padding_abbrev_code, <span class="tok-number">0</span>,
            }) <span class="tok-kw">orelse</span> fbr.buf.len;
            <span class="tok-kw">if</span> (fbr.pos &gt;= next_unit_pos) <span class="tok-kw">break</span>;
            <span class="tok-kw">var</span> die_obj = (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.parseDie">parseDie</a>(
                &amp;fbr,
                attrs_bufs[<span class="tok-number">0</span>],
                abbrev_table,
                unit_header.format,
            )) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;

            <span class="tok-kw">switch</span> (die_obj.tag_id) {
                <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.TAG.html">TAG</a>.<a href="std.dwarf.TAG.html#std.dwarf.TAG.compile_unit">compile_unit</a> =&gt; {
                    compile_unit.die = die_obj;
                    compile_unit.die.attrs = attrs_bufs[<span class="tok-number">1</span>][<span class="tok-number">0</span>..die_obj.attrs.len];
                    <span class="tok-builtin">@memcpy</span>(compile_unit.die.attrs, die_obj.attrs);

                    compile_unit.str_offsets_base = <span class="tok-kw">if</span> (die_obj.getAttr(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.str_offsets_base">str_offsets_base</a>)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>;
                    compile_unit.addr_base = <span class="tok-kw">if</span> (die_obj.getAttr(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.addr_base">addr_base</a>)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>;
                    compile_unit.rnglists_base = <span class="tok-kw">if</span> (die_obj.getAttr(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.rnglists_base">rnglists_base</a>)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>;
                    compile_unit.loclists_base = <span class="tok-kw">if</span> (die_obj.getAttr(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.loclists_base">loclists_base</a>)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>;
                    compile_unit.frame_base = die_obj.getAttr(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.frame_base">frame_base</a>);
                },
                <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.TAG.html">TAG</a>.<a href="std.dwarf.TAG.html#std.dwarf.TAG.subprogram">subprogram</a>, <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.TAG.html">TAG</a>.<a href="std.dwarf.TAG.html#std.dwarf.TAG.inlined_subroutine">inlined_subroutine</a>, <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.TAG.html">TAG</a>.<a href="std.dwarf.TAG.html#std.dwarf.TAG.subroutine">subroutine</a>, <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.TAG.html">TAG</a>.<a href="std.dwarf.TAG.html#std.dwarf.TAG.entry_point">entry_point</a> =&gt; {
                    <span class="tok-kw">const</span> fn_name = x: {
                        <span class="tok-kw">var</span> this_die_obj = die_obj;<span class="tok-comment">
                        // Prevent endless loops
                        </span><span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">3</span>) |_| {
                            <span class="tok-kw">if</span> (this_die_obj.getAttr(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.name">name</a>)) |_| {
                                <span class="tok-kw">break</span> :x <span class="tok-kw">try</span> this_die_obj.getAttrString(di, <a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.name">name</a>, di.section(.debug_str), compile_unit);
                            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (this_die_obj.getAttr(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.abstract_origin">abstract_origin</a>)) |_| {
                                <span class="tok-kw">const</span> after_die_offset = fbr.pos;
                                <span class="tok-kw">defer</span> fbr.pos = after_die_offset;<span class="tok-comment">

                                // Follow the DIE it points to and repeat
                                </span><span class="tok-kw">const</span> ref_offset = <span class="tok-kw">try</span> this_die_obj.getAttrRef(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.abstract_origin">abstract_origin</a>, this_unit_offset, next_offset);
                                <span class="tok-kw">try</span> fbr.seekTo(ref_offset);
                                this_die_obj = (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.parseDie">parseDie</a>(
                                    &amp;fbr,
                                    attrs_bufs[<span class="tok-number">2</span>],
                                    abbrev_table,<span class="tok-comment"> // wrong abbrev table for different cu
                                    </span>unit_header.format,
                                )) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
                            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (this_die_obj.getAttr(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.specification">specification</a>)) |_| {
                                <span class="tok-kw">const</span> after_die_offset = fbr.pos;
                                <span class="tok-kw">defer</span> fbr.pos = after_die_offset;<span class="tok-comment">

                                // Follow the DIE it points to and repeat
                                </span><span class="tok-kw">const</span> ref_offset = <span class="tok-kw">try</span> this_die_obj.getAttrRef(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.specification">specification</a>, this_unit_offset, next_offset);
                                <span class="tok-kw">try</span> fbr.seekTo(ref_offset);
                                this_die_obj = (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.parseDie">parseDie</a>(
                                    &amp;fbr,
                                    attrs_bufs[<span class="tok-number">2</span>],
                                    abbrev_table,<span class="tok-comment"> // wrong abbrev table for different cu
                                    </span>unit_header.format,
                                )) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
                            } <span class="tok-kw">else</span> {
                                <span class="tok-kw">break</span> :x <span class="tok-null">null</span>;
                            }
                        }

                        <span class="tok-kw">break</span> :x <span class="tok-null">null</span>;
                    };

                    <span class="tok-kw">var</span> range_added = <span class="tok-kw">if</span> (die_obj.getAttrAddr(di, <a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.low_pc">low_pc</a>, compile_unit)) |low_pc| blk: {
                        <span class="tok-kw">if</span> (die_obj.getAttr(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.high_pc">high_pc</a>)) |high_pc_value| {
                            <span class="tok-kw">const</span> pc_end = <span class="tok-kw">switch</span> (high_pc_value.*) {
                                .addr =&gt; |value| value,
                                .udata =&gt; |offset| low_pc + offset,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
                            };

                            <span class="tok-kw">try</span> di.func_list.append(allocator, .{
                                .name = fn_name,
                                .pc_range = .{
                                    .start = low_pc,
                                    .end = pc_end,
                                },
                            });

                            <span class="tok-kw">break</span> :blk <span class="tok-null">true</span>;
                        }

                        <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;
                    } <span class="tok-kw">else</span> |err| blk: {
                        <span class="tok-kw">if</span> (err != <span class="tok-kw">error</span>.MissingDebugInfo) <span class="tok-kw">return</span> err;
                        <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;
                    };

                    <span class="tok-kw">if</span> (die_obj.getAttr(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.ranges">ranges</a>)) |ranges_value| blk: {
                        <span class="tok-kw">var</span> iter = <a href="std.debug.Dwarf.DebugRangeIterator.html">DebugRangeIterator</a>.<a href="std.debug.Dwarf.DebugRangeIterator.html#std.debug.Dwarf.DebugRangeIterator.init">init</a>(ranges_value, di, &amp;compile_unit) <span class="tok-kw">catch</span> |err| {
                            <span class="tok-kw">if</span> (err != <span class="tok-kw">error</span>.MissingDebugInfo) <span class="tok-kw">return</span> err;
                            <span class="tok-kw">break</span> :blk;
                        };

                        <span class="tok-kw">while</span> (<span class="tok-kw">try</span> iter.next()) |range| {
                            range_added = <span class="tok-null">true</span>;
                            <span class="tok-kw">try</span> di.func_list.append(allocator, .{
                                .name = fn_name,
                                .pc_range = .{
                                    .start = range.start,
                                    .end = range.end,
                                },
                            });
                        }
                    }

                    <span class="tok-kw">if</span> (fn_name != <span class="tok-null">null</span> <span class="tok-kw">and</span> !range_added) {
                        <span class="tok-kw">try</span> di.func_list.append(allocator, .{
                            .name = fn_name,
                            .pc_range = <span class="tok-null">null</span>,
                        });
                    }
                },
                <span class="tok-kw">else</span> =&gt; {},
            }
        }

        this_unit_offset += next_offset;
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">scanAllCompileUnits</span>(di: *<a href="std.debug.Dwarf.html">Dwarf</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.debug.Dwarf.html#std.debug.Dwarf.ScanError">ScanError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> fbr: <a href="std.debug.FixedBufferReader.html">FixedBufferReader</a> = .{ .buf = di.section(.debug_info).?, .endian = di.endian };
    <span class="tok-kw">var</span> this_unit_offset: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">var</span> attrs_buf = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.debug.Dwarf.Die.html">Die</a>.<a href="std.debug.Dwarf.Die.Attr.html">Attr</a>).init(allocator);
    <span class="tok-kw">defer</span> attrs_buf.deinit();

    <span class="tok-kw">while</span> (this_unit_offset &lt; fbr.buf.len) {
        <span class="tok-kw">try</span> fbr.seekTo(this_unit_offset);

        <span class="tok-kw">const</span> unit_header = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.readUnitHeader">readUnitHeader</a>(&amp;fbr, <span class="tok-null">null</span>);
        <span class="tok-kw">if</span> (unit_header.unit_length == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;
        <span class="tok-kw">const</span> next_offset = unit_header.header_length + unit_header.unit_length;

        <span class="tok-kw">const</span> version = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>);
        <span class="tok-kw">if</span> (version &lt; <span class="tok-number">2</span> <span class="tok-kw">or</span> version &gt; <span class="tok-number">5</span>) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

        <span class="tok-kw">var</span> address_size: <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> debug_abbrev_offset: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">if</span> (version &gt;= <span class="tok-number">5</span>) {
            <span class="tok-kw">const</span> unit_type = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u8</span>);
            <span class="tok-kw">if</span> (unit_type != <a href="std.dwarf.UT.html">UT</a>.<a href="std.dwarf.UT.html#std.dwarf.UT.compile">compile</a>) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
            address_size = <span class="tok-kw">try</span> fbr.readByte();
            debug_abbrev_offset = <span class="tok-kw">try</span> fbr.readAddress(unit_header.format);
        } <span class="tok-kw">else</span> {
            debug_abbrev_offset = <span class="tok-kw">try</span> fbr.readAddress(unit_header.format);
            address_size = <span class="tok-kw">try</span> fbr.readByte();
        }
        <span class="tok-kw">if</span> (address_size != <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

        <span class="tok-kw">const</span> abbrev_table = <span class="tok-kw">try</span> di.getAbbrevTable(allocator, debug_abbrev_offset);

        <span class="tok-kw">var</span> max_attrs: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> (abbrev_table.abbrevs) |abbrev| {
            max_attrs = <span class="tok-builtin">@max</span>(max_attrs, abbrev.attrs.len);
        }
        <span class="tok-kw">try</span> attrs_buf.resize(max_attrs);

        <span class="tok-kw">var</span> compile_unit_die = (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.parseDie">parseDie</a>(
            &amp;fbr,
            attrs_buf.items,
            abbrev_table,
            unit_header.format,
        )) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

        <span class="tok-kw">if</span> (compile_unit_die.tag_id != <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.TAG.html">TAG</a>.<a href="std.dwarf.TAG.html#std.dwarf.TAG.compile_unit">compile_unit</a>) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

        compile_unit_die.attrs = <span class="tok-kw">try</span> allocator.dupe(<a href="std.debug.Dwarf.Die.html">Die</a>.<a href="std.debug.Dwarf.Die.Attr.html">Attr</a>, compile_unit_die.attrs);

        <span class="tok-kw">var</span> compile_unit: <a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a> = .{
            .version = version,
            .format = unit_header.format,
            .pc_range = <span class="tok-null">null</span>,
            .die = compile_unit_die,
            .str_offsets_base = <span class="tok-kw">if</span> (compile_unit_die.getAttr(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.str_offsets_base">str_offsets_base</a>)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>,
            .addr_base = <span class="tok-kw">if</span> (compile_unit_die.getAttr(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.addr_base">addr_base</a>)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>,
            .rnglists_base = <span class="tok-kw">if</span> (compile_unit_die.getAttr(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.rnglists_base">rnglists_base</a>)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>,
            .loclists_base = <span class="tok-kw">if</span> (compile_unit_die.getAttr(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.loclists_base">loclists_base</a>)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>,
            .frame_base = compile_unit_die.getAttr(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.frame_base">frame_base</a>),
            .src_loc_cache = <span class="tok-null">null</span>,
        };

        compile_unit.pc_range = x: {
            <span class="tok-kw">if</span> (compile_unit_die.getAttrAddr(di, <a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.low_pc">low_pc</a>, compile_unit)) |low_pc| {
                <span class="tok-kw">if</span> (compile_unit_die.getAttr(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.high_pc">high_pc</a>)) |high_pc_value| {
                    <span class="tok-kw">const</span> pc_end = <span class="tok-kw">switch</span> (high_pc_value.*) {
                        .addr =&gt; |value| value,
                        .udata =&gt; |offset| low_pc + offset,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
                    };
                    <span class="tok-kw">break</span> :x <a href="std.debug.Dwarf.PcRange.html">PcRange</a>{
                        .start = low_pc,
                        .end = pc_end,
                    };
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">break</span> :x <span class="tok-null">null</span>;
                }
            } <span class="tok-kw">else</span> |err| {
                <span class="tok-kw">if</span> (err != <span class="tok-kw">error</span>.MissingDebugInfo) <span class="tok-kw">return</span> err;
                <span class="tok-kw">break</span> :x <span class="tok-null">null</span>;
            }
        };

        <span class="tok-kw">try</span> di.compile_unit_list.append(allocator, compile_unit);

        this_unit_offset += next_offset;
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">populateRanges</span>(d: *<a href="std.debug.Dwarf.html">Dwarf</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.debug.Dwarf.html#std.debug.Dwarf.ScanError">ScanError</a>!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(d.ranges.items.len == <span class="tok-number">0</span>);

    <span class="tok-kw">for</span> (d.compile_unit_list.items, <span class="tok-number">0</span>..) |*cu, cu_index| {
        <span class="tok-kw">if</span> (cu.pc_range) |range| {
            <span class="tok-kw">try</span> d.ranges.append(gpa, .{
                .start = range.start,
                .end = range.end,
                .compile_unit_index = cu_index,
            });
            <span class="tok-kw">continue</span>;
        }
        <span class="tok-kw">const</span> ranges_value = cu.die.getAttr(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.ranges">ranges</a>) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
        <span class="tok-kw">var</span> iter = <a href="std.debug.Dwarf.DebugRangeIterator.html">DebugRangeIterator</a>.<a href="std.debug.Dwarf.DebugRangeIterator.html#std.debug.Dwarf.DebugRangeIterator.init">init</a>(ranges_value, d, cu) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;
        <span class="tok-kw">while</span> (<span class="tok-kw">try</span> iter.next()) |range| {<span class="tok-comment">
            // Not sure why LLVM thinks it's OK to emit these...
            </span><span class="tok-kw">if</span> (range.start == range.end) <span class="tok-kw">continue</span>;

            <span class="tok-kw">try</span> d.ranges.append(gpa, .{
                .start = range.start,
                .end = range.end,
                .compile_unit_index = cu_index,
            });
        }
    }

    <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sortUnstable">sortUnstable</a>(<a href="std.debug.Dwarf.Range.html">Range</a>, d.ranges.items, {}, <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-type">void</span>, a: <a href="std.debug.Dwarf.Range.html">Range</a>, b: <a href="std.debug.Dwarf.Range.html">Range</a>) <span class="tok-type">bool</span> {
            _ = ctx;
            <span class="tok-kw">return</span> a.start &lt; b.start;
        }
    }.lessThan);
}

<span class="tok-kw">const</span> DebugRangeIterator = <span class="tok-kw">struct</span> {
    base_address: <span class="tok-type">u64</span>,
    section_type: <a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>,
    di: *<span class="tok-kw">const</span> <a href="std.debug.Dwarf.html">Dwarf</a>,
    compile_unit: *<span class="tok-kw">const</span> <a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a>,
    fbr: <a href="std.debug.FixedBufferReader.html">FixedBufferReader</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(ranges_value: *<span class="tok-kw">const</span> <a href="std.debug.Dwarf.FormValue.html">FormValue</a>, di: *<span class="tok-kw">const</span> <a href="std.debug.Dwarf.html">Dwarf</a>, compile_unit: *<span class="tok-kw">const</span> <a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a>) !<span class="tok-builtin">@This</span>() {
        <span class="tok-kw">const</span> section_type = <span class="tok-kw">if</span> (compile_unit.version &gt;= <span class="tok-number">5</span>) <a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>.<a href="#">debug_rnglists</a> <span class="tok-kw">else</span> <a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>.<a href="#">debug_ranges</a>;
        <span class="tok-kw">const</span> debug_ranges = di.section(section_type) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;

        <span class="tok-kw">const</span> ranges_offset = <span class="tok-kw">switch</span> (ranges_value.*) {
            .sec_offset, .udata =&gt; |off| off,
            .rnglistx =&gt; |idx| off: {
                <span class="tok-kw">switch</span> (compile_unit.format) {
                    .@&quot;32&quot; =&gt; {
                        <span class="tok-kw">const</span> offset_loc = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(compile_unit.rnglists_base + <span class="tok-number">4</span> * idx));
                        <span class="tok-kw">if</span> (offset_loc + <span class="tok-number">4</span> &gt; debug_ranges.len) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
                        <span class="tok-kw">const</span> offset = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, debug_ranges[offset_loc..][<span class="tok-number">0</span>..<span class="tok-number">4</span>], di.endian);
                        <span class="tok-kw">break</span> :off compile_unit.rnglists_base + offset;
                    },
                    .@&quot;64&quot; =&gt; {
                        <span class="tok-kw">const</span> offset_loc = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(compile_unit.rnglists_base + <span class="tok-number">8</span> * idx));
                        <span class="tok-kw">if</span> (offset_loc + <span class="tok-number">8</span> &gt; debug_ranges.len) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
                        <span class="tok-kw">const</span> offset = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u64</span>, debug_ranges[offset_loc..][<span class="tok-number">0</span>..<span class="tok-number">8</span>], di.endian);
                        <span class="tok-kw">break</span> :off compile_unit.rnglists_base + offset;
                    },
                }
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
        };<span class="tok-comment">

        // All the addresses in the list are relative to the value
        // specified by DW_AT.low_pc or to some other value encoded
        // in the list itself.
        // If no starting value is specified use zero.
        </span><span class="tok-kw">const</span> base_address = compile_unit.die.getAttrAddr(di, <a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.low_pc">low_pc</a>, compile_unit.*) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.MissingDebugInfo =&gt; <span class="tok-number">0</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
        };

        <span class="tok-kw">return</span> .{
            .base_address = base_address,
            .section_type = section_type,
            .di = di,
            .compile_unit = compile_unit,
            .fbr = .{
                .buf = debug_ranges,
                .pos = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, ranges_offset) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
                .endian = di.endian,
            },
        };
    }<span class="tok-comment">

    // Returns the next range in the list, or null if the end was reached.
    </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<span class="tok-builtin">@This</span>()) !?<a href="std.debug.Dwarf.PcRange.html">PcRange</a> {
        <span class="tok-kw">switch</span> (self.section_type) {
            .debug_rnglists =&gt; {
                <span class="tok-kw">const</span> kind = <span class="tok-kw">try</span> self.fbr.readByte();
                <span class="tok-kw">switch</span> (kind) {
                    <a href="std.dwarf.RLE.html">RLE</a>.<a href="std.dwarf.RLE.html#std.dwarf.RLE.end_of_list">end_of_list</a> =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
                    <a href="std.dwarf.RLE.html">RLE</a>.<a href="std.dwarf.RLE.html#std.dwarf.RLE.base_addressx">base_addressx</a> =&gt; {
                        <span class="tok-kw">const</span> index = <span class="tok-kw">try</span> self.fbr.readUleb128(<span class="tok-type">usize</span>);
                        self.base_address = <span class="tok-kw">try</span> self.di.readDebugAddr(self.compile_unit.*, index);
                        <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.next();
                    },
                    <a href="std.dwarf.RLE.html">RLE</a>.<a href="std.dwarf.RLE.html#std.dwarf.RLE.startx_endx">startx_endx</a> =&gt; {
                        <span class="tok-kw">const</span> start_index = <span class="tok-kw">try</span> self.fbr.readUleb128(<span class="tok-type">usize</span>);
                        <span class="tok-kw">const</span> start_addr = <span class="tok-kw">try</span> self.di.readDebugAddr(self.compile_unit.*, start_index);

                        <span class="tok-kw">const</span> end_index = <span class="tok-kw">try</span> self.fbr.readUleb128(<span class="tok-type">usize</span>);
                        <span class="tok-kw">const</span> end_addr = <span class="tok-kw">try</span> self.di.readDebugAddr(self.compile_unit.*, end_index);

                        <span class="tok-kw">return</span> .{
                            .start = start_addr,
                            .end = end_addr,
                        };
                    },
                    <a href="std.dwarf.RLE.html">RLE</a>.<a href="std.dwarf.RLE.html#std.dwarf.RLE.startx_length">startx_length</a> =&gt; {
                        <span class="tok-kw">const</span> start_index = <span class="tok-kw">try</span> self.fbr.readUleb128(<span class="tok-type">usize</span>);
                        <span class="tok-kw">const</span> start_addr = <span class="tok-kw">try</span> self.di.readDebugAddr(self.compile_unit.*, start_index);

                        <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> self.fbr.readUleb128(<span class="tok-type">usize</span>);
                        <span class="tok-kw">const</span> end_addr = start_addr + len;

                        <span class="tok-kw">return</span> .{
                            .start = start_addr,
                            .end = end_addr,
                        };
                    },
                    <a href="std.dwarf.RLE.html">RLE</a>.<a href="std.dwarf.RLE.html#std.dwarf.RLE.offset_pair">offset_pair</a> =&gt; {
                        <span class="tok-kw">const</span> start_addr = <span class="tok-kw">try</span> self.fbr.readUleb128(<span class="tok-type">usize</span>);
                        <span class="tok-kw">const</span> end_addr = <span class="tok-kw">try</span> self.fbr.readUleb128(<span class="tok-type">usize</span>);<span class="tok-comment">

                        // This is the only kind that uses the base address
                        </span><span class="tok-kw">return</span> .{
                            .start = self.base_address + start_addr,
                            .end = self.base_address + end_addr,
                        };
                    },
                    <a href="std.dwarf.RLE.html">RLE</a>.<a href="std.dwarf.RLE.html#std.dwarf.RLE.base_address">base_address</a> =&gt; {
                        self.base_address = <span class="tok-kw">try</span> self.fbr.readInt(<span class="tok-type">usize</span>);
                        <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.next();
                    },
                    <a href="std.dwarf.RLE.html">RLE</a>.<a href="std.dwarf.RLE.html#std.dwarf.RLE.start_end">start_end</a> =&gt; {
                        <span class="tok-kw">const</span> start_addr = <span class="tok-kw">try</span> self.fbr.readInt(<span class="tok-type">usize</span>);
                        <span class="tok-kw">const</span> end_addr = <span class="tok-kw">try</span> self.fbr.readInt(<span class="tok-type">usize</span>);

                        <span class="tok-kw">return</span> .{
                            .start = start_addr,
                            .end = end_addr,
                        };
                    },
                    <a href="std.dwarf.RLE.html">RLE</a>.<a href="std.dwarf.RLE.html#std.dwarf.RLE.start_length">start_length</a> =&gt; {
                        <span class="tok-kw">const</span> start_addr = <span class="tok-kw">try</span> self.fbr.readInt(<span class="tok-type">usize</span>);
                        <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> self.fbr.readUleb128(<span class="tok-type">usize</span>);
                        <span class="tok-kw">const</span> end_addr = start_addr + len;

                        <span class="tok-kw">return</span> .{
                            .start = start_addr,
                            .end = end_addr,
                        };
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
                }
            },
            .debug_ranges =&gt; {
                <span class="tok-kw">const</span> start_addr = <span class="tok-kw">try</span> self.fbr.readInt(<span class="tok-type">usize</span>);
                <span class="tok-kw">const</span> end_addr = <span class="tok-kw">try</span> self.fbr.readInt(<span class="tok-type">usize</span>);
                <span class="tok-kw">if</span> (start_addr == <span class="tok-number">0</span> <span class="tok-kw">and</span> end_addr == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;<span class="tok-comment">

                // This entry selects a new value for the base address
                </span><span class="tok-kw">if</span> (start_addr == <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>)) {
                    self.base_address = end_addr;
                    <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.next();
                }

                <span class="tok-kw">return</span> .{
                    .start = self.base_address + start_addr,
                    .end = self.base_address + end_addr,
                };
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
};

<span class="tok-comment">/// TODO: change this to binary searching the sorted compile unit list</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findCompileUnit</span>(di: *<span class="tok-kw">const</span> <a href="std.debug.Dwarf.html">Dwarf</a>, target_address: <span class="tok-type">u64</span>) !*<a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a> {
    <span class="tok-kw">for</span> (di.compile_unit_list.items) |*compile_unit| {
        <span class="tok-kw">if</span> (compile_unit.pc_range) |range| {
            <span class="tok-kw">if</span> (target_address &gt;= range.start <span class="tok-kw">and</span> target_address &lt; range.end) <span class="tok-kw">return</span> compile_unit;
        }

        <span class="tok-kw">const</span> ranges_value = compile_unit.die.getAttr(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.ranges">ranges</a>) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
        <span class="tok-kw">var</span> iter = <a href="std.debug.Dwarf.DebugRangeIterator.html">DebugRangeIterator</a>.<a href="std.debug.Dwarf.DebugRangeIterator.html#std.debug.Dwarf.DebugRangeIterator.init">init</a>(ranges_value, di, compile_unit) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;
        <span class="tok-kw">while</span> (<span class="tok-kw">try</span> iter.next()) |range| {
            <span class="tok-kw">if</span> (target_address &gt;= range.start <span class="tok-kw">and</span> target_address &lt; range.end) <span class="tok-kw">return</span> compile_unit;
        }
    }

    <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.missing">missing</a>();
}

<span class="tok-comment">/// Gets an already existing AbbrevTable given the abbrev_offset, or if not found,</span>
<span class="tok-comment">/// seeks in the stream and parses it.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">getAbbrevTable</span>(di: *<a href="std.debug.Dwarf.html">Dwarf</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, abbrev_offset: <span class="tok-type">u64</span>) !*<span class="tok-kw">const</span> <a href="std.debug.Dwarf.Abbrev.html">Abbrev</a>.<a href="std.debug.Dwarf.Abbrev.Table.html">Table</a> {
    <span class="tok-kw">for</span> (di.abbrev_table_list.items) |*table| {
        <span class="tok-kw">if</span> (table.offset == abbrev_offset) {
            <span class="tok-kw">return</span> table;
        }
    }
    <span class="tok-kw">try</span> di.abbrev_table_list.append(
        allocator,
        <span class="tok-kw">try</span> di.parseAbbrevTable(allocator, abbrev_offset),
    );
    <span class="tok-kw">return</span> &amp;di.abbrev_table_list.items[di.abbrev_table_list.items.len - <span class="tok-number">1</span>];
}

<span class="tok-kw">fn</span> <span class="tok-fn">parseAbbrevTable</span>(di: *<a href="std.debug.Dwarf.html">Dwarf</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, offset: <span class="tok-type">u64</span>) !<a href="std.debug.Dwarf.Abbrev.html">Abbrev</a>.<a href="std.debug.Dwarf.Abbrev.Table.html">Table</a> {
    <span class="tok-kw">var</span> fbr: <a href="std.debug.FixedBufferReader.html">FixedBufferReader</a> = .{
        .buf = di.section(.debug_abbrev).?,
        .pos = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, offset) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
        .endian = di.endian,
    };

    <span class="tok-kw">var</span> abbrevs = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.debug.Dwarf.Abbrev.html">Abbrev</a>).init(allocator);
    <span class="tok-kw">defer</span> {
        <span class="tok-kw">for</span> (abbrevs.items) |*abbrev| {
            abbrev.deinit(allocator);
        }
        abbrevs.deinit();
    }

    <span class="tok-kw">var</span> attrs = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.debug.Dwarf.Abbrev.html">Abbrev</a>.<a href="std.debug.Dwarf.Abbrev.Attr.html">Attr</a>).init(allocator);
    <span class="tok-kw">defer</span> attrs.deinit();

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> code = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);
        <span class="tok-kw">if</span> (code == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
        <span class="tok-kw">const</span> tag_id = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);
        <span class="tok-kw">const</span> has_children = (<span class="tok-kw">try</span> fbr.readByte()) == <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.CHILDREN.html">CHILDREN</a>.<a href="std.dwarf.CHILDREN.html#std.dwarf.CHILDREN.yes">yes</a>;

        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">const</span> attr_id = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);
            <span class="tok-kw">const</span> form_id = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);
            <span class="tok-kw">if</span> (attr_id == <span class="tok-number">0</span> <span class="tok-kw">and</span> form_id == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            <span class="tok-kw">try</span> attrs.append(.{
                .id = attr_id,
                .form_id = form_id,
                .payload = <span class="tok-kw">switch</span> (form_id) {
                    <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.implicit_const">implicit_const</a> =&gt; <span class="tok-kw">try</span> fbr.readIleb128(<span class="tok-type">i64</span>),
                    <span class="tok-kw">else</span> =&gt; <span class="tok-null">undefined</span>,
                },
            });
        }

        <span class="tok-kw">try</span> abbrevs.append(.{
            .code = code,
            .tag_id = tag_id,
            .has_children = has_children,
            .attrs = <span class="tok-kw">try</span> attrs.toOwnedSlice(),
        });
    }

    <span class="tok-kw">return</span> .{
        .offset = offset,
        .abbrevs = <span class="tok-kw">try</span> abbrevs.toOwnedSlice(),
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">parseDie</span>(
    fbr: *<a href="std.debug.FixedBufferReader.html">FixedBufferReader</a>,
    attrs_buf: []<a href="std.debug.Dwarf.Die.html">Die</a>.<a href="std.debug.Dwarf.Die.Attr.html">Attr</a>,
    abbrev_table: *<span class="tok-kw">const</span> <a href="std.debug.Dwarf.Abbrev.html">Abbrev</a>.<a href="std.debug.Dwarf.Abbrev.Table.html">Table</a>,
    format: <a href="std.dwarf.Format.html">Format</a>,
) <a href="std.debug.Dwarf.html#std.debug.Dwarf.ScanError">ScanError</a>!?<a href="std.debug.Dwarf.Die.html">Die</a> {
    <span class="tok-kw">const</span> abbrev_code = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);
    <span class="tok-kw">if</span> (abbrev_code == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> table_entry = abbrev_table.get(abbrev_code) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

    <span class="tok-kw">const</span> attrs = attrs_buf[<span class="tok-number">0</span>..table_entry.attrs.len];
    <span class="tok-kw">for</span> (attrs, table_entry.attrs) |*result_attr, attr| result_attr.* = <a href="std.debug.Dwarf.Die.html">Die</a>.<a href="std.debug.Dwarf.Die.Attr.html">Attr</a>{
        .id = attr.id,
        .value = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.parseFormValue">parseFormValue</a>(
            fbr,
            attr.form_id,
            format,
            attr.payload,
        ),
    };
    <span class="tok-kw">return</span> .{
        .tag_id = table_entry.tag_id,
        .has_children = table_entry.has_children,
        .attrs = attrs,
    };
}

<span class="tok-comment">/// Ensures that addresses in the returned LineTable are monotonically increasing.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">runLineNumberProgram</span>(d: *<a href="std.debug.Dwarf.html">Dwarf</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, compile_unit: *<a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a>) !<a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a>.<a href="std.debug.Dwarf.CompileUnit.SrcLocCache.html">SrcLocCache</a> {
    <span class="tok-kw">const</span> compile_unit_cwd = <span class="tok-kw">try</span> compile_unit.die.getAttrString(d, <a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.comp_dir">comp_dir</a>, d.section(.debug_line_str), compile_unit.*);
    <span class="tok-kw">const</span> line_info_offset = <span class="tok-kw">try</span> compile_unit.die.getAttrSecOffset(<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.stmt_list">stmt_list</a>);

    <span class="tok-kw">var</span> fbr: <a href="std.debug.FixedBufferReader.html">FixedBufferReader</a> = .{
        .buf = d.section(.debug_line).?,
        .endian = d.endian,
    };
    <span class="tok-kw">try</span> fbr.seekTo(line_info_offset);

    <span class="tok-kw">const</span> unit_header = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.readUnitHeader">readUnitHeader</a>(&amp;fbr, <span class="tok-null">null</span>);
    <span class="tok-kw">if</span> (unit_header.unit_length == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.missing">missing</a>();

    <span class="tok-kw">const</span> next_offset = unit_header.header_length + unit_header.unit_length;

    <span class="tok-kw">const</span> version = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>);
    <span class="tok-kw">if</span> (version &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

    <span class="tok-kw">const</span> addr_size: <span class="tok-type">u8</span>, <span class="tok-kw">const</span> seg_size: <span class="tok-type">u8</span> = <span class="tok-kw">if</span> (version &gt;= <span class="tok-number">5</span>) .{
        <span class="tok-kw">try</span> fbr.readByte(),
        <span class="tok-kw">try</span> fbr.readByte(),
    } <span class="tok-kw">else</span> .{
        <span class="tok-kw">switch</span> (unit_header.format) {
            .@&quot;32&quot; =&gt; <span class="tok-number">4</span>,
            .@&quot;64&quot; =&gt; <span class="tok-number">8</span>,
        },
        <span class="tok-number">0</span>,
    };
    _ = addr_size;
    _ = seg_size;

    <span class="tok-kw">const</span> prologue_length = <span class="tok-kw">try</span> fbr.readAddress(unit_header.format);
    <span class="tok-kw">const</span> prog_start_offset = fbr.pos + prologue_length;

    <span class="tok-kw">const</span> minimum_instruction_length = <span class="tok-kw">try</span> fbr.readByte();
    <span class="tok-kw">if</span> (minimum_instruction_length == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

    <span class="tok-kw">if</span> (version &gt;= <span class="tok-number">4</span>) {
        <span class="tok-kw">const</span> maximum_operations_per_instruction = <span class="tok-kw">try</span> fbr.readByte();
        _ = maximum_operations_per_instruction;
    }

    <span class="tok-kw">const</span> default_is_stmt = (<span class="tok-kw">try</span> fbr.readByte()) != <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> line_base = <span class="tok-kw">try</span> fbr.readByteSigned();

    <span class="tok-kw">const</span> line_range = <span class="tok-kw">try</span> fbr.readByte();
    <span class="tok-kw">if</span> (line_range == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

    <span class="tok-kw">const</span> opcode_base = <span class="tok-kw">try</span> fbr.readByte();

    <span class="tok-kw">const</span> standard_opcode_lengths = <span class="tok-kw">try</span> fbr.readBytes(opcode_base - <span class="tok-number">1</span>);

    <span class="tok-kw">var</span> directories: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.debug.Dwarf.FileEntry.html">FileEntry</a>) = .empty;
    <span class="tok-kw">defer</span> directories.deinit(gpa);
    <span class="tok-kw">var</span> file_entries: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.debug.Dwarf.FileEntry.html">FileEntry</a>) = .empty;
    <span class="tok-kw">defer</span> file_entries.deinit(gpa);

    <span class="tok-kw">if</span> (version &lt; <span class="tok-number">5</span>) {
        <span class="tok-kw">try</span> directories.append(gpa, .{ .path = compile_unit_cwd });

        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">const</span> dir = <span class="tok-kw">try</span> fbr.readBytesTo(<span class="tok-number">0</span>);
            <span class="tok-kw">if</span> (dir.len == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            <span class="tok-kw">try</span> directories.append(gpa, .{ .path = dir });
        }

        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">const</span> file_name = <span class="tok-kw">try</span> fbr.readBytesTo(<span class="tok-number">0</span>);
            <span class="tok-kw">if</span> (file_name.len == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            <span class="tok-kw">const</span> dir_index = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u32</span>);
            <span class="tok-kw">const</span> mtime = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);
            <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);
            <span class="tok-kw">try</span> file_entries.append(gpa, .{
                .path = file_name,
                .dir_index = dir_index,
                .mtime = mtime,
                .size = size,
            });
        }
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> FileEntFmt = <span class="tok-kw">struct</span> {
            content_type_code: <span class="tok-type">u16</span>,
            form_code: <span class="tok-type">u16</span>,
        };
        {
            <span class="tok-kw">var</span> dir_ent_fmt_buf: [<span class="tok-number">10</span>]FileEntFmt = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> directory_entry_format_count = <span class="tok-kw">try</span> fbr.readByte();
            <span class="tok-kw">if</span> (directory_entry_format_count &gt; dir_ent_fmt_buf.len) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
            <span class="tok-kw">for</span> (dir_ent_fmt_buf[<span class="tok-number">0</span>..directory_entry_format_count]) |*ent_fmt| {
                ent_fmt.* = .{
                    .content_type_code = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u8</span>),
                    .form_code = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u16</span>),
                };
            }

            <span class="tok-kw">const</span> directories_count = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">usize</span>);

            <span class="tok-kw">for</span> (<span class="tok-kw">try</span> directories.addManyAsSlice(gpa, directories_count)) |*e| {
                e.* = .{ .path = &amp;.{} };
                <span class="tok-kw">for</span> (dir_ent_fmt_buf[<span class="tok-number">0</span>..directory_entry_format_count]) |ent_fmt| {
                    <span class="tok-kw">const</span> form_value = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.parseFormValue">parseFormValue</a>(
                        &amp;fbr,
                        ent_fmt.form_code,
                        unit_header.format,
                        <span class="tok-null">null</span>,
                    );
                    <span class="tok-kw">switch</span> (ent_fmt.content_type_code) {
                        <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNCT.html">LNCT</a>.<a href="std.dwarf.LNCT.html#std.dwarf.LNCT.path">path</a> =&gt; e.path = <span class="tok-kw">try</span> form_value.getString(d.*),
                        <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNCT.html">LNCT</a>.<a href="std.dwarf.LNCT.html#std.dwarf.LNCT.directory_index">directory_index</a> =&gt; e.dir_index = <span class="tok-kw">try</span> form_value.getUInt(<span class="tok-type">u32</span>),
                        <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNCT.html">LNCT</a>.<a href="std.dwarf.LNCT.html#std.dwarf.LNCT.timestamp">timestamp</a> =&gt; e.mtime = <span class="tok-kw">try</span> form_value.getUInt(<span class="tok-type">u64</span>),
                        <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNCT.html">LNCT</a>.<a href="std.dwarf.LNCT.html#std.dwarf.LNCT.size">size</a> =&gt; e.size = <span class="tok-kw">try</span> form_value.getUInt(<span class="tok-type">u64</span>),
                        <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNCT.html">LNCT</a>.<a href="std.dwarf.LNCT.html#std.dwarf.LNCT.MD5">MD5</a> =&gt; e.md5 = <span class="tok-kw">switch</span> (form_value) {
                            .data16 =&gt; |data16| data16.*,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,
                    }
                }
            }
        }

        <span class="tok-kw">var</span> file_ent_fmt_buf: [<span class="tok-number">10</span>]FileEntFmt = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> file_name_entry_format_count = <span class="tok-kw">try</span> fbr.readByte();
        <span class="tok-kw">if</span> (file_name_entry_format_count &gt; file_ent_fmt_buf.len) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
        <span class="tok-kw">for</span> (file_ent_fmt_buf[<span class="tok-number">0</span>..file_name_entry_format_count]) |*ent_fmt| {
            ent_fmt.* = .{
                .content_type_code = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u16</span>),
                .form_code = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u16</span>),
            };
        }

        <span class="tok-kw">const</span> file_names_count = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">usize</span>);
        <span class="tok-kw">try</span> file_entries.ensureUnusedCapacity(gpa, file_names_count);

        <span class="tok-kw">for</span> (<span class="tok-kw">try</span> file_entries.addManyAsSlice(gpa, file_names_count)) |*e| {
            e.* = .{ .path = &amp;.{} };
            <span class="tok-kw">for</span> (file_ent_fmt_buf[<span class="tok-number">0</span>..file_name_entry_format_count]) |ent_fmt| {
                <span class="tok-kw">const</span> form_value = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.parseFormValue">parseFormValue</a>(
                    &amp;fbr,
                    ent_fmt.form_code,
                    unit_header.format,
                    <span class="tok-null">null</span>,
                );
                <span class="tok-kw">switch</span> (ent_fmt.content_type_code) {
                    <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNCT.html">LNCT</a>.<a href="std.dwarf.LNCT.html#std.dwarf.LNCT.path">path</a> =&gt; e.path = <span class="tok-kw">try</span> form_value.getString(d.*),
                    <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNCT.html">LNCT</a>.<a href="std.dwarf.LNCT.html#std.dwarf.LNCT.directory_index">directory_index</a> =&gt; e.dir_index = <span class="tok-kw">try</span> form_value.getUInt(<span class="tok-type">u32</span>),
                    <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNCT.html">LNCT</a>.<a href="std.dwarf.LNCT.html#std.dwarf.LNCT.timestamp">timestamp</a> =&gt; e.mtime = <span class="tok-kw">try</span> form_value.getUInt(<span class="tok-type">u64</span>),
                    <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNCT.html">LNCT</a>.<a href="std.dwarf.LNCT.html#std.dwarf.LNCT.size">size</a> =&gt; e.size = <span class="tok-kw">try</span> form_value.getUInt(<span class="tok-type">u64</span>),
                    <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNCT.html">LNCT</a>.<a href="std.dwarf.LNCT.html#std.dwarf.LNCT.MD5">MD5</a> =&gt; e.md5 = <span class="tok-kw">switch</span> (form_value) {
                        .data16 =&gt; |data16| data16.*,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,
                }
            }
        }
    }

    <span class="tok-kw">var</span> prog = <a href="std.debug.Dwarf.LineNumberProgram.html">LineNumberProgram</a>.<a href="std.debug.Dwarf.LineNumberProgram.html#std.debug.Dwarf.LineNumberProgram.init">init</a>(default_is_stmt, version);
    <span class="tok-kw">var</span> line_table: <a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a>.<a href="std.debug.Dwarf.CompileUnit.SrcLocCache.html">SrcLocCache</a>.<a href="std.debug.Dwarf.CompileUnit.SrcLocCache.html#std.debug.Dwarf.CompileUnit.SrcLocCache.LineTable">LineTable</a> = .{};
    <span class="tok-kw">errdefer</span> line_table.deinit(gpa);

    <span class="tok-kw">try</span> fbr.seekTo(prog_start_offset);

    <span class="tok-kw">const</span> next_unit_pos = line_info_offset + next_offset;

    <span class="tok-kw">while</span> (fbr.pos &lt; next_unit_pos) {
        <span class="tok-kw">const</span> opcode = <span class="tok-kw">try</span> fbr.readByte();

        <span class="tok-kw">if</span> (opcode == <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNS.html">LNS</a>.<a href="std.dwarf.LNS.html#std.dwarf.LNS.extended_op">extended_op</a>) {
            <span class="tok-kw">const</span> op_size = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);
            <span class="tok-kw">if</span> (op_size &lt; <span class="tok-number">1</span>) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
            <span class="tok-kw">const</span> sub_op = <span class="tok-kw">try</span> fbr.readByte();
            <span class="tok-kw">switch</span> (sub_op) {
                <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNE.html">LNE</a>.<a href="std.dwarf.LNE.html#std.dwarf.LNE.end_sequence">end_sequence</a> =&gt; {<span class="tok-comment">
                    // The row being added here is an &quot;end&quot; address, meaning
                    // that it does not map to the source location here -
                    // rather it marks the previous address as the last address
                    // that maps to this source location.

                    // In this implementation we don't mark end of addresses.
                    // This is a performance optimization based on the fact
                    // that we don't need to know if an address is missing
                    // source location info; we are only interested in being
                    // able to look up source location info for addresses that
                    // are known to have debug info.
                    //if (debug_debug_mode) assert(!line_table.contains(prog.address));
                    //try line_table.put(gpa, prog.address, CompileUnit.SrcLocCache.LineEntry.invalid);
                    </span>prog.reset();
                },
                <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNE.html">LNE</a>.<a href="std.dwarf.LNE.html#std.dwarf.LNE.set_address">set_address</a> =&gt; {
                    <span class="tok-kw">const</span> addr = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">usize</span>);
                    prog.address = addr;
                },
                <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNE.html">LNE</a>.<a href="std.dwarf.LNE.html#std.dwarf.LNE.define_file">define_file</a> =&gt; {
                    <span class="tok-kw">const</span> path = <span class="tok-kw">try</span> fbr.readBytesTo(<span class="tok-number">0</span>);
                    <span class="tok-kw">const</span> dir_index = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u32</span>);
                    <span class="tok-kw">const</span> mtime = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);
                    <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);
                    <span class="tok-kw">try</span> file_entries.append(gpa, .{
                        .path = path,
                        .dir_index = dir_index,
                        .mtime = mtime,
                        .size = size,
                    });
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> fbr.seekForward(op_size - <span class="tok-number">1</span>),
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (opcode &gt;= opcode_base) {<span class="tok-comment">
            // special opcodes
            </span><span class="tok-kw">const</span> adjusted_opcode = opcode - opcode_base;
            <span class="tok-kw">const</span> inc_addr = minimum_instruction_length * (adjusted_opcode / line_range);
            <span class="tok-kw">const</span> inc_line = <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, line_base) + <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, adjusted_opcode % line_range);
            prog.line += inc_line;
            prog.address += inc_addr;
            <span class="tok-kw">try</span> prog.addRow(gpa, &amp;line_table);
            prog.basic_block = <span class="tok-null">false</span>;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">switch</span> (opcode) {
                <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNS.html">LNS</a>.<a href="std.dwarf.LNS.html#std.dwarf.LNS.copy">copy</a> =&gt; {
                    <span class="tok-kw">try</span> prog.addRow(gpa, &amp;line_table);
                    prog.basic_block = <span class="tok-null">false</span>;
                },
                <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNS.html">LNS</a>.<a href="std.dwarf.LNS.html#std.dwarf.LNS.advance_pc">advance_pc</a> =&gt; {
                    <span class="tok-kw">const</span> arg = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">usize</span>);
                    prog.address += arg * minimum_instruction_length;
                },
                <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNS.html">LNS</a>.<a href="std.dwarf.LNS.html#std.dwarf.LNS.advance_line">advance_line</a> =&gt; {
                    <span class="tok-kw">const</span> arg = <span class="tok-kw">try</span> fbr.readIleb128(<span class="tok-type">i64</span>);
                    prog.line += arg;
                },
                <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNS.html">LNS</a>.<a href="std.dwarf.LNS.html#std.dwarf.LNS.set_file">set_file</a> =&gt; {
                    <span class="tok-kw">const</span> arg = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">usize</span>);
                    prog.file = arg;
                },
                <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNS.html">LNS</a>.<a href="std.dwarf.LNS.html#std.dwarf.LNS.set_column">set_column</a> =&gt; {
                    <span class="tok-kw">const</span> arg = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);
                    prog.column = arg;
                },
                <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNS.html">LNS</a>.<a href="std.dwarf.LNS.html#std.dwarf.LNS.negate_stmt">negate_stmt</a> =&gt; {
                    prog.is_stmt = !prog.is_stmt;
                },
                <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNS.html">LNS</a>.<a href="std.dwarf.LNS.html#std.dwarf.LNS.set_basic_block">set_basic_block</a> =&gt; {
                    prog.basic_block = <span class="tok-null">true</span>;
                },
                <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNS.html">LNS</a>.<a href="std.dwarf.LNS.html#std.dwarf.LNS.const_add_pc">const_add_pc</a> =&gt; {
                    <span class="tok-kw">const</span> inc_addr = minimum_instruction_length * ((<span class="tok-number">255</span> - opcode_base) / line_range);
                    prog.address += inc_addr;
                },
                <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNS.html">LNS</a>.<a href="std.dwarf.LNS.html#std.dwarf.LNS.fixed_advance_pc">fixed_advance_pc</a> =&gt; {
                    <span class="tok-kw">const</span> arg = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>);
                    prog.address += arg;
                },
                <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.LNS.html">LNS</a>.<a href="std.dwarf.LNS.html#std.dwarf.LNS.set_prologue_end">set_prologue_end</a> =&gt; {},
                <span class="tok-kw">else</span> =&gt; {
                    <span class="tok-kw">if</span> (opcode - <span class="tok-number">1</span> &gt;= standard_opcode_lengths.len) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
                    <span class="tok-kw">try</span> fbr.seekForward(standard_opcode_lengths[opcode - <span class="tok-number">1</span>]);
                },
            }
        }
    }<span class="tok-comment">

    // Dwarf standard v5, 6.2.5 says
    // &gt; Within a sequence, addresses and operation pointers may only increase.
    // However, this is empirically not the case in reality, so we sort here.
    </span>line_table.sortUnstable(<span class="tok-kw">struct</span> {
        keys: []<span class="tok-kw">const</span> <span class="tok-type">u64</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@This</span>(), a_index: <span class="tok-type">usize</span>, b_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> ctx.keys[a_index] &lt; ctx.keys[b_index];
        }
    }{ .keys = line_table.keys() });

    <span class="tok-kw">return</span> .{
        .line_table = line_table,
        .directories = <span class="tok-kw">try</span> directories.toOwnedSlice(gpa),
        .files = <span class="tok-kw">try</span> file_entries.toOwnedSlice(gpa),
        .version = version,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">populateSrcLocCache</span>(d: *<a href="std.debug.Dwarf.html">Dwarf</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, cu: *<a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a>) <a href="std.debug.Dwarf.html#std.debug.Dwarf.ScanError">ScanError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (cu.src_loc_cache != <span class="tok-null">null</span>) <span class="tok-kw">return</span>;
    cu.src_loc_cache = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.runLineNumberProgram">runLineNumberProgram</a>(d, gpa, cu);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLineNumberInfo</span>(
    d: *<a href="std.debug.Dwarf.html">Dwarf</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    compile_unit: *<a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a>,
    target_address: <span class="tok-type">u64</span>,
) !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SourceLocation.html">SourceLocation</a> {
    <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.populateSrcLocCache">populateSrcLocCache</a>(d, gpa, compile_unit);
    <span class="tok-kw">const</span> slc = &amp;compile_unit.src_loc_cache.?;
    <span class="tok-kw">const</span> entry = <span class="tok-kw">try</span> slc.findSource(target_address);
    <span class="tok-kw">const</span> file_index = entry.file - <span class="tok-builtin">@intFromBool</span>(slc.version &lt; <span class="tok-number">5</span>);
    <span class="tok-kw">if</span> (file_index &gt;= slc.files.len) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
    <span class="tok-kw">const</span> file_entry = &amp;slc.files[file_index];
    <span class="tok-kw">if</span> (file_entry.dir_index &gt;= slc.directories.len) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
    <span class="tok-kw">const</span> dir_name = slc.directories[file_entry.dir_index].path;
    <span class="tok-kw">const</span> file_name = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>(gpa, &amp;.{ dir_name, file_entry.path });
    <span class="tok-kw">return</span> .{
        .line = entry.line,
        .column = entry.column,
        .file_name = file_name,
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">getString</span>(di: <a href="std.debug.Dwarf.html">Dwarf</a>, offset: <span class="tok-type">u64</span>) ![:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.getStringGeneric">getStringGeneric</a>(di.section(.debug_str), offset);
}

<span class="tok-kw">fn</span> <span class="tok-fn">getLineString</span>(di: <a href="std.debug.Dwarf.html">Dwarf</a>, offset: <span class="tok-type">u64</span>) ![:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.getStringGeneric">getStringGeneric</a>(di.section(.debug_line_str), offset);
}

<span class="tok-kw">fn</span> <span class="tok-fn">readDebugAddr</span>(di: <a href="std.debug.Dwarf.html">Dwarf</a>, compile_unit: <a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a>, index: <span class="tok-type">u64</span>) !<span class="tok-type">u64</span> {
    <span class="tok-kw">const</span> debug_addr = di.section(.debug_addr) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();<span class="tok-comment">

    // addr_base points to the first item after the header, however we
    // need to read the header to know the size of each item. Empirically,
    // it may disagree with is_64 on the compile unit.
    // The header is 8 or 12 bytes depending on is_64.
    </span><span class="tok-kw">if</span> (compile_unit.addr_base &lt; <span class="tok-number">8</span>) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

    <span class="tok-kw">const</span> version = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u16</span>, debug_addr[compile_unit.addr_base - <span class="tok-number">4</span> ..][<span class="tok-number">0</span>..<span class="tok-number">2</span>], di.endian);
    <span class="tok-kw">if</span> (version != <span class="tok-number">5</span>) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

    <span class="tok-kw">const</span> addr_size = debug_addr[compile_unit.addr_base - <span class="tok-number">2</span>];
    <span class="tok-kw">const</span> seg_size = debug_addr[compile_unit.addr_base - <span class="tok-number">1</span>];

    <span class="tok-kw">const</span> byte_offset = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(compile_unit.addr_base + (addr_size + seg_size) * index));
    <span class="tok-kw">if</span> (byte_offset + addr_size &gt; debug_addr.len) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (addr_size) {
        <span class="tok-number">1</span> =&gt; debug_addr[byte_offset],
        <span class="tok-number">2</span> =&gt; <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u16</span>, debug_addr[byte_offset..][<span class="tok-number">0</span>..<span class="tok-number">2</span>], di.endian),
        <span class="tok-number">4</span> =&gt; <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, debug_addr[byte_offset..][<span class="tok-number">0</span>..<span class="tok-number">4</span>], di.endian),
        <span class="tok-number">8</span> =&gt; <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u64</span>, debug_addr[byte_offset..][<span class="tok-number">0</span>..<span class="tok-number">8</span>], di.endian),
        <span class="tok-kw">else</span> =&gt; <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
    };
}

<span class="tok-comment">/// If `.eh_frame_hdr` is present, then only the header needs to be parsed. Otherwise, `.eh_frame`</span>
<span class="tok-comment">/// and `.debug_frame` are scanned and a sorted list of FDEs is built for binary searching during</span>
<span class="tok-comment">/// unwinding. Even if `.eh_frame_hdr` is used, we may find during unwinding that it's incomplete,</span>
<span class="tok-comment">/// in which case we build the sorted list of FDEs at that point.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See also `scanCieFdeInfo`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">scanAllUnwindInfo</span>(di: *<a href="std.debug.Dwarf.html">Dwarf</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, base_address: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (di.section(.eh_frame_hdr)) |eh_frame_hdr| blk: {
        <span class="tok-kw">var</span> fbr: <a href="std.debug.FixedBufferReader.html">FixedBufferReader</a> = .{ .buf = eh_frame_hdr, .endian = <a href="std.debug.Dwarf.html#std.debug.Dwarf.native_endian">native_endian</a> };

        <span class="tok-kw">const</span> version = <span class="tok-kw">try</span> fbr.readByte();
        <span class="tok-kw">if</span> (version != <span class="tok-number">1</span>) <span class="tok-kw">break</span> :blk;

        <span class="tok-kw">const</span> eh_frame_ptr_enc = <span class="tok-kw">try</span> fbr.readByte();
        <span class="tok-kw">if</span> (eh_frame_ptr_enc == <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.omit">omit</a>) <span class="tok-kw">break</span> :blk;
        <span class="tok-kw">const</span> fde_count_enc = <span class="tok-kw">try</span> fbr.readByte();
        <span class="tok-kw">if</span> (fde_count_enc == <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.omit">omit</a>) <span class="tok-kw">break</span> :blk;
        <span class="tok-kw">const</span> table_enc = <span class="tok-kw">try</span> fbr.readByte();
        <span class="tok-kw">if</span> (table_enc == <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.omit">omit</a>) <span class="tok-kw">break</span> :blk;

        <span class="tok-kw">const</span> eh_frame_ptr = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.readEhPointer">readEhPointer</a>(&amp;fbr, eh_frame_ptr_enc, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>), .{
            .pc_rel_base = <span class="tok-builtin">@intFromPtr</span>(&amp;eh_frame_hdr[fbr.pos]),
            .follow_indirect = <span class="tok-null">true</span>,
        }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>()) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

        <span class="tok-kw">const</span> fde_count = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.readEhPointer">readEhPointer</a>(&amp;fbr, fde_count_enc, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>), .{
            .pc_rel_base = <span class="tok-builtin">@intFromPtr</span>(&amp;eh_frame_hdr[fbr.pos]),
            .follow_indirect = <span class="tok-null">true</span>,
        }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>()) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

        <span class="tok-kw">const</span> entry_size = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.ExceptionFrameHeader.html">ExceptionFrameHeader</a>.<a href="std.debug.Dwarf.ExceptionFrameHeader.html#std.debug.Dwarf.ExceptionFrameHeader.entrySize">entrySize</a>(table_enc);
        <span class="tok-kw">const</span> entries_len = fde_count * entry_size;
        <span class="tok-kw">if</span> (entries_len &gt; eh_frame_hdr.len - fbr.pos) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();

        di.eh_frame_hdr = .{
            .eh_frame_ptr = eh_frame_ptr,
            .table_enc = table_enc,
            .fde_count = fde_count,
            .entries = eh_frame_hdr[fbr.pos..][<span class="tok-number">0</span>..entries_len],
        };<span class="tok-comment">

        // No need to scan .eh_frame, we have a binary search table already
        </span><span class="tok-kw">return</span>;
    }

    <span class="tok-kw">try</span> di.scanCieFdeInfo(allocator, base_address);
}

<span class="tok-comment">/// Scan `.eh_frame` and `.debug_frame` and build a sorted list of FDEs for binary searching during</span>
<span class="tok-comment">/// unwinding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">scanCieFdeInfo</span>(di: *<a href="std.debug.Dwarf.html">Dwarf</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, base_address: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> frame_sections = [<span class="tok-number">2</span>]<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>{ .eh_frame, .debug_frame };
    <span class="tok-kw">for</span> (frame_sections) |frame_section| {
        <span class="tok-kw">if</span> (di.section(frame_section)) |section_data| {
            <span class="tok-kw">var</span> fbr: <a href="std.debug.FixedBufferReader.html">FixedBufferReader</a> = .{ .buf = section_data, .endian = di.endian };
            <span class="tok-kw">while</span> (fbr.pos &lt; fbr.buf.len) {
                <span class="tok-kw">const</span> entry_header = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.EntryHeader.html">EntryHeader</a>.<a href="std.debug.Dwarf.EntryHeader.html#std.debug.Dwarf.EntryHeader.read">read</a>(&amp;fbr, <span class="tok-null">null</span>, frame_section);
                <span class="tok-kw">switch</span> (entry_header.<span class="tok-type">type</span>) {
                    .cie =&gt; {
                        <span class="tok-kw">const</span> cie = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.CommonInformationEntry.html">CommonInformationEntry</a>.<a href="std.debug.Dwarf.CommonInformationEntry.html#std.debug.Dwarf.CommonInformationEntry.parse">parse</a>(
                            entry_header.entry_bytes,
                            di.sectionVirtualOffset(frame_section, base_address).?,
                            <span class="tok-null">true</span>,
                            entry_header.format,
                            frame_section,
                            entry_header.length_offset,
                            <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),
                            di.endian,
                        );
                        <span class="tok-kw">try</span> di.cie_map.put(allocator, entry_header.length_offset, cie);
                    },
                    .fde =&gt; |cie_offset| {
                        <span class="tok-kw">const</span> cie = di.cie_map.get(cie_offset) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
                        <span class="tok-kw">const</span> fde = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.FrameDescriptionEntry.html">FrameDescriptionEntry</a>.<a href="std.debug.Dwarf.FrameDescriptionEntry.html#std.debug.Dwarf.FrameDescriptionEntry.parse">parse</a>(
                            entry_header.entry_bytes,
                            di.sectionVirtualOffset(frame_section, base_address).?,
                            <span class="tok-null">true</span>,
                            cie,
                            <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),
                            di.endian,
                        );
                        <span class="tok-kw">try</span> di.fde_list.append(allocator, fde);
                    },
                    .terminator =&gt; <span class="tok-kw">break</span>,
                }
            }

            <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sortUnstable">sortUnstable</a>(<a href="std.debug.Dwarf.FrameDescriptionEntry.html">FrameDescriptionEntry</a>, di.fde_list.items, {}, <span class="tok-kw">struct</span> {
                <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-type">void</span>, a: <a href="std.debug.Dwarf.FrameDescriptionEntry.html">FrameDescriptionEntry</a>, b: <a href="std.debug.Dwarf.FrameDescriptionEntry.html">FrameDescriptionEntry</a>) <span class="tok-type">bool</span> {
                    _ = ctx;
                    <span class="tok-kw">return</span> a.pc_begin &lt; b.pc_begin;
                }
            }.lessThan);
        }
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">parseFormValue</span>(
    fbr: *<a href="std.debug.FixedBufferReader.html">FixedBufferReader</a>,
    form_id: <span class="tok-type">u64</span>,
    format: <a href="std.dwarf.Format.html">Format</a>,
    implicit_const: ?<span class="tok-type">i64</span>,
) <a href="std.debug.Dwarf.html#std.debug.Dwarf.ScanError">ScanError</a>!<a href="std.debug.Dwarf.FormValue.html">FormValue</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (form_id) {
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.addr">addr</a> =&gt; .{ .addr = <span class="tok-kw">try</span> fbr.readAddress(<span class="tok-kw">switch</span> (<span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>)) {
            <span class="tok-number">32</span> =&gt; .@&quot;32&quot;,
            <span class="tok-number">64</span> =&gt; .@&quot;64&quot;,
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unsupported @sizeOf(usize)&quot;</span>),
        }) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.addrx1">addrx1</a> =&gt; .{ .addrx = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u8</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.addrx2">addrx2</a> =&gt; .{ .addrx = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.addrx3">addrx3</a> =&gt; .{ .addrx = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u24</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.addrx4">addrx4</a> =&gt; .{ .addrx = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u32</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.addrx">addrx</a> =&gt; .{ .addrx = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">usize</span>) },

        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.block1">block1</a>,
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.block2">block2</a>,
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.block4">block4</a>,
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.block">block</a>,
        =&gt; .{ .block = <span class="tok-kw">try</span> fbr.readBytes(<span class="tok-kw">switch</span> (form_id) {
            <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.block1">block1</a> =&gt; <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u8</span>),
            <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.block2">block2</a> =&gt; <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>),
            <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.block4">block4</a> =&gt; <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u32</span>),
            <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.block">block</a> =&gt; <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">usize</span>),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }) },

        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.data1">data1</a> =&gt; .{ .udata = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u8</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.data2">data2</a> =&gt; .{ .udata = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.data4">data4</a> =&gt; .{ .udata = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u32</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.data8">data8</a> =&gt; .{ .udata = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u64</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.data16">data16</a> =&gt; .{ .data16 = (<span class="tok-kw">try</span> fbr.readBytes(<span class="tok-number">16</span>))[<span class="tok-number">0</span>..<span class="tok-number">16</span>] },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.udata">udata</a> =&gt; .{ .udata = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.sdata">sdata</a> =&gt; .{ .sdata = <span class="tok-kw">try</span> fbr.readIleb128(<span class="tok-type">i64</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.exprloc">exprloc</a> =&gt; .{ .exprloc = <span class="tok-kw">try</span> fbr.readBytes(<span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">usize</span>)) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.flag">flag</a> =&gt; .{ .flag = (<span class="tok-kw">try</span> fbr.readByte()) != <span class="tok-number">0</span> },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.flag_present">flag_present</a> =&gt; .{ .flag = <span class="tok-null">true</span> },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.sec_offset">sec_offset</a> =&gt; .{ .sec_offset = <span class="tok-kw">try</span> fbr.readAddress(format) },

        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.ref1">ref1</a> =&gt; .{ .ref = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u8</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.ref2">ref2</a> =&gt; .{ .ref = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.ref4">ref4</a> =&gt; .{ .ref = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u32</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.ref8">ref8</a> =&gt; .{ .ref = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u64</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.ref_udata">ref_udata</a> =&gt; .{ .ref = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>) },

        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.ref_addr">ref_addr</a> =&gt; .{ .ref_addr = <span class="tok-kw">try</span> fbr.readAddress(format) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.ref_sig8">ref_sig8</a> =&gt; .{ .ref = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u64</span>) },

        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.string">string</a> =&gt; .{ .string = <span class="tok-kw">try</span> fbr.readBytesTo(<span class="tok-number">0</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.strp">strp</a> =&gt; .{ .strp = <span class="tok-kw">try</span> fbr.readAddress(format) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.strx1">strx1</a> =&gt; .{ .strx = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u8</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.strx2">strx2</a> =&gt; .{ .strx = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.strx3">strx3</a> =&gt; .{ .strx = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u24</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.strx4">strx4</a> =&gt; .{ .strx = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u32</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.strx">strx</a> =&gt; .{ .strx = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">usize</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.line_strp">line_strp</a> =&gt; .{ .line_strp = <span class="tok-kw">try</span> fbr.readAddress(format) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.indirect">indirect</a> =&gt; <a href="std.debug.Dwarf.html#std.debug.Dwarf.parseFormValue">parseFormValue</a>(fbr, <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>), format, implicit_const),
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.implicit_const">implicit_const</a> =&gt; .{ .sdata = implicit_const <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>() },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.loclistx">loclistx</a> =&gt; .{ .loclistx = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>) },
        <a href="std.dwarf.FORM.html">FORM</a>.<a href="std.dwarf.FORM.html#std.dwarf.FORM.rnglistx">rnglistx</a> =&gt; .{ .rnglistx = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>) },
        <span class="tok-kw">else</span> =&gt; {<span class="tok-comment">
            //debug.print(&quot;unrecognized form id: {x}\n&quot;, .{form_id});
            </span><span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
        },
    };
}

<span class="tok-kw">const</span> FileEntry = <span class="tok-kw">struct</span> {
    path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    dir_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,
    mtime: <span class="tok-type">u64</span> = <span class="tok-number">0</span>,
    size: <span class="tok-type">u64</span> = <span class="tok-number">0</span>,
    md5: [<span class="tok-number">16</span>]<span class="tok-type">u8</span> = [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-number">16</span>,
};

<span class="tok-kw">const</span> LineNumberProgram = <span class="tok-kw">struct</span> {
    address: <span class="tok-type">u64</span>,
    file: <span class="tok-type">usize</span>,
    line: <span class="tok-type">i64</span>,
    column: <span class="tok-type">u64</span>,
    version: <span class="tok-type">u16</span>,
    is_stmt: <span class="tok-type">bool</span>,
    basic_block: <span class="tok-type">bool</span>,

    default_is_stmt: <span class="tok-type">bool</span>,<span class="tok-comment">

    // Reset the state machine following the DWARF specification
    </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.debug.Dwarf.LineNumberProgram.html">LineNumberProgram</a>) <span class="tok-type">void</span> {
        self.address = <span class="tok-number">0</span>;
        self.file = <span class="tok-number">1</span>;
        self.line = <span class="tok-number">1</span>;
        self.column = <span class="tok-number">0</span>;
        self.is_stmt = self.default_is_stmt;
        self.basic_block = <span class="tok-null">false</span>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(is_stmt: <span class="tok-type">bool</span>, version: <span class="tok-type">u16</span>) <a href="std.debug.Dwarf.LineNumberProgram.html">LineNumberProgram</a> {
        <span class="tok-kw">return</span> .{
            .address = <span class="tok-number">0</span>,
            .file = <span class="tok-number">1</span>,
            .line = <span class="tok-number">1</span>,
            .column = <span class="tok-number">0</span>,
            .version = version,
            .is_stmt = is_stmt,
            .basic_block = <span class="tok-null">false</span>,
            .default_is_stmt = is_stmt,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addRow</span>(prog: *<a href="std.debug.Dwarf.LineNumberProgram.html">LineNumberProgram</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, table: *<a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a>.<a href="std.debug.Dwarf.CompileUnit.SrcLocCache.html">SrcLocCache</a>.<a href="std.debug.Dwarf.CompileUnit.SrcLocCache.html#std.debug.Dwarf.CompileUnit.SrcLocCache.LineTable">LineTable</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (prog.line == <span class="tok-number">0</span>) {<span class="tok-comment">
            //if (debug_debug_mode) @panic(&quot;garbage line data&quot;);
            </span><span class="tok-kw">return</span>;
        }
        <span class="tok-kw">if</span> (<a href="std.debug.Dwarf.html#std.debug.Dwarf.debug_debug_mode">debug_debug_mode</a>) <a href="std.debug.html#std.debug.assert">assert</a>(!table.contains(prog.address));
        <span class="tok-kw">try</span> table.put(gpa, prog.address, .{
            .line = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u32</span>, prog.line) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>),
            .column = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u32</span>, prog.column) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>),
            .file = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u32</span>, prog.file) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
        });
    }
};

<span class="tok-kw">const</span> UnitHeader = <span class="tok-kw">struct</span> {
    format: <a href="std.dwarf.Format.html">Format</a>,
    header_length: <span class="tok-type">u4</span>,
    unit_length: <span class="tok-type">u64</span>,
};

<span class="tok-kw">fn</span> <span class="tok-fn">readUnitHeader</span>(fbr: *<a href="std.debug.FixedBufferReader.html">FixedBufferReader</a>, opt_ma: ?*<a href="std.debug.MemoryAccessor.html">MemoryAccessor</a>) <a href="std.debug.Dwarf.html#std.debug.Dwarf.ScanError">ScanError</a>!<a href="std.debug.Dwarf.UnitHeader.html">UnitHeader</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> <span class="tok-kw">if</span> (opt_ma) |ma| fbr.readIntChecked(<span class="tok-type">u32</span>, ma) <span class="tok-kw">else</span> fbr.readInt(<span class="tok-type">u32</span>)) {
        <span class="tok-number">0</span>...<span class="tok-number">0xfffffff0</span> - <span class="tok-number">1</span> =&gt; |unit_length| .{
            .format = .@&quot;32&quot;,
            .header_length = <span class="tok-number">4</span>,
            .unit_length = unit_length,
        },
        <span class="tok-number">0xfffffff0</span>...<span class="tok-number">0xffffffff</span> - <span class="tok-number">1</span> =&gt; <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
        <span class="tok-number">0xffffffff</span> =&gt; .{
            .format = .@&quot;64&quot;,
            .header_length = <span class="tok-number">12</span>,
            .unit_length = <span class="tok-kw">try</span> <span class="tok-kw">if</span> (opt_ma) |ma| fbr.readIntChecked(<span class="tok-type">u64</span>, ma) <span class="tok-kw">else</span> fbr.readInt(<span class="tok-type">u64</span>),
        },
    };
}

<span class="tok-comment">/// Returns the DWARF register number for an x86_64 register number found in compact unwind info</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">compactUnwindToDwarfRegNumber</span>(unwind_reg_number: <span class="tok-type">u3</span>) !<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (unwind_reg_number) {
        <span class="tok-number">1</span> =&gt; <span class="tok-number">3</span>,<span class="tok-comment"> // RBX
        </span><span class="tok-number">2</span> =&gt; <span class="tok-number">12</span>,<span class="tok-comment"> // R12
        </span><span class="tok-number">3</span> =&gt; <span class="tok-number">13</span>,<span class="tok-comment"> // R13
        </span><span class="tok-number">4</span> =&gt; <span class="tok-number">14</span>,<span class="tok-comment"> // R14
        </span><span class="tok-number">5</span> =&gt; <span class="tok-number">15</span>,<span class="tok-comment"> // R15
        </span><span class="tok-number">6</span> =&gt; <span class="tok-number">6</span>,<span class="tok-comment"> // RBP
        </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">error</span>.InvalidUnwindRegisterNumber,
    };
}

<span class="tok-comment">/// This function is to make it handy to comment out the return and make it</span>
<span class="tok-comment">/// into a crash when working on this file.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bad</span>() <span class="tok-kw">error</span>{InvalidDebugInfo} {
    <span class="tok-kw">if</span> (<a href="std.debug.Dwarf.html#std.debug.Dwarf.debug_debug_mode">debug_debug_mode</a>) <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;bad dwarf&quot;</span>);
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;
}

<span class="tok-kw">fn</span> <span class="tok-fn">missing</span>() <span class="tok-kw">error</span>{MissingDebugInfo} {
    <span class="tok-kw">if</span> (<a href="std.debug.Dwarf.html#std.debug.Dwarf.debug_debug_mode">debug_debug_mode</a>) <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;missing dwarf&quot;</span>);
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
}

<span class="tok-kw">fn</span> <span class="tok-fn">getStringGeneric</span>(opt_str: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) ![:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> str = opt_str <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
    <span class="tok-kw">if</span> (offset &gt; str.len) <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
    <span class="tok-kw">const</span> casted_offset = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, offset) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();<span class="tok-comment">
    // Valid strings always have a terminating zero byte
    </span><span class="tok-kw">const</span> last = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalarPos">indexOfScalarPos</a>(<span class="tok-type">u8</span>, str, casted_offset, <span class="tok-number">0</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
    <span class="tok-kw">return</span> str[casted_offset..last :<span class="tok-number">0</span>];
}

<span class="tok-kw">const</span> EhPointerContext = <span class="tok-kw">struct</span> {<span class="tok-comment">
    // The address of the pointer field itself
    </span>pc_rel_base: <span class="tok-type">u64</span>,<span class="tok-comment">

    // Whether or not to follow indirect pointers. This should only be
    // used when decoding pointers at runtime using the current process's
    // debug info
    </span>follow_indirect: <span class="tok-type">bool</span>,<span class="tok-comment">

    // These relative addressing modes are only used in specific cases, and
    // might not be available / required in all parsing contexts
    </span>data_rel_base: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>,
    text_rel_base: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>,
    function_rel_base: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>,
};
<span class="tok-kw">fn</span> <span class="tok-fn">readEhPointer</span>(fbr: *<a href="std.debug.FixedBufferReader.html">FixedBufferReader</a>, enc: <span class="tok-type">u8</span>, addr_size_bytes: <span class="tok-type">u8</span>, ctx: <a href="std.debug.Dwarf.EhPointerContext.html">EhPointerContext</a>) !?<span class="tok-type">u64</span> {
    <span class="tok-kw">if</span> (enc == <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.omit">omit</a>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;

    <span class="tok-kw">const</span> value: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        signed: <span class="tok-type">i64</span>,
        unsigned: <span class="tok-type">u64</span>,
    } = <span class="tok-kw">switch</span> (enc &amp; <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.type_mask">type_mask</a>) {
        <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.absptr">absptr</a> =&gt; .{
            .unsigned = <span class="tok-kw">switch</span> (addr_size_bytes) {
                <span class="tok-number">2</span> =&gt; <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>),
                <span class="tok-number">4</span> =&gt; <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u32</span>),
                <span class="tok-number">8</span> =&gt; <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u64</span>),
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidAddrSize,
            },
        },
        <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.uleb128">uleb128</a> =&gt; .{ .unsigned = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>) },
        <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.udata2">udata2</a> =&gt; .{ .unsigned = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>) },
        <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.udata4">udata4</a> =&gt; .{ .unsigned = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u32</span>) },
        <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.udata8">udata8</a> =&gt; .{ .unsigned = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u64</span>) },
        <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.sleb128">sleb128</a> =&gt; .{ .signed = <span class="tok-kw">try</span> fbr.readIleb128(<span class="tok-type">i64</span>) },
        <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.sdata2">sdata2</a> =&gt; .{ .signed = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">i16</span>) },
        <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.sdata4">sdata4</a> =&gt; .{ .signed = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">i32</span>) },
        <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.sdata8">sdata8</a> =&gt; .{ .signed = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">i64</span>) },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>(),
    };

    <span class="tok-kw">const</span> base = <span class="tok-kw">switch</span> (enc &amp; <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.rel_mask">rel_mask</a>) {
        <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.pcrel">pcrel</a> =&gt; ctx.pc_rel_base,
        <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.textrel">textrel</a> =&gt; ctx.text_rel_base <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PointerBaseNotSpecified,
        <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.datarel">datarel</a> =&gt; ctx.data_rel_base <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PointerBaseNotSpecified,
        <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.funcrel">funcrel</a> =&gt; ctx.function_rel_base <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PointerBaseNotSpecified,
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };

    <span class="tok-kw">const</span> ptr: <span class="tok-type">u64</span> = <span class="tok-kw">if</span> (base) |b| <span class="tok-kw">switch</span> (value) {
        .signed =&gt; |s| <span class="tok-builtin">@intCast</span>(<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(<span class="tok-type">i64</span>, s, <span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-builtin">@intCast</span>(b)))),<span class="tok-comment">
        // absptr can actually contain signed values in some cases (aarch64 MachO)
        </span>.unsigned =&gt; |u| u +% b,
    } <span class="tok-kw">else</span> <span class="tok-kw">switch</span> (value) {
        .signed =&gt; |s| <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intCast</span>(s)),
        .unsigned =&gt; |u| u,
    };

    <span class="tok-kw">if</span> ((enc &amp; <a href="std.dwarf.EH.html">EH</a>.<a href="std.dwarf.EH.PE.html">PE</a>.<a href="std.dwarf.EH.PE.html#std.dwarf.EH.PE.indirect">indirect</a>) &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> ctx.follow_indirect) {
        <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) != addr_size_bytes) {<span class="tok-comment">
            // See the documentation for `follow_indirect`
            </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.NonNativeIndirection;
        }

        <span class="tok-kw">const</span> native_ptr = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, ptr) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PointerOverflow;
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (addr_size_bytes) {
            <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span> =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(native_ptr)).*,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedAddrSize,
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> ptr;
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">pcRelBase</span>(field_ptr: <span class="tok-type">usize</span>, pc_rel_offset: <span class="tok-type">i64</span>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (pc_rel_offset &lt; <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.sub">sub</a>(<span class="tok-type">usize</span>, field_ptr, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(-pc_rel_offset)));
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(<span class="tok-type">usize</span>, field_ptr, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(pc_rel_offset)));
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ElfModule = <span class="tok-kw">struct</span> {
    base_address: <span class="tok-type">usize</span>,
    dwarf: <a href="std.debug.Dwarf.html">Dwarf</a>,
    mapped_memory: []<span class="tok-kw">align</span>(<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    external_mapped_memory: ?[]<span class="tok-kw">align</span>(<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-kw">const</span> <span class="tok-type">u8</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
        self.dwarf.deinit(allocator);
        <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.munmap">munmap</a>(self.mapped_memory);
        <span class="tok-kw">if</span> (self.external_mapped_memory) |m| <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.munmap">munmap</a>(m);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Symbol.html">Symbol</a> {<span class="tok-comment">
        // Translate the VA into an address into this object
        </span><span class="tok-kw">const</span> relocated_address = address - self.base_address;
        <span class="tok-kw">return</span> self.dwarf.getSymbol(allocator, relocated_address);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">usize</span>) !?*<a href="std.debug.Dwarf.html">Dwarf</a> {
        _ = allocator;
        _ = address;
        <span class="tok-kw">return</span> &amp;self.dwarf;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> LoadError = <span class="tok-kw">error</span>{
        InvalidDebugInfo,
        MissingDebugInfo,
        InvalidElfMagic,
        InvalidElfVersion,
        InvalidElfEndian,
        <span class="tok-comment">/// TODO: implement this and then remove this error code</span>
        UnimplementedDwarfForeignEndian,
        <span class="tok-comment">/// The debug info may be valid but this implementation uses memory</span>
        <span class="tok-comment">/// mapping which limits things to usize. If the target debug info is</span>
        <span class="tok-comment">/// 64-bit and host is 32-bit, there may be debug info that is not</span>
        <span class="tok-comment">/// supportable using this method.</span>
        Overflow,

        PermissionDenied,
        LockedMemoryLimitExceeded,
        MemoryMappingNotSupported,
    } || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a> || <a href="std.debug.Dwarf.html#std.debug.Dwarf.ScanError">OpenError</a>;

    <span class="tok-comment">/// Reads debug info from an already mapped ELF file.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If the required sections aren't present but a reference to external debug</span>
    <span class="tok-comment">/// info is, then this this function will recurse to attempt to load the debug</span>
    <span class="tok-comment">/// sections from an external file.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">load</span>(
        gpa: <a href="std.mem.Allocator.html">Allocator</a>,
        mapped_mem: []<span class="tok-kw">align</span>(<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        build_id: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        expected_crc: ?<span class="tok-type">u32</span>,
        parent_sections: *<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.SectionArray">SectionArray</a>,
        parent_mapped_mem: ?[]<span class="tok-kw">align</span>(<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        elf_filename: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.debug.Dwarf.ElfModule.html#std.debug.Dwarf.ElfModule.LoadError">LoadError</a>!<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.ElfModule.html">ElfModule</a> {
        <span class="tok-kw">if</span> (expected_crc) |crc| <span class="tok-kw">if</span> (crc != <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.crc.html">crc</a>.<a href="std.hash.crc.html#std.hash.crc.Crc32IsoHdlc">Crc32</a>.<a href="#">hash</a>(mapped_mem)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;

        <span class="tok-kw">const</span> hdr: *<span class="tok-kw">const</span> <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.Ehdr">Ehdr</a> = <span class="tok-builtin">@ptrCast</span>(&amp;mapped_mem[<span class="tok-number">0</span>]);
        <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, hdr.e_ident[<span class="tok-number">0</span>..<span class="tok-number">4</span>], <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.MAGIC">MAGIC</a>)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfMagic;
        <span class="tok-kw">if</span> (hdr.e_ident[<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.EI_VERSION">EI_VERSION</a>] != <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfVersion;

        <span class="tok-kw">const</span> endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a> = <span class="tok-kw">switch</span> (hdr.e_ident[<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.EI_DATA">EI_DATA</a>]) {
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.ELFDATA2LSB">ELFDATA2LSB</a> =&gt; .little,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.ELFDATA2MSB">ELFDATA2MSB</a> =&gt; .big,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfEndian,
        };
        <span class="tok-kw">if</span> (endian != <a href="std.debug.Dwarf.html#std.debug.Dwarf.native_endian">native_endian</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedDwarfForeignEndian;

        <span class="tok-kw">const</span> shoff = hdr.e_shoff;
        <span class="tok-kw">const</span> str_section_off = shoff + <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, hdr.e_shentsize) * <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, hdr.e_shstrndx);
        <span class="tok-kw">const</span> str_shdr: *<span class="tok-kw">const</span> <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.Shdr">Shdr</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mapped_mem[<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, str_section_off) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow]));
        <span class="tok-kw">const</span> header_strings = mapped_mem[str_shdr.sh_offset..][<span class="tok-number">0</span>..str_shdr.sh_size];
        <span class="tok-kw">const</span> shdrs = <span class="tok-builtin">@as</span>(
            [*]<span class="tok-kw">const</span> <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.Shdr">Shdr</a>,
            <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mapped_mem[shoff])),
        )[<span class="tok-number">0</span>..hdr.e_shnum];

        <span class="tok-kw">var</span> sections: <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.SectionArray">SectionArray</a> = <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.null_section_array">null_section_array</a>;<span class="tok-comment">

        // Combine section list. This takes ownership over any owned sections from the parent scope.
        </span><span class="tok-kw">for</span> (parent_sections, &amp;sections) |*parent, *section_elem| {
            <span class="tok-kw">if</span> (parent.*) |*p| {
                section_elem.* = p.*;
                p.owned = <span class="tok-null">false</span>;
            }
        }
        <span class="tok-kw">errdefer</span> <span class="tok-kw">for</span> (sections) |opt_section| <span class="tok-kw">if</span> (opt_section) |s| <span class="tok-kw">if</span> (s.owned) gpa.free(s.data);

        <span class="tok-kw">var</span> separate_debug_filename: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;
        <span class="tok-kw">var</span> separate_debug_crc: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;

        <span class="tok-kw">for</span> (shdrs) |*shdr| {
            <span class="tok-kw">if</span> (shdr.sh_type == <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_NULL">SHT_NULL</a> <span class="tok-kw">or</span> shdr.sh_type == <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_NOBITS">SHT_NOBITS</a>) <span class="tok-kw">continue</span>;
            <span class="tok-kw">const</span> name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(header_strings[shdr.sh_name..], <span class="tok-number">0</span>);

            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.gnu_debuglink&quot;</span>)) {
                <span class="tok-kw">const</span> gnu_debuglink = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.chopSlice">chopSlice</a>(mapped_mem, shdr.sh_offset, shdr.sh_size);
                <span class="tok-kw">const</span> debug_filename = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(gnu_debuglink.ptr)), <span class="tok-number">0</span>);
                <span class="tok-kw">const</span> crc_offset = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, debug_filename.len + <span class="tok-number">1</span>, <span class="tok-number">4</span>);
                <span class="tok-kw">const</span> crc_bytes = gnu_debuglink[crc_offset..][<span class="tok-number">0</span>..<span class="tok-number">4</span>];
                separate_debug_crc = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, crc_bytes, <a href="std.debug.Dwarf.html#std.debug.Dwarf.native_endian">native_endian</a>);
                separate_debug_filename = debug_filename;
                <span class="tok-kw">continue</span>;
            }

            <span class="tok-kw">var</span> section_index: ?<span class="tok-type">usize</span> = <span class="tok-null">null</span>;
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>).@&quot;enum&quot;.fields, <span class="tok-number">0</span>..) |sect, i| {
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;.&quot;</span> ++ sect.name, name)) section_index = i;
            }
            <span class="tok-kw">if</span> (section_index == <span class="tok-null">null</span>) <span class="tok-kw">continue</span>;
            <span class="tok-kw">if</span> (sections[section_index.?] != <span class="tok-null">null</span>) <span class="tok-kw">continue</span>;

            <span class="tok-kw">const</span> section_bytes = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.chopSlice">chopSlice</a>(mapped_mem, shdr.sh_offset, shdr.sh_size);
            sections[section_index.?] = <span class="tok-kw">if</span> ((shdr.sh_flags &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHF_COMPRESSED">SHF_COMPRESSED</a>) &gt; <span class="tok-number">0</span>) blk: {
                <span class="tok-kw">var</span> section_stream = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(section_bytes);
                <span class="tok-kw">const</span> section_reader = section_stream.reader();
                <span class="tok-kw">const</span> chdr = section_reader.readStruct(<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.Chdr">Chdr</a>) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;
                <span class="tok-kw">if</span> (chdr.ch_type != .ZLIB) <span class="tok-kw">continue</span>;

                <span class="tok-kw">var</span> zlib_stream = <a href="std.html">std</a>.<a href="std.compress.html">compress</a>.<a href="std.compress.zlib.html">zlib</a>.<a href="std.compress.zlib.html#std.compress.zlib.decompressor">decompressor</a>(section_reader);

                <span class="tok-kw">const</span> decompressed_section = <span class="tok-kw">try</span> gpa.alloc(<span class="tok-type">u8</span>, chdr.ch_size);
                <span class="tok-kw">errdefer</span> gpa.free(decompressed_section);

                <span class="tok-kw">const</span> read = zlib_stream.reader().readAll(decompressed_section) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;
                <a href="std.debug.html#std.debug.assert">assert</a>(read == decompressed_section.len);

                <span class="tok-kw">break</span> :blk .{
                    .data = decompressed_section,
                    .virtual_address = shdr.sh_addr,
                    .owned = <span class="tok-null">true</span>,
                };
            } <span class="tok-kw">else</span> .{
                .data = section_bytes,
                .virtual_address = shdr.sh_addr,
                .owned = <span class="tok-null">false</span>,
            };
        }

        <span class="tok-kw">const</span> missing_debug_info =
            sections[<span class="tok-builtin">@intFromEnum</span>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>.<a href="#">debug_info</a>)] == <span class="tok-null">null</span> <span class="tok-kw">or</span>
            sections[<span class="tok-builtin">@intFromEnum</span>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>.<a href="#">debug_abbrev</a>)] == <span class="tok-null">null</span> <span class="tok-kw">or</span>
            sections[<span class="tok-builtin">@intFromEnum</span>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>.<a href="#">debug_str</a>)] == <span class="tok-null">null</span> <span class="tok-kw">or</span>
            sections[<span class="tok-builtin">@intFromEnum</span>(<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.Section.html">Section</a>.<a href="std.debug.Dwarf.Section.Id.html">Id</a>.<a href="#">debug_line</a>)] == <span class="tok-null">null</span>;<span class="tok-comment">

        // Attempt to load debug info from an external file
        // See: https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.html
        </span><span class="tok-kw">if</span> (missing_debug_info) {<span class="tok-comment">

            // Only allow one level of debug info nesting
            </span><span class="tok-kw">if</span> (parent_mapped_mem) |_| {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
            }<span class="tok-comment">

            // $XDG_CACHE_HOME/debuginfod_client/&lt;buildid&gt;/debuginfo
            // This only opportunisticly tries to load from the debuginfod cache, but doesn't try to populate it.
            // One can manually run `debuginfod-find debuginfo PATH` to download the symbols
            </span><span class="tok-kw">if</span> (build_id) |id| blk: {
                <span class="tok-kw">var</span> debuginfod_dir: <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a> = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
                    .wasi, .windows =&gt; <span class="tok-kw">break</span> :blk,
                    <span class="tok-kw">else</span> =&gt; dir: {
                        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenv">getenv</a>(<span class="tok-str">&quot;DEBUGINFOD_CACHE_PATH&quot;</span>)) |path| {
                            <span class="tok-kw">break</span> :dir <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.openDirAbsolute">openDirAbsolute</a>(path, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">break</span> :blk;
                        }
                        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenv">getenv</a>(<span class="tok-str">&quot;XDG_CACHE_HOME&quot;</span>)) |cache_path| {
                            <span class="tok-kw">if</span> (cache_path.len &gt; <span class="tok-number">0</span>) {
                                <span class="tok-kw">const</span> path = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>(gpa, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ cache_path, <span class="tok-str">&quot;debuginfod_client&quot;</span> }) <span class="tok-kw">catch</span> <span class="tok-kw">break</span> :blk;
                                <span class="tok-kw">defer</span> gpa.free(path);
                                <span class="tok-kw">break</span> :dir <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.openDirAbsolute">openDirAbsolute</a>(path, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">break</span> :blk;
                            }
                        }
                        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenv">getenv</a>(<span class="tok-str">&quot;HOME&quot;</span>)) |home_path| {
                            <span class="tok-kw">const</span> path = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>(gpa, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ home_path, <span class="tok-str">&quot;.cache&quot;</span>, <span class="tok-str">&quot;debuginfod_client&quot;</span> }) <span class="tok-kw">catch</span> <span class="tok-kw">break</span> :blk;
                            <span class="tok-kw">defer</span> gpa.free(path);
                            <span class="tok-kw">break</span> :dir <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.openDirAbsolute">openDirAbsolute</a>(path, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">break</span> :blk;
                        }
                        <span class="tok-kw">break</span> :blk;
                    },
                };
                <span class="tok-kw">defer</span> debuginfod_dir.close();

                <span class="tok-kw">const</span> filename = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrint">allocPrint</a>(
                    gpa,
                    <span class="tok-str">&quot;{s}/debuginfo&quot;</span>,
                    .{<a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.fmtSliceHexLower">fmtSliceHexLower</a>(id)},
                ) <span class="tok-kw">catch</span> <span class="tok-kw">break</span> :blk;
                <span class="tok-kw">defer</span> gpa.free(filename);

                <span class="tok-kw">const</span> path: <a href="std.Build.Cache.Path.html">Path</a> = .{
                    .root_dir = .{ .path = <span class="tok-null">null</span>, .handle = debuginfod_dir },
                    .sub_path = filename,
                };

                <span class="tok-kw">return</span> <a href="std.debug.Dwarf.ElfModule.html#std.debug.Dwarf.ElfModule.loadPath">loadPath</a>(gpa, path, <span class="tok-null">null</span>, separate_debug_crc, &amp;sections, mapped_mem) <span class="tok-kw">catch</span> <span class="tok-kw">break</span> :blk;
            }

            <span class="tok-kw">const</span> global_debug_directories = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{
                <span class="tok-str">&quot;/usr/lib/debug&quot;</span>,
            };<span class="tok-comment">

            // &lt;global debug directory&gt;/.build-id/&lt;2-character id prefix&gt;/&lt;id remainder&gt;.debug
            </span><span class="tok-kw">if</span> (build_id) |id| blk: {
                <span class="tok-kw">if</span> (id.len &lt; <span class="tok-number">3</span>) <span class="tok-kw">break</span> :blk;<span class="tok-comment">

                // Either md5 (16 bytes) or sha1 (20 bytes) are used here in practice
                </span><span class="tok-kw">const</span> extension = <span class="tok-str">&quot;.debug&quot;</span>;
                <span class="tok-kw">var</span> id_prefix_buf: [<span class="tok-number">2</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">var</span> filename_buf: [<span class="tok-number">38</span> + extension.len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

                _ = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.bufPrint">bufPrint</a>(&amp;id_prefix_buf, <span class="tok-str">&quot;{s}&quot;</span>, .{<a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.fmtSliceHexLower">fmtSliceHexLower</a>(id[<span class="tok-number">0</span>..<span class="tok-number">1</span>])}) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
                <span class="tok-kw">const</span> filename = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.bufPrint">bufPrint</a>(
                    &amp;filename_buf,
                    <span class="tok-str">&quot;{s}&quot;</span> ++ extension,
                    .{<a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.fmtSliceHexLower">fmtSliceHexLower</a>(id[<span class="tok-number">1</span>..])},
                ) <span class="tok-kw">catch</span> <span class="tok-kw">break</span> :blk;

                <span class="tok-kw">for</span> (global_debug_directories) |global_directory| {
                    <span class="tok-kw">const</span> path: <a href="std.Build.Cache.Path.html">Path</a> = .{
                        .root_dir = <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a>.<a href="std.Build.Cache.Directory.html#std.Build.Cache.Directory.cwd">cwd</a>(),
                        .sub_path = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>(gpa, &amp;.{
                            global_directory, <span class="tok-str">&quot;.build-id&quot;</span>, &amp;id_prefix_buf, filename,
                        }),
                    };
                    <span class="tok-kw">defer</span> gpa.free(path.sub_path);

                    <span class="tok-kw">return</span> <a href="std.debug.Dwarf.ElfModule.html#std.debug.Dwarf.ElfModule.loadPath">loadPath</a>(gpa, path, <span class="tok-null">null</span>, separate_debug_crc, &amp;sections, mapped_mem) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;
                }
            }<span class="tok-comment">

            // use the path from .gnu_debuglink, in the same search order as gdb
            </span><span class="tok-kw">if</span> (separate_debug_filename) |separate_filename| blk: {
                <span class="tok-kw">if</span> (elf_filename != <span class="tok-null">null</span> <span class="tok-kw">and</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, elf_filename.?, separate_filename))
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;

                exe_dir: {
                    <span class="tok-kw">var</span> exe_dir_buf: [<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
                    <span class="tok-kw">const</span> exe_dir_path = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.selfExeDirPath">selfExeDirPath</a>(&amp;exe_dir_buf) <span class="tok-kw">catch</span> <span class="tok-kw">break</span> :exe_dir;
                    <span class="tok-kw">var</span> exe_dir = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.openDirAbsolute">openDirAbsolute</a>(exe_dir_path, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">break</span> :exe_dir;
                    <span class="tok-kw">defer</span> exe_dir.close();<span class="tok-comment">

                    // &lt;exe_dir&gt;/&lt;gnu_debuglink&gt;
                    </span><span class="tok-kw">if</span> (<a href="std.debug.Dwarf.ElfModule.html#std.debug.Dwarf.ElfModule.loadPath">loadPath</a>(
                        gpa,
                        .{
                            .root_dir = .{ .path = <span class="tok-null">null</span>, .handle = exe_dir },
                            .sub_path = separate_filename,
                        },
                        <span class="tok-null">null</span>,
                        separate_debug_crc,
                        &amp;sections,
                        mapped_mem,
                    )) |debug_info| {
                        <span class="tok-kw">return</span> debug_info;
                    } <span class="tok-kw">else</span> |_| {}<span class="tok-comment">

                    // &lt;exe_dir&gt;/.debug/&lt;gnu_debuglink&gt;
                    </span><span class="tok-kw">const</span> path: <a href="std.Build.Cache.Path.html">Path</a> = .{
                        .root_dir = .{ .path = <span class="tok-null">null</span>, .handle = exe_dir },
                        .sub_path = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>(gpa, &amp;.{ <span class="tok-str">&quot;.debug&quot;</span>, separate_filename }),
                    };
                    <span class="tok-kw">defer</span> gpa.free(path.sub_path);

                    <span class="tok-kw">if</span> (<a href="std.debug.Dwarf.ElfModule.html#std.debug.Dwarf.ElfModule.loadPath">loadPath</a>(gpa, path, <span class="tok-null">null</span>, separate_debug_crc, &amp;sections, mapped_mem)) |debug_info| <span class="tok-kw">return</span> debug_info <span class="tok-kw">else</span> |_| {}
                }

                <span class="tok-kw">var</span> cwd_buf: [<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">const</span> cwd_path = <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.realpath">realpath</a>(<span class="tok-str">&quot;.&quot;</span>, &amp;cwd_buf) <span class="tok-kw">catch</span> <span class="tok-kw">break</span> :blk;<span class="tok-comment">

                // &lt;global debug directory&gt;/&lt;absolute folder of current binary&gt;/&lt;gnu_debuglink&gt;
                </span><span class="tok-kw">for</span> (global_debug_directories) |global_directory| {
                    <span class="tok-kw">const</span> path: <a href="std.Build.Cache.Path.html">Path</a> = .{
                        .root_dir = <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a>.<a href="std.Build.Cache.Directory.html#std.Build.Cache.Directory.cwd">cwd</a>(),
                        .sub_path = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>(gpa, &amp;.{ global_directory, cwd_path, separate_filename }),
                    };
                    <span class="tok-kw">defer</span> gpa.free(path.sub_path);
                    <span class="tok-kw">if</span> (<a href="std.debug.Dwarf.ElfModule.html#std.debug.Dwarf.ElfModule.loadPath">loadPath</a>(gpa, path, <span class="tok-null">null</span>, separate_debug_crc, &amp;sections, mapped_mem)) |debug_info| <span class="tok-kw">return</span> debug_info <span class="tok-kw">else</span> |_| {}
                }
            }

            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
        }

        <span class="tok-kw">var</span> di: <a href="std.debug.Dwarf.html">Dwarf</a> = .{
            .endian = endian,
            .sections = sections,
            .is_macho = <span class="tok-null">false</span>,
        };

        <span class="tok-kw">try</span> <a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.open">open</a>(&amp;di, gpa);

        <span class="tok-kw">return</span> .{
            .base_address = <span class="tok-number">0</span>,
            .dwarf = di,
            .mapped_memory = parent_mapped_mem <span class="tok-kw">orelse</span> mapped_mem,
            .external_mapped_memory = <span class="tok-kw">if</span> (parent_mapped_mem != <span class="tok-null">null</span>) mapped_mem <span class="tok-kw">else</span> <span class="tok-null">null</span>,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">loadPath</span>(
        gpa: <a href="std.mem.Allocator.html">Allocator</a>,
        elf_file_path: <a href="std.Build.Cache.Path.html">Path</a>,
        build_id: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        expected_crc: ?<span class="tok-type">u32</span>,
        parent_sections: *<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.html#std.debug.Dwarf.SectionArray">SectionArray</a>,
        parent_mapped_mem: ?[]<span class="tok-kw">align</span>(<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.debug.Dwarf.ElfModule.html#std.debug.Dwarf.ElfModule.LoadError">LoadError</a>!<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.ElfModule.html">ElfModule</a> {
        <span class="tok-kw">const</span> elf_file = elf_file_path.root_dir.handle.openFile(elf_file_path.sub_path, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.missing">missing</a>(),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
        };
        <span class="tok-kw">defer</span> elf_file.close();

        <span class="tok-kw">const</span> end_pos = elf_file.getEndPos() <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <a href="std.debug.Dwarf.html#std.debug.Dwarf.bad">bad</a>();
        <span class="tok-kw">const</span> file_len = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, end_pos) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;

        <span class="tok-kw">const</span> mapped_mem = <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mmap">mmap</a>(
            <span class="tok-null">null</span>,
            file_len,
            <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PROT">PROT</a>.<a href="#">READ</a>,
            .{ .TYPE = .SHARED },
            elf_file.handle,
            <span class="tok-number">0</span>,
        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.MappingAlreadyExists =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        <span class="tok-kw">errdefer</span> <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.munmap">munmap</a>(mapped_mem);

        <span class="tok-kw">return</span> <a href="std.debug.Dwarf.ElfModule.html#std.debug.Dwarf.ElfModule.load">load</a>(
            gpa,
            mapped_mem,
            build_id,
            expected_crc,
            parent_sections,
            parent_mapped_mem,
            elf_file_path.sub_path,
        );
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbol</span>(di: *<a href="std.debug.Dwarf.html">Dwarf</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, address: <span class="tok-type">u64</span>) !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Symbol.html">Symbol</a> {
    <span class="tok-kw">if</span> (di.findCompileUnit(address)) |compile_unit| {
        <span class="tok-kw">return</span> .{
            .name = di.getSymbolName(address) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>,
            .compile_unit_name = compile_unit.die.getAttrString(di, <a href="std.html">std</a>.<a href="std.dwarf.html">dwarf</a>.<a href="std.dwarf.AT.html">AT</a>.<a href="std.dwarf.AT.html#std.dwarf.AT.name">name</a>, di.section(.debug_str), compile_unit.*) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-str">&quot;???&quot;</span>,
            },
            .source_location = di.getLineNumberInfo(allocator, compile_unit, address) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-null">null</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
            },
        };
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-kw">return</span> .{},
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chopSlice</span>(ptr: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>, size: <span class="tok-type">u64</span>) <span class="tok-kw">error</span>{Overflow}![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> start = <a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, offset) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
    <span class="tok-kw">const</span> end = start + (<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, size) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow);
    <span class="tok-kw">return</span> ptr[start..end];
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
