<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">compress</a></li><li><a href="std.compress.html" class="">zstandard</a></li><li><a href="std.compress.zstandard.decompress.html" class="active">decompress</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.compress.zstandard.decompress" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.compress.zstandard.decompress</span><a href="#src.zig-std.compress.zstandard.decompress">[src]</a></h1><div class="sectNamespaces"><h2 class="sectionHeader">Namespaces</h2><ul class="listNamespaces columns"><li><a href="std.compress.zstandard.decode.block.html">std.compress.zstandard.decode.block</a></li></ul></div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.compress.zstandard.decompress.FrameHeader.html">std.compress.zstandard.decompress.FrameHeader</a></li><li><a href="std.compress.zstandard.decompress.ReadWriteCount.html">std.compress.zstandard.decompress.ReadWriteCount</a></li><li><a href="std.compress.zstandard.decompress.FrameContext.html">std.compress.zstandard.decompress.FrameContext</a></li></ul></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.compress.zstandard.decompress.HeaderError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">HeaderError</span><a href="#src.zig-std.compress.zstandard.decompress.HeaderError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>BadMagic</dt></div><div><dt>EndOfStream</dt></div><div><dt>ReservedBitSet</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.compress.zstandard.decompress.HeaderError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> HeaderError = <span class="tok-kw">error</span>{ BadMagic, EndOfStream, ReservedBitSet }</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.compress.zstandard.decompress.isSkippableMagic" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isSkippableMagic</span><a href="#src.zig-std.compress.zstandard.decompress.isSkippableMagic">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSkippableMagic</span>(magic: <span class="tok-type">u32</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns <code>true</code> is <code>magic</code> is a valid magic number for a skippable frame</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>magic: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.compress.zstandard.decompress.isSkippableMagic">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSkippableMagic</span>(magic: <span class="tok-type">u32</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <a href="std.compress.zstandard.types.frame.html">frame</a>.<a href="std.compress.zstandard.types.frame.Skippable.html">Skippable</a>.<a href="std.compress.zstandard.types.frame.Skippable.html#std.compress.zstandard.types.frame.Skippable.magic_number_min">magic_number_min</a> &lt;= magic <span class="tok-kw">and</span> magic &lt;= <a href="std.compress.zstandard.types.frame.html">frame</a>.<a href="std.compress.zstandard.types.frame.Skippable.html">Skippable</a>.<a href="std.compress.zstandard.types.frame.Skippable.html#std.compress.zstandard.types.frame.Skippable.magic_number_max">magic_number_max</a>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.compress.zstandard.decompress.decodeFrameType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">decodeFrameType</span><a href="#src.zig-std.compress.zstandard.decompress.decodeFrameType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeFrameType</span>(source: <span class="tok-kw">anytype</span>) <span class="tok-kw">error</span>{ BadMagic, EndOfStream }!<a href="std.compress.zstandard.types.frame.html">frame</a>.<a href="std.compress.zstandard.types.frame.Kind.html">Kind</a></code></pre></div><div class="tldDocs"><p>Returns the kind of frame at the beginning of <code>source</code>.</p>
<p>Errors returned:</p>
<ul>
<li><code>error.BadMagic</code> if <code>source</code> begins with bytes not equal to the
Zstandard frame magic number, or outside the range of magic numbers for
skippable frames.</li>
<li><code>error.EndOfStream</code> if <code>source</code> contains fewer than 4 bytes</li>
</ul>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.compress.zstandard.decompress.decodeFrameType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeFrameType</span>(source: <span class="tok-kw">anytype</span>) <span class="tok-kw">error</span>{ BadMagic, EndOfStream }!<a href="std.compress.zstandard.types.frame.html">frame</a>.<a href="std.compress.zstandard.types.frame.Kind.html">Kind</a> {
    <span class="tok-kw">const</span> magic = <span class="tok-kw">try</span> source.readInt(<span class="tok-type">u32</span>, .little);
    <span class="tok-kw">return</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.frameType">frameType</a>(magic);
}</code></pre></details></div></div><div class="decl"><h2 id="std.compress.zstandard.decompress.frameType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">frameType</span><a href="#src.zig-std.compress.zstandard.decompress.frameType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">frameType</span>(magic: <span class="tok-type">u32</span>) <span class="tok-kw">error</span>{BadMagic}!<a href="std.compress.zstandard.types.frame.html">frame</a>.<a href="std.compress.zstandard.types.frame.Kind.html">Kind</a></code></pre></div><div class="tldDocs"><p>Returns the kind of frame associated to <code>magic</code>.</p>
<p>Errors returned:</p>
<ul>
<li><code>error.BadMagic</code> if <code>magic</code> is not a valid magic number.</li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>magic: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.compress.zstandard.decompress.frameType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">frameType</span>(magic: <span class="tok-type">u32</span>) <span class="tok-kw">error</span>{BadMagic}!<a href="std.compress.zstandard.types.frame.html">frame</a>.<a href="std.compress.zstandard.types.frame.Kind.html">Kind</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (magic == <a href="std.compress.zstandard.types.frame.html">frame</a>.<a href="std.compress.zstandard.types.frame.Zstandard.html">Zstandard</a>.<a href="std.compress.zstandard.types.frame.Zstandard.html#std.compress.zstandard.types.frame.Zstandard.magic_number">magic_number</a>)
        .zstandard
    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.isSkippableMagic">isSkippableMagic</a>(magic))
        .skippable
    <span class="tok-kw">else</span>
        <span class="tok-kw">error</span>.BadMagic;
}</code></pre></details></div></div><div class="decl"><h2 id="std.compress.zstandard.decompress.decodeFrameHeader" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">decodeFrameHeader</span><a href="#src.zig-std.compress.zstandard.decompress.decodeFrameHeader">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeFrameHeader</span>(source: <span class="tok-kw">anytype</span>) (<span class="tok-builtin">@TypeOf</span>(source).Error || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.HeaderError">HeaderError</a>)!<a href="std.compress.zstandard.decompress.FrameHeader.html">FrameHeader</a></code></pre></div><div class="tldDocs"><p>Returns the header of the frame at the beginning of <code>source</code>.</p>
<p>Errors returned:</p>
<ul>
<li><code>error.BadMagic</code> if <code>source</code> begins with bytes not equal to the
Zstandard frame magic number, or outside the range of magic numbers for
skippable frames.</li>
<li><code>error.EndOfStream</code> if <code>source</code> contains fewer than 4 bytes</li>
<li><code>error.ReservedBitSet</code> if the frame is a Zstandard frame and any of the
reserved bits are set</li>
</ul>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.compress.zstandard.decompress.decodeFrameHeader">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeFrameHeader</span>(source: <span class="tok-kw">anytype</span>) (<span class="tok-builtin">@TypeOf</span>(source).Error || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.HeaderError">HeaderError</a>)!<a href="std.compress.zstandard.decompress.FrameHeader.html">FrameHeader</a> {
    <span class="tok-kw">const</span> magic = <span class="tok-kw">try</span> source.readInt(<span class="tok-type">u32</span>, .little);
    <span class="tok-kw">const</span> frame_type = <span class="tok-kw">try</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.frameType">frameType</a>(magic);
    <span class="tok-kw">switch</span> (frame_type) {
        .zstandard =&gt; <span class="tok-kw">return</span> <a href="std.compress.zstandard.decompress.FrameHeader.html">FrameHeader</a>{ .zstandard = <span class="tok-kw">try</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeZstandardHeader">decodeZstandardHeader</a>(source) },
        .skippable =&gt; <span class="tok-kw">return</span> <a href="std.compress.zstandard.decompress.FrameHeader.html">FrameHeader</a>{
            .skippable = .{
                .magic_number = magic,
                .frame_size = <span class="tok-kw">try</span> source.readInt(<span class="tok-type">u32</span>, .little),
            },
        },
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.compress.zstandard.decompress.decode" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">decode</span><a href="#src.zig-std.compress.zstandard.decompress.decode">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decode</span>(dest: []<span class="tok-type">u8</span>, src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, verify_checksum: <span class="tok-type">bool</span>) <span class="tok-kw">error</span>{ MalformedFrame, UnknownContentSizeUnsupported, DictionaryIdFlagUnsupported, }!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Decodes frames from <code>src</code> into <code>dest</code>; returns the length of the result.
The stream should not have extra trailing bytes - either all bytes in <code>src</code>
will be decoded, or an error will be returned. An error will be returned if
a Zstandard frame in <code>src</code> does not declare its content size.</p>
<p>Errors returned:</p>
<ul>
<li><code>error.DictionaryIdFlagUnsupported</code> if a <code>src</code> contains a frame that
uses a dictionary</li>
<li><code>error.MalformedFrame</code> if a frame in <code>src</code> is invalid</li>
<li><code>error.UnknownContentSizeUnsupported</code> if a frame in <code>src</code> does not
declare its content size</li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dest: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>verify_checksum: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.compress.zstandard.decompress.decode">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decode</span>(dest: []<span class="tok-type">u8</span>, src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, verify_checksum: <span class="tok-type">bool</span>) <span class="tok-kw">error</span>{
    MalformedFrame,
    UnknownContentSizeUnsupported,
    DictionaryIdFlagUnsupported,
}!<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> write_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> read_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (read_count &lt; src.len) {
        <span class="tok-kw">const</span> counts = <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeFrame">decodeFrame</a>(dest, src[read_count..], verify_checksum) <span class="tok-kw">catch</span> |err| {
            <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.UnknownContentSizeUnsupported =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownContentSizeUnsupported,
                <span class="tok-kw">error</span>.DictionaryIdFlagUnsupported =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DictionaryIdFlagUnsupported,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedFrame,
            }
        };
        read_count += counts.read_count;
        write_count += counts.write_count;
    }
    <span class="tok-kw">return</span> write_count;
}</code></pre></details></div></div><div class="decl"><h2 id="std.compress.zstandard.decompress.decodeAlloc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">decodeAlloc</span><a href="#src.zig-std.compress.zstandard.decompress.decodeAlloc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeAlloc</span>( allocator: <a href="std.mem.Allocator.html">Allocator</a>, src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, verify_checksum: <span class="tok-type">bool</span>, window_size_max: <span class="tok-type">usize</span>, ) <span class="tok-kw">error</span>{ DictionaryIdFlagUnsupported, MalformedFrame, OutOfMemory }![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Decodes a stream of frames from <code>src</code>; returns the decoded bytes. The stream
should not have extra trailing bytes - either all bytes in <code>src</code> will be
decoded, or an error will be returned.</p>
<p>Errors returned:</p>
<ul>
<li><code>error.DictionaryIdFlagUnsupported</code> if a <code>src</code> contains a frame that
uses a dictionary</li>
<li><code>error.MalformedFrame</code> if a frame in <code>src</code> is invalid</li>
<li><code>error.OutOfMemory</code> if <code>allocator</code> cannot allocate enough memory</li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>verify_checksum: <span class="tok-type">bool</span></code></pre></div><div><pre><code>window_size_max: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.compress.zstandard.decompress.decodeAlloc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeAlloc</span>(
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    verify_checksum: <span class="tok-type">bool</span>,
    window_size_max: <span class="tok-type">usize</span>,
) <span class="tok-kw">error</span>{ DictionaryIdFlagUnsupported, MalformedFrame, OutOfMemory }![]<span class="tok-type">u8</span> {
    <span class="tok-kw">var</span> result = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(allocator);
    <span class="tok-kw">errdefer</span> result.deinit();

    <span class="tok-kw">var</span> read_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (read_count &lt; src.len) {
        read_count += <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeFrameArrayList">decodeFrameArrayList</a>(
            allocator,
            &amp;result,
            src[read_count..],
            verify_checksum,
            window_size_max,
        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
            <span class="tok-kw">error</span>.DictionaryIdFlagUnsupported =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DictionaryIdFlagUnsupported,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedFrame,
        };
    }
    <span class="tok-kw">return</span> result.toOwnedSlice();
}</code></pre></details></div></div><div class="decl"><h2 id="std.compress.zstandard.decompress.decodeFrame" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">decodeFrame</span><a href="#src.zig-std.compress.zstandard.decompress.decodeFrame">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeFrame</span>( dest: []<span class="tok-type">u8</span>, src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, verify_checksum: <span class="tok-type">bool</span>, ) (<span class="tok-kw">error</span>{ BadMagic, UnknownContentSizeUnsupported, ContentTooLarge, ContentSizeTooLarge, WindowSizeUnknown, DictionaryIdFlagUnsupported, SkippableSizeTooLarge, } || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.FrameError">FrameError</a>)!<a href="std.compress.zstandard.decompress.ReadWriteCount.html">ReadWriteCount</a></code></pre></div><div class="tldDocs"><p>Decodes the frame at the start of <code>src</code> into <code>dest</code>. Returns the number of
bytes read from <code>src</code> and written to <code>dest</code>. This function can only decode
frames that declare the decompressed content size.</p>
<p>Errors returned:</p>
<ul>
<li><code>error.BadMagic</code> if the first 4 bytes of <code>src</code> is not a valid magic
number for a Zstandard or skippable frame</li>
<li><code>error.UnknownContentSizeUnsupported</code> if the frame does not declare the
uncompressed content size</li>
<li><code>error.WindowSizeUnknown</code> if the frame does not have a valid window size</li>
<li><code>error.ContentTooLarge</code> if <code>dest</code> is smaller than the uncompressed data
size declared by the frame header</li>
<li><code>error.ContentSizeTooLarge</code> if the frame header indicates a content size
that is larger than <code>std.math.maxInt(usize)</code></li>
<li><code>error.DictionaryIdFlagUnsupported</code> if the frame uses a dictionary</li>
<li><code>error.ChecksumFailure</code> if <code>verify_checksum</code> is true and the frame
contains a checksum that does not match the checksum of the decompressed
data</li>
<li><code>error.ReservedBitSet</code> if any of the reserved bits of the frame header
are set</li>
<li><code>error.EndOfStream</code> if <code>src</code> does not contain a complete frame</li>
<li><code>error.BadContentSize</code> if the content size declared by the frame does
not equal the actual size of decompressed data</li>
<li>an error in <code><a href="std.compress.zstandard.decode.block.html#std.compress.zstandard.decode.block.Error">block.Error</a></code> if there are errors decoding a block</li>
<li><code>error.SkippableSizeTooLarge</code> if the frame is skippable and reports a
size greater than <code>src.len</code></li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dest: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>verify_checksum: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.compress.zstandard.decompress.decodeFrame">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeFrame</span>(
    dest: []<span class="tok-type">u8</span>,
    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    verify_checksum: <span class="tok-type">bool</span>,
) (<span class="tok-kw">error</span>{
    BadMagic,
    UnknownContentSizeUnsupported,
    ContentTooLarge,
    ContentSizeTooLarge,
    WindowSizeUnknown,
    DictionaryIdFlagUnsupported,
    SkippableSizeTooLarge,
} || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.FrameError">FrameError</a>)!<a href="std.compress.zstandard.decompress.ReadWriteCount.html">ReadWriteCount</a> {
    <span class="tok-kw">var</span> fbs = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(src);
    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeFrameType">decodeFrameType</a>(fbs.reader())) {
        .zstandard =&gt; <span class="tok-kw">return</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeZstandardFrame">decodeZstandardFrame</a>(dest, src, verify_checksum),
        .skippable =&gt; {
            <span class="tok-kw">const</span> content_size = <span class="tok-kw">try</span> fbs.reader().readInt(<span class="tok-type">u32</span>, .little);
            <span class="tok-kw">if</span> (content_size &gt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>) - <span class="tok-number">8</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkippableSizeTooLarge;
            <span class="tok-kw">const</span> read_count = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, content_size) + <span class="tok-number">8</span>;
            <span class="tok-kw">if</span> (read_count &gt; src.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkippableSizeTooLarge;
            <span class="tok-kw">return</span> <a href="std.compress.zstandard.decompress.ReadWriteCount.html">ReadWriteCount</a>{
                .read_count = read_count,
                .write_count = <span class="tok-number">0</span>,
            };
        },
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.compress.zstandard.decompress.decodeFrameArrayList" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">decodeFrameArrayList</span><a href="#src.zig-std.compress.zstandard.decompress.decodeFrameArrayList">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeFrameArrayList</span>( allocator: <a href="std.mem.Allocator.html">Allocator</a>, dest: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>), src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, verify_checksum: <span class="tok-type">bool</span>, window_size_max: <span class="tok-type">usize</span>, ) (<span class="tok-kw">error</span>{ BadMagic, OutOfMemory, SkippableSizeTooLarge } || <a href="std.compress.zstandard.decompress.FrameContext.html">FrameContext</a>.<a href="std.compress.zstandard.decompress.FrameContext.html#std.compress.zstandard.decompress.FrameContext.Error">Error</a> || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.FrameError">FrameError</a>)!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Decodes the frame at the start of <code>src</code> into <code>dest</code>. Returns the number of
bytes read from <code>src</code>.</p>
<p>Errors returned:</p>
<ul>
<li><code>error.BadMagic</code> if the first 4 bytes of <code>src</code> is not a valid magic
number for a Zstandard or skippable frame</li>
<li><code>error.WindowSizeUnknown</code> if the frame does not have a valid window size</li>
<li><code>error.WindowTooLarge</code> if the window size is larger than
<code>window_size_max</code></li>
<li><code>error.ContentSizeTooLarge</code> if the frame header indicates a content size
that is larger than <code>std.math.maxInt(usize)</code></li>
<li><code>error.DictionaryIdFlagUnsupported</code> if the frame uses a dictionary</li>
<li><code>error.ChecksumFailure</code> if <code>verify_checksum</code> is true and the frame
contains a checksum that does not match the checksum of the decompressed
data</li>
<li><code>error.ReservedBitSet</code> if any of the reserved bits of the frame header
are set</li>
<li><code>error.EndOfStream</code> if <code>src</code> does not contain a complete frame</li>
<li><code>error.BadContentSize</code> if the content size declared by the frame does
not equal the actual size of decompressed data</li>
<li><code>error.OutOfMemory</code> if <code>allocator</code> cannot allocate enough memory</li>
<li>an error in <code><a href="std.compress.zstandard.decode.block.html#std.compress.zstandard.decode.block.Error">block.Error</a></code> if there are errors decoding a block</li>
<li><code>error.SkippableSizeTooLarge</code> if the frame is skippable and reports a
size greater than <code>src.len</code></li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>dest: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>)</code></pre></div><div><pre><code>src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>verify_checksum: <span class="tok-type">bool</span></code></pre></div><div><pre><code>window_size_max: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.compress.zstandard.decompress.decodeFrameArrayList">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeFrameArrayList</span>(
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    dest: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>),
    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    verify_checksum: <span class="tok-type">bool</span>,
    window_size_max: <span class="tok-type">usize</span>,
) (<span class="tok-kw">error</span>{ BadMagic, OutOfMemory, SkippableSizeTooLarge } || <a href="std.compress.zstandard.decompress.FrameContext.html">FrameContext</a>.<a href="std.compress.zstandard.decompress.FrameContext.html#std.compress.zstandard.decompress.FrameContext.Error">Error</a> || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.FrameError">FrameError</a>)!<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> fbs = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(src);
    <span class="tok-kw">const</span> reader = fbs.reader();
    <span class="tok-kw">const</span> magic = <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, .little);
    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.frameType">frameType</a>(magic)) {
        .zstandard =&gt; <span class="tok-kw">return</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeZstandardFrameArrayList">decodeZstandardFrameArrayList</a>(
            allocator,
            dest,
            src,
            verify_checksum,
            window_size_max,
        ),
        .skippable =&gt; {
            <span class="tok-kw">const</span> content_size = <span class="tok-kw">try</span> fbs.reader().readInt(<span class="tok-type">u32</span>, .little);
            <span class="tok-kw">if</span> (content_size &gt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>) - <span class="tok-number">8</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkippableSizeTooLarge;
            <span class="tok-kw">const</span> read_count = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, content_size) + <span class="tok-number">8</span>;
            <span class="tok-kw">if</span> (read_count &gt; src.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkippableSizeTooLarge;
            <span class="tok-kw">return</span> read_count;
        },
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.compress.zstandard.decompress.computeChecksum" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">computeChecksum</span><a href="#src.zig-std.compress.zstandard.decompress.computeChecksum">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">computeChecksum</span>(hasher: *<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.xxhash.XxHash64.html">XxHash64</a>) <span class="tok-type">u32</span></code></pre></div><div class="tldDocs"><p>Returns the frame checksum corresponding to the data fed into <code>hasher</code></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>hasher: *<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.xxhash.XxHash64.html">XxHash64</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.compress.zstandard.decompress.computeChecksum">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">computeChecksum</span>(hasher: *<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.xxhash.XxHash64.html">XxHash64</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> hash = hasher.final();
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(hash &amp; <span class="tok-number">0xFFFFFFFF</span>));
}</code></pre></details></div></div><div class="decl"><h2 id="std.compress.zstandard.decompress.decodeZstandardFrame" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">decodeZstandardFrame</span><a href="#src.zig-std.compress.zstandard.decompress.decodeZstandardFrame">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeZstandardFrame</span>( dest: []<span class="tok-type">u8</span>, src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, verify_checksum: <span class="tok-type">bool</span>, ) (<span class="tok-kw">error</span>{ UnknownContentSizeUnsupported, ContentTooLarge, ContentSizeTooLarge, WindowSizeUnknown, DictionaryIdFlagUnsupported, } || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.FrameError">FrameError</a>)!<a href="std.compress.zstandard.decompress.ReadWriteCount.html">ReadWriteCount</a></code></pre></div><div class="tldDocs"><p>Decode a Zstandard frame from <code>src</code> into <code>dest</code>, returning the number of
bytes read from <code>src</code> and written to <code>dest</code>. The first four bytes of <code>src</code>
must be the magic number for a Zstandard frame.</p>
<p>Error returned:</p>
<ul>
<li><code>error.UnknownContentSizeUnsupported</code> if the frame does not declare the
uncompressed content size</li>
<li><code>error.ContentTooLarge</code> if <code>dest</code> is smaller than the uncompressed data
size declared by the frame header</li>
<li><code>error.WindowSizeUnknown</code> if the frame does not have a valid window size</li>
<li><code>error.DictionaryIdFlagUnsupported</code> if the frame uses a dictionary</li>
<li><code>error.ContentSizeTooLarge</code> if the frame header indicates a content size
that is larger than <code>std.math.maxInt(usize)</code></li>
<li><code>error.ChecksumFailure</code> if <code>verify_checksum</code> is true and the frame
contains a checksum that does not match the checksum of the decompressed
data</li>
<li><code>error.ReservedBitSet</code> if the reserved bit of the frame header is set</li>
<li><code>error.EndOfStream</code> if <code>src</code> does not contain a complete frame</li>
<li>an error in <code><a href="std.compress.zstandard.decode.block.html#std.compress.zstandard.decode.block.Error">block.Error</a></code> if there are errors decoding a block</li>
<li><code>error.BadContentSize</code> if the content size declared by the frame does
not equal the actual size of decompressed data</li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dest: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>verify_checksum: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.compress.zstandard.decompress.decodeZstandardFrame">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeZstandardFrame</span>(
    dest: []<span class="tok-type">u8</span>,
    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    verify_checksum: <span class="tok-type">bool</span>,
) (<span class="tok-kw">error</span>{
    UnknownContentSizeUnsupported,
    ContentTooLarge,
    ContentSizeTooLarge,
    WindowSizeUnknown,
    DictionaryIdFlagUnsupported,
} || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.FrameError">FrameError</a>)!<a href="std.compress.zstandard.decompress.ReadWriteCount.html">ReadWriteCount</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, src[<span class="tok-number">0</span>..<span class="tok-number">4</span>], .little) == <a href="std.compress.zstandard.types.frame.html">frame</a>.<a href="std.compress.zstandard.types.frame.Zstandard.html">Zstandard</a>.<a href="std.compress.zstandard.types.frame.Zstandard.html#std.compress.zstandard.types.frame.Zstandard.magic_number">magic_number</a>);
    <span class="tok-kw">var</span> consumed_count: <span class="tok-type">usize</span> = <span class="tok-number">4</span>;

    <span class="tok-kw">var</span> frame_context = context: {
        <span class="tok-kw">var</span> fbs = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(src[consumed_count..]);
        <span class="tok-kw">const</span> source = fbs.reader();
        <span class="tok-kw">const</span> frame_header = <span class="tok-kw">try</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeZstandardHeader">decodeZstandardHeader</a>(source);
        consumed_count += fbs.pos;
        <span class="tok-kw">break</span> :context <a href="std.compress.zstandard.decompress.FrameContext.html">FrameContext</a>.<a href="std.compress.zstandard.decompress.FrameContext.html#std.compress.zstandard.decompress.FrameContext.init">init</a>(
            frame_header,
            <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>),
            verify_checksum,
        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WindowTooLarge =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    };
    <span class="tok-kw">const</span> counts = <span class="tok-kw">try</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeZStandardFrameBlocks">decodeZStandardFrameBlocks</a>(
        dest,
        src[consumed_count..],
        &amp;frame_context,
    );
    <span class="tok-kw">return</span> <a href="std.compress.zstandard.decompress.ReadWriteCount.html">ReadWriteCount</a>{
        .read_count = counts.read_count + consumed_count,
        .write_count = counts.write_count,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.compress.zstandard.decompress.decodeZStandardFrameBlocks" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">decodeZStandardFrameBlocks</span><a href="#src.zig-std.compress.zstandard.decompress.decodeZStandardFrameBlocks">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeZStandardFrameBlocks</span>( dest: []<span class="tok-type">u8</span>, src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, frame_context: *<a href="std.compress.zstandard.decompress.FrameContext.html">FrameContext</a>, ) (<span class="tok-kw">error</span>{ ContentTooLarge, UnknownContentSizeUnsupported } || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.FrameError">FrameError</a>)!<a href="std.compress.zstandard.decompress.ReadWriteCount.html">ReadWriteCount</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dest: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>frame_context: *<a href="std.compress.zstandard.decompress.FrameContext.html">FrameContext</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.compress.zstandard.decompress.decodeZStandardFrameBlocks">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeZStandardFrameBlocks</span>(
    dest: []<span class="tok-type">u8</span>,
    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    frame_context: *<a href="std.compress.zstandard.decompress.FrameContext.html">FrameContext</a>,
) (<span class="tok-kw">error</span>{ ContentTooLarge, UnknownContentSizeUnsupported } || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.FrameError">FrameError</a>)!<a href="std.compress.zstandard.decompress.ReadWriteCount.html">ReadWriteCount</a> {
    <span class="tok-kw">const</span> content_size = frame_context.content_size <span class="tok-kw">orelse</span>
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownContentSizeUnsupported;
    <span class="tok-kw">if</span> (dest.len &lt; content_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ContentTooLarge;

    <span class="tok-kw">var</span> consumed_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> written_count = <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeFrameBlocksInner">decodeFrameBlocksInner</a>(
        dest[<span class="tok-number">0</span>..content_size],
        src[consumed_count..],
        &amp;consumed_count,
        <span class="tok-kw">if</span> (frame_context.hasher_opt) |*hasher| hasher <span class="tok-kw">else</span> <span class="tok-null">null</span>,
        frame_context.block_size_max,
    ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.DestTooSmall =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadContentSize,
        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };

    <span class="tok-kw">if</span> (written_count != content_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadContentSize;
    <span class="tok-kw">if</span> (frame_context.has_checksum) {
        <span class="tok-kw">if</span> (src.len &lt; consumed_count + <span class="tok-number">4</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfStream;
        <span class="tok-kw">const</span> checksum = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, src[consumed_count..][<span class="tok-number">0</span>..<span class="tok-number">4</span>], .little);
        consumed_count += <span class="tok-number">4</span>;
        <span class="tok-kw">if</span> (frame_context.hasher_opt) |*hasher| {
            <span class="tok-kw">if</span> (checksum != <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.computeChecksum">computeChecksum</a>(hasher)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ChecksumFailure;
        }
    }
    <span class="tok-kw">return</span> <a href="std.compress.zstandard.decompress.ReadWriteCount.html">ReadWriteCount</a>{ .read_count = consumed_count, .write_count = written_count };
}</code></pre></details></div></div><div class="decl"><h2 id="std.compress.zstandard.decompress.decodeZstandardFrameArrayList" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">decodeZstandardFrameArrayList</span><a href="#src.zig-std.compress.zstandard.decompress.decodeZstandardFrameArrayList">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeZstandardFrameArrayList</span>( allocator: <a href="std.mem.Allocator.html">Allocator</a>, dest: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>), src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, verify_checksum: <span class="tok-type">bool</span>, window_size_max: <span class="tok-type">usize</span>, ) (<span class="tok-kw">error</span>{OutOfMemory} || <a href="std.compress.zstandard.decompress.FrameContext.html">FrameContext</a>.<a href="std.compress.zstandard.decompress.FrameContext.html#std.compress.zstandard.decompress.FrameContext.Error">Error</a> || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.FrameError">FrameError</a>)!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Decode a Zstandard from from <code>src</code> and return number of bytes read; see
<code>decodeZstandardFrame()</code>. The first four bytes of <code>src</code> must be the magic
number for a Zstandard frame.</p>
<p>Errors returned:</p>
<ul>
<li><code>error.WindowSizeUnknown</code> if the frame does not have a valid window size</li>
<li><code>error.WindowTooLarge</code> if the window size is larger than
<code>window_size_max</code></li>
<li><code>error.DictionaryIdFlagUnsupported</code> if the frame uses a dictionary</li>
<li><code>error.ContentSizeTooLarge</code> if the frame header indicates a content size
that is larger than <code>std.math.maxInt(usize)</code></li>
<li><code>error.ChecksumFailure</code> if <code>verify_checksum</code> is true and the frame
contains a checksum that does not match the checksum of the decompressed
data</li>
<li><code>error.ReservedBitSet</code> if the reserved bit of the frame header is set</li>
<li><code>error.EndOfStream</code> if <code>src</code> does not contain a complete frame</li>
<li><code>error.OutOfMemory</code> if <code>allocator</code> cannot allocate enough memory</li>
<li>an error in <code><a href="std.compress.zstandard.decode.block.html#std.compress.zstandard.decode.block.Error">block.Error</a></code> if there are errors decoding a block</li>
<li><code>error.BadContentSize</code> if the content size declared by the frame does
not equal the size of decompressed data</li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>dest: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>)</code></pre></div><div><pre><code>src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>verify_checksum: <span class="tok-type">bool</span></code></pre></div><div><pre><code>window_size_max: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.compress.zstandard.decompress.decodeZstandardFrameArrayList">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeZstandardFrameArrayList</span>(
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    dest: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>),
    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    verify_checksum: <span class="tok-type">bool</span>,
    window_size_max: <span class="tok-type">usize</span>,
) (<span class="tok-kw">error</span>{OutOfMemory} || <a href="std.compress.zstandard.decompress.FrameContext.html">FrameContext</a>.<a href="std.compress.zstandard.decompress.FrameContext.html#std.compress.zstandard.decompress.FrameContext.Error">Error</a> || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.FrameError">FrameError</a>)!<span class="tok-type">usize</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, src[<span class="tok-number">0</span>..<span class="tok-number">4</span>], .little) == <a href="std.compress.zstandard.types.frame.html">frame</a>.<a href="std.compress.zstandard.types.frame.Zstandard.html">Zstandard</a>.<a href="std.compress.zstandard.types.frame.Zstandard.html#std.compress.zstandard.types.frame.Zstandard.magic_number">magic_number</a>);
    <span class="tok-kw">var</span> consumed_count: <span class="tok-type">usize</span> = <span class="tok-number">4</span>;

    <span class="tok-kw">var</span> frame_context = context: {
        <span class="tok-kw">var</span> fbs = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(src[consumed_count..]);
        <span class="tok-kw">const</span> source = fbs.reader();
        <span class="tok-kw">const</span> frame_header = <span class="tok-kw">try</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeZstandardHeader">decodeZstandardHeader</a>(source);
        consumed_count += fbs.pos;
        <span class="tok-kw">break</span> :context <span class="tok-kw">try</span> <a href="std.compress.zstandard.decompress.FrameContext.html">FrameContext</a>.<a href="std.compress.zstandard.decompress.FrameContext.html#std.compress.zstandard.decompress.FrameContext.init">init</a>(frame_header, window_size_max, verify_checksum);
    };

    consumed_count += <span class="tok-kw">try</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeZstandardFrameBlocksArrayList">decodeZstandardFrameBlocksArrayList</a>(
        allocator,
        dest,
        src[consumed_count..],
        &amp;frame_context,
    );
    <span class="tok-kw">return</span> consumed_count;
}</code></pre></details></div></div><div class="decl"><h2 id="std.compress.zstandard.decompress.decodeZstandardFrameBlocksArrayList" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">decodeZstandardFrameBlocksArrayList</span><a href="#src.zig-std.compress.zstandard.decompress.decodeZstandardFrameBlocksArrayList">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeZstandardFrameBlocksArrayList</span>( allocator: <a href="std.mem.Allocator.html">Allocator</a>, dest: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>), src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, frame_context: *<a href="std.compress.zstandard.decompress.FrameContext.html">FrameContext</a>, ) (<span class="tok-kw">error</span>{OutOfMemory} || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.FrameError">FrameError</a>)!<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>dest: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>)</code></pre></div><div><pre><code>src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>frame_context: *<a href="std.compress.zstandard.decompress.FrameContext.html">FrameContext</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.compress.zstandard.decompress.decodeZstandardFrameBlocksArrayList">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeZstandardFrameBlocksArrayList</span>(
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    dest: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>),
    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    frame_context: *<a href="std.compress.zstandard.decompress.FrameContext.html">FrameContext</a>,
) (<span class="tok-kw">error</span>{OutOfMemory} || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.FrameError">FrameError</a>)!<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> initial_len = dest.items.len;

    <span class="tok-kw">var</span> ring_buffer = <span class="tok-kw">try</span> <a href="std.RingBuffer.html">RingBuffer</a>.<a href="std.RingBuffer.html#std.RingBuffer.init">init</a>(allocator, frame_context.window_size);
    <span class="tok-kw">defer</span> ring_buffer.deinit(allocator);<span class="tok-comment">

    // These tables take 7680 bytes
    </span><span class="tok-kw">var</span> literal_fse_data: [<a href="std.compress.zstandard.types.html">types</a>.<a href="std.compress.zstandard.types.compressed_block.html">compressed_block</a>.<a href="std.compress.zstandard.types.compressed_block.table_size_max.html">table_size_max</a>.<a href="std.compress.zstandard.types.compressed_block.table_size_max.html#std.compress.zstandard.types.compressed_block.table_size_max.literal">literal</a>]<a href="std.compress.zstandard.types.compressed_block.Table.html">Table</a>.<a href="std.compress.zstandard.types.compressed_block.Table.Fse.html">Fse</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> match_fse_data: [<a href="std.compress.zstandard.types.html">types</a>.<a href="std.compress.zstandard.types.compressed_block.html">compressed_block</a>.<a href="std.compress.zstandard.types.compressed_block.table_size_max.html">table_size_max</a>.<a href="std.compress.zstandard.types.compressed_block.table_size_max.html#std.compress.zstandard.types.compressed_block.table_size_max.match">match</a>]<a href="std.compress.zstandard.types.compressed_block.Table.html">Table</a>.<a href="std.compress.zstandard.types.compressed_block.Table.Fse.html">Fse</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> offset_fse_data: [<a href="std.compress.zstandard.types.html">types</a>.<a href="std.compress.zstandard.types.compressed_block.html">compressed_block</a>.<a href="std.compress.zstandard.types.compressed_block.table_size_max.html">table_size_max</a>.<a href="std.compress.zstandard.types.compressed_block.table_size_max.html#std.compress.zstandard.types.compressed_block.table_size_max.offset">offset</a>]<a href="std.compress.zstandard.types.compressed_block.Table.html">Table</a>.<a href="std.compress.zstandard.types.compressed_block.Table.Fse.html">Fse</a> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">var</span> block_header = <span class="tok-kw">try</span> <a href="std.compress.zstandard.decode.block.html">block</a>.<a href="std.compress.zstandard.decode.block.html#std.compress.zstandard.decode.block.decodeBlockHeaderSlice">decodeBlockHeaderSlice</a>(src);
    <span class="tok-kw">var</span> consumed_count: <span class="tok-type">usize</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">var</span> decode_state = <a href="std.compress.zstandard.decode.block.html">block</a>.<a href="std.compress.zstandard.decode.block.DecodeState.html">DecodeState</a>.<a href="std.compress.zstandard.decode.block.DecodeState.html#std.compress.zstandard.decode.block.DecodeState.init">init</a>(&amp;literal_fse_data, &amp;match_fse_data, &amp;offset_fse_data);
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : ({
        block_header = <span class="tok-kw">try</span> <a href="std.compress.zstandard.decode.block.html">block</a>.<a href="std.compress.zstandard.decode.block.html#std.compress.zstandard.decode.block.decodeBlockHeaderSlice">decodeBlockHeaderSlice</a>(src[consumed_count..]);
        consumed_count += <span class="tok-number">3</span>;
    }) {
        <span class="tok-kw">const</span> written_size = <span class="tok-kw">try</span> <a href="std.compress.zstandard.decode.block.html">block</a>.<a href="std.compress.zstandard.decode.block.html#std.compress.zstandard.decode.block.decodeBlockRingBuffer">decodeBlockRingBuffer</a>(
            &amp;ring_buffer,
            src[consumed_count..],
            block_header,
            &amp;decode_state,
            &amp;consumed_count,
            frame_context.block_size_max,
        );
        <span class="tok-kw">if</span> (frame_context.content_size) |size| {
            <span class="tok-kw">if</span> (dest.items.len - initial_len &gt; size) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadContentSize;
            }
        }
        <span class="tok-kw">if</span> (written_size &gt; <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> written_slice = ring_buffer.sliceLast(written_size);
            <span class="tok-kw">try</span> dest.appendSlice(written_slice.first);
            <span class="tok-kw">try</span> dest.appendSlice(written_slice.second);
            <span class="tok-kw">if</span> (frame_context.hasher_opt) |*hasher| {
                hasher.update(written_slice.first);
                hasher.update(written_slice.second);
            }
        }
        <span class="tok-kw">if</span> (block_header.last_block) <span class="tok-kw">break</span>;
    }
    <span class="tok-kw">if</span> (frame_context.content_size) |size| {
        <span class="tok-kw">if</span> (dest.items.len - initial_len != size) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadContentSize;
        }
    }

    <span class="tok-kw">if</span> (frame_context.has_checksum) {
        <span class="tok-kw">if</span> (src.len &lt; consumed_count + <span class="tok-number">4</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfStream;
        <span class="tok-kw">const</span> checksum = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, src[consumed_count..][<span class="tok-number">0</span>..<span class="tok-number">4</span>], .little);
        consumed_count += <span class="tok-number">4</span>;
        <span class="tok-kw">if</span> (frame_context.hasher_opt) |*hasher| {
            <span class="tok-kw">if</span> (checksum != <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.computeChecksum">computeChecksum</a>(hasher)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ChecksumFailure;
        }
    }
    <span class="tok-kw">return</span> consumed_count;
}</code></pre></details></div></div><div class="decl"><h2 id="std.compress.zstandard.decompress.decodeSkippableHeader" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">decodeSkippableHeader</span><a href="#src.zig-std.compress.zstandard.decompress.decodeSkippableHeader">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeSkippableHeader</span>(src: *<span class="tok-kw">const</span> [<span class="tok-number">8</span>]<span class="tok-type">u8</span>) <a href="std.compress.zstandard.types.frame.Skippable.Header.html">SkippableHeader</a></code></pre></div><div class="tldDocs"><p>Decode the header of a skippable frame. The first four bytes of <code>src</code> must
be a valid magic number for a skippable frame.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>src: *<span class="tok-kw">const</span> [<span class="tok-number">8</span>]<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.compress.zstandard.decompress.decodeSkippableHeader">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeSkippableHeader</span>(src: *<span class="tok-kw">const</span> [<span class="tok-number">8</span>]<span class="tok-type">u8</span>) <a href="std.compress.zstandard.types.frame.Skippable.Header.html">SkippableHeader</a> {
    <span class="tok-kw">const</span> magic = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, src[<span class="tok-number">0</span>..<span class="tok-number">4</span>], .little);
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.isSkippableMagic">isSkippableMagic</a>(magic));
    <span class="tok-kw">const</span> frame_size = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, src[<span class="tok-number">4</span>..<span class="tok-number">8</span>], .little);
    <span class="tok-kw">return</span> .{
        .magic_number = magic,
        .frame_size = frame_size,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.compress.zstandard.decompress.frameWindowSize" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">frameWindowSize</span><a href="#src.zig-std.compress.zstandard.decompress.frameWindowSize">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">frameWindowSize</span>(header: <a href="std.compress.zstandard.types.frame.Zstandard.Header.html">ZstandardHeader</a>) ?<span class="tok-type">u64</span></code></pre></div><div class="tldDocs"><p>Returns the window size required to decompress a frame, or <code>null</code> if it
cannot be determined (which indicates a malformed frame header).</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>header: <a href="std.compress.zstandard.types.frame.Zstandard.Header.html">ZstandardHeader</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.compress.zstandard.decompress.frameWindowSize">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">frameWindowSize</span>(header: <a href="std.compress.zstandard.types.frame.Zstandard.Header.html">ZstandardHeader</a>) ?<span class="tok-type">u64</span> {
    <span class="tok-kw">if</span> (header.window_descriptor) |descriptor| {
        <span class="tok-kw">const</span> exponent = (descriptor &amp; <span class="tok-number">0b11111000</span>) &gt;&gt; <span class="tok-number">3</span>;
        <span class="tok-kw">const</span> mantissa = descriptor &amp; <span class="tok-number">0b00000111</span>;
        <span class="tok-kw">const</span> window_log = <span class="tok-number">10</span> + exponent;
        <span class="tok-kw">const</span> window_base = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(<span class="tok-type">u6</span>, <span class="tok-builtin">@intCast</span>(window_log));
        <span class="tok-kw">const</span> window_add = (window_base / <span class="tok-number">8</span>) * mantissa;
        <span class="tok-kw">return</span> window_base + window_add;
    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> header.content_size;
}</code></pre></details></div></div><div class="decl"><h2 id="std.compress.zstandard.decompress.decodeZstandardHeader" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">decodeZstandardHeader</span><a href="#src.zig-std.compress.zstandard.decompress.decodeZstandardHeader">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeZstandardHeader</span>( source: <span class="tok-kw">anytype</span>, ) (<span class="tok-builtin">@TypeOf</span>(source).Error || <span class="tok-kw">error</span>{ EndOfStream, ReservedBitSet })!<a href="std.compress.zstandard.types.frame.Zstandard.Header.html">ZstandardHeader</a></code></pre></div><div class="tldDocs"><p>Decode the header of a Zstandard frame.</p>
<p>Errors returned:</p>
<ul>
<li><code>error.ReservedBitSet</code> if any of the reserved bits of the header are set</li>
<li><code>error.EndOfStream</code> if <code>source</code> does not contain a complete header</li>
</ul>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.compress.zstandard.decompress.decodeZstandardHeader">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeZstandardHeader</span>(
    source: <span class="tok-kw">anytype</span>,
) (<span class="tok-builtin">@TypeOf</span>(source).Error || <span class="tok-kw">error</span>{ EndOfStream, ReservedBitSet })!<a href="std.compress.zstandard.types.frame.Zstandard.Header.html">ZstandardHeader</a> {
    <span class="tok-kw">const</span> descriptor = <span class="tok-builtin">@as</span>(<a href="std.compress.zstandard.types.frame.Zstandard.Header.html">ZstandardHeader</a>.<a href="std.compress.zstandard.types.frame.Zstandard.Header.Descriptor.html">Descriptor</a>, <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> source.readByte()));

    <span class="tok-kw">if</span> (descriptor.reserved) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReservedBitSet;

    <span class="tok-kw">var</span> window_descriptor: ?<span class="tok-type">u8</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (!descriptor.single_segment_flag) {
        window_descriptor = <span class="tok-kw">try</span> source.readByte();
    }

    <span class="tok-kw">var</span> dictionary_id: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (descriptor.dictionary_id_flag &gt; <span class="tok-number">0</span>) {<span class="tok-comment">
        // if flag is 3 then field_size = 4, else field_size = flag
        </span><span class="tok-kw">const</span> field_size = (<span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-number">1</span>) &lt;&lt; descriptor.dictionary_id_flag) &gt;&gt; <span class="tok-number">1</span>;
        dictionary_id = <span class="tok-kw">try</span> source.readVarInt(<span class="tok-type">u32</span>, .little, field_size);
    }

    <span class="tok-kw">var</span> content_size: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (descriptor.single_segment_flag <span class="tok-kw">or</span> descriptor.content_size_flag &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> field_size = <span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-number">1</span>) &lt;&lt; descriptor.content_size_flag;
        content_size = <span class="tok-kw">try</span> source.readVarInt(<span class="tok-type">u64</span>, .little, field_size);
        <span class="tok-kw">if</span> (field_size == <span class="tok-number">2</span>) content_size.? += <span class="tok-number">256</span>;
    }

    <span class="tok-kw">const</span> header = <a href="std.compress.zstandard.types.frame.Zstandard.Header.html">ZstandardHeader</a>{
        .descriptor = descriptor,
        .window_descriptor = window_descriptor,
        .dictionary_id = dictionary_id,
        .content_size = content_size,
    };
    <span class="tok-kw">return</span> header;
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.compress.zstandard.decompress">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> Allocator = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> RingBuffer = <a href="std.html">std</a>.<a href="std.RingBuffer.html">RingBuffer</a>;

<span class="tok-kw">const</span> types = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;types.zig&quot;</span>);
<span class="tok-kw">const</span> frame = <a href="std.compress.zstandard.types.html">types</a>.<a href="std.compress.zstandard.types.frame.html">frame</a>;
<span class="tok-kw">const</span> LiteralsSection = <a href="std.compress.zstandard.types.html">types</a>.<a href="std.compress.zstandard.types.compressed_block.html">compressed_block</a>.<a href="std.compress.zstandard.types.compressed_block.LiteralsSection.html">LiteralsSection</a>;
<span class="tok-kw">const</span> SequencesSection = <a href="std.compress.zstandard.types.html">types</a>.<a href="std.compress.zstandard.types.compressed_block.html">compressed_block</a>.<a href="std.compress.zstandard.types.compressed_block.SequencesSection.html">SequencesSection</a>;
<span class="tok-kw">const</span> SkippableHeader = <a href="std.compress.zstandard.types.html">types</a>.<a href="std.compress.zstandard.types.frame.html">frame</a>.<a href="std.compress.zstandard.types.frame.Skippable.html">Skippable</a>.<a href="std.compress.zstandard.types.frame.Skippable.Header.html">Header</a>;
<span class="tok-kw">const</span> ZstandardHeader = <a href="std.compress.zstandard.types.html">types</a>.<a href="std.compress.zstandard.types.frame.html">frame</a>.<a href="std.compress.zstandard.types.frame.Zstandard.html">Zstandard</a>.<a href="std.compress.zstandard.types.frame.Zstandard.Header.html">Header</a>;
<span class="tok-kw">const</span> Table = <a href="std.compress.zstandard.types.html">types</a>.<a href="std.compress.zstandard.types.compressed_block.html">compressed_block</a>.<a href="std.compress.zstandard.types.compressed_block.Table.html">Table</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> block = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;decode/block.zig&quot;</span>);

<span class="tok-kw">const</span> readers = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;readers.zig&quot;</span>);

<span class="tok-comment">/// Returns `true` is `magic` is a valid magic number for a skippable frame</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSkippableMagic</span>(magic: <span class="tok-type">u32</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <a href="std.compress.zstandard.types.frame.html">frame</a>.<a href="std.compress.zstandard.types.frame.Skippable.html">Skippable</a>.<a href="std.compress.zstandard.types.frame.Skippable.html#std.compress.zstandard.types.frame.Skippable.magic_number_min">magic_number_min</a> &lt;= magic <span class="tok-kw">and</span> magic &lt;= <a href="std.compress.zstandard.types.frame.html">frame</a>.<a href="std.compress.zstandard.types.frame.Skippable.html">Skippable</a>.<a href="std.compress.zstandard.types.frame.Skippable.html#std.compress.zstandard.types.frame.Skippable.magic_number_max">magic_number_max</a>;
}

<span class="tok-comment">/// Returns the kind of frame at the beginning of `source`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Errors returned:</span>
<span class="tok-comment">///   - `error.BadMagic` if `source` begins with bytes not equal to the</span>
<span class="tok-comment">///     Zstandard frame magic number, or outside the range of magic numbers for</span>
<span class="tok-comment">///     skippable frames.</span>
<span class="tok-comment">///   - `error.EndOfStream` if `source` contains fewer than 4 bytes</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeFrameType</span>(source: <span class="tok-kw">anytype</span>) <span class="tok-kw">error</span>{ BadMagic, EndOfStream }!<a href="std.compress.zstandard.types.frame.html">frame</a>.<a href="std.compress.zstandard.types.frame.Kind.html">Kind</a> {
    <span class="tok-kw">const</span> magic = <span class="tok-kw">try</span> source.readInt(<span class="tok-type">u32</span>, .little);
    <span class="tok-kw">return</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.frameType">frameType</a>(magic);
}

<span class="tok-comment">/// Returns the kind of frame associated to `magic`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Errors returned:</span>
<span class="tok-comment">///   - `error.BadMagic` if `magic` is not a valid magic number.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">frameType</span>(magic: <span class="tok-type">u32</span>) <span class="tok-kw">error</span>{BadMagic}!<a href="std.compress.zstandard.types.frame.html">frame</a>.<a href="std.compress.zstandard.types.frame.Kind.html">Kind</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (magic == <a href="std.compress.zstandard.types.frame.html">frame</a>.<a href="std.compress.zstandard.types.frame.Zstandard.html">Zstandard</a>.<a href="std.compress.zstandard.types.frame.Zstandard.html#std.compress.zstandard.types.frame.Zstandard.magic_number">magic_number</a>)
        .zstandard
    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.isSkippableMagic">isSkippableMagic</a>(magic))
        .skippable
    <span class="tok-kw">else</span>
        <span class="tok-kw">error</span>.BadMagic;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FrameHeader = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    zstandard: <a href="std.compress.zstandard.types.frame.Zstandard.Header.html">ZstandardHeader</a>,
    skippable: <a href="std.compress.zstandard.types.frame.Skippable.Header.html">SkippableHeader</a>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> HeaderError = <span class="tok-kw">error</span>{ BadMagic, EndOfStream, ReservedBitSet };

<span class="tok-comment">/// Returns the header of the frame at the beginning of `source`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Errors returned:</span>
<span class="tok-comment">///   - `error.BadMagic` if `source` begins with bytes not equal to the</span>
<span class="tok-comment">///     Zstandard frame magic number, or outside the range of magic numbers for</span>
<span class="tok-comment">///     skippable frames.</span>
<span class="tok-comment">///   - `error.EndOfStream` if `source` contains fewer than 4 bytes</span>
<span class="tok-comment">///   - `error.ReservedBitSet` if the frame is a Zstandard frame and any of the</span>
<span class="tok-comment">///     reserved bits are set</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeFrameHeader</span>(source: <span class="tok-kw">anytype</span>) (<span class="tok-builtin">@TypeOf</span>(source).Error || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.HeaderError">HeaderError</a>)!<a href="std.compress.zstandard.decompress.FrameHeader.html">FrameHeader</a> {
    <span class="tok-kw">const</span> magic = <span class="tok-kw">try</span> source.readInt(<span class="tok-type">u32</span>, .little);
    <span class="tok-kw">const</span> frame_type = <span class="tok-kw">try</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.frameType">frameType</a>(magic);
    <span class="tok-kw">switch</span> (frame_type) {
        .zstandard =&gt; <span class="tok-kw">return</span> <a href="std.compress.zstandard.decompress.FrameHeader.html">FrameHeader</a>{ .zstandard = <span class="tok-kw">try</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeZstandardHeader">decodeZstandardHeader</a>(source) },
        .skippable =&gt; <span class="tok-kw">return</span> <a href="std.compress.zstandard.decompress.FrameHeader.html">FrameHeader</a>{
            .skippable = .{
                .magic_number = magic,
                .frame_size = <span class="tok-kw">try</span> source.readInt(<span class="tok-type">u32</span>, .little),
            },
        },
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadWriteCount = <span class="tok-kw">struct</span> {
    read_count: <span class="tok-type">usize</span>,
    write_count: <span class="tok-type">usize</span>,
};

<span class="tok-comment">/// Decodes frames from `src` into `dest`; returns the length of the result.</span>
<span class="tok-comment">/// The stream should not have extra trailing bytes - either all bytes in `src`</span>
<span class="tok-comment">/// will be decoded, or an error will be returned. An error will be returned if</span>
<span class="tok-comment">/// a Zstandard frame in `src` does not declare its content size.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Errors returned:</span>
<span class="tok-comment">///   - `error.DictionaryIdFlagUnsupported` if a `src` contains a frame that</span>
<span class="tok-comment">///     uses a dictionary</span>
<span class="tok-comment">///   - `error.MalformedFrame` if a frame in `src` is invalid</span>
<span class="tok-comment">///   - `error.UnknownContentSizeUnsupported` if a frame in `src` does not</span>
<span class="tok-comment">///     declare its content size</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decode</span>(dest: []<span class="tok-type">u8</span>, src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, verify_checksum: <span class="tok-type">bool</span>) <span class="tok-kw">error</span>{
    MalformedFrame,
    UnknownContentSizeUnsupported,
    DictionaryIdFlagUnsupported,
}!<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> write_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> read_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (read_count &lt; src.len) {
        <span class="tok-kw">const</span> counts = <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeFrame">decodeFrame</a>(dest, src[read_count..], verify_checksum) <span class="tok-kw">catch</span> |err| {
            <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.UnknownContentSizeUnsupported =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownContentSizeUnsupported,
                <span class="tok-kw">error</span>.DictionaryIdFlagUnsupported =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DictionaryIdFlagUnsupported,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedFrame,
            }
        };
        read_count += counts.read_count;
        write_count += counts.write_count;
    }
    <span class="tok-kw">return</span> write_count;
}

<span class="tok-comment">/// Decodes a stream of frames from `src`; returns the decoded bytes. The stream</span>
<span class="tok-comment">/// should not have extra trailing bytes - either all bytes in `src` will be</span>
<span class="tok-comment">/// decoded, or an error will be returned.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Errors returned:</span>
<span class="tok-comment">///   - `error.DictionaryIdFlagUnsupported` if a `src` contains a frame that</span>
<span class="tok-comment">///     uses a dictionary</span>
<span class="tok-comment">///   - `error.MalformedFrame` if a frame in `src` is invalid</span>
<span class="tok-comment">///   - `error.OutOfMemory` if `allocator` cannot allocate enough memory</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeAlloc</span>(
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    verify_checksum: <span class="tok-type">bool</span>,
    window_size_max: <span class="tok-type">usize</span>,
) <span class="tok-kw">error</span>{ DictionaryIdFlagUnsupported, MalformedFrame, OutOfMemory }![]<span class="tok-type">u8</span> {
    <span class="tok-kw">var</span> result = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(allocator);
    <span class="tok-kw">errdefer</span> result.deinit();

    <span class="tok-kw">var</span> read_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (read_count &lt; src.len) {
        read_count += <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeFrameArrayList">decodeFrameArrayList</a>(
            allocator,
            &amp;result,
            src[read_count..],
            verify_checksum,
            window_size_max,
        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
            <span class="tok-kw">error</span>.DictionaryIdFlagUnsupported =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DictionaryIdFlagUnsupported,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedFrame,
        };
    }
    <span class="tok-kw">return</span> result.toOwnedSlice();
}

<span class="tok-comment">/// Decodes the frame at the start of `src` into `dest`. Returns the number of</span>
<span class="tok-comment">/// bytes read from `src` and written to `dest`. This function can only decode</span>
<span class="tok-comment">/// frames that declare the decompressed content size.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Errors returned:</span>
<span class="tok-comment">///   - `error.BadMagic` if the first 4 bytes of `src` is not a valid magic</span>
<span class="tok-comment">///     number for a Zstandard or skippable frame</span>
<span class="tok-comment">///   - `error.UnknownContentSizeUnsupported` if the frame does not declare the</span>
<span class="tok-comment">///     uncompressed content size</span>
<span class="tok-comment">///   - `error.WindowSizeUnknown` if the frame does not have a valid window size</span>
<span class="tok-comment">///   - `error.ContentTooLarge` if `dest` is smaller than the uncompressed data</span>
<span class="tok-comment">///     size declared by the frame header</span>
<span class="tok-comment">///   - `error.ContentSizeTooLarge` if the frame header indicates a content size</span>
<span class="tok-comment">///     that is larger than `std.math.maxInt(usize)`</span>
<span class="tok-comment">///   - `error.DictionaryIdFlagUnsupported` if the frame uses a dictionary</span>
<span class="tok-comment">///   - `error.ChecksumFailure` if `verify_checksum` is true and the frame</span>
<span class="tok-comment">///     contains a checksum that does not match the checksum of the decompressed</span>
<span class="tok-comment">///     data</span>
<span class="tok-comment">///   - `error.ReservedBitSet` if any of the reserved bits of the frame header</span>
<span class="tok-comment">///     are set</span>
<span class="tok-comment">///   - `error.EndOfStream` if `src` does not contain a complete frame</span>
<span class="tok-comment">///   - `error.BadContentSize` if the content size declared by the frame does</span>
<span class="tok-comment">///     not equal the actual size of decompressed data</span>
<span class="tok-comment">///   - an error in `block.Error` if there are errors decoding a block</span>
<span class="tok-comment">///   - `error.SkippableSizeTooLarge` if the frame is skippable and reports a</span>
<span class="tok-comment">///     size greater than `src.len`</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeFrame</span>(
    dest: []<span class="tok-type">u8</span>,
    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    verify_checksum: <span class="tok-type">bool</span>,
) (<span class="tok-kw">error</span>{
    BadMagic,
    UnknownContentSizeUnsupported,
    ContentTooLarge,
    ContentSizeTooLarge,
    WindowSizeUnknown,
    DictionaryIdFlagUnsupported,
    SkippableSizeTooLarge,
} || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.FrameError">FrameError</a>)!<a href="std.compress.zstandard.decompress.ReadWriteCount.html">ReadWriteCount</a> {
    <span class="tok-kw">var</span> fbs = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(src);
    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeFrameType">decodeFrameType</a>(fbs.reader())) {
        .zstandard =&gt; <span class="tok-kw">return</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeZstandardFrame">decodeZstandardFrame</a>(dest, src, verify_checksum),
        .skippable =&gt; {
            <span class="tok-kw">const</span> content_size = <span class="tok-kw">try</span> fbs.reader().readInt(<span class="tok-type">u32</span>, .little);
            <span class="tok-kw">if</span> (content_size &gt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>) - <span class="tok-number">8</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkippableSizeTooLarge;
            <span class="tok-kw">const</span> read_count = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, content_size) + <span class="tok-number">8</span>;
            <span class="tok-kw">if</span> (read_count &gt; src.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkippableSizeTooLarge;
            <span class="tok-kw">return</span> <a href="std.compress.zstandard.decompress.ReadWriteCount.html">ReadWriteCount</a>{
                .read_count = read_count,
                .write_count = <span class="tok-number">0</span>,
            };
        },
    }
}

<span class="tok-comment">/// Decodes the frame at the start of `src` into `dest`. Returns the number of</span>
<span class="tok-comment">/// bytes read from `src`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Errors returned:</span>
<span class="tok-comment">///   - `error.BadMagic` if the first 4 bytes of `src` is not a valid magic</span>
<span class="tok-comment">///     number for a Zstandard or skippable frame</span>
<span class="tok-comment">///   - `error.WindowSizeUnknown` if the frame does not have a valid window size</span>
<span class="tok-comment">///   - `error.WindowTooLarge` if the window size is larger than</span>
<span class="tok-comment">///     `window_size_max`</span>
<span class="tok-comment">///   - `error.ContentSizeTooLarge` if the frame header indicates a content size</span>
<span class="tok-comment">///     that is larger than `std.math.maxInt(usize)`</span>
<span class="tok-comment">///   - `error.DictionaryIdFlagUnsupported` if the frame uses a dictionary</span>
<span class="tok-comment">///   - `error.ChecksumFailure` if `verify_checksum` is true and the frame</span>
<span class="tok-comment">///     contains a checksum that does not match the checksum of the decompressed</span>
<span class="tok-comment">///     data</span>
<span class="tok-comment">///   - `error.ReservedBitSet` if any of the reserved bits of the frame header</span>
<span class="tok-comment">///     are set</span>
<span class="tok-comment">///   - `error.EndOfStream` if `src` does not contain a complete frame</span>
<span class="tok-comment">///   - `error.BadContentSize` if the content size declared by the frame does</span>
<span class="tok-comment">///     not equal the actual size of decompressed data</span>
<span class="tok-comment">///   - `error.OutOfMemory` if `allocator` cannot allocate enough memory</span>
<span class="tok-comment">///   - an error in `block.Error` if there are errors decoding a block</span>
<span class="tok-comment">///   - `error.SkippableSizeTooLarge` if the frame is skippable and reports a</span>
<span class="tok-comment">///     size greater than `src.len`</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeFrameArrayList</span>(
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    dest: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>),
    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    verify_checksum: <span class="tok-type">bool</span>,
    window_size_max: <span class="tok-type">usize</span>,
) (<span class="tok-kw">error</span>{ BadMagic, OutOfMemory, SkippableSizeTooLarge } || <a href="std.compress.zstandard.decompress.FrameContext.html">FrameContext</a>.<a href="std.compress.zstandard.decompress.FrameContext.html#std.compress.zstandard.decompress.FrameContext.Error">Error</a> || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.FrameError">FrameError</a>)!<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> fbs = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(src);
    <span class="tok-kw">const</span> reader = fbs.reader();
    <span class="tok-kw">const</span> magic = <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, .little);
    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.frameType">frameType</a>(magic)) {
        .zstandard =&gt; <span class="tok-kw">return</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeZstandardFrameArrayList">decodeZstandardFrameArrayList</a>(
            allocator,
            dest,
            src,
            verify_checksum,
            window_size_max,
        ),
        .skippable =&gt; {
            <span class="tok-kw">const</span> content_size = <span class="tok-kw">try</span> fbs.reader().readInt(<span class="tok-type">u32</span>, .little);
            <span class="tok-kw">if</span> (content_size &gt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>) - <span class="tok-number">8</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkippableSizeTooLarge;
            <span class="tok-kw">const</span> read_count = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, content_size) + <span class="tok-number">8</span>;
            <span class="tok-kw">if</span> (read_count &gt; src.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkippableSizeTooLarge;
            <span class="tok-kw">return</span> read_count;
        },
    }
}

<span class="tok-comment">/// Returns the frame checksum corresponding to the data fed into `hasher`</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">computeChecksum</span>(hasher: *<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.xxhash.XxHash64.html">XxHash64</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> hash = hasher.final();
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(hash &amp; <span class="tok-number">0xFFFFFFFF</span>));
}

<span class="tok-kw">const</span> FrameError = <span class="tok-kw">error</span>{
    ChecksumFailure,
    BadContentSize,
    EndOfStream,
    ReservedBitSet,
} || <a href="std.compress.zstandard.decode.block.html">block</a>.<a href="std.compress.zstandard.decode.block.html#std.compress.zstandard.decode.block.Error">Error</a>;

<span class="tok-comment">/// Decode a Zstandard frame from `src` into `dest`, returning the number of</span>
<span class="tok-comment">/// bytes read from `src` and written to `dest`. The first four bytes of `src`</span>
<span class="tok-comment">/// must be the magic number for a Zstandard frame.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Error returned:</span>
<span class="tok-comment">///   - `error.UnknownContentSizeUnsupported` if the frame does not declare the</span>
<span class="tok-comment">///     uncompressed content size</span>
<span class="tok-comment">///   - `error.ContentTooLarge` if `dest` is smaller than the uncompressed data</span>
<span class="tok-comment">///     size declared by the frame header</span>
<span class="tok-comment">///   - `error.WindowSizeUnknown` if the frame does not have a valid window size</span>
<span class="tok-comment">///   - `error.DictionaryIdFlagUnsupported` if the frame uses a dictionary</span>
<span class="tok-comment">///   - `error.ContentSizeTooLarge` if the frame header indicates a content size</span>
<span class="tok-comment">///     that is larger than `std.math.maxInt(usize)`</span>
<span class="tok-comment">///   - `error.ChecksumFailure` if `verify_checksum` is true and the frame</span>
<span class="tok-comment">///     contains a checksum that does not match the checksum of the decompressed</span>
<span class="tok-comment">///     data</span>
<span class="tok-comment">///   - `error.ReservedBitSet` if the reserved bit of the frame header is set</span>
<span class="tok-comment">///   - `error.EndOfStream` if `src` does not contain a complete frame</span>
<span class="tok-comment">///   - an error in `block.Error` if there are errors decoding a block</span>
<span class="tok-comment">///   - `error.BadContentSize` if the content size declared by the frame does</span>
<span class="tok-comment">///     not equal the actual size of decompressed data</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeZstandardFrame</span>(
    dest: []<span class="tok-type">u8</span>,
    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    verify_checksum: <span class="tok-type">bool</span>,
) (<span class="tok-kw">error</span>{
    UnknownContentSizeUnsupported,
    ContentTooLarge,
    ContentSizeTooLarge,
    WindowSizeUnknown,
    DictionaryIdFlagUnsupported,
} || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.FrameError">FrameError</a>)!<a href="std.compress.zstandard.decompress.ReadWriteCount.html">ReadWriteCount</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, src[<span class="tok-number">0</span>..<span class="tok-number">4</span>], .little) == <a href="std.compress.zstandard.types.frame.html">frame</a>.<a href="std.compress.zstandard.types.frame.Zstandard.html">Zstandard</a>.<a href="std.compress.zstandard.types.frame.Zstandard.html#std.compress.zstandard.types.frame.Zstandard.magic_number">magic_number</a>);
    <span class="tok-kw">var</span> consumed_count: <span class="tok-type">usize</span> = <span class="tok-number">4</span>;

    <span class="tok-kw">var</span> frame_context = context: {
        <span class="tok-kw">var</span> fbs = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(src[consumed_count..]);
        <span class="tok-kw">const</span> source = fbs.reader();
        <span class="tok-kw">const</span> frame_header = <span class="tok-kw">try</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeZstandardHeader">decodeZstandardHeader</a>(source);
        consumed_count += fbs.pos;
        <span class="tok-kw">break</span> :context <a href="std.compress.zstandard.decompress.FrameContext.html">FrameContext</a>.<a href="std.compress.zstandard.decompress.FrameContext.html#std.compress.zstandard.decompress.FrameContext.init">init</a>(
            frame_header,
            <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>),
            verify_checksum,
        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WindowTooLarge =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    };
    <span class="tok-kw">const</span> counts = <span class="tok-kw">try</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeZStandardFrameBlocks">decodeZStandardFrameBlocks</a>(
        dest,
        src[consumed_count..],
        &amp;frame_context,
    );
    <span class="tok-kw">return</span> <a href="std.compress.zstandard.decompress.ReadWriteCount.html">ReadWriteCount</a>{
        .read_count = counts.read_count + consumed_count,
        .write_count = counts.write_count,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeZStandardFrameBlocks</span>(
    dest: []<span class="tok-type">u8</span>,
    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    frame_context: *<a href="std.compress.zstandard.decompress.FrameContext.html">FrameContext</a>,
) (<span class="tok-kw">error</span>{ ContentTooLarge, UnknownContentSizeUnsupported } || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.FrameError">FrameError</a>)!<a href="std.compress.zstandard.decompress.ReadWriteCount.html">ReadWriteCount</a> {
    <span class="tok-kw">const</span> content_size = frame_context.content_size <span class="tok-kw">orelse</span>
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownContentSizeUnsupported;
    <span class="tok-kw">if</span> (dest.len &lt; content_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ContentTooLarge;

    <span class="tok-kw">var</span> consumed_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> written_count = <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeFrameBlocksInner">decodeFrameBlocksInner</a>(
        dest[<span class="tok-number">0</span>..content_size],
        src[consumed_count..],
        &amp;consumed_count,
        <span class="tok-kw">if</span> (frame_context.hasher_opt) |*hasher| hasher <span class="tok-kw">else</span> <span class="tok-null">null</span>,
        frame_context.block_size_max,
    ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.DestTooSmall =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadContentSize,
        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };

    <span class="tok-kw">if</span> (written_count != content_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadContentSize;
    <span class="tok-kw">if</span> (frame_context.has_checksum) {
        <span class="tok-kw">if</span> (src.len &lt; consumed_count + <span class="tok-number">4</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfStream;
        <span class="tok-kw">const</span> checksum = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, src[consumed_count..][<span class="tok-number">0</span>..<span class="tok-number">4</span>], .little);
        consumed_count += <span class="tok-number">4</span>;
        <span class="tok-kw">if</span> (frame_context.hasher_opt) |*hasher| {
            <span class="tok-kw">if</span> (checksum != <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.computeChecksum">computeChecksum</a>(hasher)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ChecksumFailure;
        }
    }
    <span class="tok-kw">return</span> <a href="std.compress.zstandard.decompress.ReadWriteCount.html">ReadWriteCount</a>{ .read_count = consumed_count, .write_count = written_count };
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FrameContext = <span class="tok-kw">struct</span> {
    hasher_opt: ?<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.xxhash.XxHash64.html">XxHash64</a>,
    window_size: <span class="tok-type">usize</span>,
    has_checksum: <span class="tok-type">bool</span>,
    block_size_max: <span class="tok-type">usize</span>,
    content_size: ?<span class="tok-type">usize</span>,

    <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{
        DictionaryIdFlagUnsupported,
        WindowSizeUnknown,
        WindowTooLarge,
        ContentSizeTooLarge,
    };
    <span class="tok-comment">/// Validates `frame_header` and returns the associated `FrameContext`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Errors returned:</span>
    <span class="tok-comment">///   - `error.DictionaryIdFlagUnsupported` if the frame uses a dictionary</span>
    <span class="tok-comment">///   - `error.WindowSizeUnknown` if the frame does not have a valid window</span>
    <span class="tok-comment">///     size</span>
    <span class="tok-comment">///   - `error.WindowTooLarge` if the window size is larger than</span>
    <span class="tok-comment">///     `window_size_max` or `std.math.intMax(usize)`</span>
    <span class="tok-comment">///   - `error.ContentSizeTooLarge` if the frame header indicates a content</span>
    <span class="tok-comment">///     size larger than `std.math.maxInt(usize)`</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(
        frame_header: <a href="std.compress.zstandard.types.frame.Zstandard.Header.html">ZstandardHeader</a>,
        window_size_max: <span class="tok-type">usize</span>,
        verify_checksum: <span class="tok-type">bool</span>,
    ) <a href="std.compress.zstandard.decompress.FrameContext.html#std.compress.zstandard.decompress.FrameContext.Error">Error</a>!<a href="std.compress.zstandard.decompress.FrameContext.html">FrameContext</a> {
        <span class="tok-kw">if</span> (frame_header.descriptor.dictionary_id_flag != <span class="tok-number">0</span>)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DictionaryIdFlagUnsupported;

        <span class="tok-kw">const</span> window_size_raw = <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.frameWindowSize">frameWindowSize</a>(frame_header) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WindowSizeUnknown;
        <span class="tok-kw">const</span> window_size = <span class="tok-kw">if</span> (window_size_raw &gt; window_size_max)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WindowTooLarge
        <span class="tok-kw">else</span>
            <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, window_size_raw) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WindowTooLarge;

        <span class="tok-kw">const</span> should_compute_checksum =
            frame_header.descriptor.content_checksum_flag <span class="tok-kw">and</span> verify_checksum;

        <span class="tok-kw">const</span> content_size = <span class="tok-kw">if</span> (frame_header.content_size) |size|
            <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, size) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ContentSizeTooLarge
        <span class="tok-kw">else</span>
            <span class="tok-null">null</span>;

        <span class="tok-kw">return</span> .{
            .hasher_opt = <span class="tok-kw">if</span> (should_compute_checksum) <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.xxhash.XxHash64.html">XxHash64</a>.<a href="std.hash.xxhash.XxHash64.html#std.hash.xxhash.XxHash64.init">init</a>(<span class="tok-number">0</span>) <span class="tok-kw">else</span> <span class="tok-null">null</span>,
            .window_size = window_size,
            .has_checksum = frame_header.descriptor.content_checksum_flag,
            .block_size_max = <span class="tok-builtin">@min</span>(<a href="std.compress.zstandard.types.html">types</a>.<a href="std.compress.zstandard.types.html#std.compress.zstandard.types.block_size_max">block_size_max</a>, window_size),
            .content_size = content_size,
        };
    }
};

<span class="tok-comment">/// Decode a Zstandard from from `src` and return number of bytes read; see</span>
<span class="tok-comment">/// `decodeZstandardFrame()`. The first four bytes of `src` must be the magic</span>
<span class="tok-comment">/// number for a Zstandard frame.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Errors returned:</span>
<span class="tok-comment">///   - `error.WindowSizeUnknown` if the frame does not have a valid window size</span>
<span class="tok-comment">///   - `error.WindowTooLarge` if the window size is larger than</span>
<span class="tok-comment">///     `window_size_max`</span>
<span class="tok-comment">///   - `error.DictionaryIdFlagUnsupported` if the frame uses a dictionary</span>
<span class="tok-comment">///   - `error.ContentSizeTooLarge` if the frame header indicates a content size</span>
<span class="tok-comment">///     that is larger than `std.math.maxInt(usize)`</span>
<span class="tok-comment">///   - `error.ChecksumFailure` if `verify_checksum` is true and the frame</span>
<span class="tok-comment">///     contains a checksum that does not match the checksum of the decompressed</span>
<span class="tok-comment">///     data</span>
<span class="tok-comment">///   - `error.ReservedBitSet` if the reserved bit of the frame header is set</span>
<span class="tok-comment">///   - `error.EndOfStream` if `src` does not contain a complete frame</span>
<span class="tok-comment">///   - `error.OutOfMemory` if `allocator` cannot allocate enough memory</span>
<span class="tok-comment">///   - an error in `block.Error` if there are errors decoding a block</span>
<span class="tok-comment">///   - `error.BadContentSize` if the content size declared by the frame does</span>
<span class="tok-comment">///     not equal the size of decompressed data</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeZstandardFrameArrayList</span>(
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    dest: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>),
    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    verify_checksum: <span class="tok-type">bool</span>,
    window_size_max: <span class="tok-type">usize</span>,
) (<span class="tok-kw">error</span>{OutOfMemory} || <a href="std.compress.zstandard.decompress.FrameContext.html">FrameContext</a>.<a href="std.compress.zstandard.decompress.FrameContext.html#std.compress.zstandard.decompress.FrameContext.Error">Error</a> || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.FrameError">FrameError</a>)!<span class="tok-type">usize</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, src[<span class="tok-number">0</span>..<span class="tok-number">4</span>], .little) == <a href="std.compress.zstandard.types.frame.html">frame</a>.<a href="std.compress.zstandard.types.frame.Zstandard.html">Zstandard</a>.<a href="std.compress.zstandard.types.frame.Zstandard.html#std.compress.zstandard.types.frame.Zstandard.magic_number">magic_number</a>);
    <span class="tok-kw">var</span> consumed_count: <span class="tok-type">usize</span> = <span class="tok-number">4</span>;

    <span class="tok-kw">var</span> frame_context = context: {
        <span class="tok-kw">var</span> fbs = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(src[consumed_count..]);
        <span class="tok-kw">const</span> source = fbs.reader();
        <span class="tok-kw">const</span> frame_header = <span class="tok-kw">try</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeZstandardHeader">decodeZstandardHeader</a>(source);
        consumed_count += fbs.pos;
        <span class="tok-kw">break</span> :context <span class="tok-kw">try</span> <a href="std.compress.zstandard.decompress.FrameContext.html">FrameContext</a>.<a href="std.compress.zstandard.decompress.FrameContext.html#std.compress.zstandard.decompress.FrameContext.init">init</a>(frame_header, window_size_max, verify_checksum);
    };

    consumed_count += <span class="tok-kw">try</span> <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.decodeZstandardFrameBlocksArrayList">decodeZstandardFrameBlocksArrayList</a>(
        allocator,
        dest,
        src[consumed_count..],
        &amp;frame_context,
    );
    <span class="tok-kw">return</span> consumed_count;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeZstandardFrameBlocksArrayList</span>(
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    dest: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>),
    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    frame_context: *<a href="std.compress.zstandard.decompress.FrameContext.html">FrameContext</a>,
) (<span class="tok-kw">error</span>{OutOfMemory} || <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.FrameError">FrameError</a>)!<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> initial_len = dest.items.len;

    <span class="tok-kw">var</span> ring_buffer = <span class="tok-kw">try</span> <a href="std.RingBuffer.html">RingBuffer</a>.<a href="std.RingBuffer.html#std.RingBuffer.init">init</a>(allocator, frame_context.window_size);
    <span class="tok-kw">defer</span> ring_buffer.deinit(allocator);<span class="tok-comment">

    // These tables take 7680 bytes
    </span><span class="tok-kw">var</span> literal_fse_data: [<a href="std.compress.zstandard.types.html">types</a>.<a href="std.compress.zstandard.types.compressed_block.html">compressed_block</a>.<a href="std.compress.zstandard.types.compressed_block.table_size_max.html">table_size_max</a>.<a href="std.compress.zstandard.types.compressed_block.table_size_max.html#std.compress.zstandard.types.compressed_block.table_size_max.literal">literal</a>]<a href="std.compress.zstandard.types.compressed_block.Table.html">Table</a>.<a href="std.compress.zstandard.types.compressed_block.Table.Fse.html">Fse</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> match_fse_data: [<a href="std.compress.zstandard.types.html">types</a>.<a href="std.compress.zstandard.types.compressed_block.html">compressed_block</a>.<a href="std.compress.zstandard.types.compressed_block.table_size_max.html">table_size_max</a>.<a href="std.compress.zstandard.types.compressed_block.table_size_max.html#std.compress.zstandard.types.compressed_block.table_size_max.match">match</a>]<a href="std.compress.zstandard.types.compressed_block.Table.html">Table</a>.<a href="std.compress.zstandard.types.compressed_block.Table.Fse.html">Fse</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> offset_fse_data: [<a href="std.compress.zstandard.types.html">types</a>.<a href="std.compress.zstandard.types.compressed_block.html">compressed_block</a>.<a href="std.compress.zstandard.types.compressed_block.table_size_max.html">table_size_max</a>.<a href="std.compress.zstandard.types.compressed_block.table_size_max.html#std.compress.zstandard.types.compressed_block.table_size_max.offset">offset</a>]<a href="std.compress.zstandard.types.compressed_block.Table.html">Table</a>.<a href="std.compress.zstandard.types.compressed_block.Table.Fse.html">Fse</a> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">var</span> block_header = <span class="tok-kw">try</span> <a href="std.compress.zstandard.decode.block.html">block</a>.<a href="std.compress.zstandard.decode.block.html#std.compress.zstandard.decode.block.decodeBlockHeaderSlice">decodeBlockHeaderSlice</a>(src);
    <span class="tok-kw">var</span> consumed_count: <span class="tok-type">usize</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">var</span> decode_state = <a href="std.compress.zstandard.decode.block.html">block</a>.<a href="std.compress.zstandard.decode.block.DecodeState.html">DecodeState</a>.<a href="std.compress.zstandard.decode.block.DecodeState.html#std.compress.zstandard.decode.block.DecodeState.init">init</a>(&amp;literal_fse_data, &amp;match_fse_data, &amp;offset_fse_data);
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : ({
        block_header = <span class="tok-kw">try</span> <a href="std.compress.zstandard.decode.block.html">block</a>.<a href="std.compress.zstandard.decode.block.html#std.compress.zstandard.decode.block.decodeBlockHeaderSlice">decodeBlockHeaderSlice</a>(src[consumed_count..]);
        consumed_count += <span class="tok-number">3</span>;
    }) {
        <span class="tok-kw">const</span> written_size = <span class="tok-kw">try</span> <a href="std.compress.zstandard.decode.block.html">block</a>.<a href="std.compress.zstandard.decode.block.html#std.compress.zstandard.decode.block.decodeBlockRingBuffer">decodeBlockRingBuffer</a>(
            &amp;ring_buffer,
            src[consumed_count..],
            block_header,
            &amp;decode_state,
            &amp;consumed_count,
            frame_context.block_size_max,
        );
        <span class="tok-kw">if</span> (frame_context.content_size) |size| {
            <span class="tok-kw">if</span> (dest.items.len - initial_len &gt; size) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadContentSize;
            }
        }
        <span class="tok-kw">if</span> (written_size &gt; <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> written_slice = ring_buffer.sliceLast(written_size);
            <span class="tok-kw">try</span> dest.appendSlice(written_slice.first);
            <span class="tok-kw">try</span> dest.appendSlice(written_slice.second);
            <span class="tok-kw">if</span> (frame_context.hasher_opt) |*hasher| {
                hasher.update(written_slice.first);
                hasher.update(written_slice.second);
            }
        }
        <span class="tok-kw">if</span> (block_header.last_block) <span class="tok-kw">break</span>;
    }
    <span class="tok-kw">if</span> (frame_context.content_size) |size| {
        <span class="tok-kw">if</span> (dest.items.len - initial_len != size) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadContentSize;
        }
    }

    <span class="tok-kw">if</span> (frame_context.has_checksum) {
        <span class="tok-kw">if</span> (src.len &lt; consumed_count + <span class="tok-number">4</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfStream;
        <span class="tok-kw">const</span> checksum = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, src[consumed_count..][<span class="tok-number">0</span>..<span class="tok-number">4</span>], .little);
        consumed_count += <span class="tok-number">4</span>;
        <span class="tok-kw">if</span> (frame_context.hasher_opt) |*hasher| {
            <span class="tok-kw">if</span> (checksum != <a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.computeChecksum">computeChecksum</a>(hasher)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ChecksumFailure;
        }
    }
    <span class="tok-kw">return</span> consumed_count;
}

<span class="tok-kw">fn</span> <span class="tok-fn">decodeFrameBlocksInner</span>(
    dest: []<span class="tok-type">u8</span>,
    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    consumed_count: *<span class="tok-type">usize</span>,
    hash: ?*<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.xxhash.XxHash64.html">XxHash64</a>,
    block_size_max: <span class="tok-type">usize</span>,
) (<span class="tok-kw">error</span>{ EndOfStream, DestTooSmall } || <a href="std.compress.zstandard.decode.block.html">block</a>.<a href="std.compress.zstandard.decode.block.html#std.compress.zstandard.decode.block.Error">Error</a>)!<span class="tok-type">usize</span> {<span class="tok-comment">
    // These tables take 7680 bytes
    </span><span class="tok-kw">var</span> literal_fse_data: [<a href="std.compress.zstandard.types.html">types</a>.<a href="std.compress.zstandard.types.compressed_block.html">compressed_block</a>.<a href="std.compress.zstandard.types.compressed_block.table_size_max.html">table_size_max</a>.<a href="std.compress.zstandard.types.compressed_block.table_size_max.html#std.compress.zstandard.types.compressed_block.table_size_max.literal">literal</a>]<a href="std.compress.zstandard.types.compressed_block.Table.html">Table</a>.<a href="std.compress.zstandard.types.compressed_block.Table.Fse.html">Fse</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> match_fse_data: [<a href="std.compress.zstandard.types.html">types</a>.<a href="std.compress.zstandard.types.compressed_block.html">compressed_block</a>.<a href="std.compress.zstandard.types.compressed_block.table_size_max.html">table_size_max</a>.<a href="std.compress.zstandard.types.compressed_block.table_size_max.html#std.compress.zstandard.types.compressed_block.table_size_max.match">match</a>]<a href="std.compress.zstandard.types.compressed_block.Table.html">Table</a>.<a href="std.compress.zstandard.types.compressed_block.Table.Fse.html">Fse</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> offset_fse_data: [<a href="std.compress.zstandard.types.html">types</a>.<a href="std.compress.zstandard.types.compressed_block.html">compressed_block</a>.<a href="std.compress.zstandard.types.compressed_block.table_size_max.html">table_size_max</a>.<a href="std.compress.zstandard.types.compressed_block.table_size_max.html#std.compress.zstandard.types.compressed_block.table_size_max.offset">offset</a>]<a href="std.compress.zstandard.types.compressed_block.Table.html">Table</a>.<a href="std.compress.zstandard.types.compressed_block.Table.Fse.html">Fse</a> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">var</span> block_header = <span class="tok-kw">try</span> <a href="std.compress.zstandard.decode.block.html">block</a>.<a href="std.compress.zstandard.decode.block.html#std.compress.zstandard.decode.block.decodeBlockHeaderSlice">decodeBlockHeaderSlice</a>(src);
    <span class="tok-kw">var</span> bytes_read: <span class="tok-type">usize</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">defer</span> consumed_count.* += bytes_read;
    <span class="tok-kw">var</span> decode_state = <a href="std.compress.zstandard.decode.block.html">block</a>.<a href="std.compress.zstandard.decode.block.DecodeState.html">DecodeState</a>.<a href="std.compress.zstandard.decode.block.DecodeState.html#std.compress.zstandard.decode.block.DecodeState.init">init</a>(&amp;literal_fse_data, &amp;match_fse_data, &amp;offset_fse_data);
    <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : ({
        block_header = <span class="tok-kw">try</span> <a href="std.compress.zstandard.decode.block.html">block</a>.<a href="std.compress.zstandard.decode.block.html#std.compress.zstandard.decode.block.decodeBlockHeaderSlice">decodeBlockHeaderSlice</a>(src[bytes_read..]);
        bytes_read += <span class="tok-number">3</span>;
    }) {
        <span class="tok-kw">const</span> written_size = <span class="tok-kw">try</span> <a href="std.compress.zstandard.decode.block.html">block</a>.<a href="std.compress.zstandard.decode.block.html#std.compress.zstandard.decode.block.decodeBlock">decodeBlock</a>(
            dest,
            src[bytes_read..],
            block_header,
            &amp;decode_state,
            &amp;bytes_read,
            block_size_max,
            count,
        );
        <span class="tok-kw">if</span> (hash) |hash_state| hash_state.update(dest[count .. count + written_size]);
        count += written_size;
        <span class="tok-kw">if</span> (block_header.last_block) <span class="tok-kw">break</span>;
    }
    <span class="tok-kw">return</span> count;
}

<span class="tok-comment">/// Decode the header of a skippable frame. The first four bytes of `src` must</span>
<span class="tok-comment">/// be a valid magic number for a skippable frame.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeSkippableHeader</span>(src: *<span class="tok-kw">const</span> [<span class="tok-number">8</span>]<span class="tok-type">u8</span>) <a href="std.compress.zstandard.types.frame.Skippable.Header.html">SkippableHeader</a> {
    <span class="tok-kw">const</span> magic = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, src[<span class="tok-number">0</span>..<span class="tok-number">4</span>], .little);
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.compress.zstandard.decompress.html#std.compress.zstandard.decompress.isSkippableMagic">isSkippableMagic</a>(magic));
    <span class="tok-kw">const</span> frame_size = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, src[<span class="tok-number">4</span>..<span class="tok-number">8</span>], .little);
    <span class="tok-kw">return</span> .{
        .magic_number = magic,
        .frame_size = frame_size,
    };
}

<span class="tok-comment">/// Returns the window size required to decompress a frame, or `null` if it</span>
<span class="tok-comment">/// cannot be determined (which indicates a malformed frame header).</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">frameWindowSize</span>(header: <a href="std.compress.zstandard.types.frame.Zstandard.Header.html">ZstandardHeader</a>) ?<span class="tok-type">u64</span> {
    <span class="tok-kw">if</span> (header.window_descriptor) |descriptor| {
        <span class="tok-kw">const</span> exponent = (descriptor &amp; <span class="tok-number">0b11111000</span>) &gt;&gt; <span class="tok-number">3</span>;
        <span class="tok-kw">const</span> mantissa = descriptor &amp; <span class="tok-number">0b00000111</span>;
        <span class="tok-kw">const</span> window_log = <span class="tok-number">10</span> + exponent;
        <span class="tok-kw">const</span> window_base = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(<span class="tok-type">u6</span>, <span class="tok-builtin">@intCast</span>(window_log));
        <span class="tok-kw">const</span> window_add = (window_base / <span class="tok-number">8</span>) * mantissa;
        <span class="tok-kw">return</span> window_base + window_add;
    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> header.content_size;
}

<span class="tok-comment">/// Decode the header of a Zstandard frame.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Errors returned:</span>
<span class="tok-comment">///   - `error.ReservedBitSet` if any of the reserved bits of the header are set</span>
<span class="tok-comment">///   - `error.EndOfStream` if `source` does not contain a complete header</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeZstandardHeader</span>(
    source: <span class="tok-kw">anytype</span>,
) (<span class="tok-builtin">@TypeOf</span>(source).Error || <span class="tok-kw">error</span>{ EndOfStream, ReservedBitSet })!<a href="std.compress.zstandard.types.frame.Zstandard.Header.html">ZstandardHeader</a> {
    <span class="tok-kw">const</span> descriptor = <span class="tok-builtin">@as</span>(<a href="std.compress.zstandard.types.frame.Zstandard.Header.html">ZstandardHeader</a>.<a href="std.compress.zstandard.types.frame.Zstandard.Header.Descriptor.html">Descriptor</a>, <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> source.readByte()));

    <span class="tok-kw">if</span> (descriptor.reserved) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReservedBitSet;

    <span class="tok-kw">var</span> window_descriptor: ?<span class="tok-type">u8</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (!descriptor.single_segment_flag) {
        window_descriptor = <span class="tok-kw">try</span> source.readByte();
    }

    <span class="tok-kw">var</span> dictionary_id: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (descriptor.dictionary_id_flag &gt; <span class="tok-number">0</span>) {<span class="tok-comment">
        // if flag is 3 then field_size = 4, else field_size = flag
        </span><span class="tok-kw">const</span> field_size = (<span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-number">1</span>) &lt;&lt; descriptor.dictionary_id_flag) &gt;&gt; <span class="tok-number">1</span>;
        dictionary_id = <span class="tok-kw">try</span> source.readVarInt(<span class="tok-type">u32</span>, .little, field_size);
    }

    <span class="tok-kw">var</span> content_size: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (descriptor.single_segment_flag <span class="tok-kw">or</span> descriptor.content_size_flag &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> field_size = <span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-number">1</span>) &lt;&lt; descriptor.content_size_flag;
        content_size = <span class="tok-kw">try</span> source.readVarInt(<span class="tok-type">u64</span>, .little, field_size);
        <span class="tok-kw">if</span> (field_size == <span class="tok-number">2</span>) content_size.? += <span class="tok-number">256</span>;
    }

    <span class="tok-kw">const</span> header = <a href="std.compress.zstandard.types.frame.Zstandard.Header.html">ZstandardHeader</a>{
        .descriptor = descriptor,
        .window_descriptor = window_descriptor,
        .dictionary_id = dictionary_id,
        .content_size = content_size,
    };
    <span class="tok-kw">return</span> header;
}

<span class="tok-kw">test</span> {
    <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.refAllDecls">refAllDecls</a>(<span class="tok-builtin">@This</span>());
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
