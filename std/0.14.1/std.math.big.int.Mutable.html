<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">math</a></li><li><a href="std.math.html" class="">big</a></li><li><a href="std.math.big.int.html" class="">int</a></li><li><a href="std.math.big.int.Mutable.html" class="active">Mutable</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.math.big.int.Mutable" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.math.big.int.Mutable</span><a href="#src.zig-std.math.big.int.Mutable">[src]</a></h1><div class="tldDocs"><p>A arbitrary-precision big integer, with a fixed set of mutable limbs.</p>
</div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>limbs: []<a href="std.math.big.html#std.math.big.Limb">Limb</a></code></pre><div class="fieldDocs"><p>Raw digits. These are:</p>
<ul>
<li>Little-endian ordered</li>
<li>limbs.len &gt;= 1</li>
<li>Zero is represented as limbs.len == 1 with limbs[0] == 0.</li>
</ul>
<p>Accessing limbs directly should be avoided.
These are allocated limbs; the <code>len</code> field tells the valid range.</p>
</div></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>positive: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.math.big.int.Mutable.toConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toConst</span><a href="#src.zig-std.math.big.int.Mutable.toConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toConst</span>(self: <a href="std.math.big.int.Mutable.html">Mutable</a>) <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.toConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toConst</span>(self: <a href="std.math.big.int.Mutable.html">Mutable</a>) <a href="std.math.big.int.Const.html">Const</a> {
    <span class="tok-kw">return</span> .{
        .limbs = self.limbs[<span class="tok-number">0</span>..self.len],
        .positive = self.positive,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.eqlZero" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">eqlZero</span><a href="#src.zig-std.math.big.int.Mutable.eqlZero">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlZero</span>(self: <a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true if <code>a == 0</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.eqlZero">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlZero</span>(self: <a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.toConst().eqlZero();
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.toManaged" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toManaged</span><a href="#src.zig-std.math.big.int.Mutable.toManaged">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toManaged</span>(self: <a href="std.math.big.int.Mutable.html">Mutable</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.math.big.int.Managed.html">Managed</a></code></pre></div><div class="tldDocs"><p>Asserts that the allocator owns the limbs memory. If this is not the case,
use <code>toConst().toManaged()</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.toManaged">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toManaged</span>(self: <a href="std.math.big.int.Mutable.html">Mutable</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.math.big.int.Managed.html">Managed</a> {
    <span class="tok-kw">return</span> .{
        .allocator = allocator,
        .limbs = self.limbs,
        .metadata = <span class="tok-kw">if</span> (self.positive)
            self.len &amp; ~<a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>
        <span class="tok-kw">else</span>
            self.len | <a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.math.big.int.Mutable.init">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, value: <span class="tok-kw">anytype</span>) <a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div class="tldDocs"><p><code>value</code> is a primitive integer type.
Asserts the value fits within the provided <code>limbs_buffer</code>.
Note: <code>calcLimbLen</code> can be used to figure out how big an array to allocate for <code>limbs_buffer</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.init">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, value: <span class="tok-kw">anytype</span>) <a href="std.math.big.int.Mutable.html">Mutable</a> {
    limbs_buffer[<span class="tok-number">0</span>] = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> self: <a href="std.math.big.int.Mutable.html">Mutable</a> = .{
        .limbs = limbs_buffer,
        .len = <span class="tok-number">1</span>,
        .positive = <span class="tok-null">true</span>,
    };
    self.set(value);
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.copy" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">copy</span><a href="#src.zig-std.math.big.int.Mutable.copy">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copy</span>(self: *<a href="std.math.big.int.Mutable.html">Mutable</a>, other: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Copies the value of a Const to an existing Mutable so that they both have the same value.
Asserts the value fits in the limbs buffer.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>other: <a href="std.math.big.int.Const.html">Const</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.copy">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copy</span>(self: *<a href="std.math.big.int.Mutable.html">Mutable</a>, other: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (self.limbs.ptr != other.limbs.ptr) {
        <span class="tok-builtin">@memcpy</span>(self.limbs[<span class="tok-number">0</span>..other.limbs.len], other.limbs[<span class="tok-number">0</span>..other.limbs.len]);
    }<span class="tok-comment">
    // Normalize before setting `positive` so the `eqlZero` doesn't need to iterate
    // over the extra zero limbs.
    </span>self.normalize(other.limbs.len);
    self.positive = other.positive <span class="tok-kw">or</span> other.eqlZero();
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.swap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swap</span><a href="#src.zig-std.math.big.int.Mutable.swap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(self: *<a href="std.math.big.int.Mutable.html">Mutable</a>, other: *<a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Efficiently swap an Mutable with another. This swaps the limb pointers and a full copy is not
performed. The address of the limbs field will not be the same after this function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>other: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.swap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(self: *<a href="std.math.big.int.Mutable.html">Mutable</a>, other: *<a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">void</span> {
    <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(<a href="std.math.big.int.Mutable.html">Mutable</a>, self, other);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.dump" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dump</span><a href="#src.zig-std.math.big.int.Mutable.dump">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(self: <a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.dump">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(self: <a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">for</span> (self.limbs[<span class="tok-number">0</span>..self.len]) |limb| {
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;{x} &quot;</span>, .{limb});
    }
    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;capacity={} positive={}\n&quot;</span>, .{ self.limbs.len, self.positive });
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.math.big.int.Mutable.clone">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(other: <a href="std.math.big.int.Mutable.html">Mutable</a>, limbs: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>) <a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div class="tldDocs"><p>Clones an Mutable and returns a new Mutable with the same value. The new Mutable is a deep copy and
can be modified separately from the original.
Asserts that limbs is big enough to store the value.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>other: <a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>limbs: []<a href="std.math.big.html#std.math.big.Limb">Limb</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.clone">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(other: <a href="std.math.big.int.Mutable.html">Mutable</a>, limbs: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>) <a href="std.math.big.int.Mutable.html">Mutable</a> {
    <span class="tok-builtin">@memcpy</span>(limbs[<span class="tok-number">0</span>..other.len], other.limbs[<span class="tok-number">0</span>..other.len]);
    <span class="tok-kw">return</span> .{
        .limbs = limbs,
        .len = other.len,
        .positive = other.positive,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.negate" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">negate</span><a href="#src.zig-std.math.big.int.Mutable.negate">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">negate</span>(self: *<a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.negate">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">negate</span>(self: *<a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">void</span> {
    self.positive = !self.positive;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.abs" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">abs</span><a href="#src.zig-std.math.big.int.Mutable.abs">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">abs</span>(self: *<a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Modify to become the absolute value</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.abs">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">abs</span>(self: *<a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">void</span> {
    self.positive = <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.set" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">set</span><a href="#src.zig-std.math.big.int.Mutable.set">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.math.big.int.Mutable.html">Mutable</a>, value: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sets the Mutable to value. Value must be an primitive integer type.
Asserts the value fits within the limbs buffer.
Note: <code>calcLimbLen</code> can be used to figure out how big the limbs buffer
needs to be to store a specific value.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.set">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.math.big.int.Mutable.html">Mutable</a>, value: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(value);
    <span class="tok-kw">const</span> needed_limbs = <a href="std.math.big.int.html#std.math.big.int.calcLimbLen">calcLimbLen</a>(value);
    <a href="std.debug.html#std.debug.assert">assert</a>(needed_limbs &lt;= self.limbs.len);<span class="tok-comment"> // value too big

    </span>self.len = needed_limbs;
    self.positive = value &gt;= <span class="tok-number">0</span>;

    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .int =&gt; |info| {
            <span class="tok-kw">var</span> w_value = <span class="tok-builtin">@abs</span>(value);

            <span class="tok-kw">if</span> (info.bits &lt;= <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) {
                self.limbs[<span class="tok-number">0</span>] = w_value;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (i += <span class="tok-number">1</span>) {
                    self.limbs[i] = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@truncate</span>(w_value));
                    w_value &gt;&gt;= <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>;

                    <span class="tok-kw">if</span> (w_value == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                }
            }
        },
        .<span class="tok-type">comptime_int</span> =&gt; {
            <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> w_value = <span class="tok-builtin">@abs</span>(value);

            <span class="tok-kw">if</span> (w_value &lt;= <a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) {
                self.limbs[<span class="tok-number">0</span>] = w_value;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> mask = (<span class="tok-number">1</span> &lt;&lt; <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) - <span class="tok-number">1</span>;

                <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
                <span class="tok-kw">inline</span> <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (i += <span class="tok-number">1</span>) {
                    self.limbs[i] = w_value &amp; mask;
                    w_value &gt;&gt;= <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>;

                    <span class="tok-kw">if</span> (w_value == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                }
            }
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;cannot set Mutable using type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T)),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.setString" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setString</span><a href="#src.zig-std.math.big.int.Mutable.setString">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setString</span>( self: *<a href="std.math.big.int.Mutable.html">Mutable</a>, base: <span class="tok-type">u8</span>, value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, allocator: ?<a href="std.mem.Allocator.html">Allocator</a>, ) <span class="tok-kw">error</span>{InvalidCharacter}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Set self from the string representation <code>value</code>.</p>
<p><code>value</code> must contain only digits &lt;= <code>base</code> and is case insensitive.  Base prefixes are
not allowed (e.g. 0x43 should simply be 43).  Underscores in the input string are
ignored and can be used as digit separators.</p>
<p>Asserts there is enough memory for the value in <code>self.limbs</code>. An upper bound on number of limbs can
be determined with <code>calcSetStringLimbCount</code>.
Asserts the base is in the range [2, 36].</p>
<p>Returns an error if the value has invalid digits for the requested base.</p>
<p><code>limbs_buffer</code> is used for temporary storage. The size required can be found with
<code>calcSetStringLimbsBufferLen</code>.</p>
<p>If <code>allocator</code> is provided, it will be used for temporary storage to improve
multiplication performance. <code>error.OutOfMemory</code> is handled with a fallback algorithm.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>base: <span class="tok-type">u8</span></code></pre></div><div><pre><code>value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a></code></pre></div><div><pre><code>allocator: ?<a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.setString">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setString</span>(
    self: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
    base: <span class="tok-type">u8</span>,
    value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
    allocator: ?<a href="std.mem.Allocator.html">Allocator</a>,
) <span class="tok-kw">error</span>{InvalidCharacter}!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(base &gt;= <span class="tok-number">2</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(base &lt;= <span class="tok-number">36</span>);

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> positive = <span class="tok-null">true</span>;
    <span class="tok-kw">if</span> (value.len &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> value[<span class="tok-number">0</span>] == <span class="tok-str">'-'</span>) {
        positive = <span class="tok-null">false</span>;
        i += <span class="tok-number">1</span>;
    }

    <span class="tok-kw">const</span> ap_base: <a href="std.math.big.int.Const.html">Const</a> = .{ .limbs = &amp;[_]<a href="std.math.big.html#std.math.big.Limb">Limb</a>{base}, .positive = <span class="tok-null">true</span> };
    self.set(<span class="tok-number">0</span>);

    <span class="tok-kw">for</span> (value[i..]) |ch| {
        <span class="tok-kw">if</span> (ch == <span class="tok-str">'_'</span>) {
            <span class="tok-kw">continue</span>;
        }
        <span class="tok-kw">const</span> d = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.charToDigit">charToDigit</a>(ch, base);
        <span class="tok-kw">const</span> ap_d: <a href="std.math.big.int.Const.html">Const</a> = .{ .limbs = &amp;[_]<a href="std.math.big.html#std.math.big.Limb">Limb</a>{d}, .positive = <span class="tok-null">true</span> };

        self.mul(self.toConst(), ap_base, limbs_buffer, allocator);
        self.add(self.toConst(), ap_d);
    }
    self.positive = positive;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.setTwosCompIntLimit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setTwosCompIntLimit</span><a href="#src.zig-std.math.big.int.Mutable.setTwosCompIntLimit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setTwosCompIntLimit</span>( r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, limit: <a href="std.math.big.int.TwosCompIntLimit.html">TwosCompIntLimit</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>, ) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Set self to either bound of a 2s-complement integer.
Note: The result is still sign-magnitude, not twos complement! In order to convert the
result to twos complement, it is sufficient to take the absolute value.</p>
<p>Asserts the result fits in <code>r</code>. An upper bound on the number of limbs needed by
r is <code>calcTwosCompLimbCount(bit_count)</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>limit: <a href="std.math.big.int.TwosCompIntLimit.html">TwosCompIntLimit</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.setTwosCompIntLimit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setTwosCompIntLimit</span>(
    r: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
    limit: <a href="std.math.big.int.TwosCompIntLimit.html">TwosCompIntLimit</a>,
    signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
    bit_count: <span class="tok-type">usize</span>,
) <span class="tok-type">void</span> {<span class="tok-comment">
    // Handle zero-bit types.
    </span><span class="tok-kw">if</span> (bit_count == <span class="tok-number">0</span>) {
        r.set(<span class="tok-number">0</span>);
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">const</span> req_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);
    <span class="tok-kw">const</span> bit: <a href="std.math.big.html#std.math.big.Log2Limb">Log2Limb</a> = <span class="tok-builtin">@truncate</span>(bit_count - <span class="tok-number">1</span>);
    <span class="tok-kw">const</span> signmask = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-number">1</span>) &lt;&lt; bit;<span class="tok-comment"> // 0b0..010..0 where 1 is the sign bit.
    </span><span class="tok-kw">const</span> mask = (signmask &lt;&lt; <span class="tok-number">1</span>) -% <span class="tok-number">1</span>;<span class="tok-comment"> // 0b0..011..1 where the leftmost 1 is the sign bit.

    </span>r.positive = <span class="tok-null">true</span>;

    <span class="tok-kw">switch</span> (signedness) {
        .signed =&gt; <span class="tok-kw">switch</span> (limit) {
            .min =&gt; {<span class="tok-comment">
                // Negative bound, signed = -0x80.
                </span>r.len = req_limbs;
                <span class="tok-builtin">@memset</span>(r.limbs[<span class="tok-number">0</span> .. r.len - <span class="tok-number">1</span>], <span class="tok-number">0</span>);
                r.limbs[r.len - <span class="tok-number">1</span>] = signmask;
                r.positive = <span class="tok-null">false</span>;
            },
            .max =&gt; {<span class="tok-comment">
                // Positive bound, signed = 0x7F
                // Note, in this branch we need to normalize because the first bit is
                // supposed to be 0.

                // Special case for 1-bit integers.
                </span><span class="tok-kw">if</span> (bit_count == <span class="tok-number">1</span>) {
                    r.set(<span class="tok-number">0</span>);
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">const</span> new_req_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count - <span class="tok-number">1</span>);
                    <span class="tok-kw">const</span> msb = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Log2Limb">Log2Limb</a>, <span class="tok-builtin">@truncate</span>(bit_count - <span class="tok-number">2</span>));
                    <span class="tok-kw">const</span> new_signmask = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-number">1</span>) &lt;&lt; msb;<span class="tok-comment"> // 0b0..010..0 where 1 is the sign bit.
                    </span><span class="tok-kw">const</span> new_mask = (new_signmask &lt;&lt; <span class="tok-number">1</span>) -% <span class="tok-number">1</span>;<span class="tok-comment"> // 0b0..001..1 where the rightmost 0 is the sign bit.

                    </span>r.len = new_req_limbs;
                    <span class="tok-builtin">@memset</span>(r.limbs[<span class="tok-number">0</span> .. r.len - <span class="tok-number">1</span>], <a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>));
                    r.limbs[r.len - <span class="tok-number">1</span>] = new_mask;
                }
            },
        },
        .unsigned =&gt; <span class="tok-kw">switch</span> (limit) {
            .min =&gt; {<span class="tok-comment">
                // Min bound, unsigned = 0x00
                </span>r.set(<span class="tok-number">0</span>);
            },
            .max =&gt; {<span class="tok-comment">
                // Max bound, unsigned = 0xFF
                </span>r.len = req_limbs;
                <span class="tok-builtin">@memset</span>(r.limbs[<span class="tok-number">0</span> .. r.len - <span class="tok-number">1</span>], <a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>));
                r.limbs[r.len - <span class="tok-number">1</span>] = mask;
            },
        },
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.addScalar" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addScalar</span><a href="#src.zig-std.math.big.int.Mutable.addScalar">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addScalar</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, scalar: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a + scalar</p>
<p>r and a may be aliases.
scalar is a primitive integer type.</p>
<p>Asserts the result fits in <code>r</code>. An upper bound on the number of limbs needed by
r is <code>@max(a.limbs.len, calcLimbLen(scalar)) + 1</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.addScalar">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addScalar</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, scalar: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {<span class="tok-comment">
    // Normally we could just determine the number of limbs needed with calcLimbLen,
    // but that is not comptime-known when scalar is not a comptime_int.  Instead, we
    // use calcTwosCompLimbCount for a non-comptime_int scalar, which can be pessimistic
    // in the case that scalar happens to be small in magnitude within its type, but it
    // is well worth being able to use the stack and not needing an allocator passed in.
    // Note that Mutable.init still sets len to calcLimbLen(scalar) in any case.
    </span><span class="tok-kw">const</span> limb_len = <span class="tok-kw">comptime</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(scalar))) {
        .<span class="tok-type">comptime_int</span> =&gt; <a href="std.math.big.int.html#std.math.big.int.calcLimbLen">calcLimbLen</a>(scalar),
        .int =&gt; |info| <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(info.bits),
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected scalar to be an int&quot;</span>),
    };
    <span class="tok-kw">var</span> limbs: [limb_len]<a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> operand = <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.init">init</a>(&amp;limbs, scalar).toConst();
    <span class="tok-kw">return</span> <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.add">add</a>(r, a, operand);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.add" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">add</span><a href="#src.zig-std.math.big.int.Mutable.add">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a + b</p>
<p>r, a and b may be aliases.</p>
<p>Asserts the result fits in <code>r</code>. An upper bound on the number of limbs needed by
r is <code>@max(a.limbs.len, b.limbs.len) + 1</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Const.html">Const</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.add">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (r.addCarry(a, b)) {<span class="tok-comment">
        // Fix up the result. Note that addCarry normalizes by a.limbs.len or b.limbs.len,
        // so we need to set the length here.
        </span><span class="tok-kw">const</span> msl = <span class="tok-builtin">@max</span>(a.limbs.len, b.limbs.len);<span class="tok-comment">
        // `[add|sub]Carry` normalizes by `msl`, so we need to fix up the result manually here.
        // Note, the fact that it normalized means that the intermediary limbs are zero here.
        </span>r.len = msl + <span class="tok-number">1</span>;
        r.limbs[msl] = <span class="tok-number">1</span>;<span class="tok-comment"> // If this panics, there wasn't enough space in `r`.
    </span>}
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.addWrap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addWrap</span><a href="#src.zig-std.math.big.int.Mutable.addWrap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWrap</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>r = a + b with 2s-complement wrapping semantics. Returns whether overflow occurred.
r, a and b may be aliases</p>
<p>Asserts the result fits in <code>r</code>. An upper bound on the number of limbs needed by
r is <code>calcTwosCompLimbCount(bit_count)</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.addWrap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWrap</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> req_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);<span class="tok-comment">

    // Slice of the upper bits if they exist, these will be ignored and allows us to use addCarry to determine
    // if an overflow occurred.
    </span><span class="tok-kw">const</span> x = <a href="std.math.big.int.Const.html">Const</a>{
        .positive = a.positive,
        .limbs = a.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(req_limbs, a.limbs.len)],
    };

    <span class="tok-kw">const</span> y = <a href="std.math.big.int.Const.html">Const</a>{
        .positive = b.positive,
        .limbs = b.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(req_limbs, b.limbs.len)],
    };

    <span class="tok-kw">var</span> carry_truncated = <span class="tok-null">false</span>;
    <span class="tok-kw">if</span> (r.addCarry(x, y)) {<span class="tok-comment">
        // There are two possibilities here:
        // - We overflowed req_limbs. In this case, the carry is ignored, as it would be removed by
        //   truncate anyway.
        // - a and b had less elements than req_limbs, and those were overflowed. This case needs to be handled.
        //   Note: after this we still might need to wrap.
        </span><span class="tok-kw">const</span> msl = <span class="tok-builtin">@max</span>(a.limbs.len, b.limbs.len);
        <span class="tok-kw">if</span> (msl &lt; req_limbs) {
            r.limbs[msl] = <span class="tok-number">1</span>;
            r.len = req_limbs;
            <span class="tok-builtin">@memset</span>(r.limbs[msl + <span class="tok-number">1</span> .. req_limbs], <span class="tok-number">0</span>);
        } <span class="tok-kw">else</span> {
            carry_truncated = <span class="tok-null">true</span>;
        }
    }

    <span class="tok-kw">if</span> (!r.toConst().fitsInTwosComp(signedness, bit_count)) {
        r.truncate(r.toConst(), signedness, bit_count);
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }

    <span class="tok-kw">return</span> carry_truncated;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.addSat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addSat</span><a href="#src.zig-std.math.big.int.Mutable.addSat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSat</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a + b with 2s-complement saturating semantics.
r, a and b may be aliases.</p>
<p>Assets the result fits in <code>r</code>. Upper bound on the number of limbs needed by
r is <code>calcTwosCompLimbCount(bit_count)</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.addSat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSat</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> req_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);<span class="tok-comment">

    // Slice of the upper bits if they exist, these will be ignored and allows us to use addCarry to determine
    // if an overflow occurred.
    </span><span class="tok-kw">const</span> x = <a href="std.math.big.int.Const.html">Const</a>{
        .positive = a.positive,
        .limbs = a.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(req_limbs, a.limbs.len)],
    };

    <span class="tok-kw">const</span> y = <a href="std.math.big.int.Const.html">Const</a>{
        .positive = b.positive,
        .limbs = b.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(req_limbs, b.limbs.len)],
    };

    <span class="tok-kw">if</span> (r.addCarry(x, y)) {<span class="tok-comment">
        // There are two possibilities here:
        // - We overflowed req_limbs, in which case we need to saturate.
        // - a and b had less elements than req_limbs, and those were overflowed.
        //   Note: In this case, might _also_ need to saturate.
        </span><span class="tok-kw">const</span> msl = <span class="tok-builtin">@max</span>(a.limbs.len, b.limbs.len);
        <span class="tok-kw">if</span> (msl &lt; req_limbs) {
            r.limbs[msl] = <span class="tok-number">1</span>;
            r.len = req_limbs;<span class="tok-comment">
            // Note: Saturation may still be required if msl == req_limbs - 1
        </span>} <span class="tok-kw">else</span> {<span class="tok-comment">
            // Overflowed req_limbs, definitely saturate.
            </span>r.setTwosCompIntLimit(<span class="tok-kw">if</span> (r.positive) .max <span class="tok-kw">else</span> .min, signedness, bit_count);
        }
    }<span class="tok-comment">

    // Saturate if the result didn't fit.
    </span>r.saturate(r.toConst(), signedness, bit_count);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.sub" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sub</span><a href="#src.zig-std.math.big.int.Mutable.sub">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a - b</p>
<p>r, a and b may be aliases.</p>
<p>Asserts the result fits in <code>r</code>. An upper bound on the number of limbs needed by
r is <code>@max(a.limbs.len, b.limbs.len) + 1</code>. The +1 is not needed if both operands are positive.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Const.html">Const</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.sub">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span> {
    r.add(a, b.negate());
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.subWrap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">subWrap</span><a href="#src.zig-std.math.big.int.Mutable.subWrap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subWrap</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>r = a - b with 2s-complement wrapping semantics. Returns whether any overflow occurred.</p>
<p>r, a and b may be aliases
Asserts the result fits in <code>r</code>. An upper bound on the number of limbs needed by
r is <code>calcTwosCompLimbCount(bit_count)</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.subWrap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subWrap</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> r.addWrap(a, b.negate(), signedness, bit_count);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.subSat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">subSat</span><a href="#src.zig-std.math.big.int.Mutable.subSat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subSat</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a - b with 2s-complement saturating semantics.
r, a and b may be aliases.</p>
<p>Assets the result fits in <code>r</code>. Upper bound on the number of limbs needed by
r is <code>calcTwosCompLimbCount(bit_count)</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.subSat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subSat</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    r.addSat(a, b.negate(), signedness, bit_count);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.mul" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mul</span><a href="#src.zig-std.math.big.int.Mutable.mul">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mul</span>(rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, allocator: ?<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>rma = a * b</p>
<p><code>rma</code> may alias with <code>a</code> or <code>b</code>.
<code>a</code> and <code>b</code> may alias with each other.</p>
<p>Asserts the result fits in <code>rma</code>. An upper bound on the number of limbs needed by
rma is given by <code>a.limbs.len + b.limbs.len</code>.</p>
<p><code>limbs_buffer</code> is used for temporary storage. The amount required is given by <code>calcMulLimbsBufferLen</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>rma: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a></code></pre></div><div><pre><code>allocator: ?<a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.mul">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mul</span>(rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, allocator: ?<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> buf_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">const</span> a_copy = <span class="tok-kw">if</span> (rma.limbs.ptr == a.limbs.ptr) blk: {
        <span class="tok-kw">const</span> start = buf_index;
        <span class="tok-builtin">@memcpy</span>(limbs_buffer[buf_index..][<span class="tok-number">0</span>..a.limbs.len], a.limbs);
        buf_index += a.limbs.len;
        <span class="tok-kw">break</span> :blk a.toMutable(limbs_buffer[start..buf_index]).toConst();
    } <span class="tok-kw">else</span> a;

    <span class="tok-kw">const</span> b_copy = <span class="tok-kw">if</span> (rma.limbs.ptr == b.limbs.ptr) blk: {
        <span class="tok-kw">const</span> start = buf_index;
        <span class="tok-builtin">@memcpy</span>(limbs_buffer[buf_index..][<span class="tok-number">0</span>..b.limbs.len], b.limbs);
        buf_index += b.limbs.len;
        <span class="tok-kw">break</span> :blk b.toMutable(limbs_buffer[start..buf_index]).toConst();
    } <span class="tok-kw">else</span> b;

    <span class="tok-kw">return</span> rma.mulNoAlias(a_copy, b_copy, allocator);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.mulNoAlias" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mulNoAlias</span><a href="#src.zig-std.math.big.int.Mutable.mulNoAlias">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulNoAlias</span>(rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, allocator: ?<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>rma = a * b</p>
<p><code>rma</code> may not alias with <code>a</code> or <code>b</code>.
<code>a</code> and <code>b</code> may alias with each other.</p>
<p>Asserts the result fits in <code>rma</code>. An upper bound on the number of limbs needed by
rma is given by <code>a.limbs.len + b.limbs.len</code>.</p>
<p>If <code>allocator</code> is provided, it will be used for temporary storage to improve
multiplication performance. <code>error.OutOfMemory</code> is handled with a fallback algorithm.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>rma: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>allocator: ?<a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.mulNoAlias">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulNoAlias</span>(rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, allocator: ?<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != a.limbs.ptr);<span class="tok-comment"> // illegal aliasing
    </span><a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != b.limbs.ptr);<span class="tok-comment"> // illegal aliasing

    </span><span class="tok-kw">if</span> (a.limbs.len == <span class="tok-number">1</span> <span class="tok-kw">and</span> b.limbs.len == <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> ov = <span class="tok-builtin">@mulWithOverflow</span>(a.limbs[<span class="tok-number">0</span>], b.limbs[<span class="tok-number">0</span>]);
        rma.limbs[<span class="tok-number">0</span>] = ov[<span class="tok-number">0</span>];
        <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] == <span class="tok-number">0</span>) {
            rma.len = <span class="tok-number">1</span>;
            rma.positive = (a.positive == b.positive);
            <span class="tok-kw">return</span>;
        }
    }

    <span class="tok-builtin">@memset</span>(rma.limbs[<span class="tok-number">0</span> .. a.limbs.len + b.limbs.len], <span class="tok-number">0</span>);

    <a href="std.math.big.int.html#std.math.big.int.llmulacc">llmulacc</a>(.add, allocator, rma.limbs, a.limbs, b.limbs);

    rma.normalize(a.limbs.len + b.limbs.len);
    rma.positive = (a.positive == b.positive);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.mulWrap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mulWrap</span><a href="#src.zig-std.math.big.int.Mutable.mulWrap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulWrap</span>( rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>, limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, allocator: ?<a href="std.mem.Allocator.html">Allocator</a>, ) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>rma = a * b with 2s-complement wrapping semantics.</p>
<p><code>rma</code> may alias with <code>a</code> or <code>b</code>.
<code>a</code> and <code>b</code> may alias with each other.</p>
<p>Asserts the result fits in <code>rma</code>. An upper bound on the number of limbs needed by
rma is given by <code>a.limbs.len + b.limbs.len</code>.</p>
<p><code>limbs_buffer</code> is used for temporary storage. The amount required is given by <code>calcMulWrapLimbsBufferLen</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>rma: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div><div><pre><code>limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a></code></pre></div><div><pre><code>allocator: ?<a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.mulWrap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulWrap</span>(
    rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
    a: <a href="std.math.big.int.Const.html">Const</a>,
    b: <a href="std.math.big.int.Const.html">Const</a>,
    signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
    bit_count: <span class="tok-type">usize</span>,
    limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
    allocator: ?<a href="std.mem.Allocator.html">Allocator</a>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> buf_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> req_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);

    <span class="tok-kw">const</span> a_copy = <span class="tok-kw">if</span> (rma.limbs.ptr == a.limbs.ptr) blk: {
        <span class="tok-kw">const</span> start = buf_index;
        <span class="tok-kw">const</span> a_len = <span class="tok-builtin">@min</span>(req_limbs, a.limbs.len);
        <span class="tok-builtin">@memcpy</span>(limbs_buffer[buf_index..][<span class="tok-number">0</span>..a_len], a.limbs[<span class="tok-number">0</span>..a_len]);
        buf_index += a_len;
        <span class="tok-kw">break</span> :blk a.toMutable(limbs_buffer[start..buf_index]).toConst();
    } <span class="tok-kw">else</span> a;

    <span class="tok-kw">const</span> b_copy = <span class="tok-kw">if</span> (rma.limbs.ptr == b.limbs.ptr) blk: {
        <span class="tok-kw">const</span> start = buf_index;
        <span class="tok-kw">const</span> b_len = <span class="tok-builtin">@min</span>(req_limbs, b.limbs.len);
        <span class="tok-builtin">@memcpy</span>(limbs_buffer[buf_index..][<span class="tok-number">0</span>..b_len], b.limbs[<span class="tok-number">0</span>..b_len]);
        buf_index += b_len;
        <span class="tok-kw">break</span> :blk a.toMutable(limbs_buffer[start..buf_index]).toConst();
    } <span class="tok-kw">else</span> b;

    <span class="tok-kw">return</span> rma.mulWrapNoAlias(a_copy, b_copy, signedness, bit_count, allocator);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.mulWrapNoAlias" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mulWrapNoAlias</span><a href="#src.zig-std.math.big.int.Mutable.mulWrapNoAlias">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulWrapNoAlias</span>( rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>, allocator: ?<a href="std.mem.Allocator.html">Allocator</a>, ) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>rma = a * b with 2s-complement wrapping semantics.</p>
<p><code>rma</code> may not alias with <code>a</code> or <code>b</code>.
<code>a</code> and <code>b</code> may alias with each other.</p>
<p>Asserts the result fits in <code>rma</code>. An upper bound on the number of limbs needed by
rma is given by <code>a.limbs.len + b.limbs.len</code>.</p>
<p>If <code>allocator</code> is provided, it will be used for temporary storage to improve
multiplication performance. <code>error.OutOfMemory</code> is handled with a fallback algorithm.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>rma: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div><div><pre><code>allocator: ?<a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.mulWrapNoAlias">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulWrapNoAlias</span>(
    rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
    a: <a href="std.math.big.int.Const.html">Const</a>,
    b: <a href="std.math.big.int.Const.html">Const</a>,
    signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
    bit_count: <span class="tok-type">usize</span>,
    allocator: ?<a href="std.mem.Allocator.html">Allocator</a>,
) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != a.limbs.ptr);<span class="tok-comment"> // illegal aliasing
    </span><a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != b.limbs.ptr);<span class="tok-comment"> // illegal aliasing

    </span><span class="tok-kw">const</span> req_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);<span class="tok-comment">

    // We can ignore the upper bits here, those results will be discarded anyway.
    </span><span class="tok-kw">const</span> a_limbs = a.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(req_limbs, a.limbs.len)];
    <span class="tok-kw">const</span> b_limbs = b.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(req_limbs, b.limbs.len)];

    <span class="tok-builtin">@memset</span>(rma.limbs[<span class="tok-number">0</span>..req_limbs], <span class="tok-number">0</span>);

    <a href="std.math.big.int.html#std.math.big.int.llmulacc">llmulacc</a>(.add, allocator, rma.limbs, a_limbs, b_limbs);
    rma.normalize(<span class="tok-builtin">@min</span>(req_limbs, a.limbs.len + b.limbs.len));
    rma.positive = (a.positive == b.positive);
    rma.truncate(rma.toConst(), signedness, bit_count);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.bitReverse" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bitReverse</span><a href="#src.zig-std.math.big.int.Mutable.bitReverse">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitReverse</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = @bitReverse(a) with 2s-complement semantics.
r and a may be aliases.</p>
<p>Asserts the result fits in <code>r</code>. Upper bound on the number of limbs needed by
r is <code>calcTwosCompLimbCount(bit_count)</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.bitReverse">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitReverse</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (bit_count == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;

    r.copy(a);

    <span class="tok-kw">const</span> limbs_required = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);

    <span class="tok-kw">if</span> (!a.positive) {
        r.positive = <span class="tok-null">true</span>;<span class="tok-comment"> // Negate.
        </span>r.bitNotWrap(r.toConst(), .unsigned, bit_count);<span class="tok-comment"> // Bitwise NOT.
        </span>r.addScalar(r.toConst(), <span class="tok-number">1</span>);<span class="tok-comment"> // Add one.
    </span>} <span class="tok-kw">else</span> <span class="tok-kw">if</span> (limbs_required &gt; a.limbs.len) {<span class="tok-comment">
        // Zero-extend to our output length
        </span><span class="tok-kw">for</span> (r.limbs[a.limbs.len..limbs_required]) |*limb| {
            limb.* = <span class="tok-number">0</span>;
        }
        r.len = limbs_required;
    }<span class="tok-comment">

    // 0b0..01..1000 with @log2(@sizeOf(Limb)) consecutive ones
    </span><span class="tok-kw">const</span> endian_mask: <span class="tok-type">usize</span> = (<span class="tok-builtin">@sizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>) - <span class="tok-number">1</span>) &lt;&lt; <span class="tok-number">3</span>;

    <span class="tok-kw">const</span> bytes = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(r.limbs);

    <span class="tok-kw">var</span> k: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (k &lt; ((bit_count + <span class="tok-number">1</span>) / <span class="tok-number">2</span>)) : (k += <span class="tok-number">1</span>) {
        <span class="tok-kw">var</span> i = k;
        <span class="tok-kw">var</span> rev_i = bit_count - i - <span class="tok-number">1</span>;<span class="tok-comment">

        // This &quot;endian mask&quot; remaps a low (LE) byte to the corresponding high
        // (BE) byte in the Limb, without changing which limbs we are indexing
        </span><span class="tok-kw">if</span> (<a href="std.math.big.int.html#std.math.big.int.native_endian">native_endian</a> == .big) {
            i ^= endian_mask;
            rev_i ^= endian_mask;
        }

        <span class="tok-kw">const</span> bit_i = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(<span class="tok-type">u1</span>, bytes, i, .little);
        <span class="tok-kw">const</span> bit_rev_i = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(<span class="tok-type">u1</span>, bytes, rev_i, .little);
        <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writePackedInt">writePackedInt</a>(<span class="tok-type">u1</span>, bytes, i, bit_rev_i, .little);
        <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writePackedInt">writePackedInt</a>(<span class="tok-type">u1</span>, bytes, rev_i, bit_i, .little);
    }<span class="tok-comment">

    // Calculate signed-magnitude representation for output
    </span><span class="tok-kw">if</span> (signedness == .signed) {
        <span class="tok-kw">const</span> last_bit = <span class="tok-kw">switch</span> (<a href="std.math.big.int.html#std.math.big.int.native_endian">native_endian</a>) {
            .little =&gt; <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(<span class="tok-type">u1</span>, bytes, bit_count - <span class="tok-number">1</span>, .little),
            .big =&gt; <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(<span class="tok-type">u1</span>, bytes, (bit_count - <span class="tok-number">1</span>) ^ endian_mask, .little),
        };
        <span class="tok-kw">if</span> (last_bit == <span class="tok-number">1</span>) {
            r.bitNotWrap(r.toConst(), .unsigned, bit_count);<span class="tok-comment"> // Bitwise NOT.
            </span>r.addScalar(r.toConst(), <span class="tok-number">1</span>);<span class="tok-comment"> // Add one.
            </span>r.positive = <span class="tok-null">false</span>;<span class="tok-comment"> // Negate.
        </span>}
    }
    r.normalize(r.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.byteSwap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">byteSwap</span><a href="#src.zig-std.math.big.int.Mutable.byteSwap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">byteSwap</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, byte_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = @byteSwap(a) with 2s-complement semantics.
r and a may be aliases.</p>
<p>Asserts the result fits in <code>r</code>. Upper bound on the number of limbs needed by
r is <code>calcTwosCompLimbCount(8*byte_count)</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>byte_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.byteSwap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">byteSwap</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, byte_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (byte_count == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;

    r.copy(a);
    <span class="tok-kw">const</span> limbs_required = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(<span class="tok-number">8</span> * byte_count);

    <span class="tok-kw">if</span> (!a.positive) {
        r.positive = <span class="tok-null">true</span>;<span class="tok-comment"> // Negate.
        </span>r.bitNotWrap(r.toConst(), .unsigned, <span class="tok-number">8</span> * byte_count);<span class="tok-comment"> // Bitwise NOT.
        </span>r.addScalar(r.toConst(), <span class="tok-number">1</span>);<span class="tok-comment"> // Add one.
    </span>} <span class="tok-kw">else</span> <span class="tok-kw">if</span> (limbs_required &gt; a.limbs.len) {<span class="tok-comment">
        // Zero-extend to our output length
        </span><span class="tok-kw">for</span> (r.limbs[a.limbs.len..limbs_required]) |*limb| {
            limb.* = <span class="tok-number">0</span>;
        }
        r.len = limbs_required;
    }<span class="tok-comment">

    // 0b0..01..1 with @log2(@sizeOf(Limb)) trailing ones
    </span><span class="tok-kw">const</span> endian_mask: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>) - <span class="tok-number">1</span>;

    <span class="tok-kw">var</span> bytes = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(r.limbs);
    <a href="std.debug.html#std.debug.assert">assert</a>(bytes.len &gt;= byte_count);

    <span class="tok-kw">var</span> k: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (k &lt; (byte_count + <span class="tok-number">1</span>) / <span class="tok-number">2</span>) : (k += <span class="tok-number">1</span>) {
        <span class="tok-kw">var</span> i = k;
        <span class="tok-kw">var</span> rev_i = byte_count - k - <span class="tok-number">1</span>;<span class="tok-comment">

        // This &quot;endian mask&quot; remaps a low (LE) byte to the corresponding high
        // (BE) byte in the Limb, without changing which limbs we are indexing
        </span><span class="tok-kw">if</span> (<a href="std.math.big.int.html#std.math.big.int.native_endian">native_endian</a> == .big) {
            i ^= endian_mask;
            rev_i ^= endian_mask;
        }

        <span class="tok-kw">const</span> byte_i = bytes[i];
        <span class="tok-kw">const</span> byte_rev_i = bytes[rev_i];
        bytes[rev_i] = byte_i;
        bytes[i] = byte_rev_i;
    }<span class="tok-comment">

    // Calculate signed-magnitude representation for output
    </span><span class="tok-kw">if</span> (signedness == .signed) {
        <span class="tok-kw">const</span> last_byte = <span class="tok-kw">switch</span> (<a href="std.math.big.int.html#std.math.big.int.native_endian">native_endian</a>) {
            .little =&gt; bytes[byte_count - <span class="tok-number">1</span>],
            .big =&gt; bytes[(byte_count - <span class="tok-number">1</span>) ^ endian_mask],
        };

        <span class="tok-kw">if</span> (last_byte &amp; (<span class="tok-number">1</span> &lt;&lt; <span class="tok-number">7</span>) != <span class="tok-number">0</span>) {<span class="tok-comment"> // Check sign bit of last byte
            </span>r.bitNotWrap(r.toConst(), .unsigned, <span class="tok-number">8</span> * byte_count);<span class="tok-comment"> // Bitwise NOT.
            </span>r.addScalar(r.toConst(), <span class="tok-number">1</span>);<span class="tok-comment"> // Add one.
            </span>r.positive = <span class="tok-null">false</span>;<span class="tok-comment"> // Negate.
        </span>}
    }
    r.normalize(r.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.popCount" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">popCount</span><a href="#src.zig-std.math.big.int.Mutable.popCount">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popCount</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = @popCount(a) with 2s-complement semantics.
r and a may be aliases.</p>
<p>Assets the result fits in <code>r</code>. Upper bound on the number of limbs needed by
r is <code>calcTwosCompLimbCount(bit_count)</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.popCount">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popCount</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    r.copy(a);

    <span class="tok-kw">if</span> (!a.positive) {
        r.positive = <span class="tok-null">true</span>;<span class="tok-comment"> // Negate.
        </span>r.bitNotWrap(r.toConst(), .unsigned, bit_count);<span class="tok-comment"> // Bitwise NOT.
        </span>r.addScalar(r.toConst(), <span class="tok-number">1</span>);<span class="tok-comment"> // Add one.
    </span>}

    <span class="tok-kw">var</span> sum: <a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (r.limbs[<span class="tok-number">0</span>..r.len]) |limb| {
        sum += <span class="tok-builtin">@popCount</span>(limb);
    }
    r.set(sum);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.sqrNoAlias" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sqrNoAlias</span><a href="#src.zig-std.math.big.int.Mutable.sqrNoAlias">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sqrNoAlias</span>(rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, opt_allocator: ?<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>rma = a * a</p>
<p><code>rma</code> may not alias with <code>a</code>.</p>
<p>Asserts the result fits in <code>rma</code>. An upper bound on the number of limbs needed by
rma is given by <code>2 * a.limbs.len + 1</code>.</p>
<p>If <code>allocator</code> is provided, it will be used for temporary storage to improve
multiplication performance. <code>error.OutOfMemory</code> is handled with a fallback algorithm.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>rma: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>opt_allocator: ?<a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.sqrNoAlias">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sqrNoAlias</span>(rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, opt_allocator: ?<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    _ = opt_allocator;
    <a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != a.limbs.ptr);<span class="tok-comment"> // illegal aliasing

    </span><span class="tok-builtin">@memset</span>(rma.limbs, <span class="tok-number">0</span>);

    <a href="std.math.big.int.html#std.math.big.int.llsquareBasecase">llsquareBasecase</a>(rma.limbs, a.limbs);

    rma.normalize(<span class="tok-number">2</span> * a.limbs.len + <span class="tok-number">1</span>);
    rma.positive = <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.divFloor" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">divFloor</span><a href="#src.zig-std.math.big.int.Mutable.divFloor">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">divFloor</span>( q: *<a href="std.math.big.int.Mutable.html">Mutable</a>, r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, ) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>q = a / b (rem r)</p>
<p>a / b are floored (rounded towards 0).
q may alias with a or b.</p>
<p>Asserts there is enough memory to store q and r.
The upper bound for r limb count is <code>b.limbs.len</code>.
The upper bound for q limb count is given by <code>a.limbs</code>.</p>
<p><code>limbs_buffer</code> is used for temporary storage. The amount required is given by <code>calcDivLimbsBufferLen</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>q: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.divFloor">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">divFloor</span>(
    q: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
    r: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
    a: <a href="std.math.big.int.Const.html">Const</a>,
    b: <a href="std.math.big.int.Const.html">Const</a>,
    limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> sep = a.limbs.len + <span class="tok-number">2</span>;
    <span class="tok-kw">var</span> x = a.toMutable(limbs_buffer[<span class="tok-number">0</span>..sep]);
    <span class="tok-kw">var</span> y = b.toMutable(limbs_buffer[sep..]);

    <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.div">div</a>(q, r, &amp;x, &amp;y);<span class="tok-comment">

    // Note, `div` performs truncating division, which satisfies
    // @divTrunc(a, b) * b + @rem(a, b) = a
    // so r = a - @divTrunc(a, b) * b
    // Note,  @rem(a, -b) = @rem(-b, a) = -@rem(a, b) = -@rem(-a, -b)
    // For divTrunc, we want to perform
    // @divFloor(a, b) * b + @mod(a, b) = a
    // Note:
    // @divFloor(-a, b)
    // = @divFloor(a, -b)
    // = -@divCeil(a, b)
    // = -@divFloor(a + b - 1, b)
    // = -@divTrunc(a + b - 1, b)

    // Note (1):
    // @divTrunc(a + b - 1, b) * b + @rem(a + b - 1, b) = a + b - 1
    // = @divTrunc(a + b - 1, b) * b + @rem(a - 1, b) = a + b - 1
    // = @divTrunc(a + b - 1, b) * b + @rem(a - 1, b) - b + 1 = a

    </span><span class="tok-kw">if</span> (a.positive <span class="tok-kw">and</span> b.positive) {<span class="tok-comment">
        // Positive-positive case, don't need to do anything.
    </span>} <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.positive <span class="tok-kw">and</span> !b.positive) {<span class="tok-comment">
        // a/-b -&gt; q is negative, and so we need to fix flooring.
        // Subtract one to make the division flooring.

        // @divFloor(a, -b) * -b + @mod(a, -b) = a
        // If b divides a exactly, we have @divFloor(a, -b) * -b = a
        // Else, we have @divFloor(a, -b) * -b &gt; a, so @mod(a, -b) becomes negative

        // We have:
        // @divFloor(a, -b) * -b + @mod(a, -b) = a
        // = -@divTrunc(a + b - 1, b) * -b + @mod(a, -b) = a
        // = @divTrunc(a + b - 1, b) * b + @mod(a, -b) = a

        // Substitute a for (1):
        // @divTrunc(a + b - 1, b) * b + @rem(a - 1, b) - b + 1 = @divTrunc(a + b - 1, b) * b + @mod(a, -b)
        // Yields:
        // @mod(a, -b) = @rem(a - 1, b) - b + 1
        // Note that `r` holds @rem(a, b) at this point.
        //
        // If @rem(a, b) is not 0:
        //   @rem(a - 1, b) = @rem(a, b) - 1
        //   =&gt; @mod(a, -b) = @rem(a, b) - 1 - b + 1 = @rem(a, b) - b
        // Else:
        //   @rem(a - 1, b) = @rem(a + b - 1, b) = @rem(b - 1, b) = b - 1
        //   =&gt; @mod(a, -b) = b - 1 - b + 1 = 0
        </span><span class="tok-kw">if</span> (!r.eqlZero()) {
            q.addScalar(q.toConst(), -<span class="tok-number">1</span>);
            r.positive = <span class="tok-null">true</span>;
            r.sub(r.toConst(), y.toConst().abs());
        }
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (!a.positive <span class="tok-kw">and</span> b.positive) {<span class="tok-comment">
        // -a/b -&gt; q is negative, and so we need to fix flooring.
        // Subtract one to make the division flooring.

        // @divFloor(-a, b) * b + @mod(-a, b) = a
        // If b divides a exactly, we have @divFloor(-a, b) * b = -a
        // Else, we have @divFloor(-a, b) * b &lt; -a, so @mod(-a, b) becomes positive

        // We have:
        // @divFloor(-a, b) * b + @mod(-a, b) = -a
        // = -@divTrunc(a + b - 1, b) * b + @mod(-a, b) = -a
        // = @divTrunc(a + b - 1, b) * b - @mod(-a, b) = a

        // Substitute a for (1):
        // @divTrunc(a + b - 1, b) * b + @rem(a - 1, b) - b + 1 = @divTrunc(a + b - 1, b) * b - @mod(-a, b)
        // Yields:
        // @rem(a - 1, b) - b + 1 = -@mod(-a, b)
        // =&gt; -@mod(-a, b) = @rem(a - 1, b) - b + 1
        // =&gt; @mod(-a, b) = -(@rem(a - 1, b) - b + 1) = -@rem(a - 1, b) + b - 1
        //
        // If @rem(a, b) is not 0:
        //   @rem(a - 1, b) = @rem(a, b) - 1
        //   =&gt; @mod(-a, b) = -(@rem(a, b) - 1) + b - 1 = -@rem(a, b) + 1 + b - 1 = -@rem(a, b) + b
        // Else :
        //   @rem(a - 1, b) = b - 1
        //   =&gt; @mod(-a, b) = -(b - 1) + b - 1 = 0
        </span><span class="tok-kw">if</span> (!r.eqlZero()) {
            q.addScalar(q.toConst(), -<span class="tok-number">1</span>);
            r.positive = <span class="tok-null">false</span>;
            r.add(r.toConst(), y.toConst().abs());
        }
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (!a.positive <span class="tok-kw">and</span> !b.positive) {<span class="tok-comment">
        // a/b -&gt; q is positive, don't need to do anything to fix flooring.

        // @divFloor(-a, -b) * -b + @mod(-a, -b) = -a
        // If b divides a exactly, we have @divFloor(-a, -b) * -b = -a
        // Else, we have @divFloor(-a, -b) * -b &gt; -a, so @mod(-a, -b) becomes negative

        // We have:
        // @divFloor(-a, -b) * -b + @mod(-a, -b) = -a
        // = @divTrunc(a, b) * -b + @mod(-a, -b) = -a
        // = @divTrunc(a, b) * b - @mod(-a, -b) = a

        // We also have:
        // @divTrunc(a, b) * b + @rem(a, b) = a

        // Substitute a:
        // @divTrunc(a, b) * b + @rem(a, b) = @divTrunc(a, b) * b - @mod(-a, -b)
        // =&gt; @rem(a, b) = -@mod(-a, -b)
        // =&gt; @mod(-a, -b) = -@rem(a, b)
        </span>r.positive = <span class="tok-null">false</span>;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.divTrunc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">divTrunc</span><a href="#src.zig-std.math.big.int.Mutable.divTrunc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">divTrunc</span>( q: *<a href="std.math.big.int.Mutable.html">Mutable</a>, r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, ) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>q = a / b (rem r)</p>
<p>a / b are truncated (rounded towards -inf).
q may alias with a or b.</p>
<p>Asserts there is enough memory to store q and r.
The upper bound for r limb count is <code>b.limbs.len</code>.
The upper bound for q limb count is given by <code>a.limbs.len</code>.</p>
<p><code>limbs_buffer</code> is used for temporary storage. The amount required is given by <code>calcDivLimbsBufferLen</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>q: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.divTrunc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">divTrunc</span>(
    q: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
    r: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
    a: <a href="std.math.big.int.Const.html">Const</a>,
    b: <a href="std.math.big.int.Const.html">Const</a>,
    limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> sep = a.limbs.len + <span class="tok-number">2</span>;
    <span class="tok-kw">var</span> x = a.toMutable(limbs_buffer[<span class="tok-number">0</span>..sep]);
    <span class="tok-kw">var</span> y = b.toMutable(limbs_buffer[sep..]);

    <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.div">div</a>(q, r, &amp;x, &amp;y);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.shiftLeft" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shiftLeft</span><a href="#src.zig-std.math.big.int.Mutable.shiftLeft">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftLeft</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, shift: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a &lt;&lt; shift, in other words, r = a * 2^shift</p>
<p>r and a may alias.</p>
<p>Asserts there is enough memory to fit the result. The upper bound Limb count is
<code>a.limbs.len + (shift / (@sizeOf(Limb) * 8))</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>shift: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.shiftLeft">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftLeft</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, shift: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.math.big.int.html#std.math.big.int.llshl">llshl</a>(r.limbs, a.limbs, shift);
    r.normalize(a.limbs.len + (shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) + <span class="tok-number">1</span>);
    r.positive = a.positive;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.shiftLeftSat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shiftLeftSat</span><a href="#src.zig-std.math.big.int.Mutable.shiftLeftSat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftLeftSat</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, shift: <span class="tok-type">usize</span>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a &lt;&lt;| shift with 2s-complement saturating semantics.</p>
<p>r and a may alias.</p>
<p>Asserts there is enough memory to fit the result. The upper bound Limb count is
r is <code>calcTwosCompLimbCount(bit_count)</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>shift: <span class="tok-type">usize</span></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.shiftLeftSat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftLeftSat</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, shift: <span class="tok-type">usize</span>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {<span class="tok-comment">
    // Special case: When the argument is negative, but the result is supposed to be unsigned,
    // return 0 in all cases.
    </span><span class="tok-kw">if</span> (!a.positive <span class="tok-kw">and</span> signedness == .unsigned) {
        r.set(<span class="tok-number">0</span>);
        <span class="tok-kw">return</span>;
    }<span class="tok-comment">

    // Check whether the shift is going to overflow. This is the case
    // when (in 2s complement) any bit above `bit_count - shift` is set in the unshifted value.
    // Note, the sign bit is not counted here.

    // Handle shifts larger than the target type. This also deals with
    // 0-bit integers.
    </span><span class="tok-kw">if</span> (bit_count &lt;= shift) {<span class="tok-comment">
        // In this case, there is only no overflow if `a` is zero.
        </span><span class="tok-kw">if</span> (a.eqlZero()) {
            r.set(<span class="tok-number">0</span>);
        } <span class="tok-kw">else</span> {
            r.setTwosCompIntLimit(<span class="tok-kw">if</span> (a.positive) .max <span class="tok-kw">else</span> .min, signedness, bit_count);
        }
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">const</span> checkbit = bit_count - shift - <span class="tok-builtin">@intFromBool</span>(signedness == .signed);<span class="tok-comment">
    // If `checkbit` and more significant bits are zero, no overflow will take place.

    </span><span class="tok-kw">if</span> (checkbit &gt;= a.limbs.len * <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) {<span class="tok-comment">
        // `checkbit` is outside the range of a, so definitely no overflow will take place. We
        // can defer to a normal shift.
        // Note that if `a` is normalized (which we assume), this checks for set bits in the upper limbs.

        // Note, in this case r should already have enough limbs required to perform the normal shift.
        // In this case the shift of the most significant limb may still overflow.
        </span>r.shiftLeft(a, shift);
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (checkbit &lt; (a.limbs.len - <span class="tok-number">1</span>) * <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) {<span class="tok-comment">
        // `checkbit` is not in the most significant limb. If `a` is normalized the most significant
        // limb will not be zero, so in this case we need to saturate. Note that `a.limbs.len` must be
        // at least one according to normalization rules.

        </span>r.setTwosCompIntLimit(<span class="tok-kw">if</span> (a.positive) .max <span class="tok-kw">else</span> .min, signedness, bit_count);
        <span class="tok-kw">return</span>;
    }<span class="tok-comment">

    // Generate a mask with the bits to check in the most significant limb. We'll need to check
    // all bits with equal or more significance than checkbit.
    // const msb = @truncate(Log2Limb, checkbit);
    // const checkmask = (@as(Limb, 1) &lt;&lt; msb) -% 1;

    </span><span class="tok-kw">if</span> (a.limbs[a.limbs.len - <span class="tok-number">1</span>] &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Log2Limb">Log2Limb</a>, <span class="tok-builtin">@truncate</span>(checkbit)) != <span class="tok-number">0</span>) {<span class="tok-comment">
        // Need to saturate.
        </span>r.setTwosCompIntLimit(<span class="tok-kw">if</span> (a.positive) .max <span class="tok-kw">else</span> .min, signedness, bit_count);
        <span class="tok-kw">return</span>;
    }<span class="tok-comment">

    // This shift should not be able to overflow, so invoke llshl and normalize manually
    // to avoid the extra required limb.
    </span><a href="std.math.big.int.html#std.math.big.int.llshl">llshl</a>(r.limbs, a.limbs, shift);
    r.normalize(a.limbs.len + (shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>));
    r.positive = a.positive;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.shiftRight" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shiftRight</span><a href="#src.zig-std.math.big.int.Mutable.shiftRight">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftRight</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, shift: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a &gt;&gt; shift
r and a may alias.</p>
<p>Asserts there is enough memory to fit the result. The upper bound Limb count is
<code>a.limbs.len - (shift / (@sizeOf(Limb) * 8))</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>shift: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.shiftRight">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftRight</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, shift: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> full_limbs_shifted_out = shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>;
    <span class="tok-kw">const</span> remaining_bits_shifted_out = shift % <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>;
    <span class="tok-kw">if</span> (a.limbs.len &lt;= full_limbs_shifted_out) {<span class="tok-comment">
        // Shifting negative numbers converges to -1 instead of 0
        </span><span class="tok-kw">if</span> (a.positive) {
            r.len = <span class="tok-number">1</span>;
            r.positive = <span class="tok-null">true</span>;
            r.limbs[<span class="tok-number">0</span>] = <span class="tok-number">0</span>;
        } <span class="tok-kw">else</span> {
            r.len = <span class="tok-number">1</span>;
            r.positive = <span class="tok-null">false</span>;
            r.limbs[<span class="tok-number">0</span>] = <span class="tok-number">1</span>;
        }
        <span class="tok-kw">return</span>;
    }
    <span class="tok-kw">const</span> nonzero_negative_shiftout = <span class="tok-kw">if</span> (a.positive) <span class="tok-null">false</span> <span class="tok-kw">else</span> nonzero: {
        <span class="tok-kw">for</span> (a.limbs[<span class="tok-number">0</span>..full_limbs_shifted_out]) |x| {
            <span class="tok-kw">if</span> (x != <span class="tok-number">0</span>)
                <span class="tok-kw">break</span> :nonzero <span class="tok-null">true</span>;
        }
        <span class="tok-kw">if</span> (remaining_bits_shifted_out == <span class="tok-number">0</span>)
            <span class="tok-kw">break</span> :nonzero <span class="tok-null">false</span>;
        <span class="tok-kw">const</span> not_covered: <a href="std.math.big.html#std.math.big.Log2Limb">Log2Limb</a> = <span class="tok-builtin">@intCast</span>(<a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a> - remaining_bits_shifted_out);
        <span class="tok-kw">break</span> :nonzero a.limbs[full_limbs_shifted_out] &lt;&lt; not_covered != <span class="tok-number">0</span>;
    };

    <a href="std.math.big.int.html#std.math.big.int.llshr">llshr</a>(r.limbs, a.limbs, shift);

    r.len = a.limbs.len - full_limbs_shifted_out;
    r.positive = a.positive;
    <span class="tok-kw">if</span> (nonzero_negative_shiftout) r.addScalar(r.toConst(), -<span class="tok-number">1</span>);
    r.normalize(r.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.bitNotWrap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bitNotWrap</span><a href="#src.zig-std.math.big.int.Mutable.bitNotWrap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitNotWrap</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = ~a under 2s complement wrapping semantics.
r may alias with a.</p>
<p>Assets that r has enough limbs to store the result. The upper bound Limb count is
r is <code>calcTwosCompLimbCount(bit_count)</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.bitNotWrap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitNotWrap</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    r.copy(a.negate());
    <span class="tok-kw">const</span> negative_one = <a href="std.math.big.int.Const.html">Const</a>{ .limbs = &amp;.{<span class="tok-number">1</span>}, .positive = <span class="tok-null">false</span> };
    _ = r.addWrap(r.toConst(), negative_one, signedness, bit_count);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.bitOr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bitOr</span><a href="#src.zig-std.math.big.int.Mutable.bitOr">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitOr</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a | b under 2s complement semantics.
r may alias with a or b.</p>
<p>a and b are zero-extended to the longer of a or b.</p>
<p>Asserts that r has enough limbs to store the result. Upper bound is <code>@max(a.limbs.len, b.limbs.len)</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Const.html">Const</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.bitOr">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitOr</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span> {<span class="tok-comment">
    // Trivial cases, llsignedor does not support zero.
    </span><span class="tok-kw">if</span> (a.eqlZero()) {
        r.copy(b);
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.eqlZero()) {
        r.copy(a);
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">if</span> (a.limbs.len &gt;= b.limbs.len) {
        r.positive = <a href="std.math.big.int.html#std.math.big.int.llsignedor">llsignedor</a>(r.limbs, a.limbs, a.positive, b.limbs, b.positive);
        r.normalize(<span class="tok-kw">if</span> (b.positive) a.limbs.len <span class="tok-kw">else</span> b.limbs.len);
    } <span class="tok-kw">else</span> {
        r.positive = <a href="std.math.big.int.html#std.math.big.int.llsignedor">llsignedor</a>(r.limbs, b.limbs, b.positive, a.limbs, a.positive);
        r.normalize(<span class="tok-kw">if</span> (a.positive) b.limbs.len <span class="tok-kw">else</span> a.limbs.len);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.bitAnd" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bitAnd</span><a href="#src.zig-std.math.big.int.Mutable.bitAnd">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitAnd</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a &amp; b under 2s complement semantics.
r may alias with a or b.</p>
<p>Asserts that r has enough limbs to store the result.
If only a is positive, the upper bound is <code>a.limbs.len</code>.
If only b is positive, the upper bound is <code>b.limbs.len</code>.
If a and b are positive, the upper bound is <code>@min(a.limbs.len, b.limbs.len)</code>.
If a and b are negative, the upper bound is <code>@max(a.limbs.len, b.limbs.len) + 1</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Const.html">Const</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.bitAnd">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitAnd</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span> {<span class="tok-comment">
    // Trivial cases, llsignedand does not support zero.
    </span><span class="tok-kw">if</span> (a.eqlZero()) {
        r.copy(a);
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.eqlZero()) {
        r.copy(b);
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">if</span> (a.limbs.len &gt;= b.limbs.len) {
        r.positive = <a href="std.math.big.int.html#std.math.big.int.llsignedand">llsignedand</a>(r.limbs, a.limbs, a.positive, b.limbs, b.positive);
        r.normalize(<span class="tok-kw">if</span> (b.positive) b.limbs.len <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.positive) a.limbs.len <span class="tok-kw">else</span> a.limbs.len + <span class="tok-number">1</span>);
    } <span class="tok-kw">else</span> {
        r.positive = <a href="std.math.big.int.html#std.math.big.int.llsignedand">llsignedand</a>(r.limbs, b.limbs, b.positive, a.limbs, a.positive);
        r.normalize(<span class="tok-kw">if</span> (a.positive) a.limbs.len <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.positive) b.limbs.len <span class="tok-kw">else</span> b.limbs.len + <span class="tok-number">1</span>);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.bitXor" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bitXor</span><a href="#src.zig-std.math.big.int.Mutable.bitXor">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitXor</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a ^ b under 2s complement semantics.
r may alias with a or b.</p>
<p>Asserts that r has enough limbs to store the result. If a and b share the same signedness, the
upper bound is <code>@max(a.limbs.len, b.limbs.len)</code>. Otherwise, if either a or b is negative
but not both, the upper bound is <code>@max(a.limbs.len, b.limbs.len) + 1</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>b: <a href="std.math.big.int.Const.html">Const</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.bitXor">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitXor</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span> {<span class="tok-comment">
    // Trivial cases, because llsignedxor does not support negative zero.
    </span><span class="tok-kw">if</span> (a.eqlZero()) {
        r.copy(b);
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.eqlZero()) {
        r.copy(a);
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">if</span> (a.limbs.len &gt; b.limbs.len) {
        r.positive = <a href="std.math.big.int.html#std.math.big.int.llsignedxor">llsignedxor</a>(r.limbs, a.limbs, a.positive, b.limbs, b.positive);
        r.normalize(a.limbs.len + <span class="tok-builtin">@intFromBool</span>(a.positive != b.positive));
    } <span class="tok-kw">else</span> {
        r.positive = <a href="std.math.big.int.html#std.math.big.int.llsignedxor">llsignedxor</a>(r.limbs, b.limbs, b.positive, a.limbs, a.positive);
        r.normalize(b.limbs.len + <span class="tok-builtin">@intFromBool</span>(a.positive != b.positive));
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.gcd" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">gcd</span><a href="#src.zig-std.math.big.int.Mutable.gcd">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gcd</span>(rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, x: <a href="std.math.big.int.Const.html">Const</a>, y: <a href="std.math.big.int.Const.html">Const</a>, limbs_buffer: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>rma may alias x or y.
x and y may alias each other.
Asserts that <code>rma</code> has enough limbs to store the result. Upper bound is
<code>@min(x.limbs.len, y.limbs.len)</code>.</p>
<p><code>limbs_buffer</code> is used for temporary storage during the operation. When this function returns,
it will have the same length as it had when the function was called.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>rma: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>x: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>y: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>limbs_buffer: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.gcd">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gcd</span>(rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, x: <a href="std.math.big.int.Const.html">Const</a>, y: <a href="std.math.big.int.Const.html">Const</a>, limbs_buffer: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> prev_len = limbs_buffer.items.len;
    <span class="tok-kw">defer</span> limbs_buffer.shrinkRetainingCapacity(prev_len);
    <span class="tok-kw">const</span> x_copy = <span class="tok-kw">if</span> (rma.limbs.ptr == x.limbs.ptr) blk: {
        <span class="tok-kw">const</span> start = limbs_buffer.items.len;
        <span class="tok-kw">try</span> limbs_buffer.appendSlice(x.limbs);
        <span class="tok-kw">break</span> :blk x.toMutable(limbs_buffer.items[start..]).toConst();
    } <span class="tok-kw">else</span> x;
    <span class="tok-kw">const</span> y_copy = <span class="tok-kw">if</span> (rma.limbs.ptr == y.limbs.ptr) blk: {
        <span class="tok-kw">const</span> start = limbs_buffer.items.len;
        <span class="tok-kw">try</span> limbs_buffer.appendSlice(y.limbs);
        <span class="tok-kw">break</span> :blk y.toMutable(limbs_buffer.items[start..]).toConst();
    } <span class="tok-kw">else</span> y;

    <span class="tok-kw">return</span> <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.gcdLehmer">gcdLehmer</a>(rma, x_copy, y_copy, limbs_buffer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.pow" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pow</span><a href="#src.zig-std.math.big.int.Mutable.pow">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pow</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <span class="tok-type">u32</span>, limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>q = a ^ b</p>
<p>r may not alias a.</p>
<p>Asserts that <code>r</code> has enough limbs to store the result. Upper bound is
<code>calcPowLimbsBufferLen(a.bitCountAbs(), b)</code>.</p>
<p><code>limbs_buffer</code> is used for temporary storage.
The amount required is given by <code>calcPowLimbsBufferLen</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>b: <span class="tok-type">u32</span></code></pre></div><div><pre><code>limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.pow">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pow</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <span class="tok-type">u32</span>, limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(r.limbs.ptr != a.limbs.ptr);<span class="tok-comment"> // illegal aliasing

    // Handle all the trivial cases first
    </span><span class="tok-kw">switch</span> (b) {
        <span class="tok-number">0</span> =&gt; {<span class="tok-comment">
            // a^0 = 1
            </span><span class="tok-kw">return</span> r.set(<span class="tok-number">1</span>);
        },
        <span class="tok-number">1</span> =&gt; {<span class="tok-comment">
            // a^1 = a
            </span><span class="tok-kw">return</span> r.copy(a);
        },
        <span class="tok-kw">else</span> =&gt; {},
    }

    <span class="tok-kw">if</span> (a.eqlZero()) {<span class="tok-comment">
        // 0^b = 0
        </span><span class="tok-kw">return</span> r.set(<span class="tok-number">0</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.limbs.len == <span class="tok-number">1</span> <span class="tok-kw">and</span> a.limbs[<span class="tok-number">0</span>] == <span class="tok-number">1</span>) {<span class="tok-comment">
        // 1^b = 1 and -1^b = 1
        </span>r.set(<span class="tok-number">1</span>);
        r.positive = a.positive <span class="tok-kw">or</span> (b &amp; <span class="tok-number">1</span>) == <span class="tok-number">0</span>;
        <span class="tok-kw">return</span>;
    }<span class="tok-comment">

    // Here a&gt;1 and b&gt;1
    </span><span class="tok-kw">const</span> needed_limbs = <a href="std.math.big.int.html#std.math.big.int.calcPowLimbsBufferLen">calcPowLimbsBufferLen</a>(a.bitCountAbs(), b);
    <a href="std.debug.html#std.debug.assert">assert</a>(r.limbs.len &gt;= needed_limbs);
    <a href="std.debug.html#std.debug.assert">assert</a>(limbs_buffer.len &gt;= needed_limbs);

    <a href="std.math.big.int.html#std.math.big.int.llpow">llpow</a>(r.limbs, a.limbs, b, limbs_buffer);

    r.normalize(needed_limbs);
    r.positive = a.positive <span class="tok-kw">or</span> (b &amp; <span class="tok-number">1</span>) == <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.sqrt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sqrt</span><a href="#src.zig-std.math.big.int.Mutable.sqrt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sqrt</span>( r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, ) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>r = a</p>
<p>r may alias a.</p>
<p>Asserts that <code>r</code> has enough limbs to store the result. Upper bound is
<code>(a.limbs.len - 1) / 2 + 1</code>.</p>
<p><code>limbs_buffer</code> is used for temporary storage.
The amount required is given by <code>calcSqrtLimbsBufferLen</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.sqrt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sqrt</span>(
    r: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
    a: <a href="std.math.big.int.Const.html">Const</a>,
    limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
) <span class="tok-type">void</span> {<span class="tok-comment">
    // Brent and Zimmermann, Modern Computer Arithmetic, Algorithm 1.13 SqrtInt
    // https://members.loria.fr/PZimmermann/mca/pub226.html
    </span><span class="tok-kw">var</span> buf_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> t = b: {
        <span class="tok-kw">const</span> start = buf_index;
        buf_index += a.limbs.len;
        <span class="tok-kw">break</span> :b <a href="std.math.big.int.Mutable.html">Mutable</a>.<a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.init">init</a>(limbs_buffer[start..buf_index], <span class="tok-number">0</span>);
    };
    <span class="tok-kw">var</span> u = b: {
        <span class="tok-kw">const</span> start = buf_index;
        <span class="tok-kw">const</span> shift = (a.bitCountAbs() + <span class="tok-number">1</span>) / <span class="tok-number">2</span>;
        buf_index += <span class="tok-number">1</span> + ((shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) + <span class="tok-number">1</span>);
        <span class="tok-kw">var</span> m = <a href="std.math.big.int.Mutable.html">Mutable</a>.<a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.init">init</a>(limbs_buffer[start..buf_index], <span class="tok-number">1</span>);
        m.shiftLeft(m.toConst(), shift);<span class="tok-comment"> // u must be &gt;= a, and should be as small as possible for efficiency
        </span><span class="tok-kw">break</span> :b m;
    };
    <span class="tok-kw">var</span> s = b: {
        <span class="tok-kw">const</span> start = buf_index;
        buf_index += u.limbs.len;
        <span class="tok-kw">break</span> :b u.toConst().toMutable(limbs_buffer[start..buf_index]);
    };
    <span class="tok-kw">var</span> rem = b: {
        <span class="tok-kw">const</span> start = buf_index;
        buf_index += s.limbs.len;
        <span class="tok-kw">break</span> :b <a href="std.math.big.int.Mutable.html">Mutable</a>.<a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.init">init</a>(limbs_buffer[start..buf_index], <span class="tok-number">0</span>);
    };

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        t.divFloor(&amp;rem, a, s.toConst(), limbs_buffer[buf_index..]);
        t.add(t.toConst(), s.toConst());
        u.shiftRight(t.toConst(), <span class="tok-number">1</span>);

        <span class="tok-kw">if</span> (u.toConst().order(s.toConst()).compare(.gte)) {
            r.copy(s.toConst());
            <span class="tok-kw">return</span>;
        }<span class="tok-comment">

        // Avoid copying u to s by swapping u and s
        </span><span class="tok-kw">const</span> tmp_s = s;
        s = u;
        u = tmp_s;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.gcdNoAlias" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">gcdNoAlias</span><a href="#src.zig-std.math.big.int.Mutable.gcdNoAlias">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gcdNoAlias</span>(rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, x: <a href="std.math.big.int.Const.html">Const</a>, y: <a href="std.math.big.int.Const.html">Const</a>, limbs_buffer: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>rma may not alias x or y.
x and y may alias each other.
Asserts that <code>rma</code> has enough limbs to store the result. Upper bound is given by <code>calcGcdNoAliasLimbLen</code>.</p>
<p><code>limbs_buffer</code> is used for temporary storage during the operation.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>rma: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>x: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>y: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>limbs_buffer: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.gcdNoAlias">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gcdNoAlias</span>(rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, x: <a href="std.math.big.int.Const.html">Const</a>, y: <a href="std.math.big.int.Const.html">Const</a>, limbs_buffer: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != x.limbs.ptr);<span class="tok-comment"> // illegal aliasing
    </span><a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != y.limbs.ptr);<span class="tok-comment"> // illegal aliasing
    </span><span class="tok-kw">return</span> <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.gcdLehmer">gcdLehmer</a>(rma, x, y, limbs_buffer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.truncate" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">truncate</span><a href="#src.zig-std.math.big.int.Mutable.truncate">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">truncate</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Truncate an integer to a number of bits, following 2s-complement semantics.
<code>r</code> may alias <code>a</code>.</p>
<p>Asserts <code>r</code> has enough storage to compute the result.
The upper bound is <code>calcTwosCompLimbCount(a.len)</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.truncate">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">truncate</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {<span class="tok-comment">
    // Handle 0-bit integers.
    </span><span class="tok-kw">if</span> (bit_count == <span class="tok-number">0</span>) {
        <span class="tok-builtin">@branchHint</span>(.unlikely);
        r.set(<span class="tok-number">0</span>);
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">const</span> max_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);
    <span class="tok-kw">const</span> sign_bit = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@truncate</span>(bit_count - <span class="tok-number">1</span>);
    <span class="tok-kw">const</span> mask = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) &gt;&gt; <span class="tok-builtin">@truncate</span>(-%bit_count);<span class="tok-comment">

    // Guess whether the result will have the same sign as `a`.
    //  * If the result will be signed zero, the guess is `true`.
    //  * If the result will be the minimum signed integer, the guess is `false`.
    //  * If the result will be unsigned zero, the guess is `a.positive`.
    //  * Otherwise the guess is correct.
    </span><span class="tok-kw">const</span> same_sign_guess = <span class="tok-kw">switch</span> (signedness) {
        .signed =&gt; max_limbs &gt; a.limbs.len <span class="tok-kw">or</span> a.limbs[max_limbs - <span class="tok-number">1</span>] &amp; sign_bit == <span class="tok-number">0</span>,
        .unsigned =&gt; a.positive,
    };

    <span class="tok-kw">const</span> abs_trunc_a: <a href="std.math.big.int.Const.html">Const</a> = .{
        .positive = <span class="tok-null">true</span>,
        .limbs = a.limbs[<span class="tok-number">0</span>..<a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(a.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(a.limbs.len, max_limbs)])],
    };
    <span class="tok-kw">if</span> (same_sign_guess <span class="tok-kw">or</span> abs_trunc_a.eqlZero()) {<span class="tok-comment">
        // One of the following is true:
        //  * The result is zero.
        //  * The result is non-zero and has the same sign as `a`.
        </span>r.copy(abs_trunc_a);
        <span class="tok-kw">if</span> (max_limbs &lt;= r.len) r.limbs[max_limbs - <span class="tok-number">1</span>] &amp;= mask;
        r.normalize(r.len);
        r.positive = a.positive <span class="tok-kw">or</span> r.eqlZero();
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // One of the following is true:
        //  * The result is the minimum signed integer.
        //  * The result is unsigned zero.
        //  * The result is non-zero and has the opposite sign as `a`.
        </span>r.addScalar(abs_trunc_a, -<span class="tok-number">1</span>);
        <a href="std.math.big.int.html#std.math.big.int.llnot">llnot</a>(r.limbs[<span class="tok-number">0</span>..r.len]);
        <span class="tok-builtin">@memset</span>(r.limbs[r.len..max_limbs], <a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>));
        r.limbs[max_limbs - <span class="tok-number">1</span>] &amp;= mask;
        r.normalize(max_limbs);
        r.positive = <span class="tok-kw">switch</span> (signedness) {<span class="tok-comment">
            // The only value with the sign bit still set is the minimum signed integer.
            </span>.signed =&gt; !a.positive <span class="tok-kw">and</span> r.limbs[max_limbs - <span class="tok-number">1</span>] &amp; sign_bit == <span class="tok-number">0</span>,
            .unsigned =&gt; !a.positive <span class="tok-kw">or</span> r.eqlZero(),
        };
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.saturate" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">saturate</span><a href="#src.zig-std.math.big.int.Mutable.saturate">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">saturate</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Saturate an integer to a number of bits, following 2s-complement semantics.
r may alias a.</p>
<p>Asserts <code>r</code> has enough storage to store the result.
The upper bound is <code>calcTwosCompLimbCount(a.len)</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>a: <a href="std.math.big.int.Const.html">Const</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.saturate">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">saturate</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!a.fitsInTwosComp(signedness, bit_count)) {
        r.setTwosCompIntLimit(<span class="tok-kw">if</span> (r.positive) .max <span class="tok-kw">else</span> .min, signedness, bit_count);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.readTwosComplement" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readTwosComplement</span><a href="#src.zig-std.math.big.int.Mutable.readTwosComplement">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readTwosComplement</span>( x: *<a href="std.math.big.int.Mutable.html">Mutable</a>, buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, bit_count: <span class="tok-type">usize</span>, endian: <a href="std.builtin.Endian.html">Endian</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, ) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Read the value of <code>x</code> from <code>buffer</code>.
Asserts that <code>buffer</code> is large enough to contain a value of bit-size <code>bit_count</code>.</p>
<p>The contents of <code>buffer</code> are interpreted as if they were the contents of
@ptrCast(*[buffer.len]const u8, &amp;x). Byte ordering is determined by <code>endian</code>
and any required padding bits are expected on the MSB end.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>x: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div><div><pre><code>endian: <a href="std.builtin.Endian.html">Endian</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.readTwosComplement">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readTwosComplement</span>(
    x: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
    buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    bit_count: <span class="tok-type">usize</span>,
    endian: <a href="std.builtin.Endian.html">Endian</a>,
    signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.readPackedTwosComplement">readPackedTwosComplement</a>(x, buffer, <span class="tok-number">0</span>, bit_count, endian, signedness);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.readPackedTwosComplement" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readPackedTwosComplement</span><a href="#src.zig-std.math.big.int.Mutable.readPackedTwosComplement">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readPackedTwosComplement</span>( x: *<a href="std.math.big.int.Mutable.html">Mutable</a>, buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, bit_offset: <span class="tok-type">usize</span>, bit_count: <span class="tok-type">usize</span>, endian: <a href="std.builtin.Endian.html">Endian</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, ) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Read the value of <code>x</code> from a packed memory <code>buffer</code>.
Asserts that <code>buffer</code> is large enough to contain a value of bit-size <code>bit_count</code>
at offset <code>bit_offset</code>.</p>
<p>This is equivalent to loading the value of an integer with <code>bit_count</code> bits as
if it were a field in packed memory at the provided bit offset.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>x: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>bit_offset: <span class="tok-type">usize</span></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div><div><pre><code>endian: <a href="std.builtin.Endian.html">Endian</a></code></pre></div><div><pre><code>signedness: <a href="std.builtin.Signedness.html">Signedness</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.readPackedTwosComplement">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readPackedTwosComplement</span>(
    x: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
    buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    bit_offset: <span class="tok-type">usize</span>,
    bit_count: <span class="tok-type">usize</span>,
    endian: <a href="std.builtin.Endian.html">Endian</a>,
    signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (bit_count == <span class="tok-number">0</span>) {
        x.limbs[<span class="tok-number">0</span>] = <span class="tok-number">0</span>;
        x.len = <span class="tok-number">1</span>;
        x.positive = <span class="tok-null">true</span>;
        <span class="tok-kw">return</span>;
    }<span class="tok-comment">

    // Check whether the input is negative
    </span><span class="tok-kw">var</span> positive = <span class="tok-null">true</span>;
    <span class="tok-kw">if</span> (signedness == .signed) {
        <span class="tok-kw">const</span> total_bits = bit_offset + bit_count;
        <span class="tok-kw">const</span> last_byte = <span class="tok-kw">switch</span> (endian) {
            .little =&gt; ((total_bits + <span class="tok-number">7</span>) / <span class="tok-number">8</span>) - <span class="tok-number">1</span>,
            .big =&gt; buffer.len - ((total_bits + <span class="tok-number">7</span>) / <span class="tok-number">8</span>),
        };

        <span class="tok-kw">const</span> sign_bit = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>((total_bits - <span class="tok-number">1</span>) % <span class="tok-number">8</span>));
        positive = ((buffer[last_byte] &amp; sign_bit) == <span class="tok-number">0</span>);
    }<span class="tok-comment">

    // Copy all complete limbs
    </span><span class="tok-kw">var</span> carry: <span class="tok-type">u1</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> limb_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> bit_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (limb_index &lt; bit_count / <span class="tok-builtin">@bitSizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) : (limb_index += <span class="tok-number">1</span>) {<span class="tok-comment">
        // Read one Limb of bits
        </span><span class="tok-kw">var</span> limb = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, buffer, bit_index + bit_offset, endian);
        bit_index += <span class="tok-builtin">@bitSizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>);<span class="tok-comment">

        // 2's complement (bitwise not, then add carry bit)
        </span><span class="tok-kw">if</span> (!positive) {
            <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(~limb, carry);
            limb = ov[<span class="tok-number">0</span>];
            carry = ov[<span class="tok-number">1</span>];
        }
        x.limbs[limb_index] = limb;
    }<span class="tok-comment">

    // Copy the remaining bits
    </span><span class="tok-kw">if</span> (bit_count != bit_index) {<span class="tok-comment">
        // Read all remaining bits
        </span><span class="tok-kw">var</span> limb = <span class="tok-kw">switch</span> (signedness) {
            .unsigned =&gt; <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readVarPackedInt">readVarPackedInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, buffer, bit_index + bit_offset, bit_count - bit_index, endian, .unsigned),
            .signed =&gt; b: {
                <span class="tok-kw">const</span> SLimb = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.signed, <span class="tok-builtin">@bitSizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>));
                <span class="tok-kw">const</span> limb = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readVarPackedInt">readVarPackedInt</a>(SLimb, buffer, bit_index + bit_offset, bit_count - bit_index, endian, .signed);
                <span class="tok-kw">break</span> :b <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@bitCast</span>(limb));
            },
        };<span class="tok-comment">

        // 2's complement (bitwise not, then add carry bit)
        </span><span class="tok-kw">if</span> (!positive) {
            <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(~limb, carry);
            <a href="std.debug.html#std.debug.assert">assert</a>(ov[<span class="tok-number">1</span>] == <span class="tok-number">0</span>);
            limb = ov[<span class="tok-number">0</span>];
        }
        x.limbs[limb_index] = limb;

        limb_index += <span class="tok-number">1</span>;
    }

    x.positive = positive;
    x.len = limb_index;
    x.normalize(x.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.Mutable.normalize" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">normalize</span><a href="#src.zig-std.math.big.int.Mutable.normalize">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">normalize</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, length: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Normalize a possible sequence of leading zeros.</p>
<p>[1, 2, 3, 4, 0] -&gt; [1, 2, 3, 4]
[1, 2, 0, 0, 0] -&gt; [1, 2]
[0, 0, 0, 0, 0] -&gt; [0]</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.math.big.int.Mutable.html">Mutable</a></code></pre></div><div><pre><code>length: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.Mutable.normalize">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">normalize</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, length: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    r.len = <a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(r.limbs[<span class="tok-number">0</span>..length]);
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.math.big.int.Mutable">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Mutable = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// Raw digits. These are:</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// * Little-endian ordered</span>
    <span class="tok-comment">/// * limbs.len &gt;= 1</span>
    <span class="tok-comment">/// * Zero is represented as limbs.len == 1 with limbs[0] == 0.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Accessing limbs directly should be avoided.</span>
    <span class="tok-comment">/// These are allocated limbs; the `len` field tells the valid range.</span>
    limbs: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
    len: <span class="tok-type">usize</span>,
    positive: <span class="tok-type">bool</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toConst</span>(self: <a href="std.math.big.int.Mutable.html">Mutable</a>) <a href="std.math.big.int.Const.html">Const</a> {
        <span class="tok-kw">return</span> .{
            .limbs = self.limbs[<span class="tok-number">0</span>..self.len],
            .positive = self.positive,
        };
    }

    <span class="tok-comment">/// Returns true if `a == 0`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlZero</span>(self: <a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self.toConst().eqlZero();
    }

    <span class="tok-comment">/// Asserts that the allocator owns the limbs memory. If this is not the case,</span>
    <span class="tok-comment">/// use `toConst().toManaged()`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toManaged</span>(self: <a href="std.math.big.int.Mutable.html">Mutable</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.math.big.int.Managed.html">Managed</a> {
        <span class="tok-kw">return</span> .{
            .allocator = allocator,
            .limbs = self.limbs,
            .metadata = <span class="tok-kw">if</span> (self.positive)
                self.len &amp; ~<a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>
            <span class="tok-kw">else</span>
                self.len | <a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>,
        };
    }

    <span class="tok-comment">/// `value` is a primitive integer type.</span>
    <span class="tok-comment">/// Asserts the value fits within the provided `limbs_buffer`.</span>
    <span class="tok-comment">/// Note: `calcLimbLen` can be used to figure out how big an array to allocate for `limbs_buffer`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, value: <span class="tok-kw">anytype</span>) <a href="std.math.big.int.Mutable.html">Mutable</a> {
        limbs_buffer[<span class="tok-number">0</span>] = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> self: <a href="std.math.big.int.Mutable.html">Mutable</a> = .{
            .limbs = limbs_buffer,
            .len = <span class="tok-number">1</span>,
            .positive = <span class="tok-null">true</span>,
        };
        self.set(value);
        <span class="tok-kw">return</span> self;
    }

    <span class="tok-comment">/// Copies the value of a Const to an existing Mutable so that they both have the same value.</span>
    <span class="tok-comment">/// Asserts the value fits in the limbs buffer.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copy</span>(self: *<a href="std.math.big.int.Mutable.html">Mutable</a>, other: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (self.limbs.ptr != other.limbs.ptr) {
            <span class="tok-builtin">@memcpy</span>(self.limbs[<span class="tok-number">0</span>..other.limbs.len], other.limbs[<span class="tok-number">0</span>..other.limbs.len]);
        }<span class="tok-comment">
        // Normalize before setting `positive` so the `eqlZero` doesn't need to iterate
        // over the extra zero limbs.
        </span>self.normalize(other.limbs.len);
        self.positive = other.positive <span class="tok-kw">or</span> other.eqlZero();
    }

    <span class="tok-comment">/// Efficiently swap an Mutable with another. This swaps the limb pointers and a full copy is not</span>
    <span class="tok-comment">/// performed. The address of the limbs field will not be the same after this function.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(self: *<a href="std.math.big.int.Mutable.html">Mutable</a>, other: *<a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">void</span> {
        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(<a href="std.math.big.int.Mutable.html">Mutable</a>, self, other);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(self: <a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">for</span> (self.limbs[<span class="tok-number">0</span>..self.len]) |limb| {
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;{x} &quot;</span>, .{limb});
        }
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;capacity={} positive={}\n&quot;</span>, .{ self.limbs.len, self.positive });
    }

    <span class="tok-comment">/// Clones an Mutable and returns a new Mutable with the same value. The new Mutable is a deep copy and</span>
    <span class="tok-comment">/// can be modified separately from the original.</span>
    <span class="tok-comment">/// Asserts that limbs is big enough to store the value.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(other: <a href="std.math.big.int.Mutable.html">Mutable</a>, limbs: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>) <a href="std.math.big.int.Mutable.html">Mutable</a> {
        <span class="tok-builtin">@memcpy</span>(limbs[<span class="tok-number">0</span>..other.len], other.limbs[<span class="tok-number">0</span>..other.len]);
        <span class="tok-kw">return</span> .{
            .limbs = limbs,
            .len = other.len,
            .positive = other.positive,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">negate</span>(self: *<a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">void</span> {
        self.positive = !self.positive;
    }

    <span class="tok-comment">/// Modify to become the absolute value</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">abs</span>(self: *<a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">void</span> {
        self.positive = <span class="tok-null">true</span>;
    }

    <span class="tok-comment">/// Sets the Mutable to value. Value must be an primitive integer type.</span>
    <span class="tok-comment">/// Asserts the value fits within the limbs buffer.</span>
    <span class="tok-comment">/// Note: `calcLimbLen` can be used to figure out how big the limbs buffer</span>
    <span class="tok-comment">/// needs to be to store a specific value.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.math.big.int.Mutable.html">Mutable</a>, value: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(value);
        <span class="tok-kw">const</span> needed_limbs = <a href="std.math.big.int.html#std.math.big.int.calcLimbLen">calcLimbLen</a>(value);
        <a href="std.debug.html#std.debug.assert">assert</a>(needed_limbs &lt;= self.limbs.len);<span class="tok-comment"> // value too big

        </span>self.len = needed_limbs;
        self.positive = value &gt;= <span class="tok-number">0</span>;

        <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
            .int =&gt; |info| {
                <span class="tok-kw">var</span> w_value = <span class="tok-builtin">@abs</span>(value);

                <span class="tok-kw">if</span> (info.bits &lt;= <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) {
                    self.limbs[<span class="tok-number">0</span>] = w_value;
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (i += <span class="tok-number">1</span>) {
                        self.limbs[i] = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@truncate</span>(w_value));
                        w_value &gt;&gt;= <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>;

                        <span class="tok-kw">if</span> (w_value == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                    }
                }
            },
            .<span class="tok-type">comptime_int</span> =&gt; {
                <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> w_value = <span class="tok-builtin">@abs</span>(value);

                <span class="tok-kw">if</span> (w_value &lt;= <a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) {
                    self.limbs[<span class="tok-number">0</span>] = w_value;
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">const</span> mask = (<span class="tok-number">1</span> &lt;&lt; <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) - <span class="tok-number">1</span>;

                    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
                    <span class="tok-kw">inline</span> <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (i += <span class="tok-number">1</span>) {
                        self.limbs[i] = w_value &amp; mask;
                        w_value &gt;&gt;= <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>;

                        <span class="tok-kw">if</span> (w_value == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                    }
                }
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;cannot set Mutable using type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T)),
        }
    }

    <span class="tok-comment">/// Set self from the string representation `value`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `value` must contain only digits &lt;= `base` and is case insensitive.  Base prefixes are</span>
    <span class="tok-comment">/// not allowed (e.g. 0x43 should simply be 43).  Underscores in the input string are</span>
    <span class="tok-comment">/// ignored and can be used as digit separators.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts there is enough memory for the value in `self.limbs`. An upper bound on number of limbs can</span>
    <span class="tok-comment">/// be determined with `calcSetStringLimbCount`.</span>
    <span class="tok-comment">/// Asserts the base is in the range [2, 36].</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if the value has invalid digits for the requested base.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `limbs_buffer` is used for temporary storage. The size required can be found with</span>
    <span class="tok-comment">/// `calcSetStringLimbsBufferLen`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If `allocator` is provided, it will be used for temporary storage to improve</span>
    <span class="tok-comment">/// multiplication performance. `error.OutOfMemory` is handled with a fallback algorithm.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setString</span>(
        self: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        base: <span class="tok-type">u8</span>,
        value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
        allocator: ?<a href="std.mem.Allocator.html">Allocator</a>,
    ) <span class="tok-kw">error</span>{InvalidCharacter}!<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(base &gt;= <span class="tok-number">2</span>);
        <a href="std.debug.html#std.debug.assert">assert</a>(base &lt;= <span class="tok-number">36</span>);

        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> positive = <span class="tok-null">true</span>;
        <span class="tok-kw">if</span> (value.len &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> value[<span class="tok-number">0</span>] == <span class="tok-str">'-'</span>) {
            positive = <span class="tok-null">false</span>;
            i += <span class="tok-number">1</span>;
        }

        <span class="tok-kw">const</span> ap_base: <a href="std.math.big.int.Const.html">Const</a> = .{ .limbs = &amp;[_]<a href="std.math.big.html#std.math.big.Limb">Limb</a>{base}, .positive = <span class="tok-null">true</span> };
        self.set(<span class="tok-number">0</span>);

        <span class="tok-kw">for</span> (value[i..]) |ch| {
            <span class="tok-kw">if</span> (ch == <span class="tok-str">'_'</span>) {
                <span class="tok-kw">continue</span>;
            }
            <span class="tok-kw">const</span> d = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.charToDigit">charToDigit</a>(ch, base);
            <span class="tok-kw">const</span> ap_d: <a href="std.math.big.int.Const.html">Const</a> = .{ .limbs = &amp;[_]<a href="std.math.big.html#std.math.big.Limb">Limb</a>{d}, .positive = <span class="tok-null">true</span> };

            self.mul(self.toConst(), ap_base, limbs_buffer, allocator);
            self.add(self.toConst(), ap_d);
        }
        self.positive = positive;
    }

    <span class="tok-comment">/// Set self to either bound of a 2s-complement integer.</span>
    <span class="tok-comment">/// Note: The result is still sign-magnitude, not twos complement! In order to convert the</span>
    <span class="tok-comment">/// result to twos complement, it is sufficient to take the absolute value.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `r`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `calcTwosCompLimbCount(bit_count)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setTwosCompIntLimit</span>(
        r: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        limit: <a href="std.math.big.int.TwosCompIntLimit.html">TwosCompIntLimit</a>,
        signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
        bit_count: <span class="tok-type">usize</span>,
    ) <span class="tok-type">void</span> {<span class="tok-comment">
        // Handle zero-bit types.
        </span><span class="tok-kw">if</span> (bit_count == <span class="tok-number">0</span>) {
            r.set(<span class="tok-number">0</span>);
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">const</span> req_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);
        <span class="tok-kw">const</span> bit: <a href="std.math.big.html#std.math.big.Log2Limb">Log2Limb</a> = <span class="tok-builtin">@truncate</span>(bit_count - <span class="tok-number">1</span>);
        <span class="tok-kw">const</span> signmask = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-number">1</span>) &lt;&lt; bit;<span class="tok-comment"> // 0b0..010..0 where 1 is the sign bit.
        </span><span class="tok-kw">const</span> mask = (signmask &lt;&lt; <span class="tok-number">1</span>) -% <span class="tok-number">1</span>;<span class="tok-comment"> // 0b0..011..1 where the leftmost 1 is the sign bit.

        </span>r.positive = <span class="tok-null">true</span>;

        <span class="tok-kw">switch</span> (signedness) {
            .signed =&gt; <span class="tok-kw">switch</span> (limit) {
                .min =&gt; {<span class="tok-comment">
                    // Negative bound, signed = -0x80.
                    </span>r.len = req_limbs;
                    <span class="tok-builtin">@memset</span>(r.limbs[<span class="tok-number">0</span> .. r.len - <span class="tok-number">1</span>], <span class="tok-number">0</span>);
                    r.limbs[r.len - <span class="tok-number">1</span>] = signmask;
                    r.positive = <span class="tok-null">false</span>;
                },
                .max =&gt; {<span class="tok-comment">
                    // Positive bound, signed = 0x7F
                    // Note, in this branch we need to normalize because the first bit is
                    // supposed to be 0.

                    // Special case for 1-bit integers.
                    </span><span class="tok-kw">if</span> (bit_count == <span class="tok-number">1</span>) {
                        r.set(<span class="tok-number">0</span>);
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">const</span> new_req_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count - <span class="tok-number">1</span>);
                        <span class="tok-kw">const</span> msb = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Log2Limb">Log2Limb</a>, <span class="tok-builtin">@truncate</span>(bit_count - <span class="tok-number">2</span>));
                        <span class="tok-kw">const</span> new_signmask = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-number">1</span>) &lt;&lt; msb;<span class="tok-comment"> // 0b0..010..0 where 1 is the sign bit.
                        </span><span class="tok-kw">const</span> new_mask = (new_signmask &lt;&lt; <span class="tok-number">1</span>) -% <span class="tok-number">1</span>;<span class="tok-comment"> // 0b0..001..1 where the rightmost 0 is the sign bit.

                        </span>r.len = new_req_limbs;
                        <span class="tok-builtin">@memset</span>(r.limbs[<span class="tok-number">0</span> .. r.len - <span class="tok-number">1</span>], <a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>));
                        r.limbs[r.len - <span class="tok-number">1</span>] = new_mask;
                    }
                },
            },
            .unsigned =&gt; <span class="tok-kw">switch</span> (limit) {
                .min =&gt; {<span class="tok-comment">
                    // Min bound, unsigned = 0x00
                    </span>r.set(<span class="tok-number">0</span>);
                },
                .max =&gt; {<span class="tok-comment">
                    // Max bound, unsigned = 0xFF
                    </span>r.len = req_limbs;
                    <span class="tok-builtin">@memset</span>(r.limbs[<span class="tok-number">0</span> .. r.len - <span class="tok-number">1</span>], <a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>));
                    r.limbs[r.len - <span class="tok-number">1</span>] = mask;
                },
            },
        }
    }

    <span class="tok-comment">/// r = a + scalar</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r and a may be aliases.</span>
    <span class="tok-comment">/// scalar is a primitive integer type.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `r`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `@max(a.limbs.len, calcLimbLen(scalar)) + 1`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addScalar</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, scalar: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {<span class="tok-comment">
        // Normally we could just determine the number of limbs needed with calcLimbLen,
        // but that is not comptime-known when scalar is not a comptime_int.  Instead, we
        // use calcTwosCompLimbCount for a non-comptime_int scalar, which can be pessimistic
        // in the case that scalar happens to be small in magnitude within its type, but it
        // is well worth being able to use the stack and not needing an allocator passed in.
        // Note that Mutable.init still sets len to calcLimbLen(scalar) in any case.
        </span><span class="tok-kw">const</span> limb_len = <span class="tok-kw">comptime</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(scalar))) {
            .<span class="tok-type">comptime_int</span> =&gt; <a href="std.math.big.int.html#std.math.big.int.calcLimbLen">calcLimbLen</a>(scalar),
            .int =&gt; |info| <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(info.bits),
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected scalar to be an int&quot;</span>),
        };
        <span class="tok-kw">var</span> limbs: [limb_len]<a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> operand = <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.init">init</a>(&amp;limbs, scalar).toConst();
        <span class="tok-kw">return</span> <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.add">add</a>(r, a, operand);
    }

    <span class="tok-comment">/// Base implementation for addition. Adds `@max(a.limbs.len, b.limbs.len)` elements from a and b,</span>
    <span class="tok-comment">/// and returns whether any overflow occurred.</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts r has enough elements to hold the result. The upper bound is `@max(a.limbs.len, b.limbs.len)`.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">addCarry</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">if</span> (a.eqlZero()) {
            r.copy(b);
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.eqlZero()) {
            r.copy(a);
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.positive != b.positive) {
            <span class="tok-kw">if</span> (a.positive) {<span class="tok-comment">
                // (a) + (-b) =&gt; a - b
                </span><span class="tok-kw">return</span> r.subCarry(a, b.abs());
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // (-a) + (b) =&gt; b - a
                </span><span class="tok-kw">return</span> r.subCarry(b, a.abs());
            }
        } <span class="tok-kw">else</span> {
            r.positive = a.positive;
            <span class="tok-kw">if</span> (a.limbs.len &gt;= b.limbs.len) {
                <span class="tok-kw">const</span> c = <a href="std.math.big.int.html#std.math.big.int.lladdcarry">lladdcarry</a>(r.limbs, a.limbs, b.limbs);
                r.normalize(a.limbs.len);
                <span class="tok-kw">return</span> c != <span class="tok-number">0</span>;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> c = <a href="std.math.big.int.html#std.math.big.int.lladdcarry">lladdcarry</a>(r.limbs, b.limbs, a.limbs);
                r.normalize(b.limbs.len);
                <span class="tok-kw">return</span> c != <span class="tok-number">0</span>;
            }
        }
    }

    <span class="tok-comment">/// r = a + b</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `r`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `@max(a.limbs.len, b.limbs.len) + 1`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (r.addCarry(a, b)) {<span class="tok-comment">
            // Fix up the result. Note that addCarry normalizes by a.limbs.len or b.limbs.len,
            // so we need to set the length here.
            </span><span class="tok-kw">const</span> msl = <span class="tok-builtin">@max</span>(a.limbs.len, b.limbs.len);<span class="tok-comment">
            // `[add|sub]Carry` normalizes by `msl`, so we need to fix up the result manually here.
            // Note, the fact that it normalized means that the intermediary limbs are zero here.
            </span>r.len = msl + <span class="tok-number">1</span>;
            r.limbs[msl] = <span class="tok-number">1</span>;<span class="tok-comment"> // If this panics, there wasn't enough space in `r`.
        </span>}
    }

    <span class="tok-comment">/// r = a + b with 2s-complement wrapping semantics. Returns whether overflow occurred.</span>
    <span class="tok-comment">/// r, a and b may be aliases</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `r`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `calcTwosCompLimbCount(bit_count)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWrap</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
        <span class="tok-kw">const</span> req_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);<span class="tok-comment">

        // Slice of the upper bits if they exist, these will be ignored and allows us to use addCarry to determine
        // if an overflow occurred.
        </span><span class="tok-kw">const</span> x = <a href="std.math.big.int.Const.html">Const</a>{
            .positive = a.positive,
            .limbs = a.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(req_limbs, a.limbs.len)],
        };

        <span class="tok-kw">const</span> y = <a href="std.math.big.int.Const.html">Const</a>{
            .positive = b.positive,
            .limbs = b.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(req_limbs, b.limbs.len)],
        };

        <span class="tok-kw">var</span> carry_truncated = <span class="tok-null">false</span>;
        <span class="tok-kw">if</span> (r.addCarry(x, y)) {<span class="tok-comment">
            // There are two possibilities here:
            // - We overflowed req_limbs. In this case, the carry is ignored, as it would be removed by
            //   truncate anyway.
            // - a and b had less elements than req_limbs, and those were overflowed. This case needs to be handled.
            //   Note: after this we still might need to wrap.
            </span><span class="tok-kw">const</span> msl = <span class="tok-builtin">@max</span>(a.limbs.len, b.limbs.len);
            <span class="tok-kw">if</span> (msl &lt; req_limbs) {
                r.limbs[msl] = <span class="tok-number">1</span>;
                r.len = req_limbs;
                <span class="tok-builtin">@memset</span>(r.limbs[msl + <span class="tok-number">1</span> .. req_limbs], <span class="tok-number">0</span>);
            } <span class="tok-kw">else</span> {
                carry_truncated = <span class="tok-null">true</span>;
            }
        }

        <span class="tok-kw">if</span> (!r.toConst().fitsInTwosComp(signedness, bit_count)) {
            r.truncate(r.toConst(), signedness, bit_count);
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }

        <span class="tok-kw">return</span> carry_truncated;
    }

    <span class="tok-comment">/// r = a + b with 2s-complement saturating semantics.</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Assets the result fits in `r`. Upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `calcTwosCompLimbCount(bit_count)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSat</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> req_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);<span class="tok-comment">

        // Slice of the upper bits if they exist, these will be ignored and allows us to use addCarry to determine
        // if an overflow occurred.
        </span><span class="tok-kw">const</span> x = <a href="std.math.big.int.Const.html">Const</a>{
            .positive = a.positive,
            .limbs = a.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(req_limbs, a.limbs.len)],
        };

        <span class="tok-kw">const</span> y = <a href="std.math.big.int.Const.html">Const</a>{
            .positive = b.positive,
            .limbs = b.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(req_limbs, b.limbs.len)],
        };

        <span class="tok-kw">if</span> (r.addCarry(x, y)) {<span class="tok-comment">
            // There are two possibilities here:
            // - We overflowed req_limbs, in which case we need to saturate.
            // - a and b had less elements than req_limbs, and those were overflowed.
            //   Note: In this case, might _also_ need to saturate.
            </span><span class="tok-kw">const</span> msl = <span class="tok-builtin">@max</span>(a.limbs.len, b.limbs.len);
            <span class="tok-kw">if</span> (msl &lt; req_limbs) {
                r.limbs[msl] = <span class="tok-number">1</span>;
                r.len = req_limbs;<span class="tok-comment">
                // Note: Saturation may still be required if msl == req_limbs - 1
            </span>} <span class="tok-kw">else</span> {<span class="tok-comment">
                // Overflowed req_limbs, definitely saturate.
                </span>r.setTwosCompIntLimit(<span class="tok-kw">if</span> (r.positive) .max <span class="tok-kw">else</span> .min, signedness, bit_count);
            }
        }<span class="tok-comment">

        // Saturate if the result didn't fit.
        </span>r.saturate(r.toConst(), signedness, bit_count);
    }

    <span class="tok-comment">/// Base implementation for subtraction. Subtracts `@max(a.limbs.len, b.limbs.len)` elements from a and b,</span>
    <span class="tok-comment">/// and returns whether any overflow occurred.</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts r has enough elements to hold the result. The upper bound is `@max(a.limbs.len, b.limbs.len)`.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">subCarry</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">if</span> (a.eqlZero()) {
            r.copy(b);
            r.positive = !b.positive;
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.eqlZero()) {
            r.copy(a);
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.positive != b.positive) {
            <span class="tok-kw">if</span> (a.positive) {<span class="tok-comment">
                // (a) - (-b) =&gt; a + b
                </span><span class="tok-kw">return</span> r.addCarry(a, b.abs());
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // (-a) - (b) =&gt; -a + -b
                </span><span class="tok-kw">return</span> r.addCarry(a, b.negate());
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.positive) {
            <span class="tok-kw">if</span> (a.order(b) != .lt) {<span class="tok-comment">
                // (a) - (b) =&gt; a - b
                </span><span class="tok-kw">const</span> c = <a href="std.math.big.int.html#std.math.big.int.llsubcarry">llsubcarry</a>(r.limbs, a.limbs, b.limbs);
                r.normalize(a.limbs.len);
                r.positive = <span class="tok-null">true</span>;
                <span class="tok-kw">return</span> c != <span class="tok-number">0</span>;
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // (a) - (b) =&gt; -b + a =&gt; -(b - a)
                </span><span class="tok-kw">const</span> c = <a href="std.math.big.int.html#std.math.big.int.llsubcarry">llsubcarry</a>(r.limbs, b.limbs, a.limbs);
                r.normalize(b.limbs.len);
                r.positive = <span class="tok-null">false</span>;
                <span class="tok-kw">return</span> c != <span class="tok-number">0</span>;
            }
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">if</span> (a.order(b) == .lt) {<span class="tok-comment">
                // (-a) - (-b) =&gt; -(a - b)
                </span><span class="tok-kw">const</span> c = <a href="std.math.big.int.html#std.math.big.int.llsubcarry">llsubcarry</a>(r.limbs, a.limbs, b.limbs);
                r.normalize(a.limbs.len);
                r.positive = <span class="tok-null">false</span>;
                <span class="tok-kw">return</span> c != <span class="tok-number">0</span>;
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // (-a) - (-b) =&gt; --b + -a =&gt; b - a
                </span><span class="tok-kw">const</span> c = <a href="std.math.big.int.html#std.math.big.int.llsubcarry">llsubcarry</a>(r.limbs, b.limbs, a.limbs);
                r.normalize(b.limbs.len);
                r.positive = <span class="tok-null">true</span>;
                <span class="tok-kw">return</span> c != <span class="tok-number">0</span>;
            }
        }
    }

    <span class="tok-comment">/// r = a - b</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `r`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `@max(a.limbs.len, b.limbs.len) + 1`. The +1 is not needed if both operands are positive.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span> {
        r.add(a, b.negate());
    }

    <span class="tok-comment">/// r = a - b with 2s-complement wrapping semantics. Returns whether any overflow occurred.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r, a and b may be aliases</span>
    <span class="tok-comment">/// Asserts the result fits in `r`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `calcTwosCompLimbCount(bit_count)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subWrap</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> r.addWrap(a, b.negate(), signedness, bit_count);
    }

    <span class="tok-comment">/// r = a - b with 2s-complement saturating semantics.</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Assets the result fits in `r`. Upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `calcTwosCompLimbCount(bit_count)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subSat</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        r.addSat(a, b.negate(), signedness, bit_count);
    }

    <span class="tok-comment">/// rma = a * b</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `rma` may alias with `a` or `b`.</span>
    <span class="tok-comment">/// `a` and `b` may alias with each other.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `rma`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// rma is given by `a.limbs.len + b.limbs.len`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `limbs_buffer` is used for temporary storage. The amount required is given by `calcMulLimbsBufferLen`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mul</span>(rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, allocator: ?<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">var</span> buf_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

        <span class="tok-kw">const</span> a_copy = <span class="tok-kw">if</span> (rma.limbs.ptr == a.limbs.ptr) blk: {
            <span class="tok-kw">const</span> start = buf_index;
            <span class="tok-builtin">@memcpy</span>(limbs_buffer[buf_index..][<span class="tok-number">0</span>..a.limbs.len], a.limbs);
            buf_index += a.limbs.len;
            <span class="tok-kw">break</span> :blk a.toMutable(limbs_buffer[start..buf_index]).toConst();
        } <span class="tok-kw">else</span> a;

        <span class="tok-kw">const</span> b_copy = <span class="tok-kw">if</span> (rma.limbs.ptr == b.limbs.ptr) blk: {
            <span class="tok-kw">const</span> start = buf_index;
            <span class="tok-builtin">@memcpy</span>(limbs_buffer[buf_index..][<span class="tok-number">0</span>..b.limbs.len], b.limbs);
            buf_index += b.limbs.len;
            <span class="tok-kw">break</span> :blk b.toMutable(limbs_buffer[start..buf_index]).toConst();
        } <span class="tok-kw">else</span> b;

        <span class="tok-kw">return</span> rma.mulNoAlias(a_copy, b_copy, allocator);
    }

    <span class="tok-comment">/// rma = a * b</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `rma` may not alias with `a` or `b`.</span>
    <span class="tok-comment">/// `a` and `b` may alias with each other.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `rma`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// rma is given by `a.limbs.len + b.limbs.len`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If `allocator` is provided, it will be used for temporary storage to improve</span>
    <span class="tok-comment">/// multiplication performance. `error.OutOfMemory` is handled with a fallback algorithm.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulNoAlias</span>(rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, allocator: ?<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != a.limbs.ptr);<span class="tok-comment"> // illegal aliasing
        </span><a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != b.limbs.ptr);<span class="tok-comment"> // illegal aliasing

        </span><span class="tok-kw">if</span> (a.limbs.len == <span class="tok-number">1</span> <span class="tok-kw">and</span> b.limbs.len == <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> ov = <span class="tok-builtin">@mulWithOverflow</span>(a.limbs[<span class="tok-number">0</span>], b.limbs[<span class="tok-number">0</span>]);
            rma.limbs[<span class="tok-number">0</span>] = ov[<span class="tok-number">0</span>];
            <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] == <span class="tok-number">0</span>) {
                rma.len = <span class="tok-number">1</span>;
                rma.positive = (a.positive == b.positive);
                <span class="tok-kw">return</span>;
            }
        }

        <span class="tok-builtin">@memset</span>(rma.limbs[<span class="tok-number">0</span> .. a.limbs.len + b.limbs.len], <span class="tok-number">0</span>);

        <a href="std.math.big.int.html#std.math.big.int.llmulacc">llmulacc</a>(.add, allocator, rma.limbs, a.limbs, b.limbs);

        rma.normalize(a.limbs.len + b.limbs.len);
        rma.positive = (a.positive == b.positive);
    }

    <span class="tok-comment">/// rma = a * b with 2s-complement wrapping semantics.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `rma` may alias with `a` or `b`.</span>
    <span class="tok-comment">/// `a` and `b` may alias with each other.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `rma`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// rma is given by `a.limbs.len + b.limbs.len`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `limbs_buffer` is used for temporary storage. The amount required is given by `calcMulWrapLimbsBufferLen`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulWrap</span>(
        rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        a: <a href="std.math.big.int.Const.html">Const</a>,
        b: <a href="std.math.big.int.Const.html">Const</a>,
        signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
        bit_count: <span class="tok-type">usize</span>,
        limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
        allocator: ?<a href="std.mem.Allocator.html">Allocator</a>,
    ) <span class="tok-type">void</span> {
        <span class="tok-kw">var</span> buf_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> req_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);

        <span class="tok-kw">const</span> a_copy = <span class="tok-kw">if</span> (rma.limbs.ptr == a.limbs.ptr) blk: {
            <span class="tok-kw">const</span> start = buf_index;
            <span class="tok-kw">const</span> a_len = <span class="tok-builtin">@min</span>(req_limbs, a.limbs.len);
            <span class="tok-builtin">@memcpy</span>(limbs_buffer[buf_index..][<span class="tok-number">0</span>..a_len], a.limbs[<span class="tok-number">0</span>..a_len]);
            buf_index += a_len;
            <span class="tok-kw">break</span> :blk a.toMutable(limbs_buffer[start..buf_index]).toConst();
        } <span class="tok-kw">else</span> a;

        <span class="tok-kw">const</span> b_copy = <span class="tok-kw">if</span> (rma.limbs.ptr == b.limbs.ptr) blk: {
            <span class="tok-kw">const</span> start = buf_index;
            <span class="tok-kw">const</span> b_len = <span class="tok-builtin">@min</span>(req_limbs, b.limbs.len);
            <span class="tok-builtin">@memcpy</span>(limbs_buffer[buf_index..][<span class="tok-number">0</span>..b_len], b.limbs[<span class="tok-number">0</span>..b_len]);
            buf_index += b_len;
            <span class="tok-kw">break</span> :blk a.toMutable(limbs_buffer[start..buf_index]).toConst();
        } <span class="tok-kw">else</span> b;

        <span class="tok-kw">return</span> rma.mulWrapNoAlias(a_copy, b_copy, signedness, bit_count, allocator);
    }

    <span class="tok-comment">/// rma = a * b with 2s-complement wrapping semantics.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `rma` may not alias with `a` or `b`.</span>
    <span class="tok-comment">/// `a` and `b` may alias with each other.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `rma`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// rma is given by `a.limbs.len + b.limbs.len`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If `allocator` is provided, it will be used for temporary storage to improve</span>
    <span class="tok-comment">/// multiplication performance. `error.OutOfMemory` is handled with a fallback algorithm.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulWrapNoAlias</span>(
        rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        a: <a href="std.math.big.int.Const.html">Const</a>,
        b: <a href="std.math.big.int.Const.html">Const</a>,
        signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
        bit_count: <span class="tok-type">usize</span>,
        allocator: ?<a href="std.mem.Allocator.html">Allocator</a>,
    ) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != a.limbs.ptr);<span class="tok-comment"> // illegal aliasing
        </span><a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != b.limbs.ptr);<span class="tok-comment"> // illegal aliasing

        </span><span class="tok-kw">const</span> req_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);<span class="tok-comment">

        // We can ignore the upper bits here, those results will be discarded anyway.
        </span><span class="tok-kw">const</span> a_limbs = a.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(req_limbs, a.limbs.len)];
        <span class="tok-kw">const</span> b_limbs = b.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(req_limbs, b.limbs.len)];

        <span class="tok-builtin">@memset</span>(rma.limbs[<span class="tok-number">0</span>..req_limbs], <span class="tok-number">0</span>);

        <a href="std.math.big.int.html#std.math.big.int.llmulacc">llmulacc</a>(.add, allocator, rma.limbs, a_limbs, b_limbs);
        rma.normalize(<span class="tok-builtin">@min</span>(req_limbs, a.limbs.len + b.limbs.len));
        rma.positive = (a.positive == b.positive);
        rma.truncate(rma.toConst(), signedness, bit_count);
    }

    <span class="tok-comment">/// r = @bitReverse(a) with 2s-complement semantics.</span>
    <span class="tok-comment">/// r and a may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `r`. Upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `calcTwosCompLimbCount(bit_count)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitReverse</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (bit_count == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;

        r.copy(a);

        <span class="tok-kw">const</span> limbs_required = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);

        <span class="tok-kw">if</span> (!a.positive) {
            r.positive = <span class="tok-null">true</span>;<span class="tok-comment"> // Negate.
            </span>r.bitNotWrap(r.toConst(), .unsigned, bit_count);<span class="tok-comment"> // Bitwise NOT.
            </span>r.addScalar(r.toConst(), <span class="tok-number">1</span>);<span class="tok-comment"> // Add one.
        </span>} <span class="tok-kw">else</span> <span class="tok-kw">if</span> (limbs_required &gt; a.limbs.len) {<span class="tok-comment">
            // Zero-extend to our output length
            </span><span class="tok-kw">for</span> (r.limbs[a.limbs.len..limbs_required]) |*limb| {
                limb.* = <span class="tok-number">0</span>;
            }
            r.len = limbs_required;
        }<span class="tok-comment">

        // 0b0..01..1000 with @log2(@sizeOf(Limb)) consecutive ones
        </span><span class="tok-kw">const</span> endian_mask: <span class="tok-type">usize</span> = (<span class="tok-builtin">@sizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>) - <span class="tok-number">1</span>) &lt;&lt; <span class="tok-number">3</span>;

        <span class="tok-kw">const</span> bytes = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(r.limbs);

        <span class="tok-kw">var</span> k: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (k &lt; ((bit_count + <span class="tok-number">1</span>) / <span class="tok-number">2</span>)) : (k += <span class="tok-number">1</span>) {
            <span class="tok-kw">var</span> i = k;
            <span class="tok-kw">var</span> rev_i = bit_count - i - <span class="tok-number">1</span>;<span class="tok-comment">

            // This &quot;endian mask&quot; remaps a low (LE) byte to the corresponding high
            // (BE) byte in the Limb, without changing which limbs we are indexing
            </span><span class="tok-kw">if</span> (<a href="std.math.big.int.html#std.math.big.int.native_endian">native_endian</a> == .big) {
                i ^= endian_mask;
                rev_i ^= endian_mask;
            }

            <span class="tok-kw">const</span> bit_i = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(<span class="tok-type">u1</span>, bytes, i, .little);
            <span class="tok-kw">const</span> bit_rev_i = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(<span class="tok-type">u1</span>, bytes, rev_i, .little);
            <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writePackedInt">writePackedInt</a>(<span class="tok-type">u1</span>, bytes, i, bit_rev_i, .little);
            <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writePackedInt">writePackedInt</a>(<span class="tok-type">u1</span>, bytes, rev_i, bit_i, .little);
        }<span class="tok-comment">

        // Calculate signed-magnitude representation for output
        </span><span class="tok-kw">if</span> (signedness == .signed) {
            <span class="tok-kw">const</span> last_bit = <span class="tok-kw">switch</span> (<a href="std.math.big.int.html#std.math.big.int.native_endian">native_endian</a>) {
                .little =&gt; <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(<span class="tok-type">u1</span>, bytes, bit_count - <span class="tok-number">1</span>, .little),
                .big =&gt; <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(<span class="tok-type">u1</span>, bytes, (bit_count - <span class="tok-number">1</span>) ^ endian_mask, .little),
            };
            <span class="tok-kw">if</span> (last_bit == <span class="tok-number">1</span>) {
                r.bitNotWrap(r.toConst(), .unsigned, bit_count);<span class="tok-comment"> // Bitwise NOT.
                </span>r.addScalar(r.toConst(), <span class="tok-number">1</span>);<span class="tok-comment"> // Add one.
                </span>r.positive = <span class="tok-null">false</span>;<span class="tok-comment"> // Negate.
            </span>}
        }
        r.normalize(r.len);
    }

    <span class="tok-comment">/// r = @byteSwap(a) with 2s-complement semantics.</span>
    <span class="tok-comment">/// r and a may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `r`. Upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `calcTwosCompLimbCount(8*byte_count)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">byteSwap</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, byte_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (byte_count == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;

        r.copy(a);
        <span class="tok-kw">const</span> limbs_required = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(<span class="tok-number">8</span> * byte_count);

        <span class="tok-kw">if</span> (!a.positive) {
            r.positive = <span class="tok-null">true</span>;<span class="tok-comment"> // Negate.
            </span>r.bitNotWrap(r.toConst(), .unsigned, <span class="tok-number">8</span> * byte_count);<span class="tok-comment"> // Bitwise NOT.
            </span>r.addScalar(r.toConst(), <span class="tok-number">1</span>);<span class="tok-comment"> // Add one.
        </span>} <span class="tok-kw">else</span> <span class="tok-kw">if</span> (limbs_required &gt; a.limbs.len) {<span class="tok-comment">
            // Zero-extend to our output length
            </span><span class="tok-kw">for</span> (r.limbs[a.limbs.len..limbs_required]) |*limb| {
                limb.* = <span class="tok-number">0</span>;
            }
            r.len = limbs_required;
        }<span class="tok-comment">

        // 0b0..01..1 with @log2(@sizeOf(Limb)) trailing ones
        </span><span class="tok-kw">const</span> endian_mask: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>) - <span class="tok-number">1</span>;

        <span class="tok-kw">var</span> bytes = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(r.limbs);
        <a href="std.debug.html#std.debug.assert">assert</a>(bytes.len &gt;= byte_count);

        <span class="tok-kw">var</span> k: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (k &lt; (byte_count + <span class="tok-number">1</span>) / <span class="tok-number">2</span>) : (k += <span class="tok-number">1</span>) {
            <span class="tok-kw">var</span> i = k;
            <span class="tok-kw">var</span> rev_i = byte_count - k - <span class="tok-number">1</span>;<span class="tok-comment">

            // This &quot;endian mask&quot; remaps a low (LE) byte to the corresponding high
            // (BE) byte in the Limb, without changing which limbs we are indexing
            </span><span class="tok-kw">if</span> (<a href="std.math.big.int.html#std.math.big.int.native_endian">native_endian</a> == .big) {
                i ^= endian_mask;
                rev_i ^= endian_mask;
            }

            <span class="tok-kw">const</span> byte_i = bytes[i];
            <span class="tok-kw">const</span> byte_rev_i = bytes[rev_i];
            bytes[rev_i] = byte_i;
            bytes[i] = byte_rev_i;
        }<span class="tok-comment">

        // Calculate signed-magnitude representation for output
        </span><span class="tok-kw">if</span> (signedness == .signed) {
            <span class="tok-kw">const</span> last_byte = <span class="tok-kw">switch</span> (<a href="std.math.big.int.html#std.math.big.int.native_endian">native_endian</a>) {
                .little =&gt; bytes[byte_count - <span class="tok-number">1</span>],
                .big =&gt; bytes[(byte_count - <span class="tok-number">1</span>) ^ endian_mask],
            };

            <span class="tok-kw">if</span> (last_byte &amp; (<span class="tok-number">1</span> &lt;&lt; <span class="tok-number">7</span>) != <span class="tok-number">0</span>) {<span class="tok-comment"> // Check sign bit of last byte
                </span>r.bitNotWrap(r.toConst(), .unsigned, <span class="tok-number">8</span> * byte_count);<span class="tok-comment"> // Bitwise NOT.
                </span>r.addScalar(r.toConst(), <span class="tok-number">1</span>);<span class="tok-comment"> // Add one.
                </span>r.positive = <span class="tok-null">false</span>;<span class="tok-comment"> // Negate.
            </span>}
        }
        r.normalize(r.len);
    }

    <span class="tok-comment">/// r = @popCount(a) with 2s-complement semantics.</span>
    <span class="tok-comment">/// r and a may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Assets the result fits in `r`. Upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `calcTwosCompLimbCount(bit_count)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popCount</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        r.copy(a);

        <span class="tok-kw">if</span> (!a.positive) {
            r.positive = <span class="tok-null">true</span>;<span class="tok-comment"> // Negate.
            </span>r.bitNotWrap(r.toConst(), .unsigned, bit_count);<span class="tok-comment"> // Bitwise NOT.
            </span>r.addScalar(r.toConst(), <span class="tok-number">1</span>);<span class="tok-comment"> // Add one.
        </span>}

        <span class="tok-kw">var</span> sum: <a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> (r.limbs[<span class="tok-number">0</span>..r.len]) |limb| {
            sum += <span class="tok-builtin">@popCount</span>(limb);
        }
        r.set(sum);
    }

    <span class="tok-comment">/// rma = a * a</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `rma` may not alias with `a`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `rma`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// rma is given by `2 * a.limbs.len + 1`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If `allocator` is provided, it will be used for temporary storage to improve</span>
    <span class="tok-comment">/// multiplication performance. `error.OutOfMemory` is handled with a fallback algorithm.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sqrNoAlias</span>(rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, opt_allocator: ?<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
        _ = opt_allocator;
        <a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != a.limbs.ptr);<span class="tok-comment"> // illegal aliasing

        </span><span class="tok-builtin">@memset</span>(rma.limbs, <span class="tok-number">0</span>);

        <a href="std.math.big.int.html#std.math.big.int.llsquareBasecase">llsquareBasecase</a>(rma.limbs, a.limbs);

        rma.normalize(<span class="tok-number">2</span> * a.limbs.len + <span class="tok-number">1</span>);
        rma.positive = <span class="tok-null">true</span>;
    }

    <span class="tok-comment">/// q = a / b (rem r)</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// a / b are floored (rounded towards 0).</span>
    <span class="tok-comment">/// q may alias with a or b.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts there is enough memory to store q and r.</span>
    <span class="tok-comment">/// The upper bound for r limb count is `b.limbs.len`.</span>
    <span class="tok-comment">/// The upper bound for q limb count is given by `a.limbs`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `limbs_buffer` is used for temporary storage. The amount required is given by `calcDivLimbsBufferLen`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">divFloor</span>(
        q: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        r: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        a: <a href="std.math.big.int.Const.html">Const</a>,
        b: <a href="std.math.big.int.Const.html">Const</a>,
        limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
    ) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> sep = a.limbs.len + <span class="tok-number">2</span>;
        <span class="tok-kw">var</span> x = a.toMutable(limbs_buffer[<span class="tok-number">0</span>..sep]);
        <span class="tok-kw">var</span> y = b.toMutable(limbs_buffer[sep..]);

        <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.div">div</a>(q, r, &amp;x, &amp;y);<span class="tok-comment">

        // Note, `div` performs truncating division, which satisfies
        // @divTrunc(a, b) * b + @rem(a, b) = a
        // so r = a - @divTrunc(a, b) * b
        // Note,  @rem(a, -b) = @rem(-b, a) = -@rem(a, b) = -@rem(-a, -b)
        // For divTrunc, we want to perform
        // @divFloor(a, b) * b + @mod(a, b) = a
        // Note:
        // @divFloor(-a, b)
        // = @divFloor(a, -b)
        // = -@divCeil(a, b)
        // = -@divFloor(a + b - 1, b)
        // = -@divTrunc(a + b - 1, b)

        // Note (1):
        // @divTrunc(a + b - 1, b) * b + @rem(a + b - 1, b) = a + b - 1
        // = @divTrunc(a + b - 1, b) * b + @rem(a - 1, b) = a + b - 1
        // = @divTrunc(a + b - 1, b) * b + @rem(a - 1, b) - b + 1 = a

        </span><span class="tok-kw">if</span> (a.positive <span class="tok-kw">and</span> b.positive) {<span class="tok-comment">
            // Positive-positive case, don't need to do anything.
        </span>} <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.positive <span class="tok-kw">and</span> !b.positive) {<span class="tok-comment">
            // a/-b -&gt; q is negative, and so we need to fix flooring.
            // Subtract one to make the division flooring.

            // @divFloor(a, -b) * -b + @mod(a, -b) = a
            // If b divides a exactly, we have @divFloor(a, -b) * -b = a
            // Else, we have @divFloor(a, -b) * -b &gt; a, so @mod(a, -b) becomes negative

            // We have:
            // @divFloor(a, -b) * -b + @mod(a, -b) = a
            // = -@divTrunc(a + b - 1, b) * -b + @mod(a, -b) = a
            // = @divTrunc(a + b - 1, b) * b + @mod(a, -b) = a

            // Substitute a for (1):
            // @divTrunc(a + b - 1, b) * b + @rem(a - 1, b) - b + 1 = @divTrunc(a + b - 1, b) * b + @mod(a, -b)
            // Yields:
            // @mod(a, -b) = @rem(a - 1, b) - b + 1
            // Note that `r` holds @rem(a, b) at this point.
            //
            // If @rem(a, b) is not 0:
            //   @rem(a - 1, b) = @rem(a, b) - 1
            //   =&gt; @mod(a, -b) = @rem(a, b) - 1 - b + 1 = @rem(a, b) - b
            // Else:
            //   @rem(a - 1, b) = @rem(a + b - 1, b) = @rem(b - 1, b) = b - 1
            //   =&gt; @mod(a, -b) = b - 1 - b + 1 = 0
            </span><span class="tok-kw">if</span> (!r.eqlZero()) {
                q.addScalar(q.toConst(), -<span class="tok-number">1</span>);
                r.positive = <span class="tok-null">true</span>;
                r.sub(r.toConst(), y.toConst().abs());
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (!a.positive <span class="tok-kw">and</span> b.positive) {<span class="tok-comment">
            // -a/b -&gt; q is negative, and so we need to fix flooring.
            // Subtract one to make the division flooring.

            // @divFloor(-a, b) * b + @mod(-a, b) = a
            // If b divides a exactly, we have @divFloor(-a, b) * b = -a
            // Else, we have @divFloor(-a, b) * b &lt; -a, so @mod(-a, b) becomes positive

            // We have:
            // @divFloor(-a, b) * b + @mod(-a, b) = -a
            // = -@divTrunc(a + b - 1, b) * b + @mod(-a, b) = -a
            // = @divTrunc(a + b - 1, b) * b - @mod(-a, b) = a

            // Substitute a for (1):
            // @divTrunc(a + b - 1, b) * b + @rem(a - 1, b) - b + 1 = @divTrunc(a + b - 1, b) * b - @mod(-a, b)
            // Yields:
            // @rem(a - 1, b) - b + 1 = -@mod(-a, b)
            // =&gt; -@mod(-a, b) = @rem(a - 1, b) - b + 1
            // =&gt; @mod(-a, b) = -(@rem(a - 1, b) - b + 1) = -@rem(a - 1, b) + b - 1
            //
            // If @rem(a, b) is not 0:
            //   @rem(a - 1, b) = @rem(a, b) - 1
            //   =&gt; @mod(-a, b) = -(@rem(a, b) - 1) + b - 1 = -@rem(a, b) + 1 + b - 1 = -@rem(a, b) + b
            // Else :
            //   @rem(a - 1, b) = b - 1
            //   =&gt; @mod(-a, b) = -(b - 1) + b - 1 = 0
            </span><span class="tok-kw">if</span> (!r.eqlZero()) {
                q.addScalar(q.toConst(), -<span class="tok-number">1</span>);
                r.positive = <span class="tok-null">false</span>;
                r.add(r.toConst(), y.toConst().abs());
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (!a.positive <span class="tok-kw">and</span> !b.positive) {<span class="tok-comment">
            // a/b -&gt; q is positive, don't need to do anything to fix flooring.

            // @divFloor(-a, -b) * -b + @mod(-a, -b) = -a
            // If b divides a exactly, we have @divFloor(-a, -b) * -b = -a
            // Else, we have @divFloor(-a, -b) * -b &gt; -a, so @mod(-a, -b) becomes negative

            // We have:
            // @divFloor(-a, -b) * -b + @mod(-a, -b) = -a
            // = @divTrunc(a, b) * -b + @mod(-a, -b) = -a
            // = @divTrunc(a, b) * b - @mod(-a, -b) = a

            // We also have:
            // @divTrunc(a, b) * b + @rem(a, b) = a

            // Substitute a:
            // @divTrunc(a, b) * b + @rem(a, b) = @divTrunc(a, b) * b - @mod(-a, -b)
            // =&gt; @rem(a, b) = -@mod(-a, -b)
            // =&gt; @mod(-a, -b) = -@rem(a, b)
            </span>r.positive = <span class="tok-null">false</span>;
        }
    }

    <span class="tok-comment">/// q = a / b (rem r)</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// a / b are truncated (rounded towards -inf).</span>
    <span class="tok-comment">/// q may alias with a or b.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts there is enough memory to store q and r.</span>
    <span class="tok-comment">/// The upper bound for r limb count is `b.limbs.len`.</span>
    <span class="tok-comment">/// The upper bound for q limb count is given by `a.limbs.len`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `limbs_buffer` is used for temporary storage. The amount required is given by `calcDivLimbsBufferLen`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">divTrunc</span>(
        q: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        r: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        a: <a href="std.math.big.int.Const.html">Const</a>,
        b: <a href="std.math.big.int.Const.html">Const</a>,
        limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
    ) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> sep = a.limbs.len + <span class="tok-number">2</span>;
        <span class="tok-kw">var</span> x = a.toMutable(limbs_buffer[<span class="tok-number">0</span>..sep]);
        <span class="tok-kw">var</span> y = b.toMutable(limbs_buffer[sep..]);

        <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.div">div</a>(q, r, &amp;x, &amp;y);
    }

    <span class="tok-comment">/// r = a &lt;&lt; shift, in other words, r = a * 2^shift</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r and a may alias.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts there is enough memory to fit the result. The upper bound Limb count is</span>
    <span class="tok-comment">/// `a.limbs.len + (shift / (@sizeOf(Limb) * 8))`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftLeft</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, shift: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <a href="std.math.big.int.html#std.math.big.int.llshl">llshl</a>(r.limbs, a.limbs, shift);
        r.normalize(a.limbs.len + (shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) + <span class="tok-number">1</span>);
        r.positive = a.positive;
    }

    <span class="tok-comment">/// r = a &lt;&lt;| shift with 2s-complement saturating semantics.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r and a may alias.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts there is enough memory to fit the result. The upper bound Limb count is</span>
    <span class="tok-comment">/// r is `calcTwosCompLimbCount(bit_count)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftLeftSat</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, shift: <span class="tok-type">usize</span>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {<span class="tok-comment">
        // Special case: When the argument is negative, but the result is supposed to be unsigned,
        // return 0 in all cases.
        </span><span class="tok-kw">if</span> (!a.positive <span class="tok-kw">and</span> signedness == .unsigned) {
            r.set(<span class="tok-number">0</span>);
            <span class="tok-kw">return</span>;
        }<span class="tok-comment">

        // Check whether the shift is going to overflow. This is the case
        // when (in 2s complement) any bit above `bit_count - shift` is set in the unshifted value.
        // Note, the sign bit is not counted here.

        // Handle shifts larger than the target type. This also deals with
        // 0-bit integers.
        </span><span class="tok-kw">if</span> (bit_count &lt;= shift) {<span class="tok-comment">
            // In this case, there is only no overflow if `a` is zero.
            </span><span class="tok-kw">if</span> (a.eqlZero()) {
                r.set(<span class="tok-number">0</span>);
            } <span class="tok-kw">else</span> {
                r.setTwosCompIntLimit(<span class="tok-kw">if</span> (a.positive) .max <span class="tok-kw">else</span> .min, signedness, bit_count);
            }
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">const</span> checkbit = bit_count - shift - <span class="tok-builtin">@intFromBool</span>(signedness == .signed);<span class="tok-comment">
        // If `checkbit` and more significant bits are zero, no overflow will take place.

        </span><span class="tok-kw">if</span> (checkbit &gt;= a.limbs.len * <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) {<span class="tok-comment">
            // `checkbit` is outside the range of a, so definitely no overflow will take place. We
            // can defer to a normal shift.
            // Note that if `a` is normalized (which we assume), this checks for set bits in the upper limbs.

            // Note, in this case r should already have enough limbs required to perform the normal shift.
            // In this case the shift of the most significant limb may still overflow.
            </span>r.shiftLeft(a, shift);
            <span class="tok-kw">return</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (checkbit &lt; (a.limbs.len - <span class="tok-number">1</span>) * <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) {<span class="tok-comment">
            // `checkbit` is not in the most significant limb. If `a` is normalized the most significant
            // limb will not be zero, so in this case we need to saturate. Note that `a.limbs.len` must be
            // at least one according to normalization rules.

            </span>r.setTwosCompIntLimit(<span class="tok-kw">if</span> (a.positive) .max <span class="tok-kw">else</span> .min, signedness, bit_count);
            <span class="tok-kw">return</span>;
        }<span class="tok-comment">

        // Generate a mask with the bits to check in the most significant limb. We'll need to check
        // all bits with equal or more significance than checkbit.
        // const msb = @truncate(Log2Limb, checkbit);
        // const checkmask = (@as(Limb, 1) &lt;&lt; msb) -% 1;

        </span><span class="tok-kw">if</span> (a.limbs[a.limbs.len - <span class="tok-number">1</span>] &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Log2Limb">Log2Limb</a>, <span class="tok-builtin">@truncate</span>(checkbit)) != <span class="tok-number">0</span>) {<span class="tok-comment">
            // Need to saturate.
            </span>r.setTwosCompIntLimit(<span class="tok-kw">if</span> (a.positive) .max <span class="tok-kw">else</span> .min, signedness, bit_count);
            <span class="tok-kw">return</span>;
        }<span class="tok-comment">

        // This shift should not be able to overflow, so invoke llshl and normalize manually
        // to avoid the extra required limb.
        </span><a href="std.math.big.int.html#std.math.big.int.llshl">llshl</a>(r.limbs, a.limbs, shift);
        r.normalize(a.limbs.len + (shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>));
        r.positive = a.positive;
    }

    <span class="tok-comment">/// r = a &gt;&gt; shift</span>
    <span class="tok-comment">/// r and a may alias.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts there is enough memory to fit the result. The upper bound Limb count is</span>
    <span class="tok-comment">/// `a.limbs.len - (shift / (@sizeOf(Limb) * 8))`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftRight</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, shift: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> full_limbs_shifted_out = shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>;
        <span class="tok-kw">const</span> remaining_bits_shifted_out = shift % <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>;
        <span class="tok-kw">if</span> (a.limbs.len &lt;= full_limbs_shifted_out) {<span class="tok-comment">
            // Shifting negative numbers converges to -1 instead of 0
            </span><span class="tok-kw">if</span> (a.positive) {
                r.len = <span class="tok-number">1</span>;
                r.positive = <span class="tok-null">true</span>;
                r.limbs[<span class="tok-number">0</span>] = <span class="tok-number">0</span>;
            } <span class="tok-kw">else</span> {
                r.len = <span class="tok-number">1</span>;
                r.positive = <span class="tok-null">false</span>;
                r.limbs[<span class="tok-number">0</span>] = <span class="tok-number">1</span>;
            }
            <span class="tok-kw">return</span>;
        }
        <span class="tok-kw">const</span> nonzero_negative_shiftout = <span class="tok-kw">if</span> (a.positive) <span class="tok-null">false</span> <span class="tok-kw">else</span> nonzero: {
            <span class="tok-kw">for</span> (a.limbs[<span class="tok-number">0</span>..full_limbs_shifted_out]) |x| {
                <span class="tok-kw">if</span> (x != <span class="tok-number">0</span>)
                    <span class="tok-kw">break</span> :nonzero <span class="tok-null">true</span>;
            }
            <span class="tok-kw">if</span> (remaining_bits_shifted_out == <span class="tok-number">0</span>)
                <span class="tok-kw">break</span> :nonzero <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> not_covered: <a href="std.math.big.html#std.math.big.Log2Limb">Log2Limb</a> = <span class="tok-builtin">@intCast</span>(<a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a> - remaining_bits_shifted_out);
            <span class="tok-kw">break</span> :nonzero a.limbs[full_limbs_shifted_out] &lt;&lt; not_covered != <span class="tok-number">0</span>;
        };

        <a href="std.math.big.int.html#std.math.big.int.llshr">llshr</a>(r.limbs, a.limbs, shift);

        r.len = a.limbs.len - full_limbs_shifted_out;
        r.positive = a.positive;
        <span class="tok-kw">if</span> (nonzero_negative_shiftout) r.addScalar(r.toConst(), -<span class="tok-number">1</span>);
        r.normalize(r.len);
    }

    <span class="tok-comment">/// r = ~a under 2s complement wrapping semantics.</span>
    <span class="tok-comment">/// r may alias with a.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Assets that r has enough limbs to store the result. The upper bound Limb count is</span>
    <span class="tok-comment">/// r is `calcTwosCompLimbCount(bit_count)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitNotWrap</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        r.copy(a.negate());
        <span class="tok-kw">const</span> negative_one = <a href="std.math.big.int.Const.html">Const</a>{ .limbs = &amp;.{<span class="tok-number">1</span>}, .positive = <span class="tok-null">false</span> };
        _ = r.addWrap(r.toConst(), negative_one, signedness, bit_count);
    }

    <span class="tok-comment">/// r = a | b under 2s complement semantics.</span>
    <span class="tok-comment">/// r may alias with a or b.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// a and b are zero-extended to the longer of a or b.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts that r has enough limbs to store the result. Upper bound is `@max(a.limbs.len, b.limbs.len)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitOr</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span> {<span class="tok-comment">
        // Trivial cases, llsignedor does not support zero.
        </span><span class="tok-kw">if</span> (a.eqlZero()) {
            r.copy(b);
            <span class="tok-kw">return</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.eqlZero()) {
            r.copy(a);
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">if</span> (a.limbs.len &gt;= b.limbs.len) {
            r.positive = <a href="std.math.big.int.html#std.math.big.int.llsignedor">llsignedor</a>(r.limbs, a.limbs, a.positive, b.limbs, b.positive);
            r.normalize(<span class="tok-kw">if</span> (b.positive) a.limbs.len <span class="tok-kw">else</span> b.limbs.len);
        } <span class="tok-kw">else</span> {
            r.positive = <a href="std.math.big.int.html#std.math.big.int.llsignedor">llsignedor</a>(r.limbs, b.limbs, b.positive, a.limbs, a.positive);
            r.normalize(<span class="tok-kw">if</span> (a.positive) b.limbs.len <span class="tok-kw">else</span> a.limbs.len);
        }
    }

    <span class="tok-comment">/// r = a &amp; b under 2s complement semantics.</span>
    <span class="tok-comment">/// r may alias with a or b.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts that r has enough limbs to store the result.</span>
    <span class="tok-comment">/// If only a is positive, the upper bound is `a.limbs.len`.</span>
    <span class="tok-comment">/// If only b is positive, the upper bound is `b.limbs.len`.</span>
    <span class="tok-comment">/// If a and b are positive, the upper bound is `@min(a.limbs.len, b.limbs.len)`.</span>
    <span class="tok-comment">/// If a and b are negative, the upper bound is `@max(a.limbs.len, b.limbs.len) + 1`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitAnd</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span> {<span class="tok-comment">
        // Trivial cases, llsignedand does not support zero.
        </span><span class="tok-kw">if</span> (a.eqlZero()) {
            r.copy(a);
            <span class="tok-kw">return</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.eqlZero()) {
            r.copy(b);
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">if</span> (a.limbs.len &gt;= b.limbs.len) {
            r.positive = <a href="std.math.big.int.html#std.math.big.int.llsignedand">llsignedand</a>(r.limbs, a.limbs, a.positive, b.limbs, b.positive);
            r.normalize(<span class="tok-kw">if</span> (b.positive) b.limbs.len <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.positive) a.limbs.len <span class="tok-kw">else</span> a.limbs.len + <span class="tok-number">1</span>);
        } <span class="tok-kw">else</span> {
            r.positive = <a href="std.math.big.int.html#std.math.big.int.llsignedand">llsignedand</a>(r.limbs, b.limbs, b.positive, a.limbs, a.positive);
            r.normalize(<span class="tok-kw">if</span> (a.positive) a.limbs.len <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.positive) b.limbs.len <span class="tok-kw">else</span> b.limbs.len + <span class="tok-number">1</span>);
        }
    }

    <span class="tok-comment">/// r = a ^ b under 2s complement semantics.</span>
    <span class="tok-comment">/// r may alias with a or b.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts that r has enough limbs to store the result. If a and b share the same signedness, the</span>
    <span class="tok-comment">/// upper bound is `@max(a.limbs.len, b.limbs.len)`. Otherwise, if either a or b is negative</span>
    <span class="tok-comment">/// but not both, the upper bound is `@max(a.limbs.len, b.limbs.len) + 1`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitXor</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span> {<span class="tok-comment">
        // Trivial cases, because llsignedxor does not support negative zero.
        </span><span class="tok-kw">if</span> (a.eqlZero()) {
            r.copy(b);
            <span class="tok-kw">return</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.eqlZero()) {
            r.copy(a);
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">if</span> (a.limbs.len &gt; b.limbs.len) {
            r.positive = <a href="std.math.big.int.html#std.math.big.int.llsignedxor">llsignedxor</a>(r.limbs, a.limbs, a.positive, b.limbs, b.positive);
            r.normalize(a.limbs.len + <span class="tok-builtin">@intFromBool</span>(a.positive != b.positive));
        } <span class="tok-kw">else</span> {
            r.positive = <a href="std.math.big.int.html#std.math.big.int.llsignedxor">llsignedxor</a>(r.limbs, b.limbs, b.positive, a.limbs, a.positive);
            r.normalize(b.limbs.len + <span class="tok-builtin">@intFromBool</span>(a.positive != b.positive));
        }
    }

    <span class="tok-comment">/// rma may alias x or y.</span>
    <span class="tok-comment">/// x and y may alias each other.</span>
    <span class="tok-comment">/// Asserts that `rma` has enough limbs to store the result. Upper bound is</span>
    <span class="tok-comment">/// `@min(x.limbs.len, y.limbs.len)`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `limbs_buffer` is used for temporary storage during the operation. When this function returns,</span>
    <span class="tok-comment">/// it will have the same length as it had when the function was called.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gcd</span>(rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, x: <a href="std.math.big.int.Const.html">Const</a>, y: <a href="std.math.big.int.Const.html">Const</a>, limbs_buffer: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> prev_len = limbs_buffer.items.len;
        <span class="tok-kw">defer</span> limbs_buffer.shrinkRetainingCapacity(prev_len);
        <span class="tok-kw">const</span> x_copy = <span class="tok-kw">if</span> (rma.limbs.ptr == x.limbs.ptr) blk: {
            <span class="tok-kw">const</span> start = limbs_buffer.items.len;
            <span class="tok-kw">try</span> limbs_buffer.appendSlice(x.limbs);
            <span class="tok-kw">break</span> :blk x.toMutable(limbs_buffer.items[start..]).toConst();
        } <span class="tok-kw">else</span> x;
        <span class="tok-kw">const</span> y_copy = <span class="tok-kw">if</span> (rma.limbs.ptr == y.limbs.ptr) blk: {
            <span class="tok-kw">const</span> start = limbs_buffer.items.len;
            <span class="tok-kw">try</span> limbs_buffer.appendSlice(y.limbs);
            <span class="tok-kw">break</span> :blk y.toMutable(limbs_buffer.items[start..]).toConst();
        } <span class="tok-kw">else</span> y;

        <span class="tok-kw">return</span> <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.gcdLehmer">gcdLehmer</a>(rma, x_copy, y_copy, limbs_buffer);
    }

    <span class="tok-comment">/// q = a ^ b</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r may not alias a.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts that `r` has enough limbs to store the result. Upper bound is</span>
    <span class="tok-comment">/// `calcPowLimbsBufferLen(a.bitCountAbs(), b)`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `limbs_buffer` is used for temporary storage.</span>
    <span class="tok-comment">/// The amount required is given by `calcPowLimbsBufferLen`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pow</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <span class="tok-type">u32</span>, limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(r.limbs.ptr != a.limbs.ptr);<span class="tok-comment"> // illegal aliasing

        // Handle all the trivial cases first
        </span><span class="tok-kw">switch</span> (b) {
            <span class="tok-number">0</span> =&gt; {<span class="tok-comment">
                // a^0 = 1
                </span><span class="tok-kw">return</span> r.set(<span class="tok-number">1</span>);
            },
            <span class="tok-number">1</span> =&gt; {<span class="tok-comment">
                // a^1 = a
                </span><span class="tok-kw">return</span> r.copy(a);
            },
            <span class="tok-kw">else</span> =&gt; {},
        }

        <span class="tok-kw">if</span> (a.eqlZero()) {<span class="tok-comment">
            // 0^b = 0
            </span><span class="tok-kw">return</span> r.set(<span class="tok-number">0</span>);
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.limbs.len == <span class="tok-number">1</span> <span class="tok-kw">and</span> a.limbs[<span class="tok-number">0</span>] == <span class="tok-number">1</span>) {<span class="tok-comment">
            // 1^b = 1 and -1^b = 1
            </span>r.set(<span class="tok-number">1</span>);
            r.positive = a.positive <span class="tok-kw">or</span> (b &amp; <span class="tok-number">1</span>) == <span class="tok-number">0</span>;
            <span class="tok-kw">return</span>;
        }<span class="tok-comment">

        // Here a&gt;1 and b&gt;1
        </span><span class="tok-kw">const</span> needed_limbs = <a href="std.math.big.int.html#std.math.big.int.calcPowLimbsBufferLen">calcPowLimbsBufferLen</a>(a.bitCountAbs(), b);
        <a href="std.debug.html#std.debug.assert">assert</a>(r.limbs.len &gt;= needed_limbs);
        <a href="std.debug.html#std.debug.assert">assert</a>(limbs_buffer.len &gt;= needed_limbs);

        <a href="std.math.big.int.html#std.math.big.int.llpow">llpow</a>(r.limbs, a.limbs, b, limbs_buffer);

        r.normalize(needed_limbs);
        r.positive = a.positive <span class="tok-kw">or</span> (b &amp; <span class="tok-number">1</span>) == <span class="tok-number">0</span>;
    }

    <span class="tok-comment">/// r = a</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r may alias a.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts that `r` has enough limbs to store the result. Upper bound is</span>
    <span class="tok-comment">/// `(a.limbs.len - 1) / 2 + 1`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `limbs_buffer` is used for temporary storage.</span>
    <span class="tok-comment">/// The amount required is given by `calcSqrtLimbsBufferLen`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sqrt</span>(
        r: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        a: <a href="std.math.big.int.Const.html">Const</a>,
        limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
    ) <span class="tok-type">void</span> {<span class="tok-comment">
        // Brent and Zimmermann, Modern Computer Arithmetic, Algorithm 1.13 SqrtInt
        // https://members.loria.fr/PZimmermann/mca/pub226.html
        </span><span class="tok-kw">var</span> buf_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> t = b: {
            <span class="tok-kw">const</span> start = buf_index;
            buf_index += a.limbs.len;
            <span class="tok-kw">break</span> :b <a href="std.math.big.int.Mutable.html">Mutable</a>.<a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.init">init</a>(limbs_buffer[start..buf_index], <span class="tok-number">0</span>);
        };
        <span class="tok-kw">var</span> u = b: {
            <span class="tok-kw">const</span> start = buf_index;
            <span class="tok-kw">const</span> shift = (a.bitCountAbs() + <span class="tok-number">1</span>) / <span class="tok-number">2</span>;
            buf_index += <span class="tok-number">1</span> + ((shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) + <span class="tok-number">1</span>);
            <span class="tok-kw">var</span> m = <a href="std.math.big.int.Mutable.html">Mutable</a>.<a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.init">init</a>(limbs_buffer[start..buf_index], <span class="tok-number">1</span>);
            m.shiftLeft(m.toConst(), shift);<span class="tok-comment"> // u must be &gt;= a, and should be as small as possible for efficiency
            </span><span class="tok-kw">break</span> :b m;
        };
        <span class="tok-kw">var</span> s = b: {
            <span class="tok-kw">const</span> start = buf_index;
            buf_index += u.limbs.len;
            <span class="tok-kw">break</span> :b u.toConst().toMutable(limbs_buffer[start..buf_index]);
        };
        <span class="tok-kw">var</span> rem = b: {
            <span class="tok-kw">const</span> start = buf_index;
            buf_index += s.limbs.len;
            <span class="tok-kw">break</span> :b <a href="std.math.big.int.Mutable.html">Mutable</a>.<a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.init">init</a>(limbs_buffer[start..buf_index], <span class="tok-number">0</span>);
        };

        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            t.divFloor(&amp;rem, a, s.toConst(), limbs_buffer[buf_index..]);
            t.add(t.toConst(), s.toConst());
            u.shiftRight(t.toConst(), <span class="tok-number">1</span>);

            <span class="tok-kw">if</span> (u.toConst().order(s.toConst()).compare(.gte)) {
                r.copy(s.toConst());
                <span class="tok-kw">return</span>;
            }<span class="tok-comment">

            // Avoid copying u to s by swapping u and s
            </span><span class="tok-kw">const</span> tmp_s = s;
            s = u;
            u = tmp_s;
        }
    }

    <span class="tok-comment">/// rma may not alias x or y.</span>
    <span class="tok-comment">/// x and y may alias each other.</span>
    <span class="tok-comment">/// Asserts that `rma` has enough limbs to store the result. Upper bound is given by `calcGcdNoAliasLimbLen`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `limbs_buffer` is used for temporary storage during the operation.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gcdNoAlias</span>(rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, x: <a href="std.math.big.int.Const.html">Const</a>, y: <a href="std.math.big.int.Const.html">Const</a>, limbs_buffer: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) !<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != x.limbs.ptr);<span class="tok-comment"> // illegal aliasing
        </span><a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != y.limbs.ptr);<span class="tok-comment"> // illegal aliasing
        </span><span class="tok-kw">return</span> <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.gcdLehmer">gcdLehmer</a>(rma, x, y, limbs_buffer);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">gcdLehmer</span>(result: *<a href="std.math.big.int.Mutable.html">Mutable</a>, xa: <a href="std.math.big.int.Const.html">Const</a>, ya: <a href="std.math.big.int.Const.html">Const</a>, limbs_buffer: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) !<span class="tok-type">void</span> {
        <span class="tok-kw">var</span> x = <span class="tok-kw">try</span> xa.toManaged(limbs_buffer.allocator);
        <span class="tok-kw">defer</span> x.deinit();
        x.abs();

        <span class="tok-kw">var</span> y = <span class="tok-kw">try</span> ya.toManaged(limbs_buffer.allocator);
        <span class="tok-kw">defer</span> y.deinit();
        y.abs();

        <span class="tok-kw">if</span> (x.toConst().order(y.toConst()) == .lt) {
            x.swap(&amp;y);
        }

        <span class="tok-kw">var</span> t_big = <span class="tok-kw">try</span> <a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.init">init</a>(limbs_buffer.allocator);
        <span class="tok-kw">defer</span> t_big.deinit();

        <span class="tok-kw">var</span> r = <span class="tok-kw">try</span> <a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.init">init</a>(limbs_buffer.allocator);
        <span class="tok-kw">defer</span> r.deinit();

        <span class="tok-kw">var</span> tmp_x = <span class="tok-kw">try</span> <a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.init">init</a>(limbs_buffer.allocator);
        <span class="tok-kw">defer</span> tmp_x.deinit();

        <span class="tok-kw">while</span> (y.len() &gt; <span class="tok-number">1</span> <span class="tok-kw">and</span> !y.eqlZero()) {
            <a href="std.debug.html#std.debug.assert">assert</a>(x.isPositive() <span class="tok-kw">and</span> y.isPositive());
            <a href="std.debug.html#std.debug.assert">assert</a>(x.len() &gt;= y.len());

            <span class="tok-kw">var</span> xh: <a href="std.math.big.html#std.math.big.SignedDoubleLimb">SignedDoubleLimb</a> = x.limbs[x.len() - <span class="tok-number">1</span>];
            <span class="tok-kw">var</span> yh: <a href="std.math.big.html#std.math.big.SignedDoubleLimb">SignedDoubleLimb</a> = <span class="tok-kw">if</span> (x.len() &gt; y.len()) <span class="tok-number">0</span> <span class="tok-kw">else</span> y.limbs[x.len() - <span class="tok-number">1</span>];

            <span class="tok-kw">var</span> A: <a href="std.math.big.html#std.math.big.SignedDoubleLimb">SignedDoubleLimb</a> = <span class="tok-number">1</span>;
            <span class="tok-kw">var</span> B: <a href="std.math.big.html#std.math.big.SignedDoubleLimb">SignedDoubleLimb</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> C: <a href="std.math.big.html#std.math.big.SignedDoubleLimb">SignedDoubleLimb</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> D: <a href="std.math.big.html#std.math.big.SignedDoubleLimb">SignedDoubleLimb</a> = <span class="tok-number">1</span>;

            <span class="tok-kw">while</span> (yh + C != <span class="tok-number">0</span> <span class="tok-kw">and</span> yh + D != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> q = <span class="tok-builtin">@divFloor</span>(xh + A, yh + C);
                <span class="tok-kw">const</span> qp = <span class="tok-builtin">@divFloor</span>(xh + B, yh + D);
                <span class="tok-kw">if</span> (q != qp) {
                    <span class="tok-kw">break</span>;
                }

                <span class="tok-kw">var</span> t = A - q * C;
                A = C;
                C = t;
                t = B - q * D;
                B = D;
                D = t;

                t = xh - q * yh;
                xh = yh;
                yh = t;
            }

            <span class="tok-kw">if</span> (B == <span class="tok-number">0</span>) {<span class="tok-comment">
                // t_big = x % y, r is unused
                </span><span class="tok-kw">try</span> r.divTrunc(&amp;t_big, &amp;x, &amp;y);
                <a href="std.debug.html#std.debug.assert">assert</a>(t_big.isPositive());

                x.swap(&amp;y);
                y.swap(&amp;t_big);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">var</span> storage: [<span class="tok-number">8</span>]<a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">const</span> Ap = <a href="std.math.big.int.html#std.math.big.int.fixedIntFromSignedDoubleLimb">fixedIntFromSignedDoubleLimb</a>(A, storage[<span class="tok-number">0</span>..<span class="tok-number">2</span>]).toManaged(limbs_buffer.allocator);
                <span class="tok-kw">const</span> Bp = <a href="std.math.big.int.html#std.math.big.int.fixedIntFromSignedDoubleLimb">fixedIntFromSignedDoubleLimb</a>(B, storage[<span class="tok-number">2</span>..<span class="tok-number">4</span>]).toManaged(limbs_buffer.allocator);
                <span class="tok-kw">const</span> Cp = <a href="std.math.big.int.html#std.math.big.int.fixedIntFromSignedDoubleLimb">fixedIntFromSignedDoubleLimb</a>(C, storage[<span class="tok-number">4</span>..<span class="tok-number">6</span>]).toManaged(limbs_buffer.allocator);
                <span class="tok-kw">const</span> Dp = <a href="std.math.big.int.html#std.math.big.int.fixedIntFromSignedDoubleLimb">fixedIntFromSignedDoubleLimb</a>(D, storage[<span class="tok-number">6</span>..<span class="tok-number">8</span>]).toManaged(limbs_buffer.allocator);<span class="tok-comment">

                // t_big = Ax + By
                </span><span class="tok-kw">try</span> r.mul(&amp;x, &amp;Ap);
                <span class="tok-kw">try</span> t_big.mul(&amp;y, &amp;Bp);
                <span class="tok-kw">try</span> t_big.add(&amp;r, &amp;t_big);<span class="tok-comment">

                // u = Cx + Dy, r as u
                </span><span class="tok-kw">try</span> tmp_x.copy(x.toConst());
                <span class="tok-kw">try</span> x.mul(&amp;tmp_x, &amp;Cp);
                <span class="tok-kw">try</span> r.mul(&amp;y, &amp;Dp);
                <span class="tok-kw">try</span> r.add(&amp;x, &amp;r);

                x.swap(&amp;t_big);
                y.swap(&amp;r);
            }
        }<span class="tok-comment">

        // euclidean algorithm
        </span><a href="std.debug.html#std.debug.assert">assert</a>(x.toConst().order(y.toConst()) != .lt);

        <span class="tok-kw">while</span> (!y.toConst().eqlZero()) {
            <span class="tok-kw">try</span> t_big.divTrunc(&amp;r, &amp;x, &amp;y);
            x.swap(&amp;y);
            y.swap(&amp;r);
        }

        result.copy(x.toConst());
    }<span class="tok-comment">

    // Truncates by default.
    </span><span class="tok-kw">fn</span> <span class="tok-fn">div</span>(q: *<a href="std.math.big.int.Mutable.html">Mutable</a>, r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, x: *<a href="std.math.big.int.Mutable.html">Mutable</a>, y: *<a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(!y.eqlZero());<span class="tok-comment"> // division by zero
        </span><a href="std.debug.html#std.debug.assert">assert</a>(q != r);<span class="tok-comment"> // illegal aliasing

        </span><span class="tok-kw">const</span> q_positive = (x.positive == y.positive);
        <span class="tok-kw">const</span> r_positive = x.positive;

        <span class="tok-kw">if</span> (x.toConst().orderAbs(y.toConst()) == .lt) {<span class="tok-comment">
            // q may alias x so handle r first.
            </span>r.copy(x.toConst());
            r.positive = r_positive;

            q.set(<span class="tok-number">0</span>);
            <span class="tok-kw">return</span>;
        }<span class="tok-comment">

        // Handle trailing zero-words of divisor/dividend. These are not handled in the following
        // algorithms.
        // Note, there must be a non-zero limb for either.
        // const x_trailing = std.mem.indexOfScalar(Limb, x.limbs[0..x.len], 0).?;
        // const y_trailing = std.mem.indexOfScalar(Limb, y.limbs[0..y.len], 0).?;

        </span><span class="tok-kw">const</span> x_trailing = <span class="tok-kw">for</span> (x.limbs[<span class="tok-number">0</span>..x.len], <span class="tok-number">0</span>..) |xi, i| {
            <span class="tok-kw">if</span> (xi != <span class="tok-number">0</span>) <span class="tok-kw">break</span> i;
        } <span class="tok-kw">else</span> <span class="tok-kw">unreachable</span>;

        <span class="tok-kw">const</span> y_trailing = <span class="tok-kw">for</span> (y.limbs[<span class="tok-number">0</span>..y.len], <span class="tok-number">0</span>..) |yi, i| {
            <span class="tok-kw">if</span> (yi != <span class="tok-number">0</span>) <span class="tok-kw">break</span> i;
        } <span class="tok-kw">else</span> <span class="tok-kw">unreachable</span>;

        <span class="tok-kw">const</span> xy_trailing = <span class="tok-builtin">@min</span>(x_trailing, y_trailing);

        <span class="tok-kw">if</span> (y.len - xy_trailing == <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> divisor = y.limbs[y.len - <span class="tok-number">1</span>];<span class="tok-comment">

            // Optimization for small divisor. By using a half limb we can avoid requiring DoubleLimb
            // divisions in the hot code path. This may often require compiler_rt software-emulation.
            </span><span class="tok-kw">if</span> (divisor &lt; <a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.HalfLimb">HalfLimb</a>)) {
                <a href="std.math.big.int.html#std.math.big.int.lldiv0p5">lldiv0p5</a>(q.limbs, &amp;r.limbs[<span class="tok-number">0</span>], x.limbs[xy_trailing..x.len], <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.HalfLimb">HalfLimb</a>, <span class="tok-builtin">@intCast</span>(divisor)));
            } <span class="tok-kw">else</span> {
                <a href="std.math.big.int.html#std.math.big.int.lldiv1">lldiv1</a>(q.limbs, &amp;r.limbs[<span class="tok-number">0</span>], x.limbs[xy_trailing..x.len], divisor);
            }

            q.normalize(x.len - xy_trailing);
            q.positive = q_positive;

            r.len = <span class="tok-number">1</span>;
            r.positive = r_positive;
        } <span class="tok-kw">else</span> {<span class="tok-comment">
            // Shrink x, y such that the trailing zero limbs shared between are removed.
            </span><span class="tok-kw">var</span> x0 = <a href="std.math.big.int.Mutable.html">Mutable</a>{
                .limbs = x.limbs[xy_trailing..],
                .len = x.len - xy_trailing,
                .positive = <span class="tok-null">true</span>,
            };

            <span class="tok-kw">var</span> y0 = <a href="std.math.big.int.Mutable.html">Mutable</a>{
                .limbs = y.limbs[xy_trailing..],
                .len = y.len - xy_trailing,
                .positive = <span class="tok-null">true</span>,
            };

            <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.divmod">divmod</a>(q, r, &amp;x0, &amp;y0);
            q.positive = q_positive;

            r.positive = r_positive;
        }

        <span class="tok-kw">if</span> (xy_trailing != <span class="tok-number">0</span> <span class="tok-kw">and</span> r.limbs[r.len - <span class="tok-number">1</span>] != <span class="tok-number">0</span>) {<span class="tok-comment">
            // Manually shift here since we know its limb aligned.
            </span><a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyBackwards">copyBackwards</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, r.limbs[xy_trailing..], r.limbs[<span class="tok-number">0</span>..r.len]);
            <span class="tok-builtin">@memset</span>(r.limbs[<span class="tok-number">0</span>..xy_trailing], <span class="tok-number">0</span>);
            r.len += xy_trailing;
        }
    }

    <span class="tok-comment">/// Handbook of Applied Cryptography, 14.20</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// x = qy + r where 0 &lt;= r &lt; y</span>
    <span class="tok-comment">/// y is modified but returned intact.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">divmod</span>(
        q: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        r: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        x: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        y: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
    ) <span class="tok-type">void</span> {<span class="tok-comment">
        // 0.
        // Normalize so that y[t] &gt; b/2
        </span><span class="tok-kw">const</span> lz = <span class="tok-builtin">@clz</span>(y.limbs[y.len - <span class="tok-number">1</span>]);
        <span class="tok-kw">const</span> norm_shift = <span class="tok-kw">if</span> (lz == <span class="tok-number">0</span> <span class="tok-kw">and</span> y.toConst().isOdd())
            <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a><span class="tok-comment"> // Force an extra limb so that y is even.
        </span><span class="tok-kw">else</span>
            lz;

        x.shiftLeft(x.toConst(), norm_shift);
        y.shiftLeft(y.toConst(), norm_shift);

        <span class="tok-kw">const</span> n = x.len - <span class="tok-number">1</span>;
        <span class="tok-kw">const</span> t = y.len - <span class="tok-number">1</span>;
        <span class="tok-kw">const</span> shift = n - t;<span class="tok-comment">

        // 1.
        // for 0 &lt;= j &lt;= n - t, set q[j] to 0
        </span>q.len = shift + <span class="tok-number">1</span>;
        q.positive = <span class="tok-null">true</span>;
        <span class="tok-builtin">@memset</span>(q.limbs[<span class="tok-number">0</span>..q.len], <span class="tok-number">0</span>);<span class="tok-comment">

        // 2.
        // while x &gt;= y * b^(n - t):
        //    x -= y * b^(n - t)
        //    q[n - t] += 1
        // Note, this algorithm is performed only once if y[t] &gt; base/2 and y is even, which we
        // enforced in step 0. This means we can replace the while with an if.
        // Note, multiplication by b^(n - t) comes down to shifting to the right by n - t limbs.
        // We can also replace x &gt;= y * b^(n - t) by x/b^(n - t) &gt;= y, and use shifts for that.
        </span>{<span class="tok-comment">
            // x &gt;= y * b^(n - t) can be replaced by x/b^(n - t) &gt;= y.

            // 'divide' x by b^(n - t)
            </span><span class="tok-kw">var</span> tmp = <a href="std.math.big.int.Mutable.html">Mutable</a>{
                .limbs = x.limbs[shift..],
                .len = x.len - shift,
                .positive = <span class="tok-null">true</span>,
            };

            <span class="tok-kw">if</span> (tmp.toConst().order(y.toConst()) != .lt) {<span class="tok-comment">
                // Perform x -= y * b^(n - t)
                // Note, we can subtract y from x[n - t..] and get the result without shifting.
                // We can also re-use tmp which already contains the relevant part of x. Note that
                // this also edits x.
                // Due to the check above, this cannot underflow.
                </span>tmp.sub(tmp.toConst(), y.toConst());<span class="tok-comment">

                // tmp.sub normalized tmp, but we need to normalize x now.
                </span>x.limbs.len = tmp.limbs.len + shift;

                q.limbs[shift] += <span class="tok-number">1</span>;
            }
        }<span class="tok-comment">

        // 3.
        // for i from n down to t + 1, do
        </span><span class="tok-kw">var</span> i = n;
        <span class="tok-kw">while</span> (i &gt;= t + <span class="tok-number">1</span>) : (i -= <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> k = i - t - <span class="tok-number">1</span>;<span class="tok-comment">
            // 3.1.
            // if x_i == y_t:
            //   q[i - t - 1] = b - 1
            // else:
            //   q[i - t - 1] = (x[i] * b + x[i - 1]) / y[t]
            </span><span class="tok-kw">if</span> (x.limbs[i] == y.limbs[t]) {
                q.limbs[k] = <a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> q0 = (<span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.DoubleLimb">DoubleLimb</a>, x.limbs[i]) &lt;&lt; <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) | <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.DoubleLimb">DoubleLimb</a>, x.limbs[i - <span class="tok-number">1</span>]);
                <span class="tok-kw">const</span> n0 = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.DoubleLimb">DoubleLimb</a>, y.limbs[t]);
                q.limbs[k] = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@intCast</span>(q0 / n0));
            }<span class="tok-comment">

            // 3.2
            // while q[i - t - 1] * (y[t] * b + y[t - 1] &gt; x[i] * b * b + x[i - 1] + x[i - 2]:
            //   q[i - t - 1] -= 1
            // Note, if y[t] &gt; b / 2 this part is repeated no more than twice.

            // Extract from y.
            </span><span class="tok-kw">const</span> y0 = <span class="tok-kw">if</span> (t &gt; <span class="tok-number">0</span>) y.limbs[t - <span class="tok-number">1</span>] <span class="tok-kw">else</span> <span class="tok-number">0</span>;
            <span class="tok-kw">const</span> y1 = y.limbs[t];<span class="tok-comment">

            // Extract from x.
            // Note, big endian.
            </span><span class="tok-kw">const</span> tmp0 = [_]<a href="std.math.big.html#std.math.big.Limb">Limb</a>{
                x.limbs[i],
                <span class="tok-kw">if</span> (i &gt;= <span class="tok-number">1</span>) x.limbs[i - <span class="tok-number">1</span>] <span class="tok-kw">else</span> <span class="tok-number">0</span>,
                <span class="tok-kw">if</span> (i &gt;= <span class="tok-number">2</span>) x.limbs[i - <span class="tok-number">2</span>] <span class="tok-kw">else</span> <span class="tok-number">0</span>,
            };

            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment">
                // Ad-hoc 2x1 multiplication with q[i - t - 1].
                // Note, big endian.
                </span><span class="tok-kw">var</span> tmp1 = [_]<a href="std.math.big.html#std.math.big.Limb">Limb</a>{ <span class="tok-number">0</span>, <span class="tok-null">undefined</span>, <span class="tok-null">undefined</span> };
                tmp1[<span class="tok-number">2</span>] = <a href="std.math.big.int.html#std.math.big.int.addMulLimbWithCarry">addMulLimbWithCarry</a>(<span class="tok-number">0</span>, y0, q.limbs[k], &amp;tmp1[<span class="tok-number">0</span>]);
                tmp1[<span class="tok-number">1</span>] = <a href="std.math.big.int.html#std.math.big.int.addMulLimbWithCarry">addMulLimbWithCarry</a>(<span class="tok-number">0</span>, y1, q.limbs[k], &amp;tmp1[<span class="tok-number">0</span>]);<span class="tok-comment">

                // Big-endian compare
                </span><span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.order">order</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, &amp;tmp1, &amp;tmp0) != .gt)
                    <span class="tok-kw">break</span>;

                q.limbs[k] -= <span class="tok-number">1</span>;
            }<span class="tok-comment">

            // 3.3.
            // x -= q[i - t - 1] * y * b^(i - t - 1)
            // Note, we multiply by a single limb here.
            // The shift doesn't need to be performed if we add the result of the first multiplication
            // to x[i - t - 1].
            </span><span class="tok-kw">const</span> underflow = <a href="std.math.big.int.html#std.math.big.int.llmulLimb">llmulLimb</a>(.sub, x.limbs[k..x.len], y.limbs[<span class="tok-number">0</span>..y.len], q.limbs[k]);<span class="tok-comment">

            // 3.4.
            // if x &lt; 0:
            //   x += y * b^(i - t - 1)
            //   q[i - t - 1] -= 1
            // Note, we check for x &lt; 0 using the underflow flag from the previous operation.
            </span><span class="tok-kw">if</span> (underflow) {<span class="tok-comment">
                // While we didn't properly set the signedness of x, this operation should 'flow' it back to positive.
                </span><a href="std.math.big.int.html#std.math.big.int.llaccum">llaccum</a>(.add, x.limbs[k..x.len], y.limbs[<span class="tok-number">0</span>..y.len]);
                q.limbs[k] -= <span class="tok-number">1</span>;
            }
        }

        x.normalize(x.len);
        q.normalize(q.len);<span class="tok-comment">

        // De-normalize r and y.
        </span>r.shiftRight(x.toConst(), norm_shift);
        y.shiftRight(y.toConst(), norm_shift);
    }

    <span class="tok-comment">/// Truncate an integer to a number of bits, following 2s-complement semantics.</span>
    <span class="tok-comment">/// `r` may alias `a`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts `r` has enough storage to compute the result.</span>
    <span class="tok-comment">/// The upper bound is `calcTwosCompLimbCount(a.len)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">truncate</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {<span class="tok-comment">
        // Handle 0-bit integers.
        </span><span class="tok-kw">if</span> (bit_count == <span class="tok-number">0</span>) {
            <span class="tok-builtin">@branchHint</span>(.unlikely);
            r.set(<span class="tok-number">0</span>);
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">const</span> max_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);
        <span class="tok-kw">const</span> sign_bit = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@truncate</span>(bit_count - <span class="tok-number">1</span>);
        <span class="tok-kw">const</span> mask = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) &gt;&gt; <span class="tok-builtin">@truncate</span>(-%bit_count);<span class="tok-comment">

        // Guess whether the result will have the same sign as `a`.
        //  * If the result will be signed zero, the guess is `true`.
        //  * If the result will be the minimum signed integer, the guess is `false`.
        //  * If the result will be unsigned zero, the guess is `a.positive`.
        //  * Otherwise the guess is correct.
        </span><span class="tok-kw">const</span> same_sign_guess = <span class="tok-kw">switch</span> (signedness) {
            .signed =&gt; max_limbs &gt; a.limbs.len <span class="tok-kw">or</span> a.limbs[max_limbs - <span class="tok-number">1</span>] &amp; sign_bit == <span class="tok-number">0</span>,
            .unsigned =&gt; a.positive,
        };

        <span class="tok-kw">const</span> abs_trunc_a: <a href="std.math.big.int.Const.html">Const</a> = .{
            .positive = <span class="tok-null">true</span>,
            .limbs = a.limbs[<span class="tok-number">0</span>..<a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(a.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(a.limbs.len, max_limbs)])],
        };
        <span class="tok-kw">if</span> (same_sign_guess <span class="tok-kw">or</span> abs_trunc_a.eqlZero()) {<span class="tok-comment">
            // One of the following is true:
            //  * The result is zero.
            //  * The result is non-zero and has the same sign as `a`.
            </span>r.copy(abs_trunc_a);
            <span class="tok-kw">if</span> (max_limbs &lt;= r.len) r.limbs[max_limbs - <span class="tok-number">1</span>] &amp;= mask;
            r.normalize(r.len);
            r.positive = a.positive <span class="tok-kw">or</span> r.eqlZero();
        } <span class="tok-kw">else</span> {<span class="tok-comment">
            // One of the following is true:
            //  * The result is the minimum signed integer.
            //  * The result is unsigned zero.
            //  * The result is non-zero and has the opposite sign as `a`.
            </span>r.addScalar(abs_trunc_a, -<span class="tok-number">1</span>);
            <a href="std.math.big.int.html#std.math.big.int.llnot">llnot</a>(r.limbs[<span class="tok-number">0</span>..r.len]);
            <span class="tok-builtin">@memset</span>(r.limbs[r.len..max_limbs], <a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>));
            r.limbs[max_limbs - <span class="tok-number">1</span>] &amp;= mask;
            r.normalize(max_limbs);
            r.positive = <span class="tok-kw">switch</span> (signedness) {<span class="tok-comment">
                // The only value with the sign bit still set is the minimum signed integer.
                </span>.signed =&gt; !a.positive <span class="tok-kw">and</span> r.limbs[max_limbs - <span class="tok-number">1</span>] &amp; sign_bit == <span class="tok-number">0</span>,
                .unsigned =&gt; !a.positive <span class="tok-kw">or</span> r.eqlZero(),
            };
        }
    }

    <span class="tok-comment">/// Saturate an integer to a number of bits, following 2s-complement semantics.</span>
    <span class="tok-comment">/// r may alias a.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts `r` has enough storage to store the result.</span>
    <span class="tok-comment">/// The upper bound is `calcTwosCompLimbCount(a.len)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">saturate</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (!a.fitsInTwosComp(signedness, bit_count)) {
            r.setTwosCompIntLimit(<span class="tok-kw">if</span> (r.positive) .max <span class="tok-kw">else</span> .min, signedness, bit_count);
        }
    }

    <span class="tok-comment">/// Read the value of `x` from `buffer`.</span>
    <span class="tok-comment">/// Asserts that `buffer` is large enough to contain a value of bit-size `bit_count`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The contents of `buffer` are interpreted as if they were the contents of</span>
    <span class="tok-comment">/// @ptrCast(*[buffer.len]const u8, &amp;x). Byte ordering is determined by `endian`</span>
    <span class="tok-comment">/// and any required padding bits are expected on the MSB end.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readTwosComplement</span>(
        x: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        bit_count: <span class="tok-type">usize</span>,
        endian: <a href="std.builtin.Endian.html">Endian</a>,
        signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
    ) <span class="tok-type">void</span> {
        <span class="tok-kw">return</span> <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.readPackedTwosComplement">readPackedTwosComplement</a>(x, buffer, <span class="tok-number">0</span>, bit_count, endian, signedness);
    }

    <span class="tok-comment">/// Read the value of `x` from a packed memory `buffer`.</span>
    <span class="tok-comment">/// Asserts that `buffer` is large enough to contain a value of bit-size `bit_count`</span>
    <span class="tok-comment">/// at offset `bit_offset`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// This is equivalent to loading the value of an integer with `bit_count` bits as</span>
    <span class="tok-comment">/// if it were a field in packed memory at the provided bit offset.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readPackedTwosComplement</span>(
        x: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        bit_offset: <span class="tok-type">usize</span>,
        bit_count: <span class="tok-type">usize</span>,
        endian: <a href="std.builtin.Endian.html">Endian</a>,
        signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
    ) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (bit_count == <span class="tok-number">0</span>) {
            x.limbs[<span class="tok-number">0</span>] = <span class="tok-number">0</span>;
            x.len = <span class="tok-number">1</span>;
            x.positive = <span class="tok-null">true</span>;
            <span class="tok-kw">return</span>;
        }<span class="tok-comment">

        // Check whether the input is negative
        </span><span class="tok-kw">var</span> positive = <span class="tok-null">true</span>;
        <span class="tok-kw">if</span> (signedness == .signed) {
            <span class="tok-kw">const</span> total_bits = bit_offset + bit_count;
            <span class="tok-kw">const</span> last_byte = <span class="tok-kw">switch</span> (endian) {
                .little =&gt; ((total_bits + <span class="tok-number">7</span>) / <span class="tok-number">8</span>) - <span class="tok-number">1</span>,
                .big =&gt; buffer.len - ((total_bits + <span class="tok-number">7</span>) / <span class="tok-number">8</span>),
            };

            <span class="tok-kw">const</span> sign_bit = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>((total_bits - <span class="tok-number">1</span>) % <span class="tok-number">8</span>));
            positive = ((buffer[last_byte] &amp; sign_bit) == <span class="tok-number">0</span>);
        }<span class="tok-comment">

        // Copy all complete limbs
        </span><span class="tok-kw">var</span> carry: <span class="tok-type">u1</span> = <span class="tok-number">1</span>;
        <span class="tok-kw">var</span> limb_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> bit_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (limb_index &lt; bit_count / <span class="tok-builtin">@bitSizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) : (limb_index += <span class="tok-number">1</span>) {<span class="tok-comment">
            // Read one Limb of bits
            </span><span class="tok-kw">var</span> limb = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, buffer, bit_index + bit_offset, endian);
            bit_index += <span class="tok-builtin">@bitSizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>);<span class="tok-comment">

            // 2's complement (bitwise not, then add carry bit)
            </span><span class="tok-kw">if</span> (!positive) {
                <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(~limb, carry);
                limb = ov[<span class="tok-number">0</span>];
                carry = ov[<span class="tok-number">1</span>];
            }
            x.limbs[limb_index] = limb;
        }<span class="tok-comment">

        // Copy the remaining bits
        </span><span class="tok-kw">if</span> (bit_count != bit_index) {<span class="tok-comment">
            // Read all remaining bits
            </span><span class="tok-kw">var</span> limb = <span class="tok-kw">switch</span> (signedness) {
                .unsigned =&gt; <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readVarPackedInt">readVarPackedInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, buffer, bit_index + bit_offset, bit_count - bit_index, endian, .unsigned),
                .signed =&gt; b: {
                    <span class="tok-kw">const</span> SLimb = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.signed, <span class="tok-builtin">@bitSizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>));
                    <span class="tok-kw">const</span> limb = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readVarPackedInt">readVarPackedInt</a>(SLimb, buffer, bit_index + bit_offset, bit_count - bit_index, endian, .signed);
                    <span class="tok-kw">break</span> :b <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@bitCast</span>(limb));
                },
            };<span class="tok-comment">

            // 2's complement (bitwise not, then add carry bit)
            </span><span class="tok-kw">if</span> (!positive) {
                <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(~limb, carry);
                <a href="std.debug.html#std.debug.assert">assert</a>(ov[<span class="tok-number">1</span>] == <span class="tok-number">0</span>);
                limb = ov[<span class="tok-number">0</span>];
            }
            x.limbs[limb_index] = limb;

            limb_index += <span class="tok-number">1</span>;
        }

        x.positive = positive;
        x.len = limb_index;
        x.normalize(x.len);
    }

    <span class="tok-comment">/// Normalize a possible sequence of leading zeros.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// [1, 2, 3, 4, 0] -&gt; [1, 2, 3, 4]</span>
    <span class="tok-comment">/// [1, 2, 0, 0, 0] -&gt; [1, 2]</span>
    <span class="tok-comment">/// [0, 0, 0, 0, 0] -&gt; [0]</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">normalize</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, length: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        r.len = <a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(r.limbs[<span class="tok-number">0</span>..length]);
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
