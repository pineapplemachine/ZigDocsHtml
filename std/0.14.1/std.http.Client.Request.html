<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">http</a></li><li><a href="std.http.Client.html" class="">Client</a></li><li><a href="std.http.Client.Request.html" class="active">Request</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.http.Client.Request" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.http.Client.Request</span><a href="#src.zig-std.http.Client.Request">[src]</a></h1><div class="tldDocs"><p>A HTTP request that has been sent.</p>
<p>Order of operations: open -&gt; send[ -&gt; write -&gt; finish] -&gt; wait -&gt; read</p>
</div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.http.Client.Request.Headers.html">std.http.Client.Request.Headers</a></li><li><a href="std.http.Client.Request.RedirectBehavior.html">std.http.Client.Request.RedirectBehavior</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.http.Client.Request.Reader" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Reader</span><a href="#src.zig-std.http.Client.Request.Reader">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.Request.Reader">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Reader = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericReader">Reader</a>(*<a href="std.http.Client.Request.html">Request</a>, <a href="std.http.Client.Request.html#std.http.Client.Request.ReadError">ReadError</a>, <a href="std.http.Client.Request.html#std.http.Client.Request.read">read</a>)</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.Request.Writer" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Writer</span><a href="#src.zig-std.http.Client.Request.Writer">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.Request.Writer">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.http.Client.Request.html">Request</a>, <a href="std.http.Client.Request.html#std.http.Client.Request.WriteError">WriteError</a>, <a href="std.http.Client.Request.html#std.http.Client.Request.write">write</a>)</code></pre></details></div></div></div></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>uri: <a href="std.Uri.html">Uri</a></code></pre></div><div><pre><code>client: *<a href="std.http.Client.html">Client</a></code></pre></div><div><pre><code>connection: ?*<a href="std.http.Client.Connection.html">Connection</a></code></pre><div class="fieldDocs"><p>This is null when the connection is released.</p>
</div></div><div><pre><code>keep_alive: <span class="tok-type">bool</span></code></pre></div><div><pre><code>method: <a href="std.http.html">http</a>.<a href="std.http.Method.html">Method</a></code></pre></div><div><pre><code>version: <a href="std.http.html">http</a>.<a href="std.http.Version.html">Version</a> = .@&quot;HTTP/1.1&quot;</code></pre></div><div><pre><code>transfer_encoding: <a href="std.http.Client.RequestTransfer.html">RequestTransfer</a></code></pre></div><div><pre><code>redirect_behavior: <a href="std.http.Client.Request.RedirectBehavior.html">RedirectBehavior</a></code></pre></div><div><pre><code>handle_continue: <span class="tok-type">bool</span></code></pre><div class="fieldDocs"><p>Whether the request should handle a 100-continue response before sending the request body.</p>
</div></div><div><pre><code>response: <a href="std.http.Client.Response.html">Response</a></code></pre><div class="fieldDocs"><p>The response associated with this request.</p>
<p>This field is undefined until <code><a href="std.http.Client.Request.html#std.http.Client.Request.wait">wait</a></code> is called.</p>
</div></div><div><pre><code>headers: <a href="std.http.Client.Request.Headers.html">Headers</a></code></pre><div class="fieldDocs"><p>Standard headers that have default, but overridable, behavior.</p>
</div></div><div><pre><code>extra_headers: []<span class="tok-kw">const</span> <a href="std.http.html">http</a>.<a href="std.http.Header.html">Header</a></code></pre><div class="fieldDocs"><p>These headers are kept including when following a redirect to a
different domain.
Externally-owned; must outlive the Request.</p>
</div></div><div><pre><code>privileged_headers: []<span class="tok-kw">const</span> <a href="std.http.html">http</a>.<a href="std.http.Header.html">Header</a></code></pre><div class="fieldDocs"><p>These headers are stripped when following a redirect to a different
domain.
Externally-owned; must outlive the Request.</p>
</div></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.http.Client.Request.SendError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SendError</span><a href="#src.zig-std.http.Client.Request.SendError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>ConnectionResetByPeer <a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a></dt></div><div><dt>InvalidContentLength</dt></div><div><dt>UnexpectedWriteFailure <a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a></dt></div><div><dt>UnsupportedTransferEncoding</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.Request.SendError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SendError = <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a> || <span class="tok-kw">error</span>{ InvalidContentLength, UnsupportedTransferEncoding }</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.Request.WaitError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">WaitError</span><a href="#src.zig-std.http.Client.Request.WaitError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>CertificateBundleLoadFailure <a href="std.http.Client.html#std.http.Client.RequestError">RequestError</a></dt></div><div><dt>CompressionInitializationFailed</dt></div><div><dt>CompressionUnsupported <a href="std.http.Client.Response.html#std.http.Client.Response.ParseError">ParseError</a></dt></div><div><dt>ConnectionRefused <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>ConnectionResetByPeer <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>ConnectionTimedOut <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>EndOfStream <a href="std.http.Client.Connection.html#std.http.Client.Connection.ReadError">ReadError</a></dt></div><div><dt>HostLacksNetworkAddresses <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>HttpChunkInvalid <a href="std.http.protocol.HeadersParser.html#std.http.protocol.HeadersParser.ReadError">ReadError</a></dt></div><div><dt>HttpConnectionHeaderUnsupported <a href="std.http.Client.Response.html#std.http.Client.Response.ParseError">ParseError</a></dt></div><div><dt>HttpHeaderContinuationsUnsupported <a href="std.http.Client.Response.html#std.http.Client.Response.ParseError">ParseError</a></dt></div><div><dt>HttpHeadersInvalid <a href="std.http.Client.Response.html#std.http.Client.Response.ParseError">ParseError</a></dt></div><div><dt>HttpHeadersOversize <a href="std.http.protocol.HeadersParser.html#std.http.protocol.HeadersParser.CheckCompleteHeadError">CheckCompleteHeadError</a></dt></div><div><dt>HttpRedirectLocationInvalid</dt></div><div><dt>HttpRedirectLocationMissing</dt></div><div><dt>HttpTransferEncodingUnsupported <a href="std.http.Client.Response.html#std.http.Client.Response.ParseError">ParseError</a></dt></div><div><dt>InvalidCharacter <a href="std.fmt.html#std.fmt.ParseIntError">ParseIntError</a></dt><dd><p>The input was empty or contained an invalid character</p>
</dd></div><div><dt>InvalidContentLength <a href="std.http.Client.Request.html#std.http.Client.Request.SendError">SendError</a></dt></div><div><dt>NameServerFailure <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>NetworkUnreachable <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>Overflow <a href="std.fmt.html#std.fmt.ParseIntError">ParseIntError</a></dt><dd><p>The result cannot fit in the type specified</p>
</dd></div><div><dt>RedirectRequiresResend</dt></div><div><dt>TemporaryNameServerFailure <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>TlsAlert <a href="std.http.Client.Connection.html#std.http.Client.Connection.ReadError">ReadError</a></dt></div><div><dt>TlsFailure <a href="std.http.Client.Connection.html#std.http.Client.Connection.ReadError">ReadError</a></dt></div><div><dt>TlsInitializationFailed <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>TooManyHttpRedirects</dt></div><div><dt>UnexpectedConnectFailure <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>UnexpectedReadFailure <a href="std.http.Client.Connection.html#std.http.Client.Connection.ReadError">ReadError</a></dt></div><div><dt>UnexpectedWriteFailure <a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a></dt></div><div><dt>UnknownHostName <a href="std.http.Client.html#std.http.Client.ConnectTcpError">ConnectTcpError</a></dt></div><div><dt>UnsupportedTransferEncoding <a href="std.http.Client.Request.html#std.http.Client.Request.SendError">SendError</a></dt></div><div><dt>UnsupportedUriScheme <a href="std.http.Client.html#std.http.Client.ConnectErrorPartial">ConnectErrorPartial</a></dt></div><div><dt>UriMissingHost <a href="std.http.Client.html#std.http.Client.RequestError">RequestError</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.Request.WaitError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> WaitError = <a href="std.http.Client.html#std.http.Client.RequestError">RequestError</a> || <a href="std.http.Client.Request.html#std.http.Client.Request.SendError">SendError</a> || <a href="std.http.Client.Request.html#std.http.Client.Request.TransferReadError">TransferReadError</a> ||
    <a href="std.http.protocol.html">proto</a>.<a href="std.http.protocol.HeadersParser.html">HeadersParser</a>.<a href="std.http.protocol.HeadersParser.html#std.http.protocol.HeadersParser.CheckCompleteHeadError">CheckCompleteHeadError</a> || <a href="std.http.Client.Response.html">Response</a>.<a href="std.http.Client.Response.html#std.http.Client.Response.ParseError">ParseError</a> ||
    <span class="tok-kw">error</span>{
        TooManyHttpRedirects,
        RedirectRequiresResend,
        HttpRedirectLocationMissing,
        HttpRedirectLocationInvalid,
        CompressionInitializationFailed,
        CompressionUnsupported,
    }</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.Request.ReadError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ReadError</span><a href="#src.zig-std.http.Client.Request.ReadError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>ConnectionResetByPeer <a href="std.http.Client.Connection.html#std.http.Client.Connection.ReadError">ReadError</a></dt></div><div><dt>ConnectionTimedOut <a href="std.http.Client.Connection.html#std.http.Client.Connection.ReadError">ReadError</a></dt></div><div><dt>DecompressionFailure</dt></div><div><dt>EndOfStream <a href="std.http.Client.Connection.html#std.http.Client.Connection.ReadError">ReadError</a></dt></div><div><dt>HttpChunkInvalid <a href="std.http.protocol.HeadersParser.html#std.http.protocol.HeadersParser.ReadError">ReadError</a></dt></div><div><dt>HttpHeadersOversize <a href="std.http.protocol.HeadersParser.html#std.http.protocol.HeadersParser.CheckCompleteHeadError">CheckCompleteHeadError</a></dt></div><div><dt>InvalidTrailers</dt></div><div><dt>TlsAlert <a href="std.http.Client.Connection.html#std.http.Client.Connection.ReadError">ReadError</a></dt></div><div><dt>TlsFailure <a href="std.http.Client.Connection.html#std.http.Client.Connection.ReadError">ReadError</a></dt></div><div><dt>UnexpectedReadFailure <a href="std.http.Client.Connection.html#std.http.Client.Connection.ReadError">ReadError</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.Request.ReadError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadError = <a href="std.http.Client.Request.html#std.http.Client.Request.TransferReadError">TransferReadError</a> || <a href="std.http.protocol.html">proto</a>.<a href="std.http.protocol.HeadersParser.html">HeadersParser</a>.<a href="std.http.protocol.HeadersParser.html#std.http.protocol.HeadersParser.CheckCompleteHeadError">CheckCompleteHeadError</a> ||
    <span class="tok-kw">error</span>{ DecompressionFailure, InvalidTrailers }</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.Request.WriteError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">WriteError</span><a href="#src.zig-std.http.Client.Request.WriteError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>ConnectionResetByPeer <a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a></dt></div><div><dt>MessageTooLong</dt></div><div><dt>NotWriteable</dt></div><div><dt>UnexpectedWriteFailure <a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.Request.WriteError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteError = <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a> || <span class="tok-kw">error</span>{ NotWriteable, MessageTooLong }</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.Request.FinishError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FinishError</span><a href="#src.zig-std.http.Client.Request.FinishError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>ConnectionResetByPeer <a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a></dt></div><div><dt>MessageNotCompleted</dt></div><div><dt>MessageTooLong <a href="std.http.Client.Request.html#std.http.Client.Request.WriteError">WriteError</a></dt></div><div><dt>NotWriteable <a href="std.http.Client.Request.html#std.http.Client.Request.WriteError">WriteError</a></dt></div><div><dt>UnexpectedWriteFailure <a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.Request.FinishError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FinishError = <a href="std.http.Client.Request.html#std.http.Client.Request.WriteError">WriteError</a> || <span class="tok-kw">error</span>{MessageNotCompleted}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.http.Client.Request.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.http.Client.Request.deinit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Frees all resources associated with the request.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>req: *<a href="std.http.Client.Request.html">Request</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.Request.deinit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (req.connection) |connection| {
        <span class="tok-kw">if</span> (!req.response.parser.done) {<span class="tok-comment">
            // If the response wasn't fully read, then we need to close the connection.
            </span>connection.closing = <span class="tok-null">true</span>;
        }
        req.client.connection_pool.release(req.client.allocator, connection);
    }
    req.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.Request.send" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">send</span><a href="#src.zig-std.http.Client.Request.send">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">send</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.SendError">SendError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Send the HTTP request headers to the server.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>req: *<a href="std.http.Client.Request.html">Request</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.Request.send">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">send</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.SendError">SendError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!req.method.requestHasBody() <span class="tok-kw">and</span> req.transfer_encoding != .none)
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedTransferEncoding;

    <span class="tok-kw">const</span> connection = req.connection.?;
    <span class="tok-kw">const</span> w = connection.writer();

    <span class="tok-kw">try</span> req.method.write(w);
    <span class="tok-kw">try</span> w.writeByte(<span class="tok-str">' '</span>);

    <span class="tok-kw">if</span> (req.method == .CONNECT) {
        <span class="tok-kw">try</span> req.uri.writeToStream(.{ .authority = <span class="tok-null">true</span> }, w);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> req.uri.writeToStream(.{
            .scheme = connection.proxied,
            .authentication = connection.proxied,
            .authority = connection.proxied,
            .path = <span class="tok-null">true</span>,
            .query = <span class="tok-null">true</span>,
        }, w);
    }
    <span class="tok-kw">try</span> w.writeByte(<span class="tok-str">' '</span>);
    <span class="tok-kw">try</span> w.writeAll(<span class="tok-builtin">@tagName</span>(req.version));
    <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);

    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.emitOverridableHeader">emitOverridableHeader</a>(<span class="tok-str">&quot;host: &quot;</span>, req.headers.host, w)) {
        <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;host: &quot;</span>);
        <span class="tok-kw">try</span> req.uri.writeToStream(.{ .authority = <span class="tok-null">true</span> }, w);
        <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);
    }

    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.emitOverridableHeader">emitOverridableHeader</a>(<span class="tok-str">&quot;authorization: &quot;</span>, req.headers.authorization, w)) {
        <span class="tok-kw">if</span> (req.uri.user != <span class="tok-null">null</span> <span class="tok-kw">or</span> req.uri.password != <span class="tok-null">null</span>) {
            <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;authorization: &quot;</span>);
            <span class="tok-kw">const</span> authorization = <span class="tok-kw">try</span> connection.allocWriteBuffer(
                <span class="tok-builtin">@intCast</span>(<a href="std.http.Client.basic_authorization.html">basic_authorization</a>.<a href="std.http.Client.basic_authorization.html#std.http.Client.basic_authorization.valueLengthFromUri">valueLengthFromUri</a>(req.uri)),
            );
            <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.http.Client.basic_authorization.html">basic_authorization</a>.<a href="std.http.Client.basic_authorization.html#std.http.Client.basic_authorization.value">value</a>(req.uri, authorization).len == authorization.len);
            <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);
        }
    }

    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.emitOverridableHeader">emitOverridableHeader</a>(<span class="tok-str">&quot;user-agent: &quot;</span>, req.headers.user_agent, w)) {
        <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;user-agent: zig/&quot;</span>);
        <span class="tok-kw">try</span> w.writeAll(<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_version_string">zig_version_string</a>);
        <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot; (std.http)\r\n&quot;</span>);
    }

    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.emitOverridableHeader">emitOverridableHeader</a>(<span class="tok-str">&quot;connection: &quot;</span>, req.headers.connection, w)) {
        <span class="tok-kw">if</span> (req.keep_alive) {
            <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;connection: keep-alive\r\n&quot;</span>);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;connection: close\r\n&quot;</span>);
        }
    }

    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.emitOverridableHeader">emitOverridableHeader</a>(<span class="tok-str">&quot;accept-encoding: &quot;</span>, req.headers.accept_encoding, w)) {<span class="tok-comment">
        // https://github.com/ziglang/zig/issues/18937
        //try w.writeAll(&quot;accept-encoding: gzip, deflate, zstd\r\n&quot;);
        </span><span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;accept-encoding: gzip, deflate\r\n&quot;</span>);
    }

    <span class="tok-kw">switch</span> (req.transfer_encoding) {
        .chunked =&gt; <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;transfer-encoding: chunked\r\n&quot;</span>),
        .content_length =&gt; |len| <span class="tok-kw">try</span> w.print(<span class="tok-str">&quot;content-length: {d}\r\n&quot;</span>, .{len}),
        .none =&gt; {},
    }

    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.emitOverridableHeader">emitOverridableHeader</a>(<span class="tok-str">&quot;content-type: &quot;</span>, req.headers.content_type, w)) {<span class="tok-comment">
        // The default is to omit content-type if not provided because
        // &quot;application/octet-stream&quot; is redundant.
    </span>}

    <span class="tok-kw">for</span> (req.extra_headers) |header| {
        <a href="std.debug.html#std.debug.assert">assert</a>(header.name.len != <span class="tok-number">0</span>);

        <span class="tok-kw">try</span> w.writeAll(header.name);
        <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;: &quot;</span>);
        <span class="tok-kw">try</span> w.writeAll(header.value);
        <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);
    }

    <span class="tok-kw">if</span> (connection.proxied) proxy: {
        <span class="tok-kw">const</span> proxy = <span class="tok-kw">switch</span> (connection.protocol) {
            .plain =&gt; req.client.http_proxy,
            .tls =&gt; req.client.https_proxy,
        } <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :proxy;

        <span class="tok-kw">const</span> authorization = proxy.authorization <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :proxy;
        <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;proxy-authorization: &quot;</span>);
        <span class="tok-kw">try</span> w.writeAll(authorization);
        <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);
    }

    <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);

    <span class="tok-kw">try</span> connection.flush();
}</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.Request.wait" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">wait</span><a href="#src.zig-std.http.Client.Request.wait">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">wait</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.WaitError">WaitError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Waits for a response from the server and parses any headers that are sent.
This function will block until the final response is received.</p>
<p>If handling redirects and the request has no payload, then this
function will automatically follow redirects. If a request payload is
present, then this function will error with
error.RedirectRequiresResend.</p>
<p>Must be called after <code>send</code> and, if any data was written to the request
body, then also after <code>finish</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>req: *<a href="std.http.Client.Request.html">Request</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.Request.wait">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">wait</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.WaitError">WaitError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment">
        // This while loop is for handling redirects, which means the request's
        // connection may be different than the previous iteration. However, it
        // is still guaranteed to be non-null with each iteration of this loop.
        </span><span class="tok-kw">const</span> connection = req.connection.?;

        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment"> // read headers
            </span><span class="tok-kw">try</span> connection.fill();

            <span class="tok-kw">const</span> nchecked = <span class="tok-kw">try</span> req.response.parser.checkCompleteHead(connection.peek());
            connection.drop(<span class="tok-builtin">@intCast</span>(nchecked));

            <span class="tok-kw">if</span> (req.response.parser.state.isContent()) <span class="tok-kw">break</span>;
        }

        <span class="tok-kw">try</span> req.response.parse(req.response.parser.get());

        <span class="tok-kw">if</span> (req.response.status == .@&quot;continue&quot;) {<span class="tok-comment">
            // We're done parsing the continue response; reset to prepare
            // for the real response.
            </span>req.response.parser.done = <span class="tok-null">true</span>;
            req.response.parser.reset();

            <span class="tok-kw">if</span> (req.handle_continue)
                <span class="tok-kw">continue</span>;

            <span class="tok-kw">return</span>;<span class="tok-comment"> // we're not handling the 100-continue
        </span>}<span class="tok-comment">

        // we're switching protocols, so this connection is no longer doing http
        </span><span class="tok-kw">if</span> (req.method == .CONNECT <span class="tok-kw">and</span> req.response.status.class() == .success) {
            connection.closing = <span class="tok-null">false</span>;
            req.response.parser.done = <span class="tok-null">true</span>;
            <span class="tok-kw">return</span>;<span class="tok-comment"> // the connection is not HTTP past this point
        </span>}

        connection.closing = !req.response.keep_alive <span class="tok-kw">or</span> !req.keep_alive;<span class="tok-comment">

        // Any response to a HEAD request and any response with a 1xx
        // (Informational), 204 (No Content), or 304 (Not Modified) status
        // code is always terminated by the first empty line after the
        // header fields, regardless of the header fields present in the
        // message.
        </span><span class="tok-kw">if</span> (req.method == .HEAD <span class="tok-kw">or</span> req.response.status.class() == .informational <span class="tok-kw">or</span>
            req.response.status == .no_content <span class="tok-kw">or</span> req.response.status == .not_modified)
        {
            req.response.parser.done = <span class="tok-null">true</span>;
            <span class="tok-kw">return</span>;<span class="tok-comment"> // The response is empty; no further setup or redirection is necessary.
        </span>}

        <span class="tok-kw">switch</span> (req.response.transfer_encoding) {
            .none =&gt; {
                <span class="tok-kw">if</span> (req.response.content_length) |cl| {
                    req.response.parser.next_chunk_length = cl;

                    <span class="tok-kw">if</span> (cl == <span class="tok-number">0</span>) req.response.parser.done = <span class="tok-null">true</span>;
                } <span class="tok-kw">else</span> {<span class="tok-comment">
                    // read until the connection is closed
                    </span>req.response.parser.next_chunk_length = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u64</span>);
                }
            },
            .chunked =&gt; {
                req.response.parser.next_chunk_length = <span class="tok-number">0</span>;
                req.response.parser.state = .chunk_head_size;
            },
        }

        <span class="tok-kw">if</span> (req.response.status.class() == .redirect <span class="tok-kw">and</span> req.redirect_behavior != .unhandled) {<span class="tok-comment">
            // skip the body of the redirect response, this will at least
            // leave the connection in a known good state.
            </span>req.response.skip = <span class="tok-null">true</span>;
            <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> req.transferRead(&amp;.{}) == <span class="tok-number">0</span>);<span class="tok-comment"> // we're skipping, no buffer is necessary

            </span><span class="tok-kw">if</span> (req.redirect_behavior == .not_allowed) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TooManyHttpRedirects;

            <span class="tok-kw">const</span> location = req.response.location <span class="tok-kw">orelse</span>
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpRedirectLocationMissing;<span class="tok-comment">

            // This mutates the beginning of header_bytes_buffer and uses that
            // for the backing memory of the returned Uri.
            </span><span class="tok-kw">try</span> req.redirect(req.uri.resolve_inplace(
                location,
                &amp;req.response.parser.header_bytes_buffer,
            ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.UnexpectedCharacter,
                <span class="tok-kw">error</span>.InvalidFormat,
                <span class="tok-kw">error</span>.InvalidPort,
                =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpRedirectLocationInvalid,
                <span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersOversize,
            });
            <span class="tok-kw">try</span> req.send();
        } <span class="tok-kw">else</span> {
            req.response.skip = <span class="tok-null">false</span>;
            <span class="tok-kw">if</span> (!req.response.parser.done) {
                <span class="tok-kw">switch</span> (req.response.transfer_compression) {
                    .identity =&gt; req.response.compression = .none,
                    .compress, .@&quot;x-compress&quot; =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CompressionUnsupported,
                    .deflate =&gt; req.response.compression = .{
                        .deflate = <a href="std.html">std</a>.<a href="std.compress.html">compress</a>.<a href="std.compress.zlib.html">zlib</a>.<a href="std.compress.zlib.html#std.compress.zlib.decompressor">decompressor</a>(req.transferReader()),
                    },
                    .gzip, .@&quot;x-gzip&quot; =&gt; req.response.compression = .{
                        .gzip = <a href="std.html">std</a>.<a href="std.compress.html">compress</a>.<a href="std.compress.gzip.html">gzip</a>.<a href="std.compress.gzip.html#std.compress.gzip.decompressor">decompressor</a>(req.transferReader()),
                    },<span class="tok-comment">
                    // https://github.com/ziglang/zig/issues/18937
                    //.zstd =&gt; req.response.compression = .{
                    //    .zstd = std.compress.zstd.decompressStream(req.client.allocator, req.transferReader()),
                    //},
                    </span>.zstd =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CompressionUnsupported,
                }
            }

            <span class="tok-kw">break</span>;
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.Request.reader" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reader</span><a href="#src.zig-std.http.Client.Request.reader">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reader</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.Reader">Reader</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>req: *<a href="std.http.Client.Request.html">Request</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.Request.reader">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reader</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.Reader">Reader</a> {
    <span class="tok-kw">return</span> .{ .context = req };
}</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.Request.read" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">read</span><a href="#src.zig-std.http.Client.Request.read">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(req: *<a href="std.http.Client.Request.html">Request</a>, buffer: []<span class="tok-type">u8</span>) <a href="std.http.Client.Request.html#std.http.Client.Request.ReadError">ReadError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Reads data from the response body. Must be called after <code>wait</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>req: *<a href="std.http.Client.Request.html">Request</a></code></pre></div><div><pre><code>buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.Request.read">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(req: *<a href="std.http.Client.Request.html">Request</a>, buffer: []<span class="tok-type">u8</span>) <a href="std.http.Client.Request.html#std.http.Client.Request.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> out_index = <span class="tok-kw">switch</span> (req.response.compression) {
        .deflate =&gt; |*deflate| deflate.read(buffer) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DecompressionFailure,
        .gzip =&gt; |*gzip| gzip.read(buffer) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DecompressionFailure,<span class="tok-comment">
        // https://github.com/ziglang/zig/issues/18937
        //.zstd =&gt; |*zstd| zstd.read(buffer) catch return error.DecompressionFailure,
        </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> req.transferRead(buffer),
    };
    <span class="tok-kw">if</span> (out_index &gt; <span class="tok-number">0</span>) <span class="tok-kw">return</span> out_index;

    <span class="tok-kw">while</span> (!req.response.parser.state.isContent()) {<span class="tok-comment"> // read trailing headers
        </span><span class="tok-kw">try</span> req.connection.?.fill();

        <span class="tok-kw">const</span> nchecked = <span class="tok-kw">try</span> req.response.parser.checkCompleteHead(req.connection.?.peek());
        req.connection.?.drop(<span class="tok-builtin">@intCast</span>(nchecked));
    }

    <span class="tok-kw">return</span> <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.Request.readAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readAll</span><a href="#src.zig-std.http.Client.Request.readAll">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readAll</span>(req: *<a href="std.http.Client.Request.html">Request</a>, buffer: []<span class="tok-type">u8</span>) !<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Reads data from the response body. Must be called after <code>wait</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>req: *<a href="std.http.Client.Request.html">Request</a></code></pre></div><div><pre><code>buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.Request.readAll">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readAll</span>(req: *<a href="std.http.Client.Request.html">Request</a>, buffer: []<span class="tok-type">u8</span>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (index &lt; buffer.len) {
        <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.read">read</a>(req, buffer[index..]);
        <span class="tok-kw">if</span> (amt == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
        index += amt;
    }
    <span class="tok-kw">return</span> index;
}</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.Request.writer" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writer</span><a href="#src.zig-std.http.Client.Request.writer">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.Writer">Writer</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>req: *<a href="std.http.Client.Request.html">Request</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.Request.writer">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.Writer">Writer</a> {
    <span class="tok-kw">return</span> .{ .context = req };
}</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.Request.write" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">write</span><a href="#src.zig-std.http.Client.Request.write">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(req: *<a href="std.http.Client.Request.html">Request</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.http.Client.Request.html#std.http.Client.Request.WriteError">WriteError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Write <code>bytes</code> to the server. The <code>transfer_encoding</code> field determines how data will be sent.
Must be called after <code>send</code> and before <code>finish</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>req: *<a href="std.http.Client.Request.html">Request</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.Request.write">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(req: *<a href="std.http.Client.Request.html">Request</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.http.Client.Request.html#std.http.Client.Request.WriteError">WriteError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">switch</span> (req.transfer_encoding) {
        .chunked =&gt; {
            <span class="tok-kw">if</span> (bytes.len &gt; <span class="tok-number">0</span>) {
                <span class="tok-kw">try</span> req.connection.?.writer().print(<span class="tok-str">&quot;{x}\r\n&quot;</span>, .{bytes.len});
                <span class="tok-kw">try</span> req.connection.?.writer().writeAll(bytes);
                <span class="tok-kw">try</span> req.connection.?.writer().writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);
            }

            <span class="tok-kw">return</span> bytes.len;
        },
        .content_length =&gt; |*len| {
            <span class="tok-kw">if</span> (len.* &lt; bytes.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MessageTooLong;

            <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> req.connection.?.write(bytes);
            len.* -= amt;
            <span class="tok-kw">return</span> amt;
        },
        .none =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotWriteable,
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.Request.writeAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeAll</span><a href="#src.zig-std.http.Client.Request.writeAll">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAll</span>(req: *<a href="std.http.Client.Request.html">Request</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.http.Client.Request.html#std.http.Client.Request.WriteError">WriteError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Write <code>bytes</code> to the server. The <code>transfer_encoding</code> field determines how data will be sent.
Must be called after <code>send</code> and before <code>finish</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>req: *<a href="std.http.Client.Request.html">Request</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.Request.writeAll">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAll</span>(req: *<a href="std.http.Client.Request.html">Request</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.http.Client.Request.html#std.http.Client.Request.WriteError">WriteError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (index &lt; bytes.len) {
        index += <span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.write">write</a>(req, bytes[index..]);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.http.Client.Request.finish" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">finish</span><a href="#src.zig-std.http.Client.Request.finish">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finish</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.FinishError">FinishError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Finish the body of a request. This notifies the server that you have no more data to send.
Must be called after <code>send</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>req: *<a href="std.http.Client.Request.html">Request</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Client.Request.finish">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finish</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.FinishError">FinishError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (req.transfer_encoding) {
        .chunked =&gt; <span class="tok-kw">try</span> req.connection.?.writer().writeAll(<span class="tok-str">&quot;0\r\n\r\n&quot;</span>),
        .content_length =&gt; |len| <span class="tok-kw">if</span> (len != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MessageNotCompleted,
        .none =&gt; {},
    }

    <span class="tok-kw">try</span> req.connection.?.flush();
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.http.Client.Request">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Request = <span class="tok-kw">struct</span> {
    uri: <a href="std.Uri.html">Uri</a>,
    client: *<a href="std.http.Client.html">Client</a>,
    <span class="tok-comment">/// This is null when the connection is released.</span>
    connection: ?*<a href="std.http.Client.Connection.html">Connection</a>,
    keep_alive: <span class="tok-type">bool</span>,

    method: <a href="std.http.html">http</a>.<a href="std.http.Method.html">Method</a>,
    version: <a href="std.http.html">http</a>.<a href="std.http.Version.html">Version</a> = .@&quot;HTTP/1.1&quot;,
    transfer_encoding: <a href="std.http.Client.RequestTransfer.html">RequestTransfer</a>,
    redirect_behavior: <a href="std.http.Client.Request.RedirectBehavior.html">RedirectBehavior</a>,

    <span class="tok-comment">/// Whether the request should handle a 100-continue response before sending the request body.</span>
    handle_continue: <span class="tok-type">bool</span>,

    <span class="tok-comment">/// The response associated with this request.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// This field is undefined until `wait` is called.</span>
    response: <a href="std.http.Client.Response.html">Response</a>,

    <span class="tok-comment">/// Standard headers that have default, but overridable, behavior.</span>
    headers: <a href="std.http.Client.Request.Headers.html">Headers</a>,

    <span class="tok-comment">/// These headers are kept including when following a redirect to a</span>
    <span class="tok-comment">/// different domain.</span>
    <span class="tok-comment">/// Externally-owned; must outlive the Request.</span>
    extra_headers: []<span class="tok-kw">const</span> <a href="std.http.html">http</a>.<a href="std.http.Header.html">Header</a>,

    <span class="tok-comment">/// These headers are stripped when following a redirect to a different</span>
    <span class="tok-comment">/// domain.</span>
    <span class="tok-comment">/// Externally-owned; must outlive the Request.</span>
    privileged_headers: []<span class="tok-kw">const</span> <a href="std.http.html">http</a>.<a href="std.http.Header.html">Header</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Headers = <span class="tok-kw">struct</span> {
        host: <a href="std.http.Client.Request.Headers.Value.html">Value</a> = .default,
        authorization: <a href="std.http.Client.Request.Headers.Value.html">Value</a> = .default,
        user_agent: <a href="std.http.Client.Request.Headers.Value.html">Value</a> = .default,
        connection: <a href="std.http.Client.Request.Headers.Value.html">Value</a> = .default,
        accept_encoding: <a href="std.http.Client.Request.Headers.Value.html">Value</a> = .default,
        content_type: <a href="std.http.Client.Request.Headers.Value.html">Value</a> = .default,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Value = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
            default,
            omit,
            override: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        };
    };

    <span class="tok-comment">/// Any value other than `not_allowed` or `unhandled` means that integer represents</span>
    <span class="tok-comment">/// how many remaining redirects are allowed.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> RedirectBehavior = <span class="tok-kw">enum</span>(<span class="tok-type">u16</span>) {
        <span class="tok-comment">/// The next redirect will cause an error.</span>
        not_allowed = <span class="tok-number">0</span>,
        <span class="tok-comment">/// Redirects are passed to the client to analyze the redirect response</span>
        <span class="tok-comment">/// directly.</span>
        unhandled = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u16</span>),
        _,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subtractOne</span>(rb: *<a href="std.http.Client.Request.RedirectBehavior.html">RedirectBehavior</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">switch</span> (rb.*) {
                .not_allowed =&gt; <span class="tok-kw">unreachable</span>,
                .unhandled =&gt; <span class="tok-kw">unreachable</span>,
                _ =&gt; rb.* = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(rb.*) - <span class="tok-number">1</span>),
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remaining</span>(rb: <a href="std.http.Client.Request.RedirectBehavior.html">RedirectBehavior</a>) <span class="tok-type">u16</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(rb != .unhandled);
            <span class="tok-kw">return</span> <span class="tok-builtin">@intFromEnum</span>(rb);
        }
    };

    <span class="tok-comment">/// Frees all resources associated with the request.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (req.connection) |connection| {
            <span class="tok-kw">if</span> (!req.response.parser.done) {<span class="tok-comment">
                // If the response wasn't fully read, then we need to close the connection.
                </span>connection.closing = <span class="tok-null">true</span>;
            }
            req.client.connection_pool.release(req.client.allocator, connection);
        }
        req.* = <span class="tok-null">undefined</span>;
    }<span class="tok-comment">

    // This function must deallocate all resources associated with the request,
    // or keep those which will be used.
    // This needs to be kept in sync with deinit and request.
    </span><span class="tok-kw">fn</span> <span class="tok-fn">redirect</span>(req: *<a href="std.http.Client.Request.html">Request</a>, uri: <a href="std.Uri.html">Uri</a>) !<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(req.response.parser.done);

        req.client.connection_pool.release(req.client.allocator, req.connection.?);
        req.connection = <span class="tok-null">null</span>;

        <span class="tok-kw">var</span> server_header: <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.FixedBufferAllocator.html">FixedBufferAllocator</a> = .init(req.response.parser.header_bytes_buffer);
        <span class="tok-kw">defer</span> req.response.parser.header_bytes_buffer = server_header.buffer[server_header.end_index..];
        <span class="tok-kw">const</span> protocol, <span class="tok-kw">const</span> valid_uri = <span class="tok-kw">try</span> validateUri(uri, server_header.allocator());

        <span class="tok-kw">const</span> new_host = valid_uri.host.?.raw;
        <span class="tok-kw">const</span> prev_host = req.uri.host.?.raw;
        <span class="tok-kw">const</span> keep_privileged_headers =
            <a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(valid_uri.scheme, req.uri.scheme) <span class="tok-kw">and</span>
            <a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.endsWithIgnoreCase">endsWithIgnoreCase</a>(new_host, prev_host) <span class="tok-kw">and</span>
            (new_host.len == prev_host.len <span class="tok-kw">or</span> new_host[new_host.len - prev_host.len - <span class="tok-number">1</span>] == <span class="tok-str">'.'</span>);
        <span class="tok-kw">if</span> (!keep_privileged_headers) {<span class="tok-comment">
            // When redirecting to a different domain, strip privileged headers.
            </span>req.privileged_headers = &amp;.{};
        }

        <span class="tok-kw">if</span> (<span class="tok-kw">switch</span> (req.response.status) {
            .see_other =&gt; <span class="tok-null">true</span>,
            .moved_permanently, .found =&gt; req.method == .POST,
            <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
        }) {<span class="tok-comment">
            // A redirect to a GET must change the method and remove the body.
            </span>req.method = .GET;
            req.transfer_encoding = .none;
            req.headers.content_type = .omit;
        }

        <span class="tok-kw">if</span> (req.transfer_encoding != .none) {<span class="tok-comment">
            // The request body has already been sent. The request is
            // still in a valid state, but the redirect must be handled
            // manually.
            </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.RedirectRequiresResend;
        }

        req.uri = valid_uri;
        req.connection = <span class="tok-kw">try</span> req.client.connect(new_host, <a href="std.http.Client.html#std.http.Client.uriPort">uriPort</a>(valid_uri, protocol), protocol);
        req.redirect_behavior.subtractOne();
        req.response.parser.reset();

        req.response = .{
            .version = <span class="tok-null">undefined</span>,
            .status = <span class="tok-null">undefined</span>,
            .reason = <span class="tok-null">undefined</span>,
            .keep_alive = <span class="tok-null">undefined</span>,
            .parser = req.response.parser,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SendError = <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a> || <span class="tok-kw">error</span>{ InvalidContentLength, UnsupportedTransferEncoding };

    <span class="tok-comment">/// Send the HTTP request headers to the server.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">send</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.SendError">SendError</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (!req.method.requestHasBody() <span class="tok-kw">and</span> req.transfer_encoding != .none)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedTransferEncoding;

        <span class="tok-kw">const</span> connection = req.connection.?;
        <span class="tok-kw">const</span> w = connection.writer();

        <span class="tok-kw">try</span> req.method.write(w);
        <span class="tok-kw">try</span> w.writeByte(<span class="tok-str">' '</span>);

        <span class="tok-kw">if</span> (req.method == .CONNECT) {
            <span class="tok-kw">try</span> req.uri.writeToStream(.{ .authority = <span class="tok-null">true</span> }, w);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> req.uri.writeToStream(.{
                .scheme = connection.proxied,
                .authentication = connection.proxied,
                .authority = connection.proxied,
                .path = <span class="tok-null">true</span>,
                .query = <span class="tok-null">true</span>,
            }, w);
        }
        <span class="tok-kw">try</span> w.writeByte(<span class="tok-str">' '</span>);
        <span class="tok-kw">try</span> w.writeAll(<span class="tok-builtin">@tagName</span>(req.version));
        <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);

        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.emitOverridableHeader">emitOverridableHeader</a>(<span class="tok-str">&quot;host: &quot;</span>, req.headers.host, w)) {
            <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;host: &quot;</span>);
            <span class="tok-kw">try</span> req.uri.writeToStream(.{ .authority = <span class="tok-null">true</span> }, w);
            <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);
        }

        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.emitOverridableHeader">emitOverridableHeader</a>(<span class="tok-str">&quot;authorization: &quot;</span>, req.headers.authorization, w)) {
            <span class="tok-kw">if</span> (req.uri.user != <span class="tok-null">null</span> <span class="tok-kw">or</span> req.uri.password != <span class="tok-null">null</span>) {
                <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;authorization: &quot;</span>);
                <span class="tok-kw">const</span> authorization = <span class="tok-kw">try</span> connection.allocWriteBuffer(
                    <span class="tok-builtin">@intCast</span>(<a href="std.http.Client.basic_authorization.html">basic_authorization</a>.<a href="std.http.Client.basic_authorization.html#std.http.Client.basic_authorization.valueLengthFromUri">valueLengthFromUri</a>(req.uri)),
                );
                <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.http.Client.basic_authorization.html">basic_authorization</a>.<a href="std.http.Client.basic_authorization.html#std.http.Client.basic_authorization.value">value</a>(req.uri, authorization).len == authorization.len);
                <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);
            }
        }

        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.emitOverridableHeader">emitOverridableHeader</a>(<span class="tok-str">&quot;user-agent: &quot;</span>, req.headers.user_agent, w)) {
            <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;user-agent: zig/&quot;</span>);
            <span class="tok-kw">try</span> w.writeAll(<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_version_string">zig_version_string</a>);
            <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot; (std.http)\r\n&quot;</span>);
        }

        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.emitOverridableHeader">emitOverridableHeader</a>(<span class="tok-str">&quot;connection: &quot;</span>, req.headers.connection, w)) {
            <span class="tok-kw">if</span> (req.keep_alive) {
                <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;connection: keep-alive\r\n&quot;</span>);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;connection: close\r\n&quot;</span>);
            }
        }

        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.emitOverridableHeader">emitOverridableHeader</a>(<span class="tok-str">&quot;accept-encoding: &quot;</span>, req.headers.accept_encoding, w)) {<span class="tok-comment">
            // https://github.com/ziglang/zig/issues/18937
            //try w.writeAll(&quot;accept-encoding: gzip, deflate, zstd\r\n&quot;);
            </span><span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;accept-encoding: gzip, deflate\r\n&quot;</span>);
        }

        <span class="tok-kw">switch</span> (req.transfer_encoding) {
            .chunked =&gt; <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;transfer-encoding: chunked\r\n&quot;</span>),
            .content_length =&gt; |len| <span class="tok-kw">try</span> w.print(<span class="tok-str">&quot;content-length: {d}\r\n&quot;</span>, .{len}),
            .none =&gt; {},
        }

        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.emitOverridableHeader">emitOverridableHeader</a>(<span class="tok-str">&quot;content-type: &quot;</span>, req.headers.content_type, w)) {<span class="tok-comment">
            // The default is to omit content-type if not provided because
            // &quot;application/octet-stream&quot; is redundant.
        </span>}

        <span class="tok-kw">for</span> (req.extra_headers) |header| {
            <a href="std.debug.html#std.debug.assert">assert</a>(header.name.len != <span class="tok-number">0</span>);

            <span class="tok-kw">try</span> w.writeAll(header.name);
            <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;: &quot;</span>);
            <span class="tok-kw">try</span> w.writeAll(header.value);
            <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);
        }

        <span class="tok-kw">if</span> (connection.proxied) proxy: {
            <span class="tok-kw">const</span> proxy = <span class="tok-kw">switch</span> (connection.protocol) {
                .plain =&gt; req.client.http_proxy,
                .tls =&gt; req.client.https_proxy,
            } <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :proxy;

            <span class="tok-kw">const</span> authorization = proxy.authorization <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :proxy;
            <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;proxy-authorization: &quot;</span>);
            <span class="tok-kw">try</span> w.writeAll(authorization);
            <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);
        }

        <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);

        <span class="tok-kw">try</span> connection.flush();
    }

    <span class="tok-comment">/// Returns true if the default behavior is required, otherwise handles</span>
    <span class="tok-comment">/// writing (or not writing) the header.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">emitOverridableHeader</span>(prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, v: <a href="std.http.Client.Request.Headers.html">Headers</a>.<a href="std.http.Client.Request.Headers.Value.html">Value</a>, w: <span class="tok-kw">anytype</span>) !<span class="tok-type">bool</span> {
        <span class="tok-kw">switch</span> (v) {
            .default =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,
            .omit =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
            .override =&gt; |x| {
                <span class="tok-kw">try</span> w.writeAll(prefix);
                <span class="tok-kw">try</span> w.writeAll(x);
                <span class="tok-kw">try</span> w.writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);
                <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            },
        }
    }

    <span class="tok-kw">const</span> TransferReadError = <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.html#std.http.Client.Connection.ReadError">ReadError</a> || <a href="std.http.protocol.html">proto</a>.<a href="std.http.protocol.HeadersParser.html">HeadersParser</a>.<a href="std.http.protocol.HeadersParser.html#std.http.protocol.HeadersParser.ReadError">ReadError</a>;

    <span class="tok-kw">const</span> TransferReader = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericReader">Reader</a>(*<a href="std.http.Client.Request.html">Request</a>, <a href="std.http.Client.Request.html#std.http.Client.Request.TransferReadError">TransferReadError</a>, <a href="std.http.Client.Request.html#std.http.Client.Request.transferRead">transferRead</a>);

    <span class="tok-kw">fn</span> <span class="tok-fn">transferReader</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.TransferReader">TransferReader</a> {
        <span class="tok-kw">return</span> .{ .context = req };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">transferRead</span>(req: *<a href="std.http.Client.Request.html">Request</a>, buf: []<span class="tok-type">u8</span>) <a href="std.http.Client.Request.html#std.http.Client.Request.TransferReadError">TransferReadError</a>!<span class="tok-type">usize</span> {
        <span class="tok-kw">if</span> (req.response.parser.done) <span class="tok-kw">return</span> <span class="tok-number">0</span>;

        <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (index == <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> req.response.parser.read(req.connection.?, buf[index..], req.response.skip);
            <span class="tok-kw">if</span> (amt == <span class="tok-number">0</span> <span class="tok-kw">and</span> req.response.parser.done) <span class="tok-kw">break</span>;
            index += amt;
        }

        <span class="tok-kw">return</span> index;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> WaitError = <a href="std.http.Client.html#std.http.Client.RequestError">RequestError</a> || <a href="std.http.Client.Request.html#std.http.Client.Request.SendError">SendError</a> || <a href="std.http.Client.Request.html#std.http.Client.Request.TransferReadError">TransferReadError</a> ||
        <a href="std.http.protocol.html">proto</a>.<a href="std.http.protocol.HeadersParser.html">HeadersParser</a>.<a href="std.http.protocol.HeadersParser.html#std.http.protocol.HeadersParser.CheckCompleteHeadError">CheckCompleteHeadError</a> || <a href="std.http.Client.Response.html">Response</a>.<a href="std.http.Client.Response.html#std.http.Client.Response.ParseError">ParseError</a> ||
        <span class="tok-kw">error</span>{
            TooManyHttpRedirects,
            RedirectRequiresResend,
            HttpRedirectLocationMissing,
            HttpRedirectLocationInvalid,
            CompressionInitializationFailed,
            CompressionUnsupported,
        };

    <span class="tok-comment">/// Waits for a response from the server and parses any headers that are sent.</span>
    <span class="tok-comment">/// This function will block until the final response is received.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If handling redirects and the request has no payload, then this</span>
    <span class="tok-comment">/// function will automatically follow redirects. If a request payload is</span>
    <span class="tok-comment">/// present, then this function will error with</span>
    <span class="tok-comment">/// error.RedirectRequiresResend.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Must be called after `send` and, if any data was written to the request</span>
    <span class="tok-comment">/// body, then also after `finish`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">wait</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.WaitError">WaitError</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment">
            // This while loop is for handling redirects, which means the request's
            // connection may be different than the previous iteration. However, it
            // is still guaranteed to be non-null with each iteration of this loop.
            </span><span class="tok-kw">const</span> connection = req.connection.?;

            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment"> // read headers
                </span><span class="tok-kw">try</span> connection.fill();

                <span class="tok-kw">const</span> nchecked = <span class="tok-kw">try</span> req.response.parser.checkCompleteHead(connection.peek());
                connection.drop(<span class="tok-builtin">@intCast</span>(nchecked));

                <span class="tok-kw">if</span> (req.response.parser.state.isContent()) <span class="tok-kw">break</span>;
            }

            <span class="tok-kw">try</span> req.response.parse(req.response.parser.get());

            <span class="tok-kw">if</span> (req.response.status == .@&quot;continue&quot;) {<span class="tok-comment">
                // We're done parsing the continue response; reset to prepare
                // for the real response.
                </span>req.response.parser.done = <span class="tok-null">true</span>;
                req.response.parser.reset();

                <span class="tok-kw">if</span> (req.handle_continue)
                    <span class="tok-kw">continue</span>;

                <span class="tok-kw">return</span>;<span class="tok-comment"> // we're not handling the 100-continue
            </span>}<span class="tok-comment">

            // we're switching protocols, so this connection is no longer doing http
            </span><span class="tok-kw">if</span> (req.method == .CONNECT <span class="tok-kw">and</span> req.response.status.class() == .success) {
                connection.closing = <span class="tok-null">false</span>;
                req.response.parser.done = <span class="tok-null">true</span>;
                <span class="tok-kw">return</span>;<span class="tok-comment"> // the connection is not HTTP past this point
            </span>}

            connection.closing = !req.response.keep_alive <span class="tok-kw">or</span> !req.keep_alive;<span class="tok-comment">

            // Any response to a HEAD request and any response with a 1xx
            // (Informational), 204 (No Content), or 304 (Not Modified) status
            // code is always terminated by the first empty line after the
            // header fields, regardless of the header fields present in the
            // message.
            </span><span class="tok-kw">if</span> (req.method == .HEAD <span class="tok-kw">or</span> req.response.status.class() == .informational <span class="tok-kw">or</span>
                req.response.status == .no_content <span class="tok-kw">or</span> req.response.status == .not_modified)
            {
                req.response.parser.done = <span class="tok-null">true</span>;
                <span class="tok-kw">return</span>;<span class="tok-comment"> // The response is empty; no further setup or redirection is necessary.
            </span>}

            <span class="tok-kw">switch</span> (req.response.transfer_encoding) {
                .none =&gt; {
                    <span class="tok-kw">if</span> (req.response.content_length) |cl| {
                        req.response.parser.next_chunk_length = cl;

                        <span class="tok-kw">if</span> (cl == <span class="tok-number">0</span>) req.response.parser.done = <span class="tok-null">true</span>;
                    } <span class="tok-kw">else</span> {<span class="tok-comment">
                        // read until the connection is closed
                        </span>req.response.parser.next_chunk_length = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u64</span>);
                    }
                },
                .chunked =&gt; {
                    req.response.parser.next_chunk_length = <span class="tok-number">0</span>;
                    req.response.parser.state = .chunk_head_size;
                },
            }

            <span class="tok-kw">if</span> (req.response.status.class() == .redirect <span class="tok-kw">and</span> req.redirect_behavior != .unhandled) {<span class="tok-comment">
                // skip the body of the redirect response, this will at least
                // leave the connection in a known good state.
                </span>req.response.skip = <span class="tok-null">true</span>;
                <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> req.transferRead(&amp;.{}) == <span class="tok-number">0</span>);<span class="tok-comment"> // we're skipping, no buffer is necessary

                </span><span class="tok-kw">if</span> (req.redirect_behavior == .not_allowed) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TooManyHttpRedirects;

                <span class="tok-kw">const</span> location = req.response.location <span class="tok-kw">orelse</span>
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpRedirectLocationMissing;<span class="tok-comment">

                // This mutates the beginning of header_bytes_buffer and uses that
                // for the backing memory of the returned Uri.
                </span><span class="tok-kw">try</span> req.redirect(req.uri.resolve_inplace(
                    location,
                    &amp;req.response.parser.header_bytes_buffer,
                ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.UnexpectedCharacter,
                    <span class="tok-kw">error</span>.InvalidFormat,
                    <span class="tok-kw">error</span>.InvalidPort,
                    =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpRedirectLocationInvalid,
                    <span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersOversize,
                });
                <span class="tok-kw">try</span> req.send();
            } <span class="tok-kw">else</span> {
                req.response.skip = <span class="tok-null">false</span>;
                <span class="tok-kw">if</span> (!req.response.parser.done) {
                    <span class="tok-kw">switch</span> (req.response.transfer_compression) {
                        .identity =&gt; req.response.compression = .none,
                        .compress, .@&quot;x-compress&quot; =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CompressionUnsupported,
                        .deflate =&gt; req.response.compression = .{
                            .deflate = <a href="std.html">std</a>.<a href="std.compress.html">compress</a>.<a href="std.compress.zlib.html">zlib</a>.<a href="std.compress.zlib.html#std.compress.zlib.decompressor">decompressor</a>(req.transferReader()),
                        },
                        .gzip, .@&quot;x-gzip&quot; =&gt; req.response.compression = .{
                            .gzip = <a href="std.html">std</a>.<a href="std.compress.html">compress</a>.<a href="std.compress.gzip.html">gzip</a>.<a href="std.compress.gzip.html#std.compress.gzip.decompressor">decompressor</a>(req.transferReader()),
                        },<span class="tok-comment">
                        // https://github.com/ziglang/zig/issues/18937
                        //.zstd =&gt; req.response.compression = .{
                        //    .zstd = std.compress.zstd.decompressStream(req.client.allocator, req.transferReader()),
                        //},
                        </span>.zstd =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CompressionUnsupported,
                    }
                }

                <span class="tok-kw">break</span>;
            }
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadError = <a href="std.http.Client.Request.html#std.http.Client.Request.TransferReadError">TransferReadError</a> || <a href="std.http.protocol.html">proto</a>.<a href="std.http.protocol.HeadersParser.html">HeadersParser</a>.<a href="std.http.protocol.HeadersParser.html#std.http.protocol.HeadersParser.CheckCompleteHeadError">CheckCompleteHeadError</a> ||
        <span class="tok-kw">error</span>{ DecompressionFailure, InvalidTrailers };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Reader = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericReader">Reader</a>(*<a href="std.http.Client.Request.html">Request</a>, <a href="std.http.Client.Request.html#std.http.Client.Request.ReadError">ReadError</a>, <a href="std.http.Client.Request.html#std.http.Client.Request.read">read</a>);

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reader</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.Reader">Reader</a> {
        <span class="tok-kw">return</span> .{ .context = req };
    }

    <span class="tok-comment">/// Reads data from the response body. Must be called after `wait`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(req: *<a href="std.http.Client.Request.html">Request</a>, buffer: []<span class="tok-type">u8</span>) <a href="std.http.Client.Request.html#std.http.Client.Request.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
        <span class="tok-kw">const</span> out_index = <span class="tok-kw">switch</span> (req.response.compression) {
            .deflate =&gt; |*deflate| deflate.read(buffer) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DecompressionFailure,
            .gzip =&gt; |*gzip| gzip.read(buffer) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DecompressionFailure,<span class="tok-comment">
            // https://github.com/ziglang/zig/issues/18937
            //.zstd =&gt; |*zstd| zstd.read(buffer) catch return error.DecompressionFailure,
            </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> req.transferRead(buffer),
        };
        <span class="tok-kw">if</span> (out_index &gt; <span class="tok-number">0</span>) <span class="tok-kw">return</span> out_index;

        <span class="tok-kw">while</span> (!req.response.parser.state.isContent()) {<span class="tok-comment"> // read trailing headers
            </span><span class="tok-kw">try</span> req.connection.?.fill();

            <span class="tok-kw">const</span> nchecked = <span class="tok-kw">try</span> req.response.parser.checkCompleteHead(req.connection.?.peek());
            req.connection.?.drop(<span class="tok-builtin">@intCast</span>(nchecked));
        }

        <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    }

    <span class="tok-comment">/// Reads data from the response body. Must be called after `wait`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readAll</span>(req: *<a href="std.http.Client.Request.html">Request</a>, buffer: []<span class="tok-type">u8</span>) !<span class="tok-type">usize</span> {
        <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (index &lt; buffer.len) {
            <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.read">read</a>(req, buffer[index..]);
            <span class="tok-kw">if</span> (amt == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            index += amt;
        }
        <span class="tok-kw">return</span> index;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteError = <a href="std.http.Client.Connection.html">Connection</a>.<a href="std.http.Client.Connection.html#std.http.Client.Connection.WriteError">WriteError</a> || <span class="tok-kw">error</span>{ NotWriteable, MessageTooLong };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.http.Client.Request.html">Request</a>, <a href="std.http.Client.Request.html#std.http.Client.Request.WriteError">WriteError</a>, <a href="std.http.Client.Request.html#std.http.Client.Request.write">write</a>);

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.Writer">Writer</a> {
        <span class="tok-kw">return</span> .{ .context = req };
    }

    <span class="tok-comment">/// Write `bytes` to the server. The `transfer_encoding` field determines how data will be sent.</span>
    <span class="tok-comment">/// Must be called after `send` and before `finish`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(req: *<a href="std.http.Client.Request.html">Request</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.http.Client.Request.html#std.http.Client.Request.WriteError">WriteError</a>!<span class="tok-type">usize</span> {
        <span class="tok-kw">switch</span> (req.transfer_encoding) {
            .chunked =&gt; {
                <span class="tok-kw">if</span> (bytes.len &gt; <span class="tok-number">0</span>) {
                    <span class="tok-kw">try</span> req.connection.?.writer().print(<span class="tok-str">&quot;{x}\r\n&quot;</span>, .{bytes.len});
                    <span class="tok-kw">try</span> req.connection.?.writer().writeAll(bytes);
                    <span class="tok-kw">try</span> req.connection.?.writer().writeAll(<span class="tok-str">&quot;\r\n&quot;</span>);
                }

                <span class="tok-kw">return</span> bytes.len;
            },
            .content_length =&gt; |*len| {
                <span class="tok-kw">if</span> (len.* &lt; bytes.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MessageTooLong;

                <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> req.connection.?.write(bytes);
                len.* -= amt;
                <span class="tok-kw">return</span> amt;
            },
            .none =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotWriteable,
        }
    }

    <span class="tok-comment">/// Write `bytes` to the server. The `transfer_encoding` field determines how data will be sent.</span>
    <span class="tok-comment">/// Must be called after `send` and before `finish`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAll</span>(req: *<a href="std.http.Client.Request.html">Request</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.http.Client.Request.html#std.http.Client.Request.WriteError">WriteError</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (index &lt; bytes.len) {
            index += <span class="tok-kw">try</span> <a href="std.http.Client.Request.html#std.http.Client.Request.write">write</a>(req, bytes[index..]);
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FinishError = <a href="std.http.Client.Request.html#std.http.Client.Request.WriteError">WriteError</a> || <span class="tok-kw">error</span>{MessageNotCompleted};

    <span class="tok-comment">/// Finish the body of a request. This notifies the server that you have no more data to send.</span>
    <span class="tok-comment">/// Must be called after `send`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finish</span>(req: *<a href="std.http.Client.Request.html">Request</a>) <a href="std.http.Client.Request.html#std.http.Client.Request.FinishError">FinishError</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">switch</span> (req.transfer_encoding) {
            .chunked =&gt; <span class="tok-kw">try</span> req.connection.?.writer().writeAll(<span class="tok-str">&quot;0\r\n\r\n&quot;</span>),
            .content_length =&gt; |len| <span class="tok-kw">if</span> (len != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MessageNotCompleted,
            .none =&gt; {},
        }

        <span class="tok-kw">try</span> req.connection.?.flush();
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
