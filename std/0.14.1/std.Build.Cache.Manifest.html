<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">Build</a></li><li><a href="std.Build.Cache.html" class="">Cache</a></li><li><a href="std.Build.Cache.Manifest.html" class="active">Manifest</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.Build.Cache.Manifest" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.Build.Cache.Manifest</span><a href="#src.zig-std.Build.Cache.Manifest">[src]</a></h1><div class="sectNamespaces"><h2 class="sectionHeader">Namespaces</h2><ul class="listNamespaces columns"><li><a href="std.Build.Cache.Manifest.FilesContext.html">std.Build.Cache.Manifest.FilesContext</a></li></ul></div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.Build.Cache.Manifest.Diagnostic.html">std.Build.Cache.Manifest.Diagnostic</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.Build.Cache.Manifest.Files" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Files</span><a href="#src.zig-std.Build.Cache.Manifest.Files">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.Files">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Files = <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a>(<a href="std.Build.Cache.File.html">File</a>, <span class="tok-type">void</span>, <a href="std.Build.Cache.Manifest.FilesContext.html">FilesContext</a>, <span class="tok-null">false</span>)</code></pre></details></div></div></div></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>cache: *<a href="std.Build.Cache.html">Cache</a></code></pre></div><div><pre><code>hash: <a href="std.Build.Cache.HashHelper.html">HashHelper</a></code></pre><div class="fieldDocs"><p>Current state for incremental hashing.</p>
</div></div><div><pre><code>manifest_file: ?<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>manifest_dirty: <span class="tok-type">bool</span></code></pre></div><div><pre><code>want_shared_lock: <span class="tok-type">bool</span> = <span class="tok-null">true</span></code></pre><div class="fieldDocs"><p>Set this flag to true before calling hit() in order to indicate that
upon a cache hit, the code using the cache will not modify the files
within the cache directory. This allows multiple processes to utilize
the same cache directory at the same time.</p>
</div></div><div><pre><code>have_exclusive_lock: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre></div><div><pre><code>want_refresh_timestamp: <span class="tok-type">bool</span> = <span class="tok-null">true</span></code></pre></div><div><pre><code>files: <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.Files">Files</a> = .{}</code></pre></div><div><pre><code>hex_digest: <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a></code></pre></div><div><pre><code>diagnostic: <a href="std.Build.Cache.Manifest.Diagnostic.html">Diagnostic</a> = .none</code></pre></div><div><pre><code>recent_problematic_timestamp: <span class="tok-type">i128</span> = <span class="tok-number">0</span></code></pre><div class="fieldDocs"><p>Keeps track of the last time we performed a file system write to observe
what time the file system thinks it is, according to its own granularity.</p>
</div></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.Build.Cache.Manifest.HitError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">HitError</span><a href="#src.zig-std.Build.Cache.Manifest.HitError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>CacheCheckFailed</dt><dd><p>Unable to check the cache for a reason that has been recorded into
the <code>diagnostic</code> field.</p>
</dd></div><div><dt>InvalidFormat</dt><dd><p>A cache manifest file exists however it could not be parsed.</p>
</dd></div><div><dt>OutOfMemory</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.HitError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> HitError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// Unable to check the cache for a reason that has been recorded into</span>
    <span class="tok-comment">/// the `diagnostic` field.</span>
    CacheCheckFailed,
    <span class="tok-comment">/// A cache manifest file exists however it could not be parsed.</span>
    InvalidFormat,
    OutOfMemory,
}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.Build.Cache.Manifest.addFilePath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addFilePath</span><a href="#src.zig-std.Build.Cache.Manifest.addFilePath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePath</span>(m: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, file_path: <a href="std.Build.Cache.Path.html">Path</a>, max_file_size: ?<span class="tok-type">usize</span>) !<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Add a file as a dependency of process being cached. When <code>hit</code> is
called, the file's contents will be checked to ensure that it matches
the contents from previous times.</p>
<p>Max file size will be used to determine the amount of space the file contents
are allowed to take up in memory. If max_file_size is null, then the contents
will not be loaded into memory.</p>
<p>Returns the index of the entry in the <code>files</code> array list. You can use it
to access the contents of the file after calling <code>hit()</code> like so:</p>
<pre><code>var file_contents = cache_hash.files.keys()[file_index].contents.?;
</code></pre>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>m: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div><div><pre><code>file_path: <a href="std.Build.Cache.Path.html">Path</a></code></pre></div><div><pre><code>max_file_size: ?<span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.addFilePath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePath</span>(m: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, file_path: <a href="std.Build.Cache.Path.html">Path</a>, max_file_size: ?<span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.addOpenedFile">addOpenedFile</a>(m, file_path, <span class="tok-null">null</span>, max_file_size);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.Manifest.addOpenedFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addOpenedFile</span><a href="#src.zig-std.Build.Cache.Manifest.addOpenedFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOpenedFile</span>(m: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, path: <a href="std.Build.Cache.Path.html">Path</a>, handle: ?<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>, max_file_size: ?<span class="tok-type">usize</span>) !<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Same as <code>addFilePath</code> except the file has already been opened.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>m: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div><div><pre><code>path: <a href="std.Build.Cache.Path.html">Path</a></code></pre></div><div><pre><code>handle: ?<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>max_file_size: ?<span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.addOpenedFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOpenedFile</span>(m: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, path: <a href="std.Build.Cache.Path.html">Path</a>, handle: ?<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>, max_file_size: ?<span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> gpa = m.cache.gpa;
    <span class="tok-kw">try</span> m.files.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">const</span> resolved_path = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.resolve">resolve</a>(gpa, &amp;.{
        path.root_dir.path <span class="tok-kw">orelse</span> <span class="tok-str">&quot;.&quot;</span>,
        path.subPathOrDot(),
    });
    <span class="tok-kw">errdefer</span> gpa.free(resolved_path);
    <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> m.cache.findPrefixResolved(resolved_path);
    <span class="tok-kw">return</span> <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.addFileInner">addFileInner</a>(m, prefixed_path, handle, max_file_size);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.Manifest.addFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addFile</span><a href="#src.zig-std.Build.Cache.Manifest.addFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFile</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_file_size: ?<span class="tok-type">usize</span>) !<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Deprecated; use <code>addFilePath</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div><div><pre><code>file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>max_file_size: ?<span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.addFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFile</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_file_size: ?<span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file == <span class="tok-null">null</span>);

    <span class="tok-kw">const</span> gpa = self.cache.gpa;
    <span class="tok-kw">try</span> self.files.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefix(file_path);
    <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);

    <span class="tok-kw">return</span> <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.addFileInner">addFileInner</a>(self, prefixed_path, <span class="tok-null">null</span>, max_file_size);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.Manifest.addOptionalFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addOptionalFile</span><a href="#src.zig-std.Build.Cache.Manifest.addOptionalFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptionalFile</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, optional_file_path: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deprecated, use <code>addOptionalFilePath</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div><div><pre><code>optional_file_path: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.addOptionalFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptionalFile</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, optional_file_path: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    self.hash.add(optional_file_path != <span class="tok-null">null</span>);
    <span class="tok-kw">const</span> file_path = optional_file_path <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
    _ = <span class="tok-kw">try</span> self.addFile(file_path, <span class="tok-null">null</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.Manifest.addOptionalFilePath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addOptionalFilePath</span><a href="#src.zig-std.Build.Cache.Manifest.addOptionalFilePath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptionalFilePath</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, optional_file_path: ?<a href="std.Build.Cache.Path.html">Path</a>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div><div><pre><code>optional_file_path: ?<a href="std.Build.Cache.Path.html">Path</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.addOptionalFilePath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptionalFilePath</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, optional_file_path: ?<a href="std.Build.Cache.Path.html">Path</a>) !<span class="tok-type">void</span> {
    self.hash.add(optional_file_path != <span class="tok-null">null</span>);
    <span class="tok-kw">const</span> file_path = optional_file_path <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
    _ = <span class="tok-kw">try</span> self.addFilePath(file_path, <span class="tok-null">null</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.Manifest.addListOfFiles" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addListOfFiles</span><a href="#src.zig-std.Build.Cache.Manifest.addListOfFiles">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addListOfFiles</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, list_of_files: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div><div><pre><code>list_of_files: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.addListOfFiles">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addListOfFiles</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, list_of_files: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    self.hash.add(list_of_files.len);
    <span class="tok-kw">for</span> (list_of_files) |file_path| {
        _ = <span class="tok-kw">try</span> self.addFile(file_path, <span class="tok-null">null</span>);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.Manifest.addDepFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addDepFile</span><a href="#src.zig-std.Build.Cache.Manifest.addDepFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addDepFile</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, dep_file_basename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div><div><pre><code>dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>dep_file_basename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.addDepFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addDepFile</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, dep_file_basename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file == <span class="tok-null">null</span>);
    <span class="tok-kw">return</span> self.addDepFileMaybePost(dir, dep_file_basename);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.Manifest.hit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">hit</span><a href="#src.zig-std.Build.Cache.Manifest.hit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hit</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.HitError">HitError</a>!<span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Check the cache to see if the input exists in it. If it exists, returns <code>true</code>.
A hex encoding of its hash is available by calling <code>final</code>.</p>
<p>This function will also acquire an exclusive lock to the manifest file. This means
that a process holding a Manifest will block any other process attempting to
acquire the lock. If <code>want_shared_lock</code> is <code>true</code>, a cache hit guarantees the
manifest file to be locked in shared mode, and a cache miss guarantees the manifest
file to be locked in exclusive mode.</p>
<p>The lock on the manifest file is released when <code>deinit</code> is called. As another
option, one may call <code>toOwnedLock</code> to obtain a smaller object which can represent
the lock. <code>deinit</code> is safe to call whether or not <code>toOwnedLock</code> has been called.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.hit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hit</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.HitError">HitError</a>!<span class="tok-type">bool</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file == <span class="tok-null">null</span>);

    self.diagnostic = .none;

    <span class="tok-kw">const</span> ext = <span class="tok-str">&quot;.txt&quot;</span>;
    <span class="tok-kw">var</span> manifest_file_path: [<a href="std.Build.Cache.html#std.Build.Cache.hex_digest_len">hex_digest_len</a> + ext.len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">var</span> bin_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a> = <span class="tok-null">undefined</span>;
    self.hash.hasher.final(&amp;bin_digest);

    self.hex_digest = <a href="std.Build.Cache.html#std.Build.Cache.binToHex">binToHex</a>(bin_digest);

    <span class="tok-builtin">@memcpy</span>(manifest_file_path[<span class="tok-number">0</span>..self.hex_digest.len], &amp;self.hex_digest);
    manifest_file_path[<a href="std.Build.Cache.html#std.Build.Cache.hex_digest_len">hex_digest_len</a>..][<span class="tok-number">0</span>..ext.len].* = ext.*;<span class="tok-comment">

    // We'll try to open the cache with an exclusive lock, but if that would block
    // and `want_shared_lock` is set, a shared lock might be sufficient, so we'll
    // open with a shared lock instead.
    </span><span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">if</span> (self.cache.manifest_dir.createFile(&amp;manifest_file_path, .{
            .read = <span class="tok-null">true</span>,
            .truncate = <span class="tok-null">false</span>,
            .lock = .exclusive,
            .lock_nonblocking = self.want_shared_lock,
        })) |manifest_file| {
            self.manifest_file = manifest_file;
            self.have_exclusive_lock = <span class="tok-null">true</span>;
            <span class="tok-kw">break</span>;
        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; {
                self.manifest_file = self.cache.manifest_dir.openFile(&amp;manifest_file_path, .{
                    .mode = .read_write,
                    .lock = .shared,
                }) <span class="tok-kw">catch</span> |e| {
                    self.diagnostic = .{ .manifest_create = e };
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                };
                <span class="tok-kw">break</span>;
            },
            <span class="tok-kw">error</span>.FileNotFound =&gt; {<span class="tok-comment">
                // There are no dir components, so the only possibility
                // should be that the directory behind the handle has been
                // deleted, however we have observed on macOS two processes
                // racing to do openat() with O_CREAT manifest in ENOENT.
                //
                // As a workaround, we retry with exclusive=true which
                // disambiguates by returning EEXIST, indicating original
                // failure was a race, or ENOENT, indicating deletion of
                // the directory of our open handle.
                </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> != .macos) {
                    self.diagnostic = .{ .manifest_create = <span class="tok-kw">error</span>.FileNotFound };
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                }

                <span class="tok-kw">if</span> (self.cache.manifest_dir.createFile(&amp;manifest_file_path, .{
                    .read = <span class="tok-null">true</span>,
                    .truncate = <span class="tok-null">false</span>,
                    .lock = .exclusive,
                    .lock_nonblocking = self.want_shared_lock,
                    .exclusive = <span class="tok-null">true</span>,
                })) |manifest_file| {
                    self.manifest_file = manifest_file;
                    self.have_exclusive_lock = <span class="tok-null">true</span>;
                    <span class="tok-kw">break</span>;
                } <span class="tok-kw">else</span> |excl_err| <span class="tok-kw">switch</span> (excl_err) {
                    <span class="tok-kw">error</span>.WouldBlock, <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">continue</span>,
                    <span class="tok-kw">error</span>.FileNotFound =&gt; {
                        self.diagnostic = .{ .manifest_create = <span class="tok-kw">error</span>.FileNotFound };
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                    },
                    <span class="tok-kw">else</span> =&gt; |e| {
                        self.diagnostic = .{ .manifest_create = e };
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                    },
                }
            },
            <span class="tok-kw">else</span> =&gt; |e| {
                self.diagnostic = .{ .manifest_create = e };
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
            },
        }
    }

    self.want_refresh_timestamp = <span class="tok-null">true</span>;

    <span class="tok-kw">const</span> input_file_count = self.files.entries.len;<span class="tok-comment">

    // We're going to construct a second hash. Its input will begin with the digest we've
    // already computed (`bin_digest`), and then it'll have the digests of each input file,
    // including &quot;post&quot; files (see `addFilePost`). If this is a hit, we learn the set of &quot;post&quot;
    // files from the manifest on disk. If this is a miss, we'll learn those from future calls
    // to `addFilePost` etc. As such, the state of `self.hash.hasher` after this function
    // depends on whether this is a hit or a miss.
    //
    // If we return `true` indicating a cache hit, then `self.hash.hasher` must already include
    // the digests of the &quot;post&quot; files, so the caller can call `final`. Otherwise, on a cache
    // miss, `self.hash.hasher` will include the digests of all non-&quot;post&quot; files -- that is,
    // the ones we've already been told about. The rest will be discovered through calls to
    // `addFilePost` etc, which will update the hasher. After all files are added, the user can
    // use `final`, and will at some point `writeManifest` the file list to disk.

    </span>self.hash.hasher = <a href="std.Build.Cache.html#std.Build.Cache.hasher_init">hasher_init</a>;
    self.hash.hasher.update(&amp;bin_digest);

    hit: {
        <span class="tok-kw">const</span> file_digests_populated: <span class="tok-type">usize</span> = digests: {
            <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.hitWithCurrentLock()) {
                .hit =&gt; <span class="tok-kw">break</span> :hit,
                .miss =&gt; |m| <span class="tok-kw">if</span> (!<span class="tok-kw">try</span> self.upgradeToExclusiveLock()) {
                    <span class="tok-kw">break</span> :digests m.file_digests_populated;
                },
            }<span class="tok-comment">
            // We've just had a miss with the shared lock, and upgraded to an exclusive lock. Someone
            // else might have modified the digest, so we need to check again before deciding to miss.
            // Before trying again, we must reset `self.hash.hasher` and `self.files`.
            // This is basically just the first half of `unhit`.
            </span>self.hash.hasher = <a href="std.Build.Cache.html#std.Build.Cache.hasher_init">hasher_init</a>;
            self.hash.hasher.update(&amp;bin_digest);
            <span class="tok-kw">while</span> (self.files.count() != input_file_count) {
                <span class="tok-kw">var</span> file = self.files.pop().?;
                file.key.deinit(self.cache.gpa);
            }<span class="tok-comment">
            // Also, seek the file back to the start.
            </span>self.manifest_file.?.seekTo(<span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| {
                self.diagnostic = .{ .manifest_seek = err };
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
            };

            <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.hitWithCurrentLock()) {
                .hit =&gt; <span class="tok-kw">break</span> :hit,
                .miss =&gt; |m| <span class="tok-kw">break</span> :digests m.file_digests_populated,
            }
        };<span class="tok-comment">

        // This is a guaranteed cache miss. We're almost ready to return `false`, but there's a
        // little bookkeeping to do first. The first `file_digests_populated` entries in `files`
        // have their `bin_digest` populated; there may be some left in `input_file_count` which
        // we'll need to populate ourselves. Other than that, this is basically `unhit`.
        </span>self.manifest_dirty = <span class="tok-null">true</span>;
        self.hash.hasher = <a href="std.Build.Cache.html#std.Build.Cache.hasher_init">hasher_init</a>;
        self.hash.hasher.update(&amp;bin_digest);
        <span class="tok-kw">while</span> (self.files.count() != input_file_count) {
            <span class="tok-kw">var</span> file = self.files.pop().?;
            file.key.deinit(self.cache.gpa);
        }
        <span class="tok-kw">for</span> (self.files.keys(), <span class="tok-number">0</span>..) |*file, idx| {
            <span class="tok-kw">if</span> (idx &lt; file_digests_populated) {<span class="tok-comment">
                // `bin_digest` is already populated by `hitWithCurrentLock`, so we can use it directly.
                </span>self.hash.hasher.update(&amp;file.bin_digest);
            } <span class="tok-kw">else</span> {
                self.populateFileHash(file) <span class="tok-kw">catch</span> |err| {
                    self.diagnostic = .{ .file_hash = .{
                        .file_index = idx,
                        .err = err,
                    } };
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                };
            }
        }
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }

    <span class="tok-kw">if</span> (self.want_shared_lock) {
        self.downgradeToSharedLock() <span class="tok-kw">catch</span> |err| {
            self.diagnostic = .{ .manifest_lock = err };
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
        };
    }

    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.Manifest.unhit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unhit</span><a href="#src.zig-std.Build.Cache.Manifest.unhit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unhit</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, bin_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a>, input_file_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Reset <code>self.hash.hasher</code> to the state it should be in after <code>hit</code> returns <code>false</code>.
The hasher contains the original input digest, and all original input file digests (i.e.
not including post files).
Assumes that <code>bin_digest</code> is populated for all files up to <code>input_file_count</code>. As such,
this is not necessarily safe to call within <code>hit</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div><div><pre><code>bin_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a></code></pre></div><div><pre><code>input_file_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.unhit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unhit</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, bin_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a>, input_file_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {<span class="tok-comment">
    // Reset the hash.
    </span>self.hash.hasher = <a href="std.Build.Cache.html#std.Build.Cache.hasher_init">hasher_init</a>;
    self.hash.hasher.update(&amp;bin_digest);<span class="tok-comment">

    // Remove files not in the initial hash.
    </span><span class="tok-kw">while</span> (self.files.count() != input_file_count) {
        <span class="tok-kw">var</span> file = self.files.pop().?;
        file.key.deinit(self.cache.gpa);
    }

    <span class="tok-kw">for</span> (self.files.keys()) |file| {
        self.hash.hasher.update(&amp;file.bin_digest);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.Manifest.addFilePostFetch" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addFilePostFetch</span><a href="#src.zig-std.Build.Cache.Manifest.addFilePostFetch">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePostFetch</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_file_size: <span class="tok-type">usize</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Add a file as a dependency of process being cached, after the initial hash has been
calculated. This is useful for processes that don't know all the files that
are depended on ahead of time. For example, a source file that can import other files
will need to be recompiled if the imported file is changed.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div><div><pre><code>file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>max_file_size: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.addFilePostFetch">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePostFetch</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_file_size: <span class="tok-type">usize</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file != <span class="tok-null">null</span>);

    <span class="tok-kw">const</span> gpa = self.cache.gpa;
    <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefix(file_path);
    <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);

    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.files.getOrPutAdapted(gpa, prefixed_path, <a href="std.Build.Cache.Manifest.FilesAdapter.html">FilesAdapter</a>{});
    <span class="tok-kw">errdefer</span> _ = self.files.pop();

    <span class="tok-kw">if</span> (gop.found_existing) {
        gpa.free(prefixed_path.sub_path);
        <span class="tok-kw">return</span> gop.key_ptr.contents.?;
    }

    gop.key_ptr.* = .{
        .prefixed_path = prefixed_path,
        .max_file_size = max_file_size,
        .stat = <span class="tok-null">undefined</span>,
        .bin_digest = <span class="tok-null">undefined</span>,
        .contents = <span class="tok-null">null</span>,
    };

    self.files.lockPointers();
    <span class="tok-kw">defer</span> self.files.unlockPointers();

    <span class="tok-kw">try</span> self.populateFileHash(gop.key_ptr);
    <span class="tok-kw">return</span> gop.key_ptr.contents.?;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.Manifest.addFilePost" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addFilePost</span><a href="#src.zig-std.Build.Cache.Manifest.addFilePost">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePost</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Add a file as a dependency of process being cached, after the initial hash has been
calculated.</p>
<p>This is useful for processes that don't know the all the files that are
depended on ahead of time. For example, a source file that can import
other files will need to be recompiled if the imported file is changed.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div><div><pre><code>file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.addFilePost">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePost</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file != <span class="tok-null">null</span>);

    <span class="tok-kw">const</span> gpa = self.cache.gpa;
    <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefix(file_path);
    <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);

    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.files.getOrPutAdapted(gpa, prefixed_path, <a href="std.Build.Cache.Manifest.FilesAdapter.html">FilesAdapter</a>{});
    <span class="tok-kw">errdefer</span> _ = self.files.pop();

    <span class="tok-kw">if</span> (gop.found_existing) {
        gpa.free(prefixed_path.sub_path);
        <span class="tok-kw">return</span>;
    }

    gop.key_ptr.* = .{
        .prefixed_path = prefixed_path,
        .max_file_size = <span class="tok-null">null</span>,
        .handle = <span class="tok-null">null</span>,
        .stat = <span class="tok-null">undefined</span>,
        .bin_digest = <span class="tok-null">undefined</span>,
        .contents = <span class="tok-null">null</span>,
    };

    self.files.lockPointers();
    <span class="tok-kw">defer</span> self.files.unlockPointers();

    <span class="tok-kw">try</span> self.populateFileHash(gop.key_ptr);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.Manifest.addFilePostContents" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addFilePostContents</span><a href="#src.zig-std.Build.Cache.Manifest.addFilePostContents">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePostContents</span>( self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, resolved_path: []<span class="tok-type">u8</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, stat: <a href="std.Build.Cache.File.html">File</a>.<a href="std.Build.Cache.File.Stat.html">Stat</a>, ) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Like <code>addFilePost</code> but when the file contents have already been loaded from disk.
On success, cache takes ownership of <code>resolved_path</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div><div><pre><code>resolved_path: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>stat: <a href="std.Build.Cache.File.html">File</a>.<a href="std.Build.Cache.File.Stat.html">Stat</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.addFilePostContents">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePostContents</span>(
    self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>,
    resolved_path: []<span class="tok-type">u8</span>,
    bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    stat: <a href="std.Build.Cache.File.html">File</a>.<a href="std.Build.Cache.File.Stat.html">Stat</a>,
) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file != <span class="tok-null">null</span>);
    <span class="tok-kw">const</span> gpa = self.cache.gpa;

    <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefixResolved(resolved_path);
    <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);

    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.files.getOrPutAdapted(gpa, prefixed_path, <a href="std.Build.Cache.Manifest.FilesAdapter.html">FilesAdapter</a>{});
    <span class="tok-kw">errdefer</span> _ = self.files.pop();

    <span class="tok-kw">if</span> (gop.found_existing) {
        gpa.free(prefixed_path.sub_path);
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">const</span> new_file = gop.key_ptr;

    new_file.* = .{
        .prefixed_path = prefixed_path,
        .max_file_size = <span class="tok-null">null</span>,
        .handle = <span class="tok-null">null</span>,
        .stat = stat,
        .bin_digest = <span class="tok-null">undefined</span>,
        .contents = <span class="tok-null">null</span>,
    };

    <span class="tok-kw">if</span> (self.isProblematicTimestamp(new_file.stat.mtime)) {<span class="tok-comment">
        // The actual file has an unreliable timestamp, force it to be hashed
        </span>new_file.stat.mtime = <span class="tok-number">0</span>;
        new_file.stat.inode = <span class="tok-number">0</span>;
    }

    {
        <span class="tok-kw">var</span> hasher = <a href="std.Build.Cache.html#std.Build.Cache.hasher_init">hasher_init</a>;
        hasher.update(bytes);
        hasher.final(&amp;new_file.bin_digest);
    }

    self.hash.hasher.update(&amp;new_file.bin_digest);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.Manifest.addDepFilePost" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addDepFilePost</span><a href="#src.zig-std.Build.Cache.Manifest.addDepFilePost">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addDepFilePost</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, dep_file_basename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div><div><pre><code>dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>dep_file_basename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.addDepFilePost">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addDepFilePost</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, dep_file_basename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file != <span class="tok-null">null</span>);
    <span class="tok-kw">return</span> self.addDepFileMaybePost(dir, dep_file_basename);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.Manifest.finalBin" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">finalBin</span><a href="#src.zig-std.Build.Cache.Manifest.finalBin">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finalBin</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a></code></pre></div><div class="tldDocs"><p>Returns a binary hash of the inputs.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.finalBin">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finalBin</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file != <span class="tok-null">null</span>);<span class="tok-comment">

    // We don't close the manifest file yet, because we want to
    // keep it locked until the API user is done using it.
    // We also don't write out the manifest yet, because until
    // cache_release is called we still might be working on creating
    // the artifacts to cache.

    </span><span class="tok-kw">var</span> bin_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a> = <span class="tok-null">undefined</span>;
    self.hash.hasher.final(&amp;bin_digest);
    <span class="tok-kw">return</span> bin_digest;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.Manifest.final" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">final</span><a href="#src.zig-std.Build.Cache.Manifest.final">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a></code></pre></div><div class="tldDocs"><p>Returns a hex encoded hash of the inputs.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.final">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a> {
    <span class="tok-kw">const</span> bin_digest = self.finalBin();
    <span class="tok-kw">return</span> <a href="std.Build.Cache.html#std.Build.Cache.binToHex">binToHex</a>(bin_digest);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.Manifest.writeManifest" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeManifest</span><a href="#src.zig-std.Build.Cache.Manifest.writeManifest">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeManifest</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>If <code>want_shared_lock</code> is true, this function automatically downgrades the
lock from exclusive to shared.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.writeManifest">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeManifest</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.have_exclusive_lock);

    <span class="tok-kw">const</span> manifest_file = self.manifest_file.?;
    <span class="tok-kw">if</span> (self.manifest_dirty) {
        self.manifest_dirty = <span class="tok-null">false</span>;

        <span class="tok-kw">var</span> contents = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(self.cache.gpa);
        <span class="tok-kw">defer</span> contents.deinit();

        <span class="tok-kw">const</span> writer = contents.writer();
        <span class="tok-kw">try</span> writer.writeAll(<a href="std.Build.Cache.html#std.Build.Cache.manifest_header">manifest_header</a> ++ <span class="tok-str">&quot;\n&quot;</span>);
        <span class="tok-kw">for</span> (self.files.keys()) |file| {
            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{d} {d} {d} {} {d} {s}\n&quot;</span>, .{
                file.stat.size,
                file.stat.inode,
                file.stat.mtime,
                <a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.fmtSliceHexLower">fmtSliceHexLower</a>(&amp;file.bin_digest),
                file.prefixed_path.prefix,
                file.prefixed_path.sub_path,
            });
        }

        <span class="tok-kw">try</span> manifest_file.setEndPos(contents.items.len);
        <span class="tok-kw">try</span> manifest_file.pwriteAll(contents.items, <span class="tok-number">0</span>);
    }

    <span class="tok-kw">if</span> (self.want_shared_lock) {
        <span class="tok-kw">try</span> self.downgradeToSharedLock();
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.Manifest.toOwnedLock" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toOwnedLock</span><a href="#src.zig-std.Build.Cache.Manifest.toOwnedLock">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedLock</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <a href="std.Build.Cache.Lock.html">Lock</a></code></pre></div><div class="tldDocs"><p>Obtain only the data needed to maintain a lock on the manifest file.
The <code>Manifest</code> remains safe to deinit.
Don't forget to call <code>writeManifest</code> before this!</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.toOwnedLock">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedLock</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <a href="std.Build.Cache.Lock.html">Lock</a> {
    <span class="tok-kw">const</span> lock: <a href="std.Build.Cache.Lock.html">Lock</a> = .{
        .manifest_file = self.manifest_file.?,
    };

    self.manifest_file = <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> lock;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.Manifest.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.Build.Cache.Manifest.deinit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Releases the manifest file and frees any memory the Manifest was using.
<code>Manifest.hit</code> must be called first.
Don't forget to call <code>writeManifest</code> before this!</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.deinit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (self.manifest_file) |file| {
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {<span class="tok-comment">
            // See Lock.release for why this is required on Windows
            </span>file.unlock();
        }

        file.close();
    }
    <span class="tok-kw">for</span> (self.files.keys()) |*file| {
        file.deinit(self.cache.gpa);
    }
    self.files.deinit(self.cache.gpa);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.Manifest.populateFileSystemInputs" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">populateFileSystemInputs</span><a href="#src.zig-std.Build.Cache.Manifest.populateFileSystemInputs">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">populateFileSystemInputs</span>(man: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, buf: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>)) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>man: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div><div><pre><code>buf: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>)</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.populateFileSystemInputs">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">populateFileSystemInputs</span>(man: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, buf: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>)) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(<a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Server.html">Server</a>.<a href="std.zig.Server.Message.html">Message</a>.<a href="std.zig.Server.Message.PathPrefix.html">PathPrefix</a>).@&quot;enum&quot;.fields.len == man.cache.prefixes_len);
    buf.clearRetainingCapacity();
    <span class="tok-kw">const</span> gpa = man.cache.gpa;
    <span class="tok-kw">const</span> files = man.files.keys();
    <span class="tok-kw">if</span> (files.len &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">for</span> (files) |file| {
            <span class="tok-kw">try</span> buf.ensureUnusedCapacity(gpa, file.prefixed_path.sub_path.len + <span class="tok-number">2</span>);
            buf.appendAssumeCapacity(file.prefixed_path.prefix + <span class="tok-number">1</span>);
            buf.appendSliceAssumeCapacity(file.prefixed_path.sub_path);
            buf.appendAssumeCapacity(<span class="tok-number">0</span>);
        }<span class="tok-comment">
        // The null byte is a separator, not a terminator.
        </span>buf.items.len -= <span class="tok-number">1</span>;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.Manifest.populateOtherManifest" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">populateOtherManifest</span><a href="#src.zig-std.Build.Cache.Manifest.populateOtherManifest">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">populateOtherManifest</span>(man: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, other: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, prefix_map: [<span class="tok-number">4</span>]<span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>man: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div><div><pre><code>other: *<a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div><div><pre><code>prefix_map: [<span class="tok-number">4</span>]<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest.populateOtherManifest">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">populateOtherManifest</span>(man: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, other: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, prefix_map: [<span class="tok-number">4</span>]<span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> gpa = other.cache.gpa;
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(<a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Server.html">Server</a>.<a href="std.zig.Server.Message.html">Message</a>.<a href="std.zig.Server.Message.PathPrefix.html">PathPrefix</a>).@&quot;enum&quot;.fields.len == man.cache.prefixes_len);
    <a href="std.debug.html#std.debug.assert">assert</a>(man.cache.prefixes_len == <span class="tok-number">4</span>);
    <span class="tok-kw">for</span> (man.files.keys()) |file| {
        <span class="tok-kw">const</span> prefixed_path: <a href="std.Build.Cache.PrefixedPath.html">PrefixedPath</a> = .{
            .prefix = prefix_map[file.prefixed_path.prefix],
            .sub_path = <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, file.prefixed_path.sub_path),
        };
        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);

        <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> other.files.getOrPutAdapted(gpa, prefixed_path, <a href="std.Build.Cache.Manifest.FilesAdapter.html">FilesAdapter</a>{});
        <span class="tok-kw">errdefer</span> _ = other.files.pop();

        <span class="tok-kw">if</span> (gop.found_existing) {
            gpa.free(prefixed_path.sub_path);
            <span class="tok-kw">continue</span>;
        }

        gop.key_ptr.* = .{
            .prefixed_path = prefixed_path,
            .max_file_size = file.max_file_size,
            .handle = file.handle,
            .stat = file.stat,
            .bin_digest = file.bin_digest,
            .contents = <span class="tok-null">null</span>,
        };

        other.hash.hasher.update(&amp;gop.key_ptr.bin_digest);
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.Build.Cache.Manifest">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Manifest = <span class="tok-kw">struct</span> {
    cache: *<a href="std.Build.Cache.html">Cache</a>,
    <span class="tok-comment">/// Current state for incremental hashing.</span>
    hash: <a href="std.Build.Cache.HashHelper.html">HashHelper</a>,
    manifest_file: ?<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>,
    manifest_dirty: <span class="tok-type">bool</span>,
    <span class="tok-comment">/// Set this flag to true before calling hit() in order to indicate that</span>
    <span class="tok-comment">/// upon a cache hit, the code using the cache will not modify the files</span>
    <span class="tok-comment">/// within the cache directory. This allows multiple processes to utilize</span>
    <span class="tok-comment">/// the same cache directory at the same time.</span>
    want_shared_lock: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,
    have_exclusive_lock: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,<span class="tok-comment">
    // Indicate that we want isProblematicTimestamp to perform a filesystem write in
    // order to obtain a problematic timestamp for the next call. Calls after that
    // will then use the same timestamp, to avoid unnecessary filesystem writes.
    </span>want_refresh_timestamp: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,
    files: <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.Files">Files</a> = .{},
    hex_digest: <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a>,
    diagnostic: <a href="std.Build.Cache.Manifest.Diagnostic.html">Diagnostic</a> = .none,
    <span class="tok-comment">/// Keeps track of the last time we performed a file system write to observe</span>
    <span class="tok-comment">/// what time the file system thinks it is, according to its own granularity.</span>
    recent_problematic_timestamp: <span class="tok-type">i128</span> = <span class="tok-number">0</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Diagnostic = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        none,
        manifest_create: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>,
        manifest_read: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.ReadError">ReadError</a>,
        manifest_lock: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.LockError">LockError</a>,
        manifest_seek: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.SeekError">SeekError</a>,
        file_open: <a href="std.Build.Cache.Manifest.Diagnostic.FileOp.html">FileOp</a>,
        file_stat: <a href="std.Build.Cache.Manifest.Diagnostic.FileOp.html">FileOp</a>,
        file_read: <a href="std.Build.Cache.Manifest.Diagnostic.FileOp.html">FileOp</a>,
        file_hash: <a href="std.Build.Cache.Manifest.Diagnostic.FileOp.html">FileOp</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FileOp = <span class="tok-kw">struct</span> {
            file_index: <span class="tok-type">usize</span>,
            err: <span class="tok-type">anyerror</span>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Files = <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a>(<a href="std.Build.Cache.File.html">File</a>, <span class="tok-type">void</span>, <a href="std.Build.Cache.Manifest.FilesContext.html">FilesContext</a>, <span class="tok-null">false</span>);

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FilesContext = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(fc: <a href="std.Build.Cache.Manifest.FilesContext.html">FilesContext</a>, file: <a href="std.Build.Cache.File.html">File</a>) <span class="tok-type">u32</span> {
            _ = fc;
            <span class="tok-kw">return</span> file.prefixed_path.hash();
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(fc: <a href="std.Build.Cache.Manifest.FilesContext.html">FilesContext</a>, a: <a href="std.Build.Cache.File.html">File</a>, b: <a href="std.Build.Cache.File.html">File</a>, b_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            _ = fc;
            _ = b_index;
            <span class="tok-kw">return</span> a.prefixed_path.eql(b.prefixed_path);
        }
    };

    <span class="tok-kw">const</span> FilesAdapter = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(context: <span class="tok-builtin">@This</span>(), a: <a href="std.Build.Cache.PrefixedPath.html">PrefixedPath</a>, b: <a href="std.Build.Cache.File.html">File</a>, b_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            _ = context;
            _ = b_index;
            <span class="tok-kw">return</span> a.eql(b.prefixed_path);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(context: <span class="tok-builtin">@This</span>(), key: <a href="std.Build.Cache.PrefixedPath.html">PrefixedPath</a>) <span class="tok-type">u32</span> {
            _ = context;
            <span class="tok-kw">return</span> key.hash();
        }
    };

    <span class="tok-comment">/// Add a file as a dependency of process being cached. When `hit` is</span>
    <span class="tok-comment">/// called, the file's contents will be checked to ensure that it matches</span>
    <span class="tok-comment">/// the contents from previous times.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Max file size will be used to determine the amount of space the file contents</span>
    <span class="tok-comment">/// are allowed to take up in memory. If max_file_size is null, then the contents</span>
    <span class="tok-comment">/// will not be loaded into memory.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns the index of the entry in the `files` array list. You can use it</span>
    <span class="tok-comment">/// to access the contents of the file after calling `hit()` like so:</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// ```</span>
    <span class="tok-comment">/// var file_contents = cache_hash.files.keys()[file_index].contents.?;</span>
    <span class="tok-comment">/// ```</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePath</span>(m: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, file_path: <a href="std.Build.Cache.Path.html">Path</a>, max_file_size: ?<span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.addOpenedFile">addOpenedFile</a>(m, file_path, <span class="tok-null">null</span>, max_file_size);
    }

    <span class="tok-comment">/// Same as `addFilePath` except the file has already been opened.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOpenedFile</span>(m: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, path: <a href="std.Build.Cache.Path.html">Path</a>, handle: ?<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>, max_file_size: ?<span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {
        <span class="tok-kw">const</span> gpa = m.cache.gpa;
        <span class="tok-kw">try</span> m.files.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">const</span> resolved_path = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.resolve">resolve</a>(gpa, &amp;.{
            path.root_dir.path <span class="tok-kw">orelse</span> <span class="tok-str">&quot;.&quot;</span>,
            path.subPathOrDot(),
        });
        <span class="tok-kw">errdefer</span> gpa.free(resolved_path);
        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> m.cache.findPrefixResolved(resolved_path);
        <span class="tok-kw">return</span> <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.addFileInner">addFileInner</a>(m, prefixed_path, handle, max_file_size);
    }

    <span class="tok-comment">/// Deprecated; use `addFilePath`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFile</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_file_size: ?<span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file == <span class="tok-null">null</span>);

        <span class="tok-kw">const</span> gpa = self.cache.gpa;
        <span class="tok-kw">try</span> self.files.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefix(file_path);
        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);

        <span class="tok-kw">return</span> <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.addFileInner">addFileInner</a>(self, prefixed_path, <span class="tok-null">null</span>, max_file_size);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addFileInner</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, prefixed_path: <a href="std.Build.Cache.PrefixedPath.html">PrefixedPath</a>, handle: ?<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>, max_file_size: ?<span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
        <span class="tok-kw">const</span> gop = self.files.getOrPutAssumeCapacityAdapted(prefixed_path, <a href="std.Build.Cache.Manifest.FilesAdapter.html">FilesAdapter</a>{});
        <span class="tok-kw">if</span> (gop.found_existing) {
            gop.key_ptr.updateMaxSize(max_file_size);
            gop.key_ptr.updateHandle(handle);
            <span class="tok-kw">return</span> gop.index;
        }
        gop.key_ptr.* = .{
            .prefixed_path = prefixed_path,
            .contents = <span class="tok-null">null</span>,
            .max_file_size = max_file_size,
            .stat = <span class="tok-null">undefined</span>,
            .bin_digest = <span class="tok-null">undefined</span>,
            .handle = handle,
        };

        self.hash.add(prefixed_path.prefix);
        self.hash.addBytes(prefixed_path.sub_path);

        <span class="tok-kw">return</span> gop.index;
    }

    <span class="tok-comment">/// Deprecated, use `addOptionalFilePath`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptionalFile</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, optional_file_path: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        self.hash.add(optional_file_path != <span class="tok-null">null</span>);
        <span class="tok-kw">const</span> file_path = optional_file_path <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
        _ = <span class="tok-kw">try</span> self.addFile(file_path, <span class="tok-null">null</span>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptionalFilePath</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, optional_file_path: ?<a href="std.Build.Cache.Path.html">Path</a>) !<span class="tok-type">void</span> {
        self.hash.add(optional_file_path != <span class="tok-null">null</span>);
        <span class="tok-kw">const</span> file_path = optional_file_path <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
        _ = <span class="tok-kw">try</span> self.addFilePath(file_path, <span class="tok-null">null</span>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addListOfFiles</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, list_of_files: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        self.hash.add(list_of_files.len);
        <span class="tok-kw">for</span> (list_of_files) |file_path| {
            _ = <span class="tok-kw">try</span> self.addFile(file_path, <span class="tok-null">null</span>);
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addDepFile</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, dep_file_basename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file == <span class="tok-null">null</span>);
        <span class="tok-kw">return</span> self.addDepFileMaybePost(dir, dep_file_basename);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> HitError = <span class="tok-kw">error</span>{
        <span class="tok-comment">/// Unable to check the cache for a reason that has been recorded into</span>
        <span class="tok-comment">/// the `diagnostic` field.</span>
        CacheCheckFailed,
        <span class="tok-comment">/// A cache manifest file exists however it could not be parsed.</span>
        InvalidFormat,
        OutOfMemory,
    };

    <span class="tok-comment">/// Check the cache to see if the input exists in it. If it exists, returns `true`.</span>
    <span class="tok-comment">/// A hex encoding of its hash is available by calling `final`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// This function will also acquire an exclusive lock to the manifest file. This means</span>
    <span class="tok-comment">/// that a process holding a Manifest will block any other process attempting to</span>
    <span class="tok-comment">/// acquire the lock. If `want_shared_lock` is `true`, a cache hit guarantees the</span>
    <span class="tok-comment">/// manifest file to be locked in shared mode, and a cache miss guarantees the manifest</span>
    <span class="tok-comment">/// file to be locked in exclusive mode.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The lock on the manifest file is released when `deinit` is called. As another</span>
    <span class="tok-comment">/// option, one may call `toOwnedLock` to obtain a smaller object which can represent</span>
    <span class="tok-comment">/// the lock. `deinit` is safe to call whether or not `toOwnedLock` has been called.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hit</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.HitError">HitError</a>!<span class="tok-type">bool</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file == <span class="tok-null">null</span>);

        self.diagnostic = .none;

        <span class="tok-kw">const</span> ext = <span class="tok-str">&quot;.txt&quot;</span>;
        <span class="tok-kw">var</span> manifest_file_path: [<a href="std.Build.Cache.html#std.Build.Cache.hex_digest_len">hex_digest_len</a> + ext.len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

        <span class="tok-kw">var</span> bin_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a> = <span class="tok-null">undefined</span>;
        self.hash.hasher.final(&amp;bin_digest);

        self.hex_digest = <a href="std.Build.Cache.html#std.Build.Cache.binToHex">binToHex</a>(bin_digest);

        <span class="tok-builtin">@memcpy</span>(manifest_file_path[<span class="tok-number">0</span>..self.hex_digest.len], &amp;self.hex_digest);
        manifest_file_path[<a href="std.Build.Cache.html#std.Build.Cache.hex_digest_len">hex_digest_len</a>..][<span class="tok-number">0</span>..ext.len].* = ext.*;<span class="tok-comment">

        // We'll try to open the cache with an exclusive lock, but if that would block
        // and `want_shared_lock` is set, a shared lock might be sufficient, so we'll
        // open with a shared lock instead.
        </span><span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">if</span> (self.cache.manifest_dir.createFile(&amp;manifest_file_path, .{
                .read = <span class="tok-null">true</span>,
                .truncate = <span class="tok-null">false</span>,
                .lock = .exclusive,
                .lock_nonblocking = self.want_shared_lock,
            })) |manifest_file| {
                self.manifest_file = manifest_file;
                self.have_exclusive_lock = <span class="tok-null">true</span>;
                <span class="tok-kw">break</span>;
            } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.WouldBlock =&gt; {
                    self.manifest_file = self.cache.manifest_dir.openFile(&amp;manifest_file_path, .{
                        .mode = .read_write,
                        .lock = .shared,
                    }) <span class="tok-kw">catch</span> |e| {
                        self.diagnostic = .{ .manifest_create = e };
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                    };
                    <span class="tok-kw">break</span>;
                },
                <span class="tok-kw">error</span>.FileNotFound =&gt; {<span class="tok-comment">
                    // There are no dir components, so the only possibility
                    // should be that the directory behind the handle has been
                    // deleted, however we have observed on macOS two processes
                    // racing to do openat() with O_CREAT manifest in ENOENT.
                    //
                    // As a workaround, we retry with exclusive=true which
                    // disambiguates by returning EEXIST, indicating original
                    // failure was a race, or ENOENT, indicating deletion of
                    // the directory of our open handle.
                    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> != .macos) {
                        self.diagnostic = .{ .manifest_create = <span class="tok-kw">error</span>.FileNotFound };
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                    }

                    <span class="tok-kw">if</span> (self.cache.manifest_dir.createFile(&amp;manifest_file_path, .{
                        .read = <span class="tok-null">true</span>,
                        .truncate = <span class="tok-null">false</span>,
                        .lock = .exclusive,
                        .lock_nonblocking = self.want_shared_lock,
                        .exclusive = <span class="tok-null">true</span>,
                    })) |manifest_file| {
                        self.manifest_file = manifest_file;
                        self.have_exclusive_lock = <span class="tok-null">true</span>;
                        <span class="tok-kw">break</span>;
                    } <span class="tok-kw">else</span> |excl_err| <span class="tok-kw">switch</span> (excl_err) {
                        <span class="tok-kw">error</span>.WouldBlock, <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">continue</span>,
                        <span class="tok-kw">error</span>.FileNotFound =&gt; {
                            self.diagnostic = .{ .manifest_create = <span class="tok-kw">error</span>.FileNotFound };
                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                        },
                        <span class="tok-kw">else</span> =&gt; |e| {
                            self.diagnostic = .{ .manifest_create = e };
                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                        },
                    }
                },
                <span class="tok-kw">else</span> =&gt; |e| {
                    self.diagnostic = .{ .manifest_create = e };
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                },
            }
        }

        self.want_refresh_timestamp = <span class="tok-null">true</span>;

        <span class="tok-kw">const</span> input_file_count = self.files.entries.len;<span class="tok-comment">

        // We're going to construct a second hash. Its input will begin with the digest we've
        // already computed (`bin_digest`), and then it'll have the digests of each input file,
        // including &quot;post&quot; files (see `addFilePost`). If this is a hit, we learn the set of &quot;post&quot;
        // files from the manifest on disk. If this is a miss, we'll learn those from future calls
        // to `addFilePost` etc. As such, the state of `self.hash.hasher` after this function
        // depends on whether this is a hit or a miss.
        //
        // If we return `true` indicating a cache hit, then `self.hash.hasher` must already include
        // the digests of the &quot;post&quot; files, so the caller can call `final`. Otherwise, on a cache
        // miss, `self.hash.hasher` will include the digests of all non-&quot;post&quot; files -- that is,
        // the ones we've already been told about. The rest will be discovered through calls to
        // `addFilePost` etc, which will update the hasher. After all files are added, the user can
        // use `final`, and will at some point `writeManifest` the file list to disk.

        </span>self.hash.hasher = <a href="std.Build.Cache.html#std.Build.Cache.hasher_init">hasher_init</a>;
        self.hash.hasher.update(&amp;bin_digest);

        hit: {
            <span class="tok-kw">const</span> file_digests_populated: <span class="tok-type">usize</span> = digests: {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.hitWithCurrentLock()) {
                    .hit =&gt; <span class="tok-kw">break</span> :hit,
                    .miss =&gt; |m| <span class="tok-kw">if</span> (!<span class="tok-kw">try</span> self.upgradeToExclusiveLock()) {
                        <span class="tok-kw">break</span> :digests m.file_digests_populated;
                    },
                }<span class="tok-comment">
                // We've just had a miss with the shared lock, and upgraded to an exclusive lock. Someone
                // else might have modified the digest, so we need to check again before deciding to miss.
                // Before trying again, we must reset `self.hash.hasher` and `self.files`.
                // This is basically just the first half of `unhit`.
                </span>self.hash.hasher = <a href="std.Build.Cache.html#std.Build.Cache.hasher_init">hasher_init</a>;
                self.hash.hasher.update(&amp;bin_digest);
                <span class="tok-kw">while</span> (self.files.count() != input_file_count) {
                    <span class="tok-kw">var</span> file = self.files.pop().?;
                    file.key.deinit(self.cache.gpa);
                }<span class="tok-comment">
                // Also, seek the file back to the start.
                </span>self.manifest_file.?.seekTo(<span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| {
                    self.diagnostic = .{ .manifest_seek = err };
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                };

                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.hitWithCurrentLock()) {
                    .hit =&gt; <span class="tok-kw">break</span> :hit,
                    .miss =&gt; |m| <span class="tok-kw">break</span> :digests m.file_digests_populated,
                }
            };<span class="tok-comment">

            // This is a guaranteed cache miss. We're almost ready to return `false`, but there's a
            // little bookkeeping to do first. The first `file_digests_populated` entries in `files`
            // have their `bin_digest` populated; there may be some left in `input_file_count` which
            // we'll need to populate ourselves. Other than that, this is basically `unhit`.
            </span>self.manifest_dirty = <span class="tok-null">true</span>;
            self.hash.hasher = <a href="std.Build.Cache.html#std.Build.Cache.hasher_init">hasher_init</a>;
            self.hash.hasher.update(&amp;bin_digest);
            <span class="tok-kw">while</span> (self.files.count() != input_file_count) {
                <span class="tok-kw">var</span> file = self.files.pop().?;
                file.key.deinit(self.cache.gpa);
            }
            <span class="tok-kw">for</span> (self.files.keys(), <span class="tok-number">0</span>..) |*file, idx| {
                <span class="tok-kw">if</span> (idx &lt; file_digests_populated) {<span class="tok-comment">
                    // `bin_digest` is already populated by `hitWithCurrentLock`, so we can use it directly.
                    </span>self.hash.hasher.update(&amp;file.bin_digest);
                } <span class="tok-kw">else</span> {
                    self.populateFileHash(file) <span class="tok-kw">catch</span> |err| {
                        self.diagnostic = .{ .file_hash = .{
                            .file_index = idx,
                            .err = err,
                        } };
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                    };
                }
            }
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }

        <span class="tok-kw">if</span> (self.want_shared_lock) {
            self.downgradeToSharedLock() <span class="tok-kw">catch</span> |err| {
                self.diagnostic = .{ .manifest_lock = err };
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
            };
        }

        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }

    <span class="tok-comment">/// Assumes that `self.hash.hasher` has been updated only with the original digest, that</span>
    <span class="tok-comment">/// `self.files` contains only the original input files, and that `self.manifest_file.?` is</span>
    <span class="tok-comment">/// seeked to the start of the file.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">hitWithCurrentLock</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.HitError">HitError</a>!<span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.hit">hit</a>,
        miss: <span class="tok-kw">struct</span> {
            file_digests_populated: <span class="tok-type">usize</span>,
        },
    } {
        <span class="tok-kw">const</span> gpa = self.cache.gpa;
        <span class="tok-kw">const</span> input_file_count = self.files.entries.len;

        <span class="tok-kw">const</span> file_contents = self.manifest_file.?.reader().readAllAlloc(gpa, <a href="std.Build.Cache.html#std.Build.Cache.manifest_file_size_max">manifest_file_size_max</a>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
            <span class="tok-kw">error</span>.StreamTooLong =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
            <span class="tok-kw">else</span> =&gt; |e| {
                self.diagnostic = .{ .manifest_read = e };
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
            },
        };
        <span class="tok-kw">defer</span> gpa.free(file_contents);

        <span class="tok-kw">var</span> any_file_changed = <span class="tok-null">false</span>;
        <span class="tok-kw">var</span> line_iter = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, file_contents, <span class="tok-str">'\n'</span>);
        <span class="tok-kw">var</span> idx: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> header_valid = valid: {
            <span class="tok-kw">const</span> line = line_iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :valid <span class="tok-null">false</span>;
            <span class="tok-kw">break</span> :valid <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, line, <a href="std.Build.Cache.html#std.Build.Cache.manifest_header">manifest_header</a>);
        };
        <span class="tok-kw">if</span> (!header_valid) {
            <span class="tok-kw">return</span> .{ .miss = .{ .file_digests_populated = <span class="tok-number">0</span> } };
        }
        <span class="tok-kw">while</span> (line_iter.next()) |line| {
            <span class="tok-kw">defer</span> idx += <span class="tok-number">1</span>;

            <span class="tok-kw">var</span> iter = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, line, <span class="tok-str">' '</span>);
            <span class="tok-kw">const</span> size = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
            <span class="tok-kw">const</span> inode = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
            <span class="tok-kw">const</span> mtime_nsec_str = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
            <span class="tok-kw">const</span> digest_str = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
            <span class="tok-kw">const</span> prefix_str = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
            <span class="tok-kw">const</span> file_path = iter.rest();

            <span class="tok-kw">const</span> stat_size = <a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">u64</span>, size, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
            <span class="tok-kw">const</span> stat_inode = <a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.ino_t">INode</a>, inode, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
            <span class="tok-kw">const</span> stat_mtime = <a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">i64</span>, mtime_nsec_str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
            <span class="tok-kw">const</span> file_bin_digest = b: {
                <span class="tok-kw">if</span> (digest_str.len != <a href="std.Build.Cache.html#std.Build.Cache.hex_digest_len">hex_digest_len</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
                <span class="tok-kw">var</span> bd: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a> = <span class="tok-null">undefined</span>;
                _ = <a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.hexToBytes">hexToBytes</a>(&amp;bd, digest_str) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
                <span class="tok-kw">break</span> :b bd;
            };

            <span class="tok-kw">const</span> prefix = <a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">u8</span>, prefix_str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
            <span class="tok-kw">if</span> (prefix &gt;= self.cache.prefixes_len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;

            <span class="tok-kw">if</span> (file_path.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;

            <span class="tok-kw">const</span> cache_hash_file = f: {
                <span class="tok-kw">const</span> prefixed_path: <a href="std.Build.Cache.PrefixedPath.html">PrefixedPath</a> = .{
                    .prefix = prefix,
                    .sub_path = file_path,<span class="tok-comment"> // expires with file_contents
                </span>};
                <span class="tok-kw">if</span> (idx &lt; input_file_count) {
                    <span class="tok-kw">const</span> file = &amp;self.files.keys()[idx];
                    <span class="tok-kw">if</span> (!file.prefixed_path.eql(prefixed_path))
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;

                    file.stat = .{
                        .size = stat_size,
                        .inode = stat_inode,
                        .mtime = stat_mtime,
                    };
                    file.bin_digest = file_bin_digest;
                    <span class="tok-kw">break</span> :f file;
                }
                <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.files.getOrPutAdapted(gpa, prefixed_path, <a href="std.Build.Cache.Manifest.FilesAdapter.html">FilesAdapter</a>{});
                <span class="tok-kw">errdefer</span> _ = self.files.pop();
                <span class="tok-kw">if</span> (!gop.found_existing) {
                    gop.key_ptr.* = .{
                        .prefixed_path = .{
                            .prefix = prefix,
                            .sub_path = <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, file_path),
                        },
                        .contents = <span class="tok-null">null</span>,
                        .max_file_size = <span class="tok-null">null</span>,
                        .handle = <span class="tok-null">null</span>,
                        .stat = .{
                            .size = stat_size,
                            .inode = stat_inode,
                            .mtime = stat_mtime,
                        },
                        .bin_digest = file_bin_digest,
                    };
                }
                <span class="tok-kw">break</span> :f gop.key_ptr;
            };

            <span class="tok-kw">const</span> pp = cache_hash_file.prefixed_path;
            <span class="tok-kw">const</span> dir = self.cache.prefixes()[pp.prefix].handle;
            <span class="tok-kw">const</span> this_file = dir.openFile(pp.sub_path, .{ .mode = .read_only }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.FileNotFound =&gt; {<span class="tok-comment">
                    // Every digest before this one has been populated successfully.
                    </span><span class="tok-kw">return</span> .{ .miss = .{ .file_digests_populated = idx } };
                },
                <span class="tok-kw">else</span> =&gt; |e| {
                    self.diagnostic = .{ .file_open = .{
                        .file_index = idx,
                        .err = e,
                    } };
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                },
            };
            <span class="tok-kw">defer</span> this_file.close();

            <span class="tok-kw">const</span> actual_stat = this_file.stat() <span class="tok-kw">catch</span> |err| {
                self.diagnostic = .{ .file_stat = .{
                    .file_index = idx,
                    .err = err,
                } };
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
            };
            <span class="tok-kw">const</span> size_match = actual_stat.size == cache_hash_file.stat.size;
            <span class="tok-kw">const</span> mtime_match = actual_stat.mtime == cache_hash_file.stat.mtime;
            <span class="tok-kw">const</span> inode_match = actual_stat.inode == cache_hash_file.stat.inode;

            <span class="tok-kw">if</span> (!size_match <span class="tok-kw">or</span> !mtime_match <span class="tok-kw">or</span> !inode_match) {
                cache_hash_file.stat = .{
                    .size = actual_stat.size,
                    .mtime = actual_stat.mtime,
                    .inode = actual_stat.inode,
                };

                <span class="tok-kw">if</span> (self.isProblematicTimestamp(cache_hash_file.stat.mtime)) {<span class="tok-comment">
                    // The actual file has an unreliable timestamp, force it to be hashed
                    </span>cache_hash_file.stat.mtime = <span class="tok-number">0</span>;
                    cache_hash_file.stat.inode = <span class="tok-number">0</span>;
                }

                <span class="tok-kw">var</span> actual_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a> = <span class="tok-null">undefined</span>;
                <a href="std.Build.Cache.html#std.Build.Cache.hashFile">hashFile</a>(this_file, &amp;actual_digest) <span class="tok-kw">catch</span> |err| {
                    self.diagnostic = .{ .file_read = .{
                        .file_index = idx,
                        .err = err,
                    } };
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                };

                <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;cache_hash_file.bin_digest, &amp;actual_digest)) {
                    cache_hash_file.bin_digest = actual_digest;<span class="tok-comment">
                    // keep going until we have the input file digests
                    </span>any_file_changed = <span class="tok-null">true</span>;
                }
            }

            <span class="tok-kw">if</span> (!any_file_changed) {
                self.hash.hasher.update(&amp;cache_hash_file.bin_digest);
            }
        }<span class="tok-comment">

        // If the manifest was somehow missing one of our input files, or if any file hash has changed,
        // then this is a cache miss. However, we have successfully populated some or all of the file
        // digests.
        </span><span class="tok-kw">if</span> (any_file_changed <span class="tok-kw">or</span> idx &lt; input_file_count) {
            <span class="tok-kw">return</span> .{ .miss = .{ .file_digests_populated = idx } };
        }

        <span class="tok-kw">return</span> .hit;
    }

    <span class="tok-comment">/// Reset `self.hash.hasher` to the state it should be in after `hit` returns `false`.</span>
    <span class="tok-comment">/// The hasher contains the original input digest, and all original input file digests (i.e.</span>
    <span class="tok-comment">/// not including post files).</span>
    <span class="tok-comment">/// Assumes that `bin_digest` is populated for all files up to `input_file_count`. As such,</span>
    <span class="tok-comment">/// this is not necessarily safe to call within `hit`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unhit</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, bin_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a>, input_file_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {<span class="tok-comment">
        // Reset the hash.
        </span>self.hash.hasher = <a href="std.Build.Cache.html#std.Build.Cache.hasher_init">hasher_init</a>;
        self.hash.hasher.update(&amp;bin_digest);<span class="tok-comment">

        // Remove files not in the initial hash.
        </span><span class="tok-kw">while</span> (self.files.count() != input_file_count) {
            <span class="tok-kw">var</span> file = self.files.pop().?;
            file.key.deinit(self.cache.gpa);
        }

        <span class="tok-kw">for</span> (self.files.keys()) |file| {
            self.hash.hasher.update(&amp;file.bin_digest);
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">isProblematicTimestamp</span>(man: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, file_time: <span class="tok-type">i128</span>) <span class="tok-type">bool</span> {<span class="tok-comment">
        // If the file_time is prior to the most recent problematic timestamp
        // then we don't need to access the filesystem.
        </span><span class="tok-kw">if</span> (file_time &lt; man.recent_problematic_timestamp)
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;<span class="tok-comment">

        // Next we will check the globally shared Cache timestamp, which is accessed
        // from multiple threads.
        </span>man.cache.mutex.lock();
        <span class="tok-kw">defer</span> man.cache.mutex.unlock();<span class="tok-comment">

        // Save the global one to our local one to avoid locking next time.
        </span>man.recent_problematic_timestamp = man.cache.recent_problematic_timestamp;
        <span class="tok-kw">if</span> (file_time &lt; man.recent_problematic_timestamp)
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;<span class="tok-comment">

        // This flag prevents multiple filesystem writes for the same hit() call.
        </span><span class="tok-kw">if</span> (man.want_refresh_timestamp) {
            man.want_refresh_timestamp = <span class="tok-null">false</span>;

            <span class="tok-kw">var</span> file = man.cache.manifest_dir.createFile(<span class="tok-str">&quot;timestamp&quot;</span>, .{
                .read = <span class="tok-null">true</span>,
                .truncate = <span class="tok-null">true</span>,
            }) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">true</span>;
            <span class="tok-kw">defer</span> file.close();<span class="tok-comment">

            // Save locally and also save globally (we still hold the global lock).
            </span>man.recent_problematic_timestamp = (file.stat() <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">true</span>).mtime;
            man.cache.recent_problematic_timestamp = man.recent_problematic_timestamp;
        }

        <span class="tok-kw">return</span> file_time &gt;= man.recent_problematic_timestamp;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">populateFileHash</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, ch_file: *<a href="std.Build.Cache.File.html">File</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (ch_file.handle) |handle| {
            <span class="tok-kw">return</span> <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.populateFileHashHandle">populateFileHashHandle</a>(self, ch_file, handle);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">const</span> pp = ch_file.prefixed_path;
            <span class="tok-kw">const</span> dir = self.cache.prefixes()[pp.prefix].handle;
            <span class="tok-kw">const</span> handle = <span class="tok-kw">try</span> dir.openFile(pp.sub_path, .{});
            <span class="tok-kw">defer</span> handle.close();
            <span class="tok-kw">return</span> <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.populateFileHashHandle">populateFileHashHandle</a>(self, ch_file, handle);
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">populateFileHashHandle</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, ch_file: *<a href="std.Build.Cache.File.html">File</a>, handle: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> actual_stat = <span class="tok-kw">try</span> handle.stat();
        ch_file.stat = .{
            .size = actual_stat.size,
            .mtime = actual_stat.mtime,
            .inode = actual_stat.inode,
        };

        <span class="tok-kw">if</span> (self.isProblematicTimestamp(ch_file.stat.mtime)) {<span class="tok-comment">
            // The actual file has an unreliable timestamp, force it to be hashed
            </span>ch_file.stat.mtime = <span class="tok-number">0</span>;
            ch_file.stat.inode = <span class="tok-number">0</span>;
        }

        <span class="tok-kw">if</span> (ch_file.max_file_size) |max_file_size| {
            <span class="tok-kw">if</span> (ch_file.stat.size &gt; max_file_size) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig;
            }

            <span class="tok-kw">const</span> contents = <span class="tok-kw">try</span> self.cache.gpa.alloc(<span class="tok-type">u8</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(ch_file.stat.size)));
            <span class="tok-kw">errdefer</span> self.cache.gpa.free(contents);<span class="tok-comment">

            // Hash while reading from disk, to keep the contents in the cpu cache while
            // doing hashing.
            </span><span class="tok-kw">var</span> hasher = <a href="std.Build.Cache.html#std.Build.Cache.hasher_init">hasher_init</a>;
            <span class="tok-kw">var</span> off: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">const</span> bytes_read = <span class="tok-kw">try</span> handle.pread(contents[off..], off);
                <span class="tok-kw">if</span> (bytes_read == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                hasher.update(contents[off..][<span class="tok-number">0</span>..bytes_read]);
                off += bytes_read;
            }
            hasher.final(&amp;ch_file.bin_digest);

            ch_file.contents = contents;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> <a href="std.Build.Cache.html#std.Build.Cache.hashFile">hashFile</a>(handle, &amp;ch_file.bin_digest);
        }

        self.hash.hasher.update(&amp;ch_file.bin_digest);
    }

    <span class="tok-comment">/// Add a file as a dependency of process being cached, after the initial hash has been</span>
    <span class="tok-comment">/// calculated. This is useful for processes that don't know all the files that</span>
    <span class="tok-comment">/// are depended on ahead of time. For example, a source file that can import other files</span>
    <span class="tok-comment">/// will need to be recompiled if the imported file is changed.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePostFetch</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_file_size: <span class="tok-type">usize</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file != <span class="tok-null">null</span>);

        <span class="tok-kw">const</span> gpa = self.cache.gpa;
        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefix(file_path);
        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);

        <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.files.getOrPutAdapted(gpa, prefixed_path, <a href="std.Build.Cache.Manifest.FilesAdapter.html">FilesAdapter</a>{});
        <span class="tok-kw">errdefer</span> _ = self.files.pop();

        <span class="tok-kw">if</span> (gop.found_existing) {
            gpa.free(prefixed_path.sub_path);
            <span class="tok-kw">return</span> gop.key_ptr.contents.?;
        }

        gop.key_ptr.* = .{
            .prefixed_path = prefixed_path,
            .max_file_size = max_file_size,
            .stat = <span class="tok-null">undefined</span>,
            .bin_digest = <span class="tok-null">undefined</span>,
            .contents = <span class="tok-null">null</span>,
        };

        self.files.lockPointers();
        <span class="tok-kw">defer</span> self.files.unlockPointers();

        <span class="tok-kw">try</span> self.populateFileHash(gop.key_ptr);
        <span class="tok-kw">return</span> gop.key_ptr.contents.?;
    }

    <span class="tok-comment">/// Add a file as a dependency of process being cached, after the initial hash has been</span>
    <span class="tok-comment">/// calculated.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// This is useful for processes that don't know the all the files that are</span>
    <span class="tok-comment">/// depended on ahead of time. For example, a source file that can import</span>
    <span class="tok-comment">/// other files will need to be recompiled if the imported file is changed.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePost</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file != <span class="tok-null">null</span>);

        <span class="tok-kw">const</span> gpa = self.cache.gpa;
        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefix(file_path);
        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);

        <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.files.getOrPutAdapted(gpa, prefixed_path, <a href="std.Build.Cache.Manifest.FilesAdapter.html">FilesAdapter</a>{});
        <span class="tok-kw">errdefer</span> _ = self.files.pop();

        <span class="tok-kw">if</span> (gop.found_existing) {
            gpa.free(prefixed_path.sub_path);
            <span class="tok-kw">return</span>;
        }

        gop.key_ptr.* = .{
            .prefixed_path = prefixed_path,
            .max_file_size = <span class="tok-null">null</span>,
            .handle = <span class="tok-null">null</span>,
            .stat = <span class="tok-null">undefined</span>,
            .bin_digest = <span class="tok-null">undefined</span>,
            .contents = <span class="tok-null">null</span>,
        };

        self.files.lockPointers();
        <span class="tok-kw">defer</span> self.files.unlockPointers();

        <span class="tok-kw">try</span> self.populateFileHash(gop.key_ptr);
    }

    <span class="tok-comment">/// Like `addFilePost` but when the file contents have already been loaded from disk.</span>
    <span class="tok-comment">/// On success, cache takes ownership of `resolved_path`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePostContents</span>(
        self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>,
        resolved_path: []<span class="tok-type">u8</span>,
        bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        stat: <a href="std.Build.Cache.File.html">File</a>.<a href="std.Build.Cache.File.Stat.html">Stat</a>,
    ) !<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file != <span class="tok-null">null</span>);
        <span class="tok-kw">const</span> gpa = self.cache.gpa;

        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefixResolved(resolved_path);
        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);

        <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.files.getOrPutAdapted(gpa, prefixed_path, <a href="std.Build.Cache.Manifest.FilesAdapter.html">FilesAdapter</a>{});
        <span class="tok-kw">errdefer</span> _ = self.files.pop();

        <span class="tok-kw">if</span> (gop.found_existing) {
            gpa.free(prefixed_path.sub_path);
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">const</span> new_file = gop.key_ptr;

        new_file.* = .{
            .prefixed_path = prefixed_path,
            .max_file_size = <span class="tok-null">null</span>,
            .handle = <span class="tok-null">null</span>,
            .stat = stat,
            .bin_digest = <span class="tok-null">undefined</span>,
            .contents = <span class="tok-null">null</span>,
        };

        <span class="tok-kw">if</span> (self.isProblematicTimestamp(new_file.stat.mtime)) {<span class="tok-comment">
            // The actual file has an unreliable timestamp, force it to be hashed
            </span>new_file.stat.mtime = <span class="tok-number">0</span>;
            new_file.stat.inode = <span class="tok-number">0</span>;
        }

        {
            <span class="tok-kw">var</span> hasher = <a href="std.Build.Cache.html#std.Build.Cache.hasher_init">hasher_init</a>;
            hasher.update(bytes);
            hasher.final(&amp;new_file.bin_digest);
        }

        self.hash.hasher.update(&amp;new_file.bin_digest);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addDepFilePost</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, dep_file_basename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file != <span class="tok-null">null</span>);
        <span class="tok-kw">return</span> self.addDepFileMaybePost(dir, dep_file_basename);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addDepFileMaybePost</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, dep_file_basename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> dep_file_contents = <span class="tok-kw">try</span> dir.readFileAlloc(self.cache.gpa, dep_file_basename, <a href="std.Build.Cache.html#std.Build.Cache.manifest_file_size_max">manifest_file_size_max</a>);
        <span class="tok-kw">defer</span> self.cache.gpa.free(dep_file_contents);

        <span class="tok-kw">var</span> error_buf = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(self.cache.gpa);
        <span class="tok-kw">defer</span> error_buf.deinit();

        <span class="tok-kw">var</span> it: <a href="std.Build.Cache.DepTokenizer.html">DepTokenizer</a> = .{ .bytes = dep_file_contents };

        <span class="tok-kw">while</span> (it.next()) |token| {
            <span class="tok-kw">switch</span> (token) {<span class="tok-comment">
                // We don't care about targets, we only want the prereqs
                // Clang is invoked in single-source mode but other programs may not
                </span>.target, .target_must_resolve =&gt; {},
                .prereq =&gt; |file_path| <span class="tok-kw">if</span> (self.manifest_file == <span class="tok-null">null</span>) {
                    _ = <span class="tok-kw">try</span> self.addFile(file_path, <span class="tok-null">null</span>);
                } <span class="tok-kw">else</span> <span class="tok-kw">try</span> self.addFilePost(file_path),
                .prereq_must_resolve =&gt; {
                    <span class="tok-kw">var</span> resolve_buf = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(self.cache.gpa);
                    <span class="tok-kw">defer</span> resolve_buf.deinit();

                    <span class="tok-kw">try</span> token.resolve(resolve_buf.writer());
                    <span class="tok-kw">if</span> (self.manifest_file == <span class="tok-null">null</span>) {
                        _ = <span class="tok-kw">try</span> self.addFile(resolve_buf.items, <span class="tok-null">null</span>);
                    } <span class="tok-kw">else</span> <span class="tok-kw">try</span> self.addFilePost(resolve_buf.items);
                },
                <span class="tok-kw">else</span> =&gt; |err| {
                    <span class="tok-kw">try</span> err.printError(error_buf.writer());
                    <a href="std.Build.Cache.html#std.Build.Cache.log">log</a>.<a href="#">err</a>(<span class="tok-str">&quot;failed parsing {s}: {s}&quot;</span>, .{ dep_file_basename, error_buf.items });
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDepFile;
                },
            }
        }
    }

    <span class="tok-comment">/// Returns a binary hash of the inputs.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finalBin</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file != <span class="tok-null">null</span>);<span class="tok-comment">

        // We don't close the manifest file yet, because we want to
        // keep it locked until the API user is done using it.
        // We also don't write out the manifest yet, because until
        // cache_release is called we still might be working on creating
        // the artifacts to cache.

        </span><span class="tok-kw">var</span> bin_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a> = <span class="tok-null">undefined</span>;
        self.hash.hasher.final(&amp;bin_digest);
        <span class="tok-kw">return</span> bin_digest;
    }

    <span class="tok-comment">/// Returns a hex encoded hash of the inputs.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a> {
        <span class="tok-kw">const</span> bin_digest = self.finalBin();
        <span class="tok-kw">return</span> <a href="std.Build.Cache.html#std.Build.Cache.binToHex">binToHex</a>(bin_digest);
    }

    <span class="tok-comment">/// If `want_shared_lock` is true, this function automatically downgrades the</span>
    <span class="tok-comment">/// lock from exclusive to shared.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeManifest</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) !<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.have_exclusive_lock);

        <span class="tok-kw">const</span> manifest_file = self.manifest_file.?;
        <span class="tok-kw">if</span> (self.manifest_dirty) {
            self.manifest_dirty = <span class="tok-null">false</span>;

            <span class="tok-kw">var</span> contents = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(self.cache.gpa);
            <span class="tok-kw">defer</span> contents.deinit();

            <span class="tok-kw">const</span> writer = contents.writer();
            <span class="tok-kw">try</span> writer.writeAll(<a href="std.Build.Cache.html#std.Build.Cache.manifest_header">manifest_header</a> ++ <span class="tok-str">&quot;\n&quot;</span>);
            <span class="tok-kw">for</span> (self.files.keys()) |file| {
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{d} {d} {d} {} {d} {s}\n&quot;</span>, .{
                    file.stat.size,
                    file.stat.inode,
                    file.stat.mtime,
                    <a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.fmtSliceHexLower">fmtSliceHexLower</a>(&amp;file.bin_digest),
                    file.prefixed_path.prefix,
                    file.prefixed_path.sub_path,
                });
            }

            <span class="tok-kw">try</span> manifest_file.setEndPos(contents.items.len);
            <span class="tok-kw">try</span> manifest_file.pwriteAll(contents.items, <span class="tok-number">0</span>);
        }

        <span class="tok-kw">if</span> (self.want_shared_lock) {
            <span class="tok-kw">try</span> self.downgradeToSharedLock();
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">downgradeToSharedLock</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (!self.have_exclusive_lock) <span class="tok-kw">return</span>;<span class="tok-comment">

        // WASI does not currently support flock, so we bypass it here.
        // TODO: If/when flock is supported on WASI, this check should be removed.
        //       See https://github.com/WebAssembly/wasi-filesystem/issues/2
        </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> != .wasi <span class="tok-kw">or</span> <a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.html#std.process.can_spawn">can_spawn</a> <span class="tok-kw">or</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>) {
            <span class="tok-kw">const</span> manifest_file = self.manifest_file.?;
            <span class="tok-kw">try</span> manifest_file.downgradeLock();
        }

        self.have_exclusive_lock = <span class="tok-null">false</span>;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">upgradeToExclusiveLock</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <span class="tok-kw">error</span>{CacheCheckFailed}!<span class="tok-type">bool</span> {
        <span class="tok-kw">if</span> (self.have_exclusive_lock) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file != <span class="tok-null">null</span>);<span class="tok-comment">

        // WASI does not currently support flock, so we bypass it here.
        // TODO: If/when flock is supported on WASI, this check should be removed.
        //       See https://github.com/WebAssembly/wasi-filesystem/issues/2
        </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> != .wasi <span class="tok-kw">or</span> <a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.html#std.process.can_spawn">can_spawn</a> <span class="tok-kw">or</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>) {
            <span class="tok-kw">const</span> manifest_file = self.manifest_file.?;<span class="tok-comment">
            // Here we intentionally have a period where the lock is released, in case there are
            // other processes holding a shared lock.
            </span>manifest_file.unlock();
            manifest_file.lock(.exclusive) <span class="tok-kw">catch</span> |err| {
                self.diagnostic = .{ .manifest_lock = err };
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
            };
        }
        self.have_exclusive_lock = <span class="tok-null">true</span>;
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }

    <span class="tok-comment">/// Obtain only the data needed to maintain a lock on the manifest file.</span>
    <span class="tok-comment">/// The `Manifest` remains safe to deinit.</span>
    <span class="tok-comment">/// Don't forget to call `writeManifest` before this!</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedLock</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <a href="std.Build.Cache.Lock.html">Lock</a> {
        <span class="tok-kw">const</span> lock: <a href="std.Build.Cache.Lock.html">Lock</a> = .{
            .manifest_file = self.manifest_file.?,
        };

        self.manifest_file = <span class="tok-null">null</span>;
        <span class="tok-kw">return</span> lock;
    }

    <span class="tok-comment">/// Releases the manifest file and frees any memory the Manifest was using.</span>
    <span class="tok-comment">/// `Manifest.hit` must be called first.</span>
    <span class="tok-comment">/// Don't forget to call `writeManifest` before this!</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (self.manifest_file) |file| {
            <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {<span class="tok-comment">
                // See Lock.release for why this is required on Windows
                </span>file.unlock();
            }

            file.close();
        }
        <span class="tok-kw">for</span> (self.files.keys()) |*file| {
            file.deinit(self.cache.gpa);
        }
        self.files.deinit(self.cache.gpa);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">populateFileSystemInputs</span>(man: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, buf: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>)) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(<a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Server.html">Server</a>.<a href="std.zig.Server.Message.html">Message</a>.<a href="std.zig.Server.Message.PathPrefix.html">PathPrefix</a>).@&quot;enum&quot;.fields.len == man.cache.prefixes_len);
        buf.clearRetainingCapacity();
        <span class="tok-kw">const</span> gpa = man.cache.gpa;
        <span class="tok-kw">const</span> files = man.files.keys();
        <span class="tok-kw">if</span> (files.len &gt; <span class="tok-number">0</span>) {
            <span class="tok-kw">for</span> (files) |file| {
                <span class="tok-kw">try</span> buf.ensureUnusedCapacity(gpa, file.prefixed_path.sub_path.len + <span class="tok-number">2</span>);
                buf.appendAssumeCapacity(file.prefixed_path.prefix + <span class="tok-number">1</span>);
                buf.appendSliceAssumeCapacity(file.prefixed_path.sub_path);
                buf.appendAssumeCapacity(<span class="tok-number">0</span>);
            }<span class="tok-comment">
            // The null byte is a separator, not a terminator.
            </span>buf.items.len -= <span class="tok-number">1</span>;
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">populateOtherManifest</span>(man: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, other: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, prefix_map: [<span class="tok-number">4</span>]<span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> gpa = other.cache.gpa;
        <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(<a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Server.html">Server</a>.<a href="std.zig.Server.Message.html">Message</a>.<a href="std.zig.Server.Message.PathPrefix.html">PathPrefix</a>).@&quot;enum&quot;.fields.len == man.cache.prefixes_len);
        <a href="std.debug.html#std.debug.assert">assert</a>(man.cache.prefixes_len == <span class="tok-number">4</span>);
        <span class="tok-kw">for</span> (man.files.keys()) |file| {
            <span class="tok-kw">const</span> prefixed_path: <a href="std.Build.Cache.PrefixedPath.html">PrefixedPath</a> = .{
                .prefix = prefix_map[file.prefixed_path.prefix],
                .sub_path = <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, file.prefixed_path.sub_path),
            };
            <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);

            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> other.files.getOrPutAdapted(gpa, prefixed_path, <a href="std.Build.Cache.Manifest.FilesAdapter.html">FilesAdapter</a>{});
            <span class="tok-kw">errdefer</span> _ = other.files.pop();

            <span class="tok-kw">if</span> (gop.found_existing) {
                gpa.free(prefixed_path.sub_path);
                <span class="tok-kw">continue</span>;
            }

            gop.key_ptr.* = .{
                .prefixed_path = prefixed_path,
                .max_file_size = file.max_file_size,
                .handle = file.handle,
                .stat = file.stat,
                .bin_digest = file.bin_digest,
                .contents = <span class="tok-null">null</span>,
            };

            other.hash.hasher.update(&amp;gop.key_ptr.bin_digest);
        }
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
